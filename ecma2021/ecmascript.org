
* 待办
** 将来会使用LaTex进行处理.
* 约定
** 若干 表示一个或者多个
** 有限 表示零个、一个或者多个
** 可数 表示零个、一个、多个或者无限个
** 所有英文为原文内容，作为专用词汇表示特定含义，比如类型、参数、概念等。
** 领 表示realm
** 域 表示domain
** 规模 表示某数的模。或者在这里进行约定。数x的模就是x的绝对值|x|
** 性质 表示property
** 属性 表示attribute
** List<some> 表示列表的元素有some特性。
** 相同值 表示两个值是同一个
** 构造范 表示constructor
** 合集 表示collection
** R域 表示R适用的所有值的集合
** 字位 一个二进制位
** 字节 8个连续的二进制位。至于大小端，如果没有明确说明，就不考虑。
** 修圆 指用有限精度数字描述准确数字的处理过程。
** 活 artefact，人工造物
** 圈（juan`） 表示scope
** \*\*#N 表示名称为N的值的\*\*，例如绑定#N，表示名称为N的值的绑定。
*** 根据编译原理，大小端由其他编译层处理。
* 前言 [44,46]
* 第一章 范围
  本标准定义了ECMAScript2021多用途编程语言。
* 第二章 约定
* 第三章 标准参考
* 第四章 概述 [47-58]
  本章节包含了非正式的ECMAScript语言的概述。
  ECMAScript是一个面向对象的编程语言，用于在主机环境中计算和操作可计算对
象。这里定义的ECMAScript没有试图是计算机上自立的；实际上，既没有提供输入
外部数据的规范，也没有提供输出计算结果的规范。它期望ECMAScript程序的计算机
环境不仅会提供对象和其他本规范描述的特色，还会提供某些环境标准的对象，
对象的描述与行为都超出本规范期望的用于指明会提供某些可访问的性质和某些
被ECMAScript程序调用的函数的范围。
  ECMAScript最初被设计作一个脚本语言，却变成了一个多用途的编程语言。所谓的
脚本语言是指用于操作、定制和自动执行已有系统特色的编程语言。在那些系统
中，有用的功能已经在用户界面了，脚本语言提供程序控制这些功能的机制。就这
种方式，已有系统是提及的用于提供完成脚本语言能力的对象和特色的主机环境。
脚本语言试图被专业或非专业程序员使用。
  ECMAScript最初被设计为Web脚本语言，提供生动化浏览器网页和在客户端执行部分
服务端计算的机制。ECMAScript现在被用于在各种主机环境中提供核心脚本能力。
因此这部分各主机环境都有的核心语言（因此也与主机环境无关）被本文档规定。
  ECMAScript的用途远超过简单的脚本，被用于广泛的不同系统和规模的编程任务。
因为ECMAScript用途的膨胀，其功能和特色也膨胀了。ECMAScript已经是一个完整多
用途特征的编程语言。
** 4.1 Web Scripting 网页脚本
*** 4.4.41 遗传性质 inherited property
** 4.5 本规范的组织方式
  本规范剩余的部分如下组织：
  条款5定义本规范的记号约定。
  条款6到10定义了ECMAScript程序操作的运行时环境。
  条款11到17定义了ECMAScript编程语言的实际行为，包括全部语言特色的句法编码
和执行语义。
  条款18到28定义ECMAScript标准库。定义了所有ECMAScript程序可用的标准对象。
  条款29描述了访问SharedArrayBuffer背景的内存和Atomicsd对象方法的内存一致性
模型
* 第五章 记号约定
** 5.1句法与词法（语句的与词汇的语法）
*** 5.1.1上下文无关语法（context-free grammar 可能就是通用的语法描述约定）
  "context-free grammar"由若干"productions"组成。每个产出是一个树，有两个支干
left-hand side 和 right-hand side，在"left-hand side"是一个抽象标记记为
"nonterminal", 在"right-hand side" 是一个队列，由可数个标记（"nonterminal"或
"terminal"）构成的序列。各个语法的"terminal"用特定字母描述。形式如NXn, 
X属于{N,T},n为非负整数，差不多类似/N[NT]*/。
  "chain product"是只有一个"right-side nonterminal"和可数个"terminal"
构成的序列组成的产出。（一定还有一个left-hand side nontermial）。
  一个语句从开始由仅一个区分出的称为"goal symbol"的"nontermimal"和一个给定
的语法描述（context-free grammar)构成。语句具体指明一个"language"，即一组可数
的"terminal symbol"序列（数学意义上的可数：有限的或无限的）。这个序列可以
通过将语句中所有的"production left-hand side nonterminal"替换为
"production right-hand side"的方式，递归获得。
**** 这里其实蕴含了序的概念。这是按照输入顺序进行语法组织的。
*** 5.1.2词汇与正则的语法
  ECMAScript的"lexical grammar"在12章详解。本语法与它的"terminal symbols"的Unicode
编码一致，符合11.1定义的源码字符规则。定义了若干产出，从"goal symbol"开始有
InputElementDiv, InputElementTemplateTail, InputElementRegExp, 
InputElementRegExpOrTemplateTail，这些产出描述了如何将输入的字符码转换为
输入元素
  除了空白符与注释的输入元素组成了ECMAScript的句法语法的"termial symbols"，
称为ECMAScript tokens。这些token是保留词、标识符、文本和ECMAScript语言符号。
同时换行符通常不被认为是token，尽管是输入元素流的一部分，引导进程自动插入
分好。简单的空白符和单行注释是被舍弃的，不会出现在句法语法的输入元素
流中。多行注释（就是/*...*/形式的注释，与占用几行无关）中如果没有换行符，
会被舍弃掉；如果含有一个或多个换行符，将被替换为一个换行符的，然后作为
语句语法输入元素流的一部分
  ECMAScript的RegExp语法在22.2.1中给出。该文法还将源字符定义的代码点作为
"terminal symbols"其终结符。从"goal symbol Pattern"开始定义了若干产出描述了
如何将字符码转换为正则表达式。
  词汇与正则语法的产出用两个冒号"::"作为分隔符号。词汇与正则语法共享部分
产出。
*** 5.1.3 数字语法
  还有一种语法是将字符串转换成数字值。这个语法与词汇语法中处理数字的部分
内容相似。语法的"terminal symbol"是源码。在7.1.4.1中详细描述。
  数字语法的产出用三个冒号":::"作为符号来标志。
*** 5.1.4 语句语法
  ECMAScript的语句语法在13至16章给出。这语法有被词汇语法定义为
"terminal symbols"的"ECMAScript tokens"。它定义了一套产出，从两个目标符号" 
Script and Module"的某个开始，描述了token序列如何沟组成ECMAScript程序的
语句的正确的独立的组件。
  当一个编码流被解析成ECMAScript的"Script"或者"Module"时，它先通过反复运用
词法语法转换成输入元素流，这个输入元素流在被解析成一个单独的语句语法的
运用。如果输入流的全部token不能被解析成一个单独的"goal nontermial Script 或
Module"，这个输入流就在语句语法上错了。
  当解析成功后，构造出了一个"parse tree"，他是一个有根的树结构，每个节点
都是"Parse Node"。每个解析节点在语法上是一个"symbol"的实例，他代表一串从
那个"symbol"派生出的源文本。这个解析树的根节点，则代表全部的源文本，是解
析的"goal symbol"的实例。如果某个解析节点是一个"nonterminal"的实例，他同时也
是某个将其"nonterminal"作为"left-hand side"的产出的实例。而且他有可数的子元
素，每个子元素对应产出的"right-hand side"的一个"symbol"，每个子元素是解析
节点，是相应"symbol"的实例。
  每次调用解析都是实例出新的解析节点，在每次解析间不重用节点，即使是同样
的源文本。解析节点当且仅当在相同解析调用中，同一个语法"symbol"的实例，代表
相同源文本串的时候才被认为是相同的解析节点。
**** 备注1 多次解析相同字符串导致不同的解析节点。例如：
let str = "1 + 1";
eval(str)
eval(str)
每次调用eval将str的值转换成ECMAScript源码，然后执行具有隔离的解析树的独立的
解析。这些树是截然不同的即使这些解析操作的源文本来自相同的字符值。
**** 备注2 解析树是本规范的方式，实现没有必要一定用相似的数据结构
  语句语法的产出使用一个冒号":"作为符号进行区别。
  13-16章出现的句法语法不是被"ECMAScript Script or Module"正确接受全部的内容。
某些额外的"token"同样被正确接受，即，那些仅当分号放在特定位置（例如换行符
前）才被语法描述的"token"。此外，某些本语法描述的"token"序列，如果换行符
出现在某些“尴尬”位置后，就不被认为可接受的。
  在某些场景内，为了规避歧义，句法语法使用笼统产出，也就是说允许"token"序列
不能组成有效的"ECMAScript Script or Module"。举例来说，这个技术被用在对象字面
量与对象结构模式上。在相应的案例中，提供了一个更严格的补充语法，用于进一
步限制这个可接受的"token"序列。典型的，有个"early error"规则会定义一个错误
条件如果"P不能覆盖N"，P是解析节点（普通的产出实例），而N是从补充来的
"nonterminal"。这样原本被P匹配的"token"序列被用N再次解析作为"goal symbol"。（
如果N用了语法性质的参数，他们就会被设置成相同的值，如果P是起初就解析的）
如果"token"序列不能作为一个N的实例来解析，且没有"token"剩下，会导致错误发
生。
  后来，算法会使用"N被P覆盖"语句访问这个解析的结果。既然任何解析失败会
被"early error"规则侦测到，这就总是一个解析节点（一个N实例对应一个给定P）。
*** 5.1.5 语法符号
  terminal symbols用等宽加黑（这里我也不知道如何表示）字体表示，无论是在语法
产出还是在文档规范里，只要文字直接表示一个terminal symbol。这会像所写的一样
出现在脚本。以这种方式指明的全部终端符代码符都被认为是恰当的Unicode代码，
包含基本的拉丁字符，而不是那些在Unicode范围内相似外形的编码。终端符不能用
\UnicodeEscapeSequence表示
  nonterminal用斜体表示。一个nonterminal（其实就是产出）的定义以跟随若干冒号
的名称开始介绍。冒号的数量表明产出属于那种语法。本产出的若干可替换的
"right-hand sides"跟随在下一行。比如一个语句定义：
WhileStatement:
    while ( Expression ) Statement
声明了WhileStatement nonterminal表示while token、(、一个Exression、)、一个Statement
组成的序列。Expression和Statement上发生他们自己的nonterminal。再举一个语句定义
的例子：
ArgumentList:
    AssignmentExpression
    ArgumentList , AssignmentExpression
声明了ArgumentList可能表示一个单独的AssignmentExpression或者一个由一个
ArgumentList、,、一个AssignmentExpression构成的序列。这个ArgumentList定义是递归
的，因为它的定义需要本身。于是ArgumenList可以包含若干参数，参数用,分隔，
每个参数表达式就是AssignmentExpression。这种nonterminal的递归定义很常见。
  下标后缀opt，出现在terminal或nonterminal后，声明一个可选标志。这种包含可选
标志的替换实际是指明两种right-hand sides，一种是缺失可选元素的，一种是包含
可选元素的。如下所示：
VariableDeclaration:
    BindingIdentifier Initializer_opt
是下列定义的简便缩写：
VariableDeclaration:
    BindingIdentifier
    BindingIdentifier Initializer
，更进一步：
ForStatement:
    for ( LexicalDeclaration Expression_opt ; Expression_opt ) Statement
是下列定义的简便缩写：
ForStatement:
    for ( LexicalDeclaration ; Expression_opt ) Statement
    for ( LexicalDeclaration Expression ; Expression_opt ) Statement
是如下的缩写：
ForStatement:
    for ( LexicalDeclaration ; ) Statement
    for ( LexicalDeclaration ; Expression ) Statement
    for ( LexicalDeclaration Expression ; ) Statement
    for ( LexicalDeclaration Expression ; Expression ) Statement
所以，在这个例子里，noterminal ForStatement有四个可替换的right-hand sides
  产出可以通过增加"[parameters]"形式的标注的方式参数化，这个标注后缀在一个
产出定义的nonterminal标志上。其中"parameters"可以一个名称或者用都号分隔的
名称列表。一个参数化的产出是一套通过在被参数化的nonterminal symbol后拼接
下划线_和参数名称的方式的所有组合的速记。例如：
StatementList_[Return]:
    ReturnStatement
    ExpressionStatement
是下列定义的简便缩写:
StatementList:
    ReturnStatement
    ExpressionStatement
StatementList_Return:
    ReturnStatement
    ExpressionStatement
，更进一步有：
StatementList_[Return, In]:
    ReturnStatement
    ExpressionStatement
是如下的缩写：
StatementList:
    ReturnStatement
    ExpressionStatement
StatementList_Return:
    ReturnStatement
    ExpressionStatement
StatementList_In:
    ReturnStatement
    ExpressionStatement
StatementList_Return_In:
    ReturnStatement
    ExpressionStatement
多个参数产生的产出组合，不全是完整语法定义需要的。
  涉及到产出right-hand side的nonterminal也同样可以使用参数。例如：
StatementList:
    ReturnStatement
    ExpressionStatement_[+In]
等价于：
StatementList:
    ReturnStatement
    ExpressionStatement_In
而
SatementList:
    ReturnStatement
    ExpressionStatement_[~In]
等价于：
SatementList:
    ReturnStatement
    ExpressionStatement
  一个nonterminal引用可能同时包含参数列表和"opt"后缀。例如:
VariableDeclaration:
    BindingIdentifier Initializer_[+In]_opt
是下面声明的缩写：
VariableDeclaration:
    BindingIdentifier
    BindingIdentifier Initializer_In
  在一个right-hand side nonterminal引用的参数上增加?前缀，表示这个参数是否
出现在依赖于是否出现在当前产出的left-hand side标识上。例如：
VariableDeclaration_[In]:
    BindingIdentifier Initializer_[?In]
是下面声明的缩写：
VariableDeclaration:
    BindingIdentifier Initializer
VariableDeclaration_In:
    BindingIdentifier Initializer_In
  如果right-hand分支上含有前缀"[+parameter]"，那么这个分支仅在这个参数名出现
在其产出的nonterminal标识上时可用。与之相反"[~parameter]"，则在其产出的
nonterminal标识上不含有参数名时，参数分支可用。例如：
StatementList_[Return]:
    [+Return]ReturnStatement
    ExpressionStatement
是下面声明的缩写：
StatementList:
    ExpressionStatement
StatementList_Return:
    ReturnStatement
    ExpressionStatement
，再者：
StatementList_[Return]:
    [~Return]ReturnStatement
    ExpressionStatement
是下面声明的缩写：
StatementList:
    ReturnStatement
    ExpressionStatement
StatementList_Return:
    ExpressionStatement
  当词汇one of跟随在语法定义的冒号":"后时，表明随后若干行的没给terminal标识
都是一个可选定义。例如，ECMAScript的词法语法包含产出：
NonZeroDigit:: one of
    1 2 3 4 5 6 7 8 9
这仅仅是下面声明的简写：
NonZeroDigit:: one of
    1
    2
    3
    4
    5
    6
    7
    8
    9
  如果短语"[empty]"出现在产出的right-hand side中，表明产出的right-hand side没有
任何terminal或者nonterminal
  如果短语"[lookahead=seq]"出现在产出的right-hand side，表明这个产出可能仅用在
这个token序列seq是随后的token序列的前置代号，也就是说随后的token序列以seq起始。
类似的"[lookahead∈set]"，其中set是一个有限的非空的token序列的集合，表明这个
产出仅在set中的某些元素是随后token序列的前置代号。为了方便这个集合可以被写
成一个nonterminal，这表示，这个nonterminal展开为这个集合的全部token序列。如果
这个nonterminal可以被展开成无穷的不同token序列，那他被认为是一个编者的错误。
**** 就是写错了。
  有些情况需要反向定义。"[lookahead≠seq]"表明产出仅在seq不是随后token序列的
前置代号时才可能被采用，"[lookahead∉set]"表明仅在没有set中的元素是随后的token
序列的前置代号时产出才会被采用。
  举例说明，前置定义：
DecimalDigit:: one of
    0 1 2 3 4 5 6 7 8 9
DecimalDigits
    DecimalDigit
    DecimalDigits DecimalDigit
定义：
LookaheadExample::
    n [lookahead ∉ {1, 3, 5, 7, 9}] DecimalDigits
    DecimalDigit [lookahead ∉ DecimalDigit]
会匹配n跟随若干偶数或者仅一位数字形式的源文本。
  需要注意这些短语被用在语句语法的时候，可能无法准确的识别跟随的token序列
，因为确定后续的token需要知道哪个词法goal symbol在随后的位置使用。因此，如果
这些短语被用在句法语法时，会被认为是编者的错误，因为如果一个token序列seq
出现在lookahead限制（包括作为一组序列的一部分）里，如果要用的词法goal symbol
是不定的无论seq是否是结果token序列的前置代号。
  如果短语"[no LineTerminator here]"出现在语句语法的产出的right-hand side，表明
这个产出是一个被限制的产出，他不可以被用在那些LineTerminator出现在指定位置
的输入流。例如产出：
ThrowStatement:
    throw [no LineTerminator here] Expression;
指明这个产出不能用在LineTerminator出现在throw token与Expression之间的输入流上。
  除非LineTerminator是被限制产出明确禁止的，任意个LineTerminator可以在输入元素
流里任何两个连续的token间出现，不影响这个脚本的合理性。
  当在词法与数字产出出现在一个多码的token中时，这表示对应的代码序列要构成
一个对应的token。
  产出right-hand有可能会用短语"but not"来限制某种展开，表明不包含这种展开。例
如产出：
Identifier::
    IdentifierName but not ReservedWord
意味着nonterminal Identifier可以是被那些提供的编码不能替换为ReservedWord的
IdentifierName替换。
**** 简单来说就是集合IdentifierName - 集合ReseredWord
  最后有少些nonterminal被描述短语"sans-serif"描述的标识难以列举所有的选项：
SourceCharacter::
    any Unicode code point
** 5.2 算法约定
  本规范经常使用若干列表指明算法步骤。这些算法被用于精确指明ECMAScript
语言结构的需要语义。算法不是意图暗示任何实现技术。事实上，鼓励用更有效
的算法实现给定的特性。
  算法可能被用一个有序的、逗号分隔的别名序列参数化，这些参数名会被用在
算法步骤里，代表在相应位置传进来的数据。可选的参数被方括号包含（如
[,name]），但是在算法步骤上没有差异。剩余形式的参数需要在参数列表的末端，
以省略号开始（,...name）。剩余形式的参数捕获在必须参数和可选参数后的提供
的所有参数放到一个List中。如果没有这种额外的参数，这个List是空的。
  算法步骤可能需要再分为有序的子步骤。子步骤是缩进的，并可能继续拆分到
缩进的子步骤中。第一层用数字标记步骤，第一层的子步骤（第二层）用小写字母
标记，第二层的子步骤（第三层）用小写的罗马数字标记。如果还有更多的层级
需要标记那就从第四层重复这个规则。例如：
1. Top-level step
    a. Substep
    b. Substep
        i. Subsubstep
        ii.Subsubstep
            1. Subsubsubstep
                a. Subsubsubsubstep
                    i. Subsubsubsubsubstep
  步骤或者子步骤会使用"if"表明本步骤需要的条件。这时只有条件是true是，这个
步骤才会被采用。如果步骤或者子步骤用"else"开始，这表明当之前同级"if"过程得
到相反结果时，此步骤才会被采用。
  步骤会有迭代的子步骤。
  以"Assert"/"断言"开始的步骤认定为此算法的恒定条件。这种声明被用于明确的
算法条件，否则就是内含的条件。并没有增加额外的语义要求，因此也无需实现
检查。他们只是让算法清晰。
  算法步骤会用"Let x be someValue"的形式定以一些别名。这些别名与"x"和
"someValue"一样是某些根本数据的引用，一个修改了内容，别的也都可见。算法步骤
想避免这种引用行为时，会使用"Let x be a copy of someValue"来浅复制someValue。
  一旦声明了别名，后续任意步骤都可以引用此别名，但是之前的步骤不行。别名
可以通过"Set x to someOtherValue"的方式修改别名指向。
*** 5.2.1 抽象操作
  为了便利一些算法在本规范的不同部分使用，称这些算法为抽象操作，被命名和
定义为带参数的函数形式，以便于被其他算法用名称的方式引用。抽象操作通常的
引用方式是函数调用，类似OperationName(arg1, arg2)。在一些class-like的规范抽象
的部分抽象操作被当作多态处理的方法。这些方法样子的抽象操作一般引用方式是
someValue.OperationName(arg1, arg2)。
*** 5.2.2 面向句法的操作
  面向句法的操作是一个命名的操作，包含若干算法，每个算法联系若干ECMAScript
语法产出。产出还有多个备选定义，但是每个备选有明确的算法。当算法联结到
语法产出后，算法可能会通过参数的方式引用产出备选的终结和非终结符。用这种
方式时，非终结符指向一个从源文本解析出的实际的备选定义。语法产出匹配的源
文本是源码的一部分，这部分源码从参与匹配的第一个终结符开始，结束到参与匹
配的最后一个终结符结束。
  当算法联结到产出备选，这个备选一般不会有任何"[]"，这种语法注解。这种注解
应该仅用于句法识别备选，而且不能对联结的备选的语义有任何作用。
  在下面的算法中的1、3、4约定的步骤中，带着解析节点和可选的参数，面向句法
的操作会被调用：
1. 让status是SomeNonTerminal的SyntaxDirectedOperation
2. 让someParseNode是某些源码的解析
3. 执行someParseNode的SyntaxDirectedOperation
4. 传递value作为参数，执行someParseNode的SyntaxDirecteOperation
  除非显式声明，否则所有的链环产出对于每个操作都有一个隐式定义，这个会被
当作产出的left-hand side的非终止符。如果有上述非终止符，这个隐式的定义就简
单的重复提交相同的操作和相同的参数，给链环产出的right-hand side非终止符，然
后返回这个结果。比如，假设算法有一步骤是：“返回评估Block的结果”，就会有
这样的一个产出：
Block:
    { StatementList }
但是评估操作不会联结算法与产出。这样，评估操作隐式的包含如下形式的联结：
Runtime Semantics: Evaluation
Block: { StatementList }
    1. 返回StatementList的评估结果。
**** 评估是运行语义的行为。
*** 5.2.3 运行语义
  描述只在运行时被调用的语义的算法称为运行语义。运行语义被定义为抽象操作
或者面向语句的操作。都会返回一个结束记录。
**** 5.2.3.1 隐式结束值
  本规范的算法通常隐式的返回结束记录，其Type是normal。除非语境中有其
他明显的形式，算法语句才会返回一个不是结束记录的值，例如：
1. Return "Infinity"
意味着同下：
1. Return NormalCompletion("Infinity")
  然而，如果return语句的表达式的值是一个结束记录的构造语句，返回结束记录的
结果。如果是抽象操作，返回语句就是简单返回抽象操作产生的结束记录。
  抽象操作Completion(completionRecord)用于强调返回之前计算的结束记录。Completion
抽象操作接受一个参数completionRecord，按照下述步骤执行：
1. 断言completionRecord是结束记录
2. 将completionRecord作为这个抽象操作的结束记录返回。
  算法步骤中"return"语句没有值，意味着：
1. 返回NormalCompletionRecord(undefined)
  如果完结记录不是意外完结，在语境中又没有明确要求是完整的完结记录，那么
任何完结记录的引用的值是指完结记录的Value字段。
**** 5.2.3.2 投掷异常
  算法会投掷异常，例如：
1. Throw a TypeError exception
意味着：
1. Return ThrowCompletion(a newly created TypeError object)
**** 5.2.3.3 意外就返回
  算法步骤有如下或等价描述：
1. ReturnIfAbrupt(argument)
意味着：
1. 如果argument是一个意外完结，返回argument
2. 否则如果argument是一个完结记录，以argument的Value覆盖argument
  算法步骤有如下或等价描述：
1. ReturnIfAbrupt(AbstractOperation())
意味着：
1. 让hygienicTemp是AbstractOperation()
2. 如果hygienicTemp是意外完结，返回hygienicTemp
3. 否则如果hygienicTemp是完结记录，以hygienicTemp的Value覆盖hygienicTemp
这里hygienicTemp是短暂的，仅被ReturnIfAbrupt适用的步骤可见。
  算法步骤有如下或等价描述：
1. 让result是AbstractOperation(ReturnIfAbrupt(argument))
意味着：
1. 如果argument是意外完结，返回argument
2. 如果argument是完结记录，以argument的Value覆盖argument
3. 让result是AbstractOperation(argument)
**** 5.2.3.4 意外就返回的简写
  调用的抽象操作和面向句法的操作有前缀"?"，表明意外就返回被用在计算完结记
录上。例如步骤：
1. ?OperationName()
等价于：
1. ReturnIfAbrupt(OperationName())
类似的，方法运用形式的步骤：
1. ?someValue.OperationName()
等价于：
1. ReturnIfAbrupt(someValue.OperationName())
  类似的，前缀"!"被用于表明后续调用抽象或面向句法的操作绝对不会返回一个意
外完结，而且完结记录的Value备用作操作的返回值。例如步骤：
1. 让val是!OperationName()
等价于如下步骤：
1. 让val是OperationName()
2. 断言val不是意外完结
3. 如果val是完结记录，让val的Value覆盖val
  运行语义的面向句法的操作调用使用!和?这种前缀简写：
4. Perform !SyntaxDirectedOperation of NonTerminal
*** 5.2.4 静态语义
  上下文无关语法没有足够的能力表达定义在被评估的Script或Module的输入元素流的
所有规则。在这些情况下，需要额外的规则来表达ECMAScript算法约定或者散文要
求。这种规则总是联结到一个语法产出，被称作产出的静态语义。
  静态语义规则有名字，通常使用算法定义。命名的静态语义规则联结到语法产出，
产出有多个备选定义，每个备选针对提供的命名的静态语法规则有明确的算法。
  一类特殊的静态语法规则是前期错误规则。前期错误规则定义了前期错误条件，联
结到特定的语法产出。大多数的前期错误的评估不是在本规范的的算法内被显示调用
的。一个一致实现必须，在首次评估Script或Module前，校验Script或者Module解析的产
出的所有前期错误规则。任何前期错误规则被违反，这个Script或者Module就是无效的
且不能被评估。
*** 5.2.5 数学操作
  本规范给各种数字值相应的引用方式：
1. 数学值 Mathematical values: 任意实数，作为默认数字类型
2. 扩展数学值 Extended mathematical values: 包含+∞和-∞的Mathematical values
3. Numbers: IEEE 754-2019双精度浮点数值
4. BigInts: ECMAScript值准确表示任意有限整数
  本规范的语言中，使用下标后缀明确各种不同数字类型的数值。下标F表示浮点
数，下标Z表示BigInt，不带下标则是数学值。
  数学操作符如：+、*、=和≥指那些与运算符一致的操作。就是如果被提供了数学
值，这些操作符指的就是那些常用的数学运算。如果提供了Numbers，这些操作符指
的就是IEEE 754-2019内相应的操作。如果被提供了BigInt，这些操作符指将BigInt转
换为数学值后再应用常用的数学运算。
   通常，在本规范引用数字值的时候，例如短语"the length of y"或者"the integer 
represented by the four hexadecimal digits ..."，没有任何显式的数字类型声明，这个
短语表示的是数学值。短语需要显示声明使用的是指Numbers或者BigInt，例如，"the
Number value for the number of code points in ..."或者"the BigInt value for ..."。
   没有定义含有混合类型运算（比如Numbers与数学值）的数字操作符，应当被认为
是本规范的编辑错误。
   本规范中绝大多数数值使用十进制；有时会是Ox跟随0-9或和A-F的形式的16进制
数。
   本规范中如果使用integer术语，除非另有声明，指的是整数集上的数学值。如果
是integer Number术语，指的是其数学值在整数集上的Numbers。
   本文档里数学值与Numbers或BigInt之间的转换总是显式的。从数学值或者扩展数
值到Numbers的转换被明示为"the Number value for x"或者F(x)，在[[6.1.6.1]]有明确定义。
从整数x到BigInt的转换被明示为"the BigInt value for x"或者Z(x)。从Numbers或
者BigInt到数学值的转换被明示为"the mathematical value of x"或者R(x)。+0和-0的数
学值是数学值0。无穷的数学值没有定义。有限值x的扩展数学值x就是x的有限数学
值，+∞和-∞依次是+∞_F和-∞_F的值。NaN没有定义的数学值。
  数学函数abs(x)产生x的绝对值，如果x<0，就是-x否则就是x本身。数学函数min(x1,
x2,...,xN)产生x1到xN中数学意义上最小的。数学函数max(x1,x2,...,xN)产生x1到xN中
数学意义上最大的。这些数学函数的定义域是扩展数学值。
  "x modulo y"（y是有限的非零的）记法，计算一个与y（或者0）同号的k，满足
abs(k) < abs(y)且x-k = q * y，其中q是整数值。
  短语"the result of clamping x between lower and upper"（x是扩展整数值，lower和
upper是数学值，而且lower≤upper），如果x<lower，产生lower，如果x>upper，产生
upper，其他产生x。
  数学函数floor(x)产生不超过x的最大的整数，如果x是+∞，就是最接近+∞的整数。
  数学函数min,max,abs,floor没有为Numbers和BigInt定义，任何非数学值应用了这些
方法，都是一个编辑错误。
**** floor(x) = x - (x modulo 1)
*** 5.2.6 值记法
  本规范中，ECMAScript语言值用粗体显示。例如null，true或者"hello"。这些区别于
更长的ECMAScrpit代码序列比如：Function.prototype.apply或者let n = 42;
  本规范内部的，不能被ECMAScript代码直接察觉的值用sans-serif字体表示。例如，
完结记录的Type字段的值像normal、return、或者throw。
* 第六章
  本规范的算法操作的值都有一个联结的类型。可能的值类型在本条款确定。Type
进一步细分为ECMAScript语言的类型和规范的类型。
  在本规范，记号"Type(x)"用于简化"the type of x"，其中type指本条款定义的
ECMAScript语言的类型和规范的类型。"empty"术语用于声明一个值时，等于说"no 
value of any type"
** 6.1 用于ECMAScript语言的类型
ECMAScript语言的类型与ECMAScript语言编写的ECMAScript程序操作的值一致。ECMAScript
语言的类型有Undefined、Null、Boolean、String、Symbol、Number、BigInt和Object。
ECMAScript语言的值必然是被ECMAScript语言类型描述的。
*** 6.1.1 Undefined类型
  Undefined类型就一个值，即undefined。任何变量没有被赋值前都有undefined值。
*** 6.1.2 Null类型
  Null类型就一个值，即null。
*** 6.1.3 Boolean类型
  表示逻辑实体的Boolean类型有两个值，即true和false。
*** 6.1.4 String类型
  String类型是所有0到2^53-1个16位二进制无符号数（元素）构成的有序序列的集
合。在运行中的ECMAScript程序中String类型用于表示文本数据，这种情景下每个
String元素被当作UTF-16的编码单元值。在序列中，每个元素被认为占据一个位置。
位置使用非负整数索引。第一个元素（如果有）索引是0，随后元素（如果有）是1，
依次类推。String的长度就是他含有的元素数量。空String长度是0，因此也就没有元
素。
  不会翻译String内容的ECMAScript操作不提供任何延伸语义。翻译String值的操作把
每个元素当作UTF-16编码单元。然而ECMAScript不会限制这些编码单元的值或者关系，
所以将String内容作为Unicode编码单元翻译的操作必须考虑从错误格式的自序列。
这些操作需要对每个在[0xD800,0xDBFF]区间的编码单元（在Unicode标准中，作为首
位，或者通用的说法高位编码单元）和每个在[0xDC00,0xDFFF]区间的编码单元（被定
以为尾位，或者通用的说法低位编码单元）依据如下规则提供特殊的处理：
1. 一个编码单元既不是首位也不是尾位，按照原本值翻译。
2. 有两个编码单元的序列，如果第一个编码单元c1是首位，第二个编码单元c2是尾
位，这就是一个编码对，需要按照一个编码点进行翻译，编码点的值是
(c1 - 0xD800)*0x400+(c2-0xDC00)+0x10000
3. 如果编码单元是首位或者尾位，但是按照编码对出现，就按照原本值翻译。
**** 我觉得在组织编码时，这里有个注意事项，就是需要连续独立显示首位和尾位
     时，中间需要增加隔离符号。
  函数String.prototype.normalize(见于22.1.3.13)备用显式的规范String值。
String.prototype.localeCompare(见于22.1.3.10)内部规范String值，但是其他操作不会在
操作内容上隐式的规范String值。只有那些显式指明是语言或者地域敏感的操作产出
语言敏感的结果。
**** 这种设计的深层原因是让String的实现尽可能简单和高效。如果ECMAScript源文本
是C规范的，字符串原文被确保是规范的，只要没有包含任意的Unicode。
  本规范里，短语"the string-concatenation of A,B,..."（每个参数都是String值、编
码单元、或者编码单元序列），表示按照参数顺序依次拼接参数的编码单元序列形
成的编码单元序列的String值。
  短语"the substring of S from inclusiveStart to exclusiveEnd"（S是一个编码单元序列
的String值，inclusiveStart和exclusiveEnd是整数），表示S单元序列上[inclusiveStart,
exclusiveEnd)区间（如果inclusiveStart==exclusiveEnd，会是空集）上的编码单元的
String值。如果缺省了"to"，S的长度作为exclusiveEnd。
**** 6.1.4.1 StringIndexOf(string, searchValue, fromIndex)
  抽象操作StringIndexOf使用参数string（String值）,searchValue（String值）和
fromIndex（非负整数）。被调用时按照下列步骤执行：
1. Assert：Type(string)是String
2. Assert：Type(searchValue)是String
3. Assert：formIndex是非负整数
4. 让len是string的长度
5. 如果searchValue是空String，而且fromIndex≤len，返回fromIndex
6. 让searchLen是searchValue的长度
7. 每个从fromIndex开始到的i，且i≤len-searchLen的整数，按照升序依次执行
    a. 让candidate是substring of string from i to i+searchLen
    b. 如果candidate与searchValue有相同的编码序列，返回i
8. 返回 -1
**** 注意。如果searchValue而且fromIndex不大于string的长度时返回fromIndex。这用
空String可以在string的任何位置被找到。
**** 如果fromIndex > string的长度，算法返回-1
*** 6.1.5 Symbol类型
  Symbol类型是所有可以被用于Object属性的键，且不是Sring值的集合。
  每个Symbol值是唯一且无法修改的。
  每个Symbol值不可修改的联结到一个被称为Description的值，undefined或者是String
值。
**** 6.1.5.1 既有Symbols
  既有symbol是内置的Symbol值，用于显式引用本规范的算法。他们通常被用于属性
的键，对应的属性值作为本规范的算法的扩展点。除非特殊说明，所有的既有symbol
在全部领下可用。
  本规范内，既有symbol使用@@name形式的标注来引用，name是下表的值。
| Specification Name   | Description                     | Value and Purpose                                                                                     |
| @@asyncIterator      | "Symbol.asyncIterator"      | 为对象返回一个默认的AsyncIterator方法。被语句for-await-of语义调用                                     |
| @@hasInstance        | "Symbol.hasInstance"        | constructor对象识别一个对象是否是自身实例的方法。被instanceOf操作符调用                               |
| @@isConcatSpreadable | "Symbol.isConcatSpreadable" | 属性值是Boolean。如果true，表明对象应该被Array.prototype.concat展平为其数组元素                       |
| @@iterator           | "Symbol.iterator"           | 为对象返回默认Iterator的方法。被for-of语句的语义调用。                                                |
| @@match              | "Symbol.match"              | 正则表达式用于匹配字符串的方法。被String.prototype.match方法调用                                      |
| @@matchAll           | "Symbol.matchAll"           | 正则表达式返回一个遍历器的方法，遍历器提供表达式匹配字符串的结果。被String.prototype.matchAll方法调用 |
| @@replace            | "Symbol.replace"            | 正则表达式替换字符串上匹配的子串的方法。被String.prototype.replace方法调用                            |
| @@search             | "Symbol.search"             | 正则表达式返回字符串上匹配的位置索引。被String.prototype.search方法调用                               |
| @@species            | "Symbol.species"            | 其属性值是constructor函数，用于创建衍生对象                                                           |
| @@split              | "Symbol.split"              | 正则表达式用于将字符串在匹配的位置索引上进行拆分的方法。被String.prototype.split方法调用              |
| @@toPrimitive        | "Symbol.toPrimitive"        | 用于将对象转换为基础值的方法。被ToPrimitive抽象操作调用                                               |
| @@toStringTag        | "Symbol.toStringTag"        | 属性值是String值，用于创建对象的默认描述。被内置方法Object.prototype.toString访问                     |
| @@unscopables        | "Symbol.unscopables"        | 属性值是对象，对象自有或继承的属性名称是被联结对象绑定的with环境排除的属性名                          |
*** 6.1.6 数值类型
  ECMAScript有两种内置的数值类型：Number和BigInt。本规范任意数值类型T包含乘法
标识记为T::unit。本规范类型也有跟随的抽象操作，就像规范名称op上的给定操作
记为T::op。所有参数是T。"Result"列显示返回的类型，如果调用操作可能会返回意
外完结，"Result"会有标示。
| 调用概要                  | 源文件示例                               | 调用者的评估语义所属                                                     | Result                           |
| T::unaryMinus(x)          | - x                                      | Unary - Operator                                                         | T                                |
| T::bitwiseNOT(x)          | ~ x                                      | 按位非操作符( ~ )                                                        | T                                |
| T::exponentiate(x, y)     | x ** y                                   | 幂运算操作和Math.pow(base, exponent)                                     | T,可能会投掷范围异常             |
| T::multiply(x, y)         | x * y                                    | 乘法算符                                                                 | T                                |
| T::divide(x, y)           | x / y                                    | 乘法算符                                                                 | T,可能会投掷范围异常             |
| T::remiander(x, y)        | x % y                                    | 乘法算符                                                                 | T,可能会投掷范围异常             |
| T::add(x, y)              | x \+\+, \+\+ x, x + y                    | 后自增算符，前自增算符和加法算符                                         | T                                |
| T::subtract(x, y)         | x--, --x, x - y                          | 后自减算符，前自减算符和减法算符                                         | T                                |
| T::leftShift(x, y)        | x << y                                   | 左移算符（<<）                                                           | T                                |
| T::signRightShift(x, y)   | x >> y                                   | 有符号右移算符（>>）                                                     | T                                |
| T::unsignRightShift(x, y) | x >>> y                                  | 无符号右移算符（>>>）                                                    | T，可能会投掷类型错误            |
| T::lessThan(x, y)         | x < y, x > y, x <= y, x >= y             | 关系算符，通过抽象关系比较                                               | Boolean或者undefined（无序输入） |
| T::equal(x, y)            | x \=\= y, x !\= y, x \=\=\= y, x !\=\= y | 相等算符，通过严格相等比较                                               | Boolean                          |
| T::sameValue(x, y)        |                                          | Object内部方法，通过SameValue(x, y)检测相等性                            | Boolean                          |
| T::sameValueZero(x, y)    |                                          | Array、Map和Set方法，通过SameValueZero(x, y)检测相等性，忽略+0与-0的差别 | Boolean                          |
| T::bitwiseAND(x, y)       | x & y                                    | 二进制按位操作符                                                         | T                                |
| T::bitwiseXOR(x, y)       | x ^ y                                    | 二进制按位操作符                                                         | T                                |
| T::bitwiseOR(x, y)        | x \vert y                                | 二进制按位操作符                                                         | T                                |
| T::toString(x)            | String(x)                                | 很多表达式或者内置函数，通过ToString(argument)                           | String                           |
  T::unit值和T::op运算不是ECMAScript语言的部分，在这里定义它们，仅仅就是帮助
ECMAScript语言的语义规范。其他抽象操作通过本规范定义。
  因为数字类型在转换时通常会丢失精度或者截断，所以ECMAScript语言在这个类型
间不提供隐式的转换。程序员必须显式调用Number和BigInt函数来转换类型，如果调
用的函数需要不同的类型时。
**** 注意 从第一版ECMAScript开始，针对某些操作，已经提供了隐式的会丢失精度
的数值转换。这些合法的转换被保留在后续的兼容里，但是支持BigInt，以便减少
程序错误的几率，和在未来版本保留通用值类型的选项。
**** 6.1.6.1 Number类型
  Number类型有18,437,736,874,454,810,627（就是2^64 - 2^53 + 3）个值，表示IEEE 
754-2019的双精度64位格式值，在IEEE标准中为二进制浮点数代数而规定的，除了
9,007,199,254,740,990（就是2^53 - 2）个被识别为IEEE标准中的"Not-a-Number"值。
这些"Not-a-Number"值在ECMAScript中被用一个特殊NaN值表示。（注意NaN值是被程序
表达式NaN产生的）。在某些实现中，扩展代码可能侦测到不同Not-a-Number值的差
异，但是这种行为是实现定义的。ECMAScript代码所有的NaN是不区分。
***** 注意在ArrayBuffer（见于[[25.1]]）或者SharedArrayBuffer（监狱[[25.2]]）中，一个
Number值被存储到其中后，可能侦测到这种位模式值（能够区分的NaN），这种
位模式没有必要与ECMAScript实现使用内部表示Number值的行为一致。
  有两个特殊的值：正无穷与负无穷。为了方便，这些值依次用说明性更好的符号
\+∞_F和\-∞_F表示（这两种Number值用+Infinity或者简单的Infinity和-Infinity产生）。
  其他18,437,736,874,454,810,624(就是2^64 - 2^53)值被称为有限值。一半正数，一半
负数。每个有限的正Numbr值都有一个对应的相同规模的负值。
  注意这里有一个正0一个负0。为了简便，这些值依次用说明性更好的符号+0_F和
-0_F的方式表示（这两种零Number值被程序表达式+0或0和-0产生）。
  这18,437,736,874,454,810,622（就是2^64 - 2^53 - 2）个非零有限值分类两类：
18,428,729,675,200,069,632（2^64 - 2^54 ）是正常化的，具有 s * m * 2^e 的形式
其中s是1或-1，m是在[2^52, 2^53)上的整数，e是[-1074,971]上的整数。剩下的
9,007,199,254,740,990（2^53 - 2）个数是非正常化的，也具有 s * m * 2 ^e 的形式，
其中s是1或-1，m是在(0, 2^52)上的整数，e是-1074.
  注意所有Number类型的整数的规模不会超过2^53。整数0有两种Number类型：+0_F和
-0_F。
  按照上述形式表达的非零有限值，如果m是奇数，这个数有奇数精度。否则是偶数
精度。
  本规范中，短语"x的Number值"，其中x表示一个实数（包括pai这种无理数），意味
Number值按照下列方式选中。（Number值都是有限精度的有理数）。构建一个包含除
-0_F以外的有限值和两个不被有限Number类型表示的特殊值，即2^1024（1*2^53*2^971）
和-2^1024（-1*2^53*2^971），的集合。在其中选择一个数最接近x的元素。如果有两个
与x一样，那么选择是偶数精度，因此2^1024与-2^1024被认为是偶数精度。如果选中
2^1024，替换为\+∞_F；如果是选中-2^1024，替换为-∞_F；如果选中+0，且x<0，替换为
-0；其他选中保持不便。这个结果就是"x的Number值"。（这个产出与IEEE 754-2019的
向偶数近似模式严格一致）。
  \+∞的Number值是\+∞_F，\-∞的Number值是\-∞_F。
  有些ECMAScript操作只能处理在[-2^31,2^31-1]或者[0,2^16-]上的整数。这些算符接受
全部的Number值，但是算法第一步会转换为期望范围内的整数。数字转换的细节描述
在[[7.1]]。
  Number::unit的值是1_F
***** 6.1.6.1.1 Number::unaryMinus(x)
  抽象操作Number::unaryMinus接受参数：Number值x，被调用时执行下列两步：
1. 如果x是NaN，返回NaN。
2. 返回相反的x；就是带有相反符号但是相同规模的Number值。
***** 6.1.6.1.2 Number::bitwiseNOT(x)
  抽象操作Number::bitwiseNOT接受参数：Number值x，被调用时执行下列两步：
1. 让oldValue是!ToInt32(x).
2. 返回oldValue的二进制补码。结果的数学值可以准确表示为32位二进制补码的字
符串。
***** 6.1.6.1.3 Number::exponentiate(base, exponent)
  抽象操作Number::exponentiate接受参数：Number值base与exponent，返回一个基于实现的
近似于base上幂乘exponent的结果（也就是说相同算式在不同实现上结果可能不同）。
被调用时按照如下步骤执行：
1. 如果exponent是NaN，返回NaN。
2. 如果exponent是+0_F或者-0_F，返回1_F。
3. 如果base是NaN，返回NaN。
4. 如果base是+∞_F，那么：
    a. 如果exponent>+0_F，返回+∞，否则返回+0_F。
5. 如果base是-∞_F，那么：
    a. 如果exponent>+0_F，那么：
        i. 如果exponent是奇数Number，返回-∞_F。否这返回+∞_F。
    b. 否则
        i. 如果exponent是奇数Number，返回-0_F。否则返回+0_F。
6. 如果base是+0_F，那么：
    a. 如果exponent > +0_F，返回+0_F。否则返回+∞_F。
7. 如果base是-0_F，那么：
    a. 如果exponent>+0_F，那么：
        i. 如果exponent是奇数Number，返回-0_F，否则返回+0_F。
    b. 否则
        i. 如果exponent是奇数Number，返回-∞_F，否则返回+∞_F。
8. Assert：base是有限的，而且不是+0_F和-0_F。
9. 如果exponent是+∞_F，那么：
    a. 如果abs(R(base))>1，返回+∞_F。
    b. 如果abs(R(base))是1，返回NaN。
    c. 如果abs(R(base))<1，返回+0_F。
10. 如果exponent是-∞_F，那么：（-∞_F在规范中被看作是偶数）
    a. 如果abs(R(base))>1，返回+0_F。
    b. 如果abs(R(base))是1，返回NaN。
    c. 如果abs(R(base))<1，返回+∞_F。
11. Assert： exponent是有限的，而且不是+0_F和-0_F。
12. 如果 base < +0_F，而且exponent不是整数Number，返回NaN。
13. 返回表示R(base)幂乘R(exponent)结果的实现近似值。
****** 注意 base ** exponent的结果在 base 是1_F或者-1_F且exponent是+∞_F或者-∞_F
，和base是1_F且exponent是NaN时与IEEE 754-2019不同。在最早ECMAScript版本中规定为
NaN，而在最新的IEEE 754-2019中规定为1_F。为了兼容，历史ECMAScript行为被保留了
下来。
***** 6.1.6.1.4 Number::multiply(x, y)
  抽象操作Number::multiply接受Number值参数：x, y。依据IEEE 754-2019中二进制双精
度算术规则执行乘法，产生x和y的乘积。被调用时，执行下列步骤：
1. 如果x或y是NaN，返回NaN。
2. 如果x是+∞_F或者-∞_F，
    a. 如果y是+0_F或者-0_F，返回NaN。
    b. 如果y > +0_F，返回x。
    c. 返回-x。
3. 如果y是+∞_F或者-∞_F，
    a. 如果x是+0_F或者-0_F，返回NaN。
    b. 如果x > +0_F，返回y。
    c. 返回-x。
4. 返回F(R(x)*R(y))
****** 有限精度乘法满足交换律，但是不满足结合律。
***** 6.1.6.1.5 Number::divide(x,y)
  抽象操作Number::divide接受Number值参数：x, y。依据IEEE 754-2019中二进制双精
度算术规则执行乘法，产生x除以y的商。被调用时，执行下列步骤：
1. 如果x是NaN或者y是NaN，返回NaN。
2. 如果x是+∞_F或者-∞_F，那么：
    a. 如果y是+∞_F或者-∞_F，返回NaN。
    b. 如果y是+0_F或者y>+0_F，返回x。
    c. 返回-x。
3. 如果y是+∞_F，那么
    a. 如果x是+0_F或者x>+0_F，返回+0_F。否则返回-0_F。
4. 如果y是-∞_F，那么
    a. 如果x是+0_F或者x>+0_F，返回-0_F。否则返回+0_F。
5. 如果x是+0_F或者-0_F，那么
    a. 如果y是+0_F或者-0_F，返回NaN。
    b. 如果y>+0_F，返回x。
    c. 返回-x。
6. 如果y是+0_F，那么
    a. 如果x>+0_F，返回+∞_F。否则返回-∞_F。
7. 如果y是-0_F，那么
    a. 如果x>+0_F，返回-∞_F。否则返回-∞_F。
8. 返回F(R(x)/R(y))
***** 6.1.6.1.6 Number::remainder(n,d)
  抽象操作Number::remainder接受Number值参数：n, d。从隐含的n除以d计算获得余数。
被调用时，执行下列步骤：
1. 如果n是NaN，或者d是NaN，返回NaN。
2. 如果n是+∞_F或者-∞_F，返回NaN。
3. 如果d是+∞_F或者-∞_F，返回n。
4. 如果d是+0_F或者-0_F，返回NaN。
5. 如果n是+0_F或者-0_F，返回n。
6. Assert：n和d是有限非零的。
7. 让r是R(n)-(R(d)*q)。q是整数，如果n与d不同号，q是负数。q的规模不超过
R(n)/R(y)的规模的情况下尽可能大。
8. 返回F(r)。
****** 注意1 C与C++在remainder操作中只接受整数，而ECMAScript中也接受浮点数。
****** 注意2 浮点数通过%计算获得的余数与IEEE 754-2019定义的不同。在IEEE 754-2019
中余数采用四舍五入商计算，而不是结算商，所以其行为与常用的整数求余不同。
相较于C库中的函数fmod，ECMAScript语言的%在浮点数上的的计算与Java的整数求余的
行为更相似。
***** 6.1.6.1.7 Number::add(x, y)
  抽象操作Number::add接受Number值参数：x, y。依据IEEE 754-2019中二进制双精
度算术规则执行加法，产生x与y的和。被调用时，执行下列步骤：
1. 如果x是NaN，或者y是NaN，返回NaN。
2. 如果x是+∞_F，且y是-∞_F，返回NaN。
3. 如果x是-∞_F，且y是+∞_F，返回NaN。
4. 如果x是+∞_F或者-∞_F，返回x。
5. 如果y是+∞_F或者-∞_F，返回y。
6. Assert：x和y是都是有限的。
7. 如果x是-0_F，且y是-0_F，返回-0_F。
8. 返回F(R(x)+R(y))。
****** 有限精度加法符合交换律，但是不符合结合律。
***** 6.1.6.1.8 Number::subtract(x,y)
  抽象操作Number::subtract接受Number值参数：x, y。执行减法，产生x减以y的结果。
被调用时，执行下列步骤：
1. 返回 Number::add(x, Number::unaryMinus(y))
****** 注意 x - y的结果总是与 x + (- y) 的结果一致。
***** 6.1.6.1.9 Number::leftShift(x, y)
  抽象操作Number::leftShift接受Number值参数：x，y。被调用时，执行下列步骤：
1. 让lnum是!ToInt32(x)
2. 让rnum是!ToUint32(y)
3. 让shiftCount是R(rnum)对于32的模，R(rnum)%32
4. 返回lnum左移shiftCount位的结果。结果的数学值准确表示这个32位的2禁止字符串。
***** 6.1.6.1.10 Number::signedRightShift(x,y)
  抽象操作Number::signedRightShift接受两个Number值参数：x、y。被调用时，执行
下列步骤：
1. 让lnum是!ToUint32(x)
2. 让rnum是!ToUint32(y)
3. 让shiftCount是R(rnum)在32上的模
4. 返回lnum按符号右移shiftCount位的结果。空位用符号位值填充。结果的数学值准
确表示结果的32位二进制补码串
***** 6.1.6.1.11 Number::unsignedRightShift(x,y)
  抽象操作Number::unsignedRightShift接受两个Number值参数：x、y。被调用时，执行
下列步骤：
1. 让lnum是!ToUint32(x)
2. 让rnum是!ToUint32(y)
3. 让shiftCount是R(rnum)在32上的模
4. 返回保留符号位lnum右移shiftCount位以0填充的结果。空位用0填充。结果的数学值
准确表示结果的32位无符号二进制串。
***** 6.1.6.1.12 Number::lessThan(x,y)
  抽象操作Number::lessThan接受两个Number值参数：x、y。被调用时，执行下列步骤：
1. 如果x是NaN，返回undefined
2. 如果y是NaN，返回undefined
3. 如果x、y是相同的Number值，返回false
4. 如果x是+0_F，y是-0_F，返回false
5. 如果x是-0_F，y是+0_F，返回false
6. 如果x是+∞_F，返回false
7. 如果y是+∞_F，返回true
8. 如果y是-∞_F，返回false
9. 如果x是-∞_F，返回true
10. Assert：x和y都是有限的非零Number值
11. 如果R(x)<R(y)，那么返回true。否则返回false。
***** 6.1.6.1.13 Number::equal(x,y)
  抽象操作Number::equal接受两个Number值参数：x、y。被调用时，执行下列步骤：
1. 如果x是NaN，返回false
2. 如果y是NaN，返回false
3. 如果x、y是相同的Number值，返回true
4. 如果x是+0_F，y是-0_F，返回true
5. 如果x是-0_F，y是+0_F，返回true
6. 返回false
***** 6.1.6.1.14 Number::sameValue(x,y)
  抽象操作Number::sameValue接受两个Number值参数：x、y。被调用时，执行下列步骤：
1. 如果x是NaN，而且y也是NaN，返回true
2. 如果x是+0_F，y是-0_F，返回false
3. 如果x是-0_F，y是+0_F，返回false
4. 如果x、y是相同的Number值，返回true
5. 返回false
***** 6.1.6.1.15 Number::sameValueZero(x,y)
  抽象操作Number::sameValueZero接受两个Number值参数：x、y。被调用时，执行下列
步骤：
1. 如果x是NaN，而且y也是NaN，返回true
2. 如果x是+0_F，y是-0_F，返回true
3. 如果x是-0_F，y是+0_F，返回true
4. 如果x、y是相同的Number值，返回true
5. 返回false
***** 6.1.6.1.16 NumberBitwiseOp(op, x, y)
  抽象操作NumberBitwiseOp接受参数：op（Unicode字符串）、Number值x和Number值y。被调
用时执行下列步骤：
1. Assert：op是"&"、"^"或者"|"
2. 让lnum是!ToInt32(x)
3. 让rnum是!ToInt32(y)
4. 让lbits是表示R(lnum)的32位2进制补码字符串
5. 让rbits是表示R(rnum)的32位2进制补码字符串
6. 如果op是&，让result是在lbits和rbits上使用按位与（AND）操作的结果
7. 如果op是^，让result是在lbits和rbits上使用按位异或（XOR）操作的结果
8. 如果op是|，让result是在lbits和rbits上使用按位或（OR）操作的结果
9. 返回result代表的整数的Number值
***** 6.1.6.1.17 Number::bitwiseAND(x,y)
  抽象操作Number::bitwiseAND接受两个Number值参数：x、y。被调用时，执行下列步
骤：
1. 返回NumberBitwiseOp('&', x, y)
***** 6.1.6.1.18 Number::bitwiseXOR(x,y)
  抽象操作Number::bitwiseXOR接受两个Number值参数：x、y。被调用时，执行下列步
骤：
1. 返回NumberBitwiseOp('^', x, y)
***** 6.1.6.1.19 Number::bitwiseOR(x,y)
  抽象操作Number::bitwiseOR接受两个Number值参数：x、y。被调用时，执行下列步
骤：
1. 返回NumberBitwiseOp('|', x, y)
***** 6.1.6.1.20 Number::toString(x)
  抽象操作Number::toString接受一个Number值参数x。转换x为字符串格式。被调用
时，执行下列步骤：
1. 如果x时NaN，返回字符串"NaN"
2. 如果x是+0_F或者-0_F，返回字符串"0"
3. 如果x<+0_F，返回"-"与!Number::toString(-x)的拼接字符串
4. 如果x是+∞_F，返回字符串"Infinity"
5. 让n、k和s是整数，且满足k>=1，10^(k-1)<= s < 10^k, s* 10^(n-k)是R(x)，而且k
尽可能小。k与s的十进制位数相等，s不能被10整除，s的最低位数字没必要由本
标准确定
6. 如果k <= n <= 21，返回下列字符串的拼接：
    。十进制s的k位数字（按顺序，非0开始）
    。n-k个0x0030（数字0）
7. 如果0 < n <= 21，返回下列字符串的拼接：
    。十进制s的n个高位部数字
    。0x002E（小数点）
    。十进制s剩余的k-n位数字
8. 如果-6 < n <= 0，返回下列字符串的拼接：
    。0x0030（数字0）
    。0x002E（小数点）
    。-n个0x0030（数字0）。注意n<0，所以取-n。
    。十进制s的k位数字
9. 如果k是1，返回下列字符串的拼接：
    。s的数字
    。0x0065（小写字母e）
    。0x002B（+）或者0x002D（-）与n-1的正负号相同
    。n-1绝对值的十进制数字（非0开始）
10. 返回下列字符串的拼接：
    。十进制s的最高位数字
    。0x002E（小数点）
    。十进制s的低位部k-1个数字
    。0x0065（小写字母e）
    。0x002B（+）或者0x002D（-）与n-1的正负号相同
    。n-1绝对值的十进制数字（非0开始）
****** 注意 如下推论可能对实现有帮助，但不是本标准的规范要求。
。如果x是Number值，且大于-0_F，那么ToNumber(ToString(x))与x的Number值相同
。本规范的第五步决定了，s的最低位非唯一
****** 注意 如果实现提供了更精确的转换，推荐第5步符合如下指导
  5. 让n、k和s是整数，且满足k>=1，10^(k-1)<= s < 10^k, s* 10^(n-k)是R(x)，而且
k尽可能小。如果由多个s，选择s*10^(n-k)最接近R(x)的。如果由两个可选的s，那么
选择偶数。k是十进制s的位数，s不能被10整除。
****** 注意 ECMAScript的实现可以在David M. Gay关于二进制浮点数转换的相关论文
中找到有用的内容和代码。
http://ampl.com/REFS/abstracts.html#rounding 近似展示数字。
http://netlib.sandia.gov/fp/dtoa.c 这是部分代码
http://netlib.sandia.gov/fp/g_fmt.c 这是其他部分代码。
这些内容也可以在netlib镜像找到。
***** 6.1.6.2 BigInt 类型
  BigInt类型表示整数值。这个值可以是任何大小，也没有二进制宽度限制（任何
大小好理解。二进制宽度限制估计是表示不限制位16的倍数。但是我估计仍然会是8
的倍数）。如果没有说明，这里的操作都返回准确数学值结果。对于二进制操作，
BigInt被作为二进制补码字符串处理，负数的话认为左侧有无穷位。
  BigInt::unit的值是1_Z。
***** 6.1.6.2.1 BigInt::unaryMinus(x)
  抽象操作BigInt::unaryMinus接受一个BigInt参数：x。被调用时执行下列步骤：
1. 如果x是0_Z，返回0_Z
2. 返回表示负的R(x)的BigInt值。
***** 6.1.6.2.2 BigInt::bitwiseNOT(x)
  抽象操作BigInt::bitwiseNOT(x)接受一个BigInt参数。返回x的补码表示的BigInt，也
就是-x-1_Z
***** 6.1.6.2.3 BigInt::exponentiate(base, exponent)
  抽象操作BigInt::exponentiate接受BigInt参数：base、exponent。被调用时执行下
列步骤：
1. 如果exponent < 0_Z。抛出异常。
2. 如果base是0_Z而且exponent是0_Z，返回1_Z。
3. 返回表示R(base)幂乘R(exponent)的结果的BigInt值。
***** 6.1.6.2.4 BigInt::multiply(x, y)
  抽象操作BigInt::multiply接受BigInt参数：x、y。返回x乘以y的结果的BigInt值。
****** 注意 即使结果远超输入规模，准确的数学值结果也应该返回。
***** 6.1.6.2.5 BigInt::divide(x,y)
  抽象操作BigInt::divide接受BigInt参数：x、y。被调用时执行下列步骤：
1. 如果y是0_Z，投掷RangeError异常。
2. 让quotient是R(x)/R(y)
3. 返回quotient向0取整的整数的BigInt值。
***** 6.1.6.2.6 BigInt::remainder(n, d)
  抽象操作BigInt::remainder接受BigInt参数：n、d。被调用时执行下列步骤：
1. 如果d是0_Z，投掷RangeError异常
2. 如果n是0_Z，返回0_Z
3. 让r是被算式r=n-(d*q)决定的BigInt值。q是BigInt，且与n/d同正负号，在不超过n
除以d的商的规模下，尽可能大
4. 返回r
****** r的符号与n的符号一致。
***** 6.1.6.2.7 BigInt::add(x,y)
  抽象操作BigInt::add接受BigInt参数：x、y。返回x与y的和的BigInt值。
***** 6.1.6.2.8 BigInt::subtract(x,y)
  抽象操作BigInt::subtract接受BigInt参数：x、y。返回x减以y的差的BigInt值。
***** 6.1.6.2.9 BigInt::leftShift(x,y)
  抽象操作BigInt::leftShift接受BigInt参数：x、y。被调用时执行下列步骤：
1. 如果y < 0_Z，那么：
    a. 计算R(x)/(2^-y)近似到最接近的整数，包括负数。返回这个整数的BigInt值
2. 返回表示R(x)*(2^y)的BigInt值
****** 语义上等价于按位左移，只是把BigInt值看作是无限长的二进制补码串。
***** 6.1.6.2.10 BigInt::signedRightShift(x,y)
  抽象操作BigInt::signedRightShift接受BigInt参数：x、y。被调用时执行下列步骤：
1. 返回BigInt::leftShift(x,-y)
***** 6.1.6.2.11 BigInt::unsignedRightShift(x,y)
  抽象操作BigInt::unsignedRightShift接受BigInt参数：x、y。被调用时执行下列步骤：
1. 投掷TypeError异常。BigInt值被看作是无限长的二进制补码串，转换没有意义。
***** 6.1.6.2.12 BigInt::lessThan(x,y)
  抽象操作BigInt::lessThan接受BigInt参数：x、y。当R(x)<R(y)时返回true，否则
返回false。
***** 6.1.6.2.13 BigInt::equal(x,y)
  抽象操作BigInt::equal接受BigInt参数：x、y。当R(x)==R(y)时返回true，否则返回
false。
***** 6.1.6.2.14 BigInt::sameValue(x,y)
  抽象操作BigInt::sameValue接受BigInt参数：x、y。被调用时执行下列步骤：
1. 返回BigInt::equal(x,y)
***** 6.1.6.2.15 BigInt::sameValueZero(x,y)
  抽象操作BigInt::sameValueZero接受BigInt参数：x、y。被调用时执行下列步骤：
1. 返回BigInt::equal(x,y)
***** 6.1.6.2.16 BinaryAnd(x,y)
  抽象操作BinaryAnd接受BigInt参数：x、y。被调用时执行下列步骤：
1. Assert：x是0或者1
2. Assert：y是0或者1
3. 如果x是1且y是1，返回1
4. 否则返回0
***** 6.1.6.2.17 BinaryOr(x,y)
  抽象操作BinaryOr接受BigInt参数：x、y。被调用时执行下列步骤：
1. Assert：x是0或者1
2. Assert：y是0或者1
3. 如果x是1或者y是1，返回1
4. 否则返回0
***** 6.1.6.2.18 BinaryXor(x,y)
  抽象操作BinaryXor接受BigInt参数：x、y。被调用时执行下列步骤：
1. Assert：x是0或者1
2. Assert：y是0或者1
3. 如果x是1且y是0，返回1
4. 如果x是0且y是1，返回1
5. 否则返回0
***** 6.1.6.2.19 BigIntBitwiseOp(op,x,y)
  抽象操作BigIntBitwiseOp接受参数op（Unicode字符串）、BigInt值x和BigInt值y。被调
用时执行下列步骤：
1. Assert：op是"&"、"^"或者"|"
2. 置x为R(x)
3. 置y为R(y)
4. 让result是0
5. 让shift是0
6. 重复执行，直到x是0或-1，而且y是0或-1：
    a. 让xDigit是 x modulo 2
    b. 让yDigit是 y modulo 2
    c. 如果op是'&'，置result为 result + (2^shift) * BinaryAnd(xDigit, yDigit)
    d. 如果op是'|'，置result为 result + (2^shift) * BinaryOr(xDigit, yDigit)
    e. 否则
        i. Assert: op 是'^'
        ii. 置result为 result + (2^shift) * BinaryXor(xDigit, yDigit)
    f. 置shift为shift+1
    g. 置x位 (x - xDigit)/2
    h. 置y位 (y - yDigit)/2
7. 如果op是'&'，让tmp是BinaryAnd(x modulo 2, y modulo 2)
8. 如果op是'|'，让tmp是BinaryOr(x modulo 2, y modulo 2)
9. 否则
    a. Assert：op是'|'
    b. 让tmp是BinaryXor(x modulo 2, y modulo 2)
10. 如果tmp!=0，那么
    a. 置result为 result - (2^shift)
    b. 注意：这就保证了符号一致。
11. 返回result的BigInt值
***** 6.1.6.2.20 BigInt::bitwiseAND(x,y)
  抽象操作BigInt::bitwiseAND接受BigInt参数：x、y。被调用时执行下列步骤：
1. 返回BigIntBitwiseOp(&,x,y)
***** 6.1.6.2.21 BigInt::bitwiseXOR(x,y)
  抽象操作BigInt::bitwiseXOR接受BigInt参数：x、y。被调用时执行下列步骤：
1. 返回BigIntBitwiseOp(^,x,y)
***** 6.1.6.2.22 BigInt::bitwiseOR(x,y)
  抽象操作BigInt::bitwiseOR接受BigInt参数：x、y。被调用时执行下列步骤：
1. 返回BigIntBitwiseOp(|,x,y)
***** 6.1.6.2.23 BitInt::toString(x)
  抽象操作BigInt::toString接受BigInt参数：x。转换x到字符串形式。被调用时执行
下列步骤：
1. 如果x < 0_Z，返回"-"与!BigInt::toString(-)的字符串拼接
2. 返回表示x十进制数字的字符串。
**** 6.1.7 Object类型
  Object逻辑上是若干性质的聚集。性质分为数据性质与访问性质：
. 数据性质指一个键值伴随一个ECMAScript语言值，和描述属性集合
. 访问性质指一个键值伴随一个或者两个访问方法，和描述属性集合
访问方法用于存储或者取回这个属性联结的ECMAScript语言值。
  性质用键值识别。键值类型是ECMAScript的String值或者Symbol值。所有的String或者
Symbol值都是有效的性质键，包括空字符串。性质名称就是性质键的String值。
  整数索引是String值的性质键，是最简的数字String，其数字值在[+0_F, 2^53-1]之
间。但是数组的索引在[+0_F,2^32-1)之间。
  性质键用于访问性质和其值。有两种访问方式：get与set，对应用于取回值和赋
值。通过get与set访问的性质包括对象直接含有的自有性质和通过原型访问的其他
对象的继承性质。继承性质是继承对象的自有性质或者继承性质。每个对象下的自有
性质的键是相互区别的。
  所有对象逻辑上都是若干性质的聚集，但是根据语义访问和操作性质的不同，有多
种对象的形式。请参考6.1.7.2关于定义对象的若干形式。
***** 6.1.7.1 性质的属性
  在本规范中性质用于定义和解释Object性质的状态。数据性质每个键值联结下表
Table3 所示的属性。
| 属性名       | 值域                 | 详细描述                                                                                                    |
| Value        | 任何ECMAScript语言值 | get访问性质获取的值                                                                                         |
| Writable     | Boolean              | 如果false，在ECMAScript代码试图通过set对Value进行赋值时，不会成功                                           |
| Enumerable   | Boolean              | 如果true，性质可以被for-in方式枚举到。否则，这个性质是不可枚举的                                            |
| Configurable | Boolean              | 如果false，那么下列行为会失败：删除性质、修改性质为访问性质、修改属性（除了Value，和Writable由true到false） |
  访问性质每个键值联结下表 Table4 所示的属性
| 属性名       | 值域                | 详细描述                                                                                               |
| Get          | Object或者undefined | 如果是Object那么必然是一个函数对象。函数内部call方法在每次取回性质值时被调同，其参数为空               |
| Set          | Object或者undefined | 如果是Object那么必然是一个函数对象。每次对性质值进行赋值时，函数内部call方法被调用，参数仅为要赋予的值 |
| Enumerable   | Boolean             | 如果true，性质可以被for-in方式枚举到。否则，这个性质是不可枚举的                                       |
| Configurable | Boolean             | 如果false，那么下列行为会失败：删除性质、修改性质为数据性质、修改属性。                                |
  如果初始化时没有显示的按照本规范声明性质的属性，默认属性设置按照下表
Table5 所示
| 属性名       | 默认值    |
| Value        | undefined |
| Get          | undefined |
| Set          | undefined |
| Writable     | false     |
| Enumerable   | false     |
| Configurabel | false     |
***** 6.1.7.2 Object内部方法与内部占位
  在ECMAScript，对象的实际语义是通过被称为内部方法的算法规范的。在ECMAScript
引擎中的每个对象都联结了一套内部方法，这些方法定义了其运行时的行为。这些
内部方法不是ECMAScript语言的内容。他们在本规范中被定义仅仅是为了用于解释。
然而，在ECMAScript实现中的对象表现必须与指定的联结的内部方法表现一致。其实际
完成的方式由实现决定。
  内部方法名称是多态的。这个不同对象值在调用一个通用的方法的时候可能会使用
不同的算法。方法调用时的实际背景对象是内部方法的"target"值。如果，运行时，
实现的算法试图使用某个对象不支持的内部方法，会投掷TypeError异常。
  内部占位对应联结对象的内部状态，被各ECMAScript实现算法使用。内部占位不是
对象性质，也不能被继承。根据内部占位实现的规范，其状态值可能是任何ECMAScript
语言类型或者ECMAScript规范类型。除非显示指明，内部占位在创建对象的过程就被
联结，而且可能不可以动态的增加。除非显示指明，内部占位的初始值是undefined。
本规范的各种算法创建的对象都有内部占位。然而ECMAScript语言不提供联结到对象
的直接途径。
  本规范定义的内部方法和内部占位的名字使用双方括号包裹的形式\[\[]]
  Table6 描述了用于本规范创建和修改对象是使用的基础内部方法。每个对象都要有
所有基础内部方法的算法。然而不同对象的内部方法的算法可能不同。
  基本对象是满足下列所有标准的对象
. 在Table6中列举的内部方法，对象使用在10.1中的定义
. 如果对象有\[\[Call]]内部方法，使用10.2.1的定义
. 如果对象由\[\[Construct]]内部方法，使用10.2.2的定义。
  不是基本对象的对象都是奇异对象。
  本规范通过其对象的内部方法识别不同的奇异对象。对象只有奇异对象的部分行为
（比如Array奇异对象或者绑定函数对象），但是没有其指明的全部内部方法，是不被
认为是对应的奇异对象。
  Table6 和其他类似表格 的签名列描述了每个内部方法的调用模式。调用模式通常
插入包含描述参数名称的列表。如果参数名与ECMAScript类型名相同，表示这里需要
相同类型的值作为参数。如果内部方法显示返回值，其参数列表后会跟随"->"符号和
返回值的类型名。在签名中使用类型名引用了章节6定义的类型和额外的any。any意味
其值可以是任何ECMAScript语言类型。
  除了其参数列表，还有一个内部方法经常访问对象，就是方法调用的对象。
  内部方法隐式返回一个完结记录，或者包含调用模式指明的返回类型对应的值的
普通完结，或者投掷完结。
| 内置方法                | 签名                                               | 描述                                                                                                                                                                |
| \[\[GetPrototypeOf]]    | ()->Object \vert Null                              | 明确为当前对象提供继承性质的对象。null表示没有继承性质                                                                                                              |
| \[\[SetPrototypeOf]]    | (Object \vert Null)-> Boolean                      | 为本对象联结其他对象以提供继承性质。传递null表示没有继承性质。返回true表示本操作成功，false表示本操作没有成功。                                                     |
| \[\[IsExtensible]]      | ()-> Boolean                                       | 明确本对象是否允许增加性质。                                                                                                                                        |
| \[\[PreventExtensions]] | ()-> Boolean                                       | 控制本对性能否增加新性质。操作成功返回true，否则返回false。                                                                                                         |
| \[\[GetOwnProperty]]    | (propertyKey)-> Undefined \vert PropertyDescriptor | 返回propertyKey对应的自有性质的PropertyDescriptor。如果不存在这个自有性质，就会返回undefined                                                                        |
| \[\[DefineOwnProperty]] | (propertyKey, PropertyDescriptor)-> Boolean        | 创建或者修改propertyKey对应的自有性质，其状态由PropertyDescriptor描述。如果操作成功返回true，否则返回false。                                                        |
| \[\[HasProperty]]       | (propertyKey) -> Boolean                           | 返回对象的自有性质或者继承性质的键是propertyKey。                                                                                                                   |
| \[\[Get]]               | (propertyKey, Receiver)->any                       | 从本对象返回propertyKey对应性质的值。如果任何ECMAScript代码必然被执行来取回这个性质值，那么在执行代码时Receiver被用作this的值。                                     |
| \[\[Set]]               | (propertyKey, value, Receiver)-> Boolean           | 设置propertyKey性质的值为value。如果任何ECMAScript代码必然被执行来设置这个性质值，那么执行代码时Receiver被用作this的值。如果性质被设置了新值返回true，否则返回false |
| \[\[Delete]]            | (propertyKey) -> Boolean                           | 从本对象中移除propertyKey对应的自有性质。如果没有删除，且性质继续存在返回false。如果删除成功，或者性质不存在，返回true。                                            |
| \[\[OwnPropertyKeys]]   | () -> List<propertyKey>                            | 返回本对象所有自有性质的键的列表                                                                                                                                    |
  Table7 描述了对象被作为函数被调用时需要的额外的基本内部方法。函数对象就是
支持\[\[Call]]内部方法的对象。构造范是支持\[\[Constructor]]内部方法的对象。任何
支持\[\[Constructor]]的对象都需要支持\[\[Call]]，因为每个构造范都是函数对象。
因此构造范也被认为是构造函数或者构造函数对象。
| 内置方法          | 签名                         | 描述                                                                                                                                                                                                                                                   |
| \[\[Call]]        | (any, List<any>)->any        | 执行本对象联结的代码。通过函数调用表达式被调用。传递给本内部方法的参数是this值和List<any>。List<any>是调用表达式执行时传递的参数列表。实现了这个内部方法的对象是可调用的。                                                                             |
| \[\[Constructor]] | (List<any>, Object)-> Object | 创建一个对象。通过new操作符或者super调用被调用。第一个参数是表达式调用时传递的值列表。第二个参数是在是使用new操作符是提供的初始值。实现了这个内部方法的对象被称为构造范。函数对象没必要是构造范，所以非构造范的函数对象没有\[\[Constructor]]内部方法。 |
  基本对象和标准奇异对象的基础内部方法的语义在第十章具体说明。奇异对象的
内部方法的具体使用没有被实现支持，当尝试调用时应该投掷TypeError异常。
***** 6.1.7.3 基础内部方法的恒定部分
  ECMAScript引擎对象的内部方法必须满足下列的恒定规定。基本ECMAScript对象与本
规范中的所有标准奇异对象维护这些恒定内容。ECMAScript代理对象维护这些恒定内
容是指在调用这个\[\[ProxyHandler]]对象时运行全部的检查。
  任何实现提供的任何奇异对象必须维护这些恒定内容。违反这些恒定内容会导致
ECMAScript代码有不可预测的行为和导致安全问题。然而违反这些恒定内容绝对不能
妥协实现的内存安全。
  实现不能允许这些恒定内容以任何方式被绕过，比如提供备选接口实现了基础内部
方法的功能但是没有强化恒定内容。
  定义：
. 内部方法的目标是这个内部方法在其上被调用的对象。
. 如果目标的\[\[IsExtensible]]返回false，或者\[\[PreventExtensions]]返回true，这个
目标是不可扩展的。
. 非存在性质是一个不可扩展对象上没有作为自有性质存在的性质。
. 所有SameValue的引用都依赖于SameValue算法的定义。
  返回值
内部方法返回的值必然是一个完结记录，携带下列之一：
. \[\[Type]]=normal, \[\[Target]]=empty而且\[\[Value]]为如下列内部方法返回的“正常
返回值”
. \[\[Type]]=normal, \[\[Target]]=empty而且[\[Value]]为任意ECMAScript语言值。
****** 注意1 内部方法不能返回\[\[Type]]是continue、break或return的完结记录
****** 6.1.7.3.1 \[\[GetPrototypeOf]]()
. 常规返回的类型是Object或者null
. 如果target是不可扩展的，而且\[\[GetPrototypeOf]]返回了一个值V，随后调用
\[\[GetPrototypeOf]]都应该返回V的相同值。
****** 注意2 对象的原型链需要是有限长度的（这就是说从任何对象开始，递归的调
用\[\[GetPrototypeOf]]内部方法，最终的结果必须是明确的null）。然而，这个要求并
不强求原型链上某个原型是没有使用标准对象\[\[GetPrototypeOf]]定义的奇异对象的
对象。这种环形原型链可能会在访问对象性质的时候导致无限循环。
****** 6.1.7.3.2 \[\[SetPrototypeOf]](V)
. 常规返回类型是Boolean
. 如果对象是不可扩展的，而且V与目标上\[\[GetPrototypeOf]]的结果不是SameValue，
那么\[\[SetPrototypeOf]]必须返回false。
****** 6.1.7.3.3 \[\[IsExtensible]]()
. 常规返回类型是Boolean
. 如果\[\[IsExtensible]]返回了false，后续目标上所有\[\[IsExtensible]]调用都要返回
false。
****** 6.1.7.3.4 \[\[PreventExtensions]]()
. 常规返回类型是Boolean
. 如果\[\[PreventExtensions]]返回true，后续目标上所有\[\[IsExtensible]]调用需要返
回false，而且目标被认为是不可扩展的。
****** 6.1.7.3.5 \[\[GetOwnProperty]](P)
. 常规返回类型是PropertyDescriptor或者Undefined
. 如果返回值类型是PropertyDescriptor，那么这个值必须是完整填充的
PropertyDescriptor
. 如果P描述的是不可设置或者不可写的自有数据性质，后续调用
\[\[GetOwnProperty]](P)返回PropertyDescriptor的\[\[Value]]必须与P的\[\[Value]]属性
是相同值
. 如果P除了\[\[Writable]]外的其他属性会在后续的过程中修改，甚至P性质可能会被
删除，那么此时P的\[\[Configurable]]属性必须是true
. P的\[\[Writable]]属性可能从false修改到true，那么\[\[Configurable]]属性必须是
true
. 如果target是不可扩展的，而且P是非存在性质，那么后续在这target上调用
\[\[GetOwnProperty]](P)必须描述P是非存在的（例如必须返回undefined）
****** 注意三
作为第三个不变性的后果，一个数据性质可能在不同时间返回不同值。那么要求其
\[\[Writable]]和\[\[Configurable]]必须都是true，即使没有暴露其他通过基本内部
方法修改这个值的机制。
****** 6.1.7.3.6 \[\[DefineOwnProperty]](P,Desc)
. 常规返回类型是Boolean
. 如果P在之前已经发现是目标的不可设置的自有性质，那么必须按照下列情况返回
    1. P是可写的数据性质。不可设置的可写数据性质变更成不可设置的不可写数据
性质。此时返回true。
    2. Desc的所有属性与P的属性全部是相同值。此时返回true。
    3. 其他情况发挥false。
. 如果目标是不可扩展的，P是非存在性质，那么\[\[DefineOwnProperty]](P,Desc)必须
返回false。其实就是不可扩展的目标对象不能扩展新的性质。
****** 6.1.7.3.7 \[\[HasProperty]](P)
. 常规返回类型是Boolean
. 如果P在之前已经发现是目标的不可设置的自有的数据或者访问性质，
\[\[HasProperty]]必须返回true
****** 6.1.7.3.8 \[\[Get]](P,Receiver)
. 常规返回类型是任意ECMAScript语言类型
. 如果P在之前发现是目标的带有值V的不可设置的或不可写的自有数据性质，那么
\[\[Get]]必须返回V的相同值
****** 6.1.7.3.9 \[\[Set]](P,V,Receiver)
. 常规返回类型是Boolean
. 如果P在之前已经发现是目标的不可设置的或不可写的自有数据性质，那么
    .如果P的\[\[Value]]属性与V是相同值，返回true
    .否则返回false
. 如果P在之前已经发现是目标的不可设置的自有访问性质，而且P的\[\[Set]]属性是
undefined，那么\[\[Set]](P,V,Receiver)操作必须返回false
****** 6.1.7.3.10 \[\[Delete]](P)
. 常规返回类型是Boolean
. 如果P在之前已经发现是目标的不可设置的自有的数据或者访问性质，\[\[Delete]]
操作必须返回false
****** 6.1.7.3.11 \[\[OwnPropertyKess]]()
. 常规返回类型是List
. 返回的List不允许包含重复的实例
. 返回的List的每个元素类型的要么是String，要么是Symbol
. 返回的List至少要包含之前已经发现的所有不可设置的自有性质的键
. 如果目标是不可扩展的，返回的List必须只能包含目标通过\[\[GetOwnProperty]]发现
的所有自有性质的键
****** 6.1.7.3.12 \[\[Call]]()
. 常规返回类型是任意ECMAScript语言类型
****** 6.1.7.3.13 \[\[Construct]]()
. 常规返回类型是Object
. 目标必须同时有\[\[Call]]内部方法
***** 6.1.7.4 常用的固有Object
  常用的固有是基于本规范算法显示引用的对象进行内建，通常也有领内标识。除非
特殊说明每个固有对象实际上对应一套相似对象，每个领一个。
  在本规范里用%name%标识一个固有对象，联结到当前领，对应这个name。类似
%name.a.b%这种用法表示，在评估ECMAScript代码前，已经访问了%name%内部对象的"a"
性质的"b"性质。本领的规定和其固有对象在9.3中描述。常用固有对象列在下表8中。
| 固有对象名称                     | 全局名称             | ECMAScript语言联结                                                 |
| %AggregateError%                 | AggregateError       | AggregateError构造范（20.5.7.1）                                   |
| %Array%                          | Array                | Array构造范（23.1.1）                                              |
| %ArrayBuffer%                    | ArrayBuffer          | ArrayBuffer构造范（25.1.3）                                        |
| %ArrayIteratorPrototype%         |                      | Array遍历器对象的原型（23.1.5）                                    |
| %AsyncFromSyncIteratorPrototype% |                      | 异步-从-同步遍历器对象的原型（27.1.4）这个完全不了解，无法有效翻译 |
| %AsyncFunction%                  |                      | 异步函数对象的构造范（27.7.1）                                     |
| %AsyncGeneratorFunction%         |                      | 异步遍历器对象的构造范（27.4.1）                                   |
| %AsyncIteratorPrototype%         |                      | 所有标准的内置异步构造器都间接的继承自这个对象                     |
| %Atomics%                        | Atomics              | Atomics对象（25.4）                                                |
| %BigInt%                         | BigInt               | BigInt构造范（21.2.1）                                             |
| %BigInt64Array%                  | BigInt64Array        | BigInt64Array构造范（23.2）                                        |
| %BigUint64Array%                 | BigUint64Array       | BigUint64Array构造范（23.2）                                       |
| %Boolean%                        | Boolean              | Boolean构造范（20.3.1）                                            |
| %DataView%                       | DataView             | DataView构造范（25.3.2）                                           |
| %Date%                           | Date                 | Date构造范（21.4.2）                                               |
| %decodeURI%                      | decodeURI            | decodeURI函数（19.2.6.2）                                          |
| %decodeURIComponent%             | decodeURIComponent   | decodeURIComponent函数（19.2.6.3)                                  |
| %encodeURI%                      | encodeURI            | encodeURI函数（19.2.6.4）                                          |
| %encodeURIComponent%             | encodeURIComponent   | encodeURIComponent函数（19.2.6.5）                                 |
| %Error%                          | Error                | Error构造范（20.5.1）                                              |
| %eval%                           | eval                 | eval函数（19.2.1）                                                 |
| %EvalError%                      | EvalError            | EvalError构造范（20.5.5.1）                                        |
| %FinalizationRegistry%           | FinalizationRegistry | FinalizationRegistry构造范（26.2.1）                               |
| %Float32Array%                   | Float32Array         | Float32Array构造范（23.2）                                         |
| %Float64Array%                   | Float64Array         | Float64Array构造范（23.2）                                         |
| %ForInIteratorPrototype%         |                      | For-In遍历器对象的原型（14.7.5.10）                                |
| %Function%                       | Function             | Function构造范（20.2.1）                                           |
| %GeneratorFunction%              |                      | generator对象的构造范（27.3.1）                                    |
| %Int8Array%                      | Int8Array            | Int8Array构造范（23.2）                                            |
| %Int16Array%                     | Int16Array           | Int16Array构造范（23.2）                                           |
| %Int32Array%                     | Int32Array           | Int32Array构造范（23.2）                                           |
| %isFinite%                       | isFinite             | isFinite函数（19.2.2）                                             |
| %isNaN%                          | isNaN                | isNaN函数（19.2.3）                                                |
| %IteratorPrototype%              |                      | 所有标准的内置遍历器对象都间接的继承自这个对象                     |
| %JSON%                           | JSON                 | JSON对象（25.5）                                                   |
| %Map%                            | Map                  | Map构造范（24.1.1）                                                |
| %MapIteratorPrototype%           |                      | Map遍历器对象的原型（24.1.5）                                      |
| %Math%                           | Math                 | Math对象（21.3）                                                   |
| %Number%                         | Number               | Number构造范（21.1.1）                                             |
| %Object%                         | Object               | Object构造范（20.1.1）                                             |
| %parseFloat%                     | parseFloat           | parseFloat函数（19.2.4）                                           |
| %parseInt%                       | parseInt             | parseInt函数（19.2.5）                                             |
| %Promise%                        | Promise              | Promise构造范（27.2.3）                                            |
| %Proxy%                          | Proxy                | Proxy构造范（28.2.1）                                              |
| %RangeError%                     | RangeError           | RangeError构造范（20.5.5.2）                                       |
| %ReferenceError%                 | ReferenceError       | ReferenceRrror构造范（20.5.5.3）                                   |
| %Reflect%                        | Reflect              | Reflect对象（28.1）                                                |
| %RegExp%                         | RegExp               | RegExp构造范（22.2.3）                                             |
| %RegExpStringIteratorPrototype%  |                      | RegExp字符串遍历器对象的原型（22.2.7）                             |
| %Set%                            | Set                  | Set构造范（24.2.1）                                                |
| %SetIteratorPrototype%           |                      | Set遍历器对象的原型（24.2.5）                                      |
| %SharedArrayBuffer%              | SharedArrayBuffer    | SharedArrayBuffer构造范（25.2.2）                                  |
| %String%                         | String               | String构造范（22.1.1）                                             |
| %StringIteratorPrototype%        |                      | String遍历器对象的原型（22.1.5）                                   |
| %Symbol%                         | Symbol               | Symbol构造范（20.4.1）                                             |
| %SyntaxError%                    | SyntaxError          | SyntaxError构造范（20.5.5.4）                                      |
| %ThrowTypeError%                 |                      | 无条件投掷一个新的%TypeError%实例的函数对象                        |
| %TypeArray%                      |                      | 所有类型化数组的构造范的父类（23.2.1）                             |
| %TypeError%                      | TypeError            | TypeError构造范（20.5.5.5）                                        |
| %Uint8Array%                     | Uint8Array           | Uint8Array构造范（23.2）                                           |
| %Uint8ClampedArray%              | Uint8ClampedArray    | Uint8ClampedArray构造范（23.2）                                    |
| %Uint16Array%                    | Uint16Array          | Uint16Array构造范（23.2）                                          |
| %Uint32Array%                    | Uint32Array          | Uint32Array构造范（23.2）                                          |
| %URIError%                       | URIError             | URIError构造范（20.5.5.6）                                         |
| %WeakMap%                        | WeakMap              | WeakMap构造范（24.3.1）                                            |
| %WeakRef%                        | WeakRef              | WeakRef构造范（26.1.1）                                            |
| %WeakSet%                        | WeakSet              | WeakSet构造范（24.4.1）                                            |
****** 注意 额外的实例在表82
** 6.2 用于ECMAScript规范类型
  规范类型与元值一致，用于描述ECMAScrpt语言构造和ECMAScript语言类型的算法语义
。规范类型包括Reference、List、Completion、PropertyDescriptor、EnvironmentRecord、
AbstrctCloure和DataBlock。规范类型是本规范制作的，不对应任何ECMAScript实现的任
何特定实例。规范类型的值可以被用于描述ECMAScript表达式评估的中间结果，但是
这种值不能存储为对象的性质或者个变量的值。
*** 6.2.1 List和Record规范类型
  List类型是用于解释在new表达式、在函数调用和其他需要简单的有序的值的算法
的参数列表评估。List类型的多值是简单有序的List元素序列，元素拥有独立的多值
。序列可能是任意长度。List元素会被按照0原点索引随机访问。为了表示的方便用
类似数组的语法访问List元素。比如argument[2]就是argument List的第三个元素的缩
写。
  为了表示着方便，一个文法语法被用于表示一个新的List值。比如<<1,2>>定义了
一个List值，它有两个元素，没有按照顺序初始为指定值。一个新的空List被表示
为<< >>。
  Record类型用于描述本规范的算法中的数据聚合。一个Record类型值包含一个或者
多个以命名的字段。每个字段的值要么是ECMAScript值要么是表示联结到一个Record
类型的名字的抽象值。字段的名字通常用双方括号包含起来例如\[\[Value]]。
  为了表示着方便，类似对象的文法语法被用于表示一个Record值。比如
{ \[\[Field1]]:42, \[\[Field2]:false, \[\[Field3]]:empty } 定义了一个拥有三个字段
的Record值，每个字段被初始化为指定值。字段名字的顺序没有意义。任何没有显式
列出的字段被认为是缺失的。
  在规范的文本与算法中，.符号被用于引用Record值的指定字段。例如，如果R表示
之前段落说的Record值，那么R.\[\[Field2]是“R中名称为Field2的字段”的缩写。
  常用的Receord字段组合提纲会被命名，这个名字被用作文法Record值的前缀，用于
标识按照描述的指定类型的聚合。例如 PropertyDescriptor { \[\[Value]]:42,
\[\[Writable]]:false, \[\[Configurable]]:true }
*** 6.2.2 Set和Relation规范类型
  Set类型是用于在内存模型中解释无序的元素合集。Set类型的值就是元素的简单合
集，且没有元素出现一次以上。元素可以在Set中增加与删除。集合间可以进行合
并、取交与差操作。
  Relation类型是用于解释Set上的约束。Relation类型的值是值域上的一套有序值对。
比如，事件上的Relation是一组有序的事件对。一个Relation R和R域上的a、b两个值，
a R B是R的成员有序对(a,b)的简写。Relation至少要表示某些条件，当它是满足
这些条件的最小Releation时。
  严格偏序是一种Relation值R，满足如下要求：
. R域上的任意值a, b, c
    . 没有a R a, 且
    . 如果a R b 和b R c，那么a R c
**** 上述两个性质分别是非反身性和传递性。
  严格全序是满足如下要求的Releation值R
. R域上的任意值a, b, c
    . a 与 b相同, a R b, b R a 三者之一，且
    . 没有 a R a， 且
    . 如果a R b 和b R c，那么a R c
**** 上述三个性质分别是完全性、非反身性和传递性。
**** 注意 
上面关系内容其实与抽象代数中关系的描述是一致的，相关的名词以数学名词为准。
这里就是随意翻译了一下。
*** 6.2.3 Completion Record规范类型
  Completion类型是一个Record，用于解释运行时值的传播和流程控制，比如语句（
break, continue, return 和 throw）的行为，会产生控制本地外的传递。
  Completion类型的值是Record值，其字段在表9中定义。这些值合起来就是Completion
Record
| 字段名称     | 值                                         | 含义                     |
| \[\[Type]]   | 必须normal,break,continue,return,throw之一 | 产生的Completion的类型   |
| \[\[Value]]  | ECMAScript语言值或者空                     | 产生的值                 |
| \[\[Target]] | ECMAScript字符串或者空                     | 直接的控制传输的目标标签 |
  术语abrupt completion（意外完结）指\[\[Type]]不是normal的Completion实例。
**** 6.2.3.1 Await
   算法步骤
 1. 让completion是Await(value)
   与下列步骤意味着相同的含意
 1. 让asyncContext是运行时执行上下文（running execution context）
 2. 让promise是?PromiseResolve(%Promise%, value)
 3. 让stepsFulfilled是定义在Await Fulfilled Functions的算法步骤
 4. 让lengthFulfilled是定义在Await Fulfilled Functions的函数需要的必要参数的数量
 5. 让onFulfilled是!CreateBuiltinFunction(stepsFulfilled, lengthFulfilled,\'''\', <<\[\[AsyncContext\]\]>>)
 6. 设置onFulfilled.\[\[AsyncContext]]为asyncContext
 7. 让stepsRejected是定义在Await Rejected Functions的算法步骤
 8. 让lengthRejected是定义在Await Rejected Functions的函数需要的必要参数的数量
 9. 让onRejected是!CreateBuiltinFunction(stepsRejected, lengthRejected, \'''\',<<\[\[AysncContext]]>>)
 10. 设置onRejected.\[\[AsyncContext]]为asyncContext
 11. 运行!PerformPromiseThen(promise, onFulfilled, onRejected)
 12. 从execution context stack中移除asyncContext，将在execution context stack顶部的execution context
     恢复为running execution context
 13. 设置asyncContext像那些带着完结completion继续的评估的代码评估状态是completion，这样跟随在Await
     算法之后的步骤就会执行下去
 14. 返回
 15. 注意：本返回到评估的操作在asyncContext中是最优先继续评估的。
 上述步骤中的别名，和预期的completion，都是瞬时的，而且仅在Await的算法步骤中可见。
***** 注意 Await可以组合?和!前缀，例如： 1. 让result是?Await(value)
      意味着下面行为：
 1. 让result是Await(value)
 2. ReturnIfAbrupt(result)
***** 6.2.3.1.1 Await Fulfilled Functions
    Await fulfilled函数是匿名内建函数，是Await规范的一部分，用于将promise fulfillment值
  作为普通完结派发到调用者。每个Await fulfilled函数有一个内置的\[\[AsyncContext\]\]
    当Await fulfilled函数被带着value调用时，下列步骤会被执行
  1. 让F是active function object
  2. 让asyncContext是F.\[\[AsyncContext]]
  3. 让prevContext是running execution context
  4. 挂起prevContext
  5. 将asyncContext压到execution context stack；asyncContext就是现在的运行时执行背景
  6. 继续asyncContext上已经挂起的评估，用NormalCompletion(value)作为这个导致挂起的操作的结果。
  7. Assert：当到达这步的时候，asyncContext已经从execution context stack中移除，而且
     prevContext是当前的运行时执行背景
  8. 返回undefined
    Await fulfilled函数的length性质是1_F
***** 6.2.3.1.2 Await Rejected Functions
    Await rejected函数是匿名内建函数，是Await规范的一部分，用于将promise rejection原因
  作为投掷完结派发给调用者。每个Await rejected函数有一个内置的\[\[AsyncContext]]
    当Await rejected函数被带着reason调用时，下列步骤会被执行
  1. 让F是active function object
  2. 让asyncContext是F.\[\[AsyncContext]]
  3. 让prevContext是running execuction context
  4. 挂起prevContext
  5. 将asyncContext压到execution context stack；asyncContext就是现在的运行时执行背景
  6. 继续asyncContext上已经挂起的评估，用ThrowCompletion(reason)作为这个导致挂起的操作的
  结果。
  7. Assert：当到达这步的时候，asyncContext已经从execution context stack中移除，而且
     prevContext是当前的运行时执行背景
  8. 返回undefined
    Await rejected函数的length性质是1_F
**** 6.2.3.2 NormalCompletion
  抽象操作NormalCompletion有单一参数argument，比如：
1. 返回 NormalCompetion(argument)
  是下列定义的简写：
1. 返回 Completion {\[\[Type]]:normal, \[\[Value]]:argument, \[\[Target]]:empty}
**** 6.2.3.3 ThrowCompletion
  抽象操作ThrowCompletion有单一参数argument，比如：
1. 返回 ThrowCompetion(argument)
  是下列定义的简写：
1. 返回 Completion {\[\[Type]]:throw, \[\[Value]]:argument, \[\[Target]]:empty}
**** 6.2.3.2 UpdateEmpty(completionRecord, value)
  抽象操作UpdateEmpty接受两个参数completionRecord和value。被调用时，执行下列步
骤：
1. Assert：completionRecord.\[\[Type]]如果是throw或者return，那么
completionRecord.\[\[Value]]必然不空
2. 如果completionRecord.\[\[Type]]不空，返回Completion(completionRecord)
3. 否则返回Completion {
  \[\[Type]]:completionRecord.\[\[Type]],
  \[\[Value]]:value,
  \[\[Target]]:completionRecord.\[\[Target]]
}
*** 6.2.4 ReferenceRecord规范类型
  ReferenceRecord类型是用于解释例如delete、typeof、赋值、super关键词和其他语言特
性等操作的行为。举例：赋值语句中的左侧的操作项就被期望产生一个
ReferenceRecord。
  ReferenceRecord是一个已解决的名称或性质的绑定，它的字段在表10中定义
| 字段名称             | 值                                                                                  | 含义                                                                                         |
| \[\[Base]]           | 三者之一：除null和undefined的ECMAScript语言的值；Environment Record; unresolvable。 | 占据这个绑定的值或者Environment Record。\[\[Base]]如果是unresolvable表明这个绑定不能被解决。 |
| \[\[ReferencedName]] | String或者Symbol                                                                    | 这个绑定的名称。如果\[\[Base]]值是Evironment Record，那么总是String。                        |
| \[\[Strict]]         | Boolean                                                                             | 如果这个ReferenceRecord来源自严格模式的代码，它就是true，否则就是false                       |
| \[\[ThisValue]]      | 任何ECMAScript语言的值，或者empty                                                   | 如果不空，这个ReferenceRecord表示一个用super关键词表示的性质绑定；它被称为SuperReferenceRecord，而且\[\[Base]]值永不会是EnvironmentRecord。在这种案例里\[\[ThisValue]]是创建ReferenceRecord时的this值。 |
  下列抽象操作被用在本规范里以操作上述的Reference。
**** 6.2.4.1 IsPropertyReference(V)
  抽象操作IsPropertyReference接受参数V。被调用时执行下列步骤：
1. Assert: V是一个ReferenceRecord
2. 如果V.\[\[Base]]是unresolvable，返回false
3. 如果V.\[\[Base]]是Boolean、String、Symbol、BigInt、Number或者Object返回true，
否则返回false
**** 6.2.4.2 IsUnresolvableReference(V)
  抽象操作IsUnresolvableReference接受参数V。被调用时执行下列步骤：
1. Assert: V是一个ReferenceRecord
2. 如果V.\[\[Base]]是unresolvable，返回true，否则返回false。
**** 6.2.4.3 IsSuperReference(V)
  抽象操作IsSuperReference接受参数V。被调用时执行下列步骤：
1. Assert: V是一个ReferenceRecord
2. 如果V.\[\[ThisValue]]非空，返回true，否则返回false。
**** 6.2.4.4 GetValue(V)
  抽象操作GetValue接受参数V。被调用时执行下列步骤：
1. ReturnIfAbrupt(V)
2. 如果V不是ReferenceRcord返回V
3. 如果IsUnresolvableReference(V)是true，那么投掷一个ReferenceError异常
4. 如果IsPropertyReference(V)是true，那么
    a. 让baseObj是!ToObject(V.\[\[Base]])
    b. 返回?baseObj.\[\[Get]](V.\[\[ReferenceName]], GetThisValue(V))
5. 否则
    a. 让base是V.\[\[Base]]
    b. Assert：base是一个EnvironmentRecord
    c. 返回 ?base.GetBindingValue(V.\[\[ReferenceName]], V.\[\[String]])（见9.1）
**** 6.2.4.5 PutValue(V, W)    
  抽象操作PutValue接受参数V和W。被调用时执行下列步骤：
1. ReturnIfAbrupt(V)
2. ReturnIfAbrupt(W)
3. 如果V不是ReferenceRecord，投掷一个ReferenceError异常
4. 如果IsUnresolvableReference(V)是true，那么
    a. 如果V.\[\[Strict]]是true，投掷一个ReferenceError异常
    b. 让globalObj是GetGlobalObject()
    c. 返回?Set(globalObj, V.\[\[ReferencedName]], W, false)
5. 如果IsPropertyReference(V)是true，那么
    a. 让baseObj是!ToObject(V.\[\[Base]])
    b. 让succeeded是?baseObj.\[\[Set]](V.\[\[ReferencedName]], W, GetThiValue(V))
    c. 如果succeeded是false，而且V.\[\[Strict]]是true，投掷一个类型异常
    d. 返回
6. 否则
    a. 让base是V.\[\[Base]]
    b. Assert：base是EnvironmentRecord
    c. 返回 ?base.SetMutableBinding(V.\[\[ReferencedName]], W, V.\[\[Strict]])（见
9.1）
***** 注意 步骤5.a可能创建一个对象，除了上述抽象操作和基本对象的\[\[Set]]内部
方法外的其他行为不能访问这个对象。实现可以选择规避实际创建这个对象。
**** 6.2.4.6 GetThisValue(V)
  抽象操作GetThisValue接受参数V。被调用时执行下列步骤：
1. Assert：IsPropertyReference(V)是true
2. 如果IsSuperReference(V)是true，returV.\[\[ThisValue]]；否则返回V.\[\[Base]]
**** 6.2.4.7 InitializeReferenceBinding(V,W)
  抽象操作InitializeReferenceBinding接受参数V和W。被调用时执行下列步骤：
1. ReturnIfAbrupt(V)
2. ReturnIfAbrupt(W)
3. Assert：V是ReferenceRecord
4. Assert：IsUnresolvableReference(V)是false
5. 让base是V.\[\[Base]]
6. Assert：base 是一个EnvironmentRecord
7. 返回base.InitializeBinding(V.\[\[ReferencedName]], W)
*** 6.2.5 Property Descriptor规范类型
  Property Descriptor类型是用于解释操作和物化Object性质的属性。Property
Descriptor类型的值是Record类型。每个字段的名称就是属性的名称，它的值与
6.1.7.1中确定的属性的值一致。另外，任何字段都可能出现或缺失。在本规范中
为了标记Property Descriptor记录的文法描述，使用PropertyDescriptor作为纲要名称。
  依据某些字段的存在或使用情况，Property Descriptor值可以被进一步划分为
数据Property Descriptor和访问Property Descriptor。数据Property Descriptor含有
\[\[Value]]或者\[\[Writable]]字段。访问Property Descriptor含有\[\[Get]]或者
\[\[Set]]字段。Property Descriptor还会含有\[\[Enumerable]]和\[\[Configurable]]。
Property Descriptor不能同时是数据Property Descriptor或者访问Property Descriptor，
然而可以两者都不是，这时就是一个普通的Property Descriptor。一个完整填充的
Property Descriptor必须是两者之一，其属性与对应的表3或者表4一致。
  随后的抽象操作被用在本规范来操作Property Descriptor值。
**** 6.2.5.1 IsAccessorDescriptor(Desc)
  抽象操作IsAccessorDescriptor接受参数Desc（Property Descriptor值或者undefined）。
被调用时执行下列步骤：
1. 如果Desc是undefined，返回false。
2. 如果Desc.\[\[Get]]和Desc.\[\[Set]]都缺失，返回false。
3. 返回true。
**** 6.2.5.2 IsDataDescriptor(Desc)
  抽象操作IsDataDescriptor接受参数Desc（Property Descriptor值或者undefined）。
被调用时执行下列步骤：
1. 如果Desc是undefined，返回false。
2. 如果Desc.\[\[Value]]和Desc.\[\[Writable]]都缺失，返回false。
3. 返回true。
**** 6.2.5.3 IsGenericDescriptor(Desc)
  抽象操作IsGenericDescriptor接受参数Desc（Property Descriptor值或者undefined）。
被调用时执行下列步骤：
1. 如果Desc是undefined，返回false。
2. 如果IsAccessorDescriptor(Desc)和IsDataDescriptor(Desc)都是false，返回true。
3. 返回false。
**** 6.2.5.4 FromPropertyDescriptor(Desc)
  抽象操作FromPropertyDescriptor接受参数Desc(Property Descriptor值货主undefined)。
被调用时执行下列步骤：
1. 如果Desc是undefined，返回undefined。
2. 让obj是!OrdinaryObjectCreate(%Object.prototype%)
3. Assert: obj是可扩展的不含性质的基本对象
4. 如果Desc有\[\[Value]]字段，那么
    a. 执行!CreateDataPropertyOrThrow(obj, "value", Desc.\[\[Value]])
5. 如果Desc有\[\[Writable]]字段，那么
    a. 执行!CreateDataPropertyOrThrow(obj, "writable", Desc.\[\[Writable]])
6. 如果Desc有\[\[Get]]字段，那么
    a. 执行!CreateDataPropertyOrThrow(obj, "get", Desc.\[\[Get]])
7. 如果Desc有\[\[Set]]字段，那么
    a. 执行!CreateDataPropertyOrThrow(obj, "set", Desc.\[\[Set]])
8. 如果Desc有\[\[Enumerable]]字段，那么
    a. 执行!CreateDataPropertyOrThrow(obj, "enumerable", Desc.\[\[Enumerable]])
9. 如果Desc有\[\[Configurable]]字段，那么
    a. 执行!CreateDataPropertyOrThrow(obj, "configurable", Desc.\[\[Configurable]])
10. 返回obj
**** 6.2.5.5 ToPropertyDescriptor(Obj)
  抽象操作ToPropertyDescriptor接受参数Obj，被调用时执行下列步骤：
1. 如果Type(Obj)不是Object，投掷TypeError异常
2. 让desc是新的Property Descriptor且没有初始化任何字段
3. 让hasEnumerable是?HasProperty(Obj, "enumerable")
4. 如果hasEnumerable是true，那么
    a. 让enumerable是!ToBoolean(?Get(Obj, "enumerable"))
    b. 设置desc.\[\[Enumerable]]是enumerable
5. 让hasConfigurable是?HasProperty(Obj, "confirgurable")
6. 如果hasConfigurable是true，那么
    a. 让configurable是!ToBoolean(?Get(Obj, "configurable"))
    b. 设置desc.\[\[Configurable]]是configurable
7. 让hasValue是?HasProperty(Obj, "value")
8. 如果hasValue是true，那么
    a. 让value是?Get(Obj, "value")
    b. 设置desc.\[\[Value]]是value
9. 让hasWritable是?HasProperty(Obj, "writable")
10. 如果hasWritable是true，那么
    a. 让writable是!ToBoolean(?Get(Obj, "writable"))
    b. 设置desc.\[\[Writable]]是writable
11. 让hasGet是?HasProperty(Obj, "get")
12. 如果hasGet是true，那么
    a. 让getter是?Get(Obj, "get")
    b. 如果IsCallable(getter)是false，而且getter不是undefined，投掷TypeError异常
    c. 设置desc.\[\[Get]]是getter
13. 让hasSet是?HasProperty(Obj, "set")
14. 如果hasSet是true，那么
    a. 让setter是?Get(Obj, "set")
    b. 如果IsCallable(setter)是false，而且setter不是undefined，投掷TypeError异常
    c. 设置desc.\[\[Set]]是setter
15. 如果desc.\[\[Get]]存在或者desc.\[\[Set]]存在，那么
    a. 如果desc.\[\[Value]]存在或者desc.\[\[Writable]]存在，投掷TypeError异常
16. 返回desc
**** 6.2.5.6 CompletePropertyDescriptor(Desc)
  抽象操作CompletePropertyDescriptor接受参数Desc（一个PropertyDescriptor）。被调用
时执行下列步骤：
1. Assert: Desc是一个PropertyDescriptor
2. 让like是Record {\[\[Value]]:undefined, \[\[Writable]]:undefined, \[\[Get]]:undefined,
\[\[Set]]:undefined, \[\[Enumerable]]:undefined, \[\[Configurable]]:undefined, }
3. 如果IsGenericDescriptor(Desc)是true，或者IsDataDescriptor(Desc)是true，那么
    a. 如果Desc没有\[\[Value]]字段，那么设置Desc.\[\[Value]]是like.\[\[Value]]
    b. 如果Desc没有\[\[Writable]]字段，那么设置Desc.\[\[Writable]]是
like.\[\[Writable]]
4. 否则
    a. 如果Desc没有\[\[Get]]字段，那么设置Desc.\[\[Get]]是like.\[\[Get]]
    b. 如果Desc没有\[\[Set]]字段，那么设置Desc.\[\[Set]]是like.\[\[Set]]
5. 如果Desc没有\[\[Enumerable]]字段，那么设置Desc.\[\[Enumerable]]是
like.\[\[Enumerable]]
6. 如果Desc没有\[\[Configurable]]字段，那么设置Desc.\[\[Configurable]]是
like.\[\[Configurable]]
7. 返回Desc
*** 6.2.6 Environment Record规范类型
  Environment Record类型是用于解释在函数和块中解释名称的行为。这个类型和其上
的操作在9.1中定义。
*** 6.2.7 Abstract Closure规范类型
  Abstract Closure规范类型用于描述连同值合集的若干算法步骤。Abstract Colsure值
是元值，用函数应用的方式调用，例如closure(arg1, arg2)。和抽象操作类似，调用时
按照Abstract Closure描述的算法步骤执行。
  在会创建Abstract Closure的算法步骤中，捕获的值用"capture"后跟随的别名列表
表示。当Abstract Closure被创建了，同时它捕获这些别名联结的值。在Abstract
Closure被调用时执行的指定算法的步骤，捕获的值仍然用捕获时的别名引用。
  如果Abstract Closure返回一个完结记录，这个完结记录的\[\[Type]]要么时normal，
要么是throw。
  Abstract Closure在行内创建，作为其他算法的组成，例如：
1. 让addend是 41
2. 让closure是新的Abstract Closure，带有parameters(x)捕获addend，并且被调用时
   执行随后的步骤:
    a. 返回 x + addend;
3. 让val时closure(1)
4. Assert: val时42
*** 6.2.8 Data Blocks规范类型
  Data Block规范类型用于描述确切的可修改的字节数值（8位数值）序列。一个字节
值是一个[0,255]内的整数。每个创建的Data Block值都有固定的字节数，每个字节都
初始化为0。
  为了在本规范中表示着方便，适用类似数组的语法访问Data Block中独立的字节。
这种记法将Data Block表示成一个零原点的整数索引的字节序列。例如，如果db是一个
5字节的Data Block值，那么db[2]表示其第三个字节的内容。
  一个data blcok驻留在内存里，可以被多个代理访问到的话，被定为Shared Data
Block。Shared Data Block有一个标识（为了检测Shared Data Block值是否相等），这个
标识是无地址的，也就是说它没有绑定到这个块映射在任何进程中的虚拟地址，而
是这个块在内存中的地址集。两个Data Block相等的唯一条件是其包含的地址集相
等，否则他们不相等，而且它们包含的地址集没有交集。最后，Shared Data Block要
能区别于Data Block。
  Shared Data Block的语义在内存模型中使用Shared Data Block事件中定义。下面的
抽象操作介绍了Shared Data Block事件，和作为评估语义与内存模型的事件语义间的
界面。事件构成了备选执行，内存模型在备选执行上作为过滤程序。请咨询内存
模型获得完整的语义。
  Shared Data Block事件用Record模型，在内存模型中定义。
  随后的抽象操作在本规范中用于Data Block值上的操作。
**** 6.2.8.1 CreateByteDataBlock(size)
  抽象操作CreateByteDataBlock接受参数size（整数）。被调用时执行下列步骤：
1. Assert：size >= 0
2. 让db是新的Data Block值，包含size个字节。如果无法创建这样的Data Block，
投掷一个RangeError异常
3. 是指db上所有的字节都是0
4. 返回db
**** 6.2.8.2 CreateSharedByteDataBlock(size)
  抽象操作CreateSharedByteDataBlock接受参数size（非负整数）。被调用时执行下列
步骤：
1. Assert：size >= 0
2. 让db是新的Shared Data Block值，包含size个字节。如果无法创建这样的Shared 
Data Block，投掷一个RangeError异常
3. 让execution是环境代理的环境记录的\[\[CandidateExecution]]字段。
4. 让eventList是execution.\[\[EventsRecords]]里满足\[\[AgentSignifier]]是
   AgentSignifier()的元素的\[\[EventList]]字段。
5. 让zero是<<0>>
6. 遍历db的每个索引i，执行
    a. 向eventList中附加WriteShareMemory { \[\[Order]]:Init, \[\[NoTear]]:true,
       \[\[Block]]:db, \[\[ByteIndex]]:i, \[\[ElementSize]]:1, \[\[Payload]]:zero }
7. 返回db
**** 6.2.8.3 CopyDataBlockBytes(toBlock, toIndex, fromBlock, fromIndex, count)
  抽象操作CopyDataBlockBytes接受参数toBlock、toIndex(非负整数）、fromBlock、
fromIndex（非负整数）和count（非负整数）。被调用时执行下列步骤：
1. Assert：fromBlock和toBlock是不同的Data Block或者Shared Data Block值。
2. 让fromSize是fromBlock的字节数
3. Assert：fromIndex + count <= fromSize
4. 让toSize是toBlock的字节数
5. Assert：toIndex + count <= toSize
6. 当count > 0时，重复执行
    a. 如果fromBlock是Shared Data Block 那么
        i. 让execution是环境代理的代理记录的\[\[CandidateExecution]]字段
       ii. 让eventList是execution.\[\[EventsRecords]]里满足\[\[AgentSignifier]]是
           AgentSignifier()的元素的\[\[EventList]]字段。
      iii. 让bytes是一个列表，只有一个未确定选定的字节值。
       iv. 注意：在实现中，bytes是底层硬件上的非原子读取指令的结果。这种
           未确定性是内存模型中描述这种弱一致性的监察硬件行为的语义处方。
        v. 让readEvent是 ReadSharedMemory { \[\[Order]]:Unordered, \[\[NoTear]]:true,
           \[\[Block]]:fromBlock, \[\[ByteIndex]]:fromIndex, \[\[ElementSize]]:1}
       vi. 在eventList上追加readEvent
      vii. 在execution.\[\[ChosenValues]]中附加Chosen Value Record {
           \[\[Event]]:readEvent, \[\[ChosenValue]]:bytes }
     viii. 如果toBlock是Shared Data Block，那么
            1. 在eventList上追加 WriteSharedMemory { \[\[Order]]:Unordered,
               \[\[NoTear]]:true, \[\[Block]]:toBlock, \[\[ByteIndex]]:toIndex,
               \[\[ElementSize]]:1, \[\[Payload]]:bytes}
       ix. 否则
            1. 设置toBlock[toIndex]是bytes[0]
    b. 否则
        i. Assert：toBlock不是Shared Data Block
       ii. 设置toBlock[toIndex]是fromBlock[fromIndex]
    c. 设置toIndex是toIndex+1
    d. 设置fromIndex是fromIndex+1
    e. 设置count是count-1.
7. 返回NormalCompletion(empty)
***** 注意 有可能有从data block到shared data block的操作。这里没有禁止有可能
在别的地方处理了。
* 7 抽象操作
  这些操作不是ECMAScript语言的部分；在这里定义他们，只是帮助ECMAScript语言的
语义规范。而且贯穿本规范还有更多的特定抽象操作被定义了。
** 7.1 类型转换    
  ECMAScript语言在需要的时候隐式的自动执行类型转换。为了明晰某种结构的语义，
很需要定义一套转换的抽象操作。转换的抽象操作是多态的，他们可以接受任意的
ECMAScript语言类型的值。但是规范类型值不能在这些操作中适用。
  在ECMAScript语言中BigInt没有隐式的转换，程序必须调用BigInt来显示的转换到其
他类型。
*** 7.1.1 ToPrimitive(input[, preferredType])
  抽象操作ToPrimitive接受参数input和可选参数preferredType。将input参数转换为一个
非对象类型。如果一个对象是可以转换为多个原生类型的，它可能需要提示选项
preferredType到想要的类型。被调用时执行下列步骤：
1. Assert：input是ECMAScript语言类型
2. 如果Type(input)是对象，那么
    a. 让exoticToPrim是?GetMethod(input, @@toPrimitive)
    b. 如果exoticToPrim不是undefined，那么
        i. 如果不存在preferredType，让hint是"default"
       ii. 不然如果preferredType是string，让hint是"string"
      iii. 否则
            1. Assert：preferredType是number
            2. 让hint是"number"
       iv. 让result是?Call(exoticToPrim, input, <<hint>>)
        v. 如果Type(result)不是对象，返回result
       vi. 投掷TypeError异常
    c. 如果preferredType不存在，让preferredType是number
    d. 返回?OrdinaryToPrimitive(input, prferredType)
3. 返回input
**** 注意 当ToPrimitive被不带提示的调用时，它的行为跟hint是number时是一样的
     然而，对象可以通过重写@@toPrimitive方法来覆盖这个行为。在本规范中只有
     Date对象（详见21.4.4.45）和Symbol对象（详见20.4.3.5）重写了ToPrimitive行为。
     Date对象对待空hint为string。
**** 7.1.1.1 OrdinaryToPrimitive(O, hint)
  抽象操作OrdinaryToPrimitive接受参数O和hint。被调用时执行下列步骤：
1. Assert：Type(O)是对象
2. Assert：hint是number或者string
3. 如果hint是string那么
    a. 让methodNames是<<"toString", "valueOf">>
4. 否则
    a. 让methodNames是<<"valueOf", "toString">>
5. 遍历methodNames的每个元素name，执行
    a. 让method是?Get(O, name)
    b. 如果IsCallable(method)是true，那么
        i. 让result是?Call(method, O)
       ii. 如果Type(result)不是Object，返回resut
6. 投掷TypeError异常
*** 7.1.2 ToBoolean(argument)
  抽象操作ToBoolean接受参数argument。它根据表11将argument转换成Boolean类型的值
| 参数类型  | 结果                                                                       |
| Undefined | 返回false                                                                  |
| Null      | 返回false                                                                  |
| Boolean   | 返回argument                                                               |
| Number    | 如果argument是+0_F、-0_F或者NaN，返回false。其他返回true                   |
| String    | 如果argument是空字符串（即length是0），返回false。其他返回true             |
| Symbol    | 返回true                                                                   |
| BigInt    | 如果argument是0_Z，返回false。其他返回true。                               |
| Object    | 返回true。注意：一个关联到内置\[\[IsHTMLDDA]]的备选算法在B.3.7.1中强制执行 |
*** 7.1.3 ToNumeric(value)
  抽象操作ToNumeric接受参数value。它返回value转换成的Number或者BigInt。被调用时
执行下列步骤：
1. 让primValue是?ToPrimitive(value, number)
2. 如果Type(primValue)是BitInt，返回primValue
3. 返回?ToNumber(primValue)
*** 7.1.4 ToNumber(argument)
  抽象操作ToNumber接受参数argument。它根据表12将argument转换为Number值。
| 参数类型  | 结果                                                                                      |
| Undefined | 返回NaN                                                                                   |
| Null      | 返回+0_F                                                                                  |
| Boolean   | 如果argument是true，返回1_F。如果argument是false，返回+0_F                                |
| Number    | 返回argument（不转换）                                                                    |
| String    | 参看按照下方的语法和转换算法                                                              |
| Symbol    | 投掷TypeError异常                                                                         |
| BigInt    | 投掷TypeError异常                                                                         |
| Object    | 执行下列步骤：1. 让primValue是?ToPrimitive(argument, number)；2. 返回?ToNumber(primValue) |
**** 7.1.4.1 接受了String类型的ToNumber行为
  ToNumber处理String值时将String解释成UTF-16编码点序列后使用后续的语法。如果
这里的语法无法将String值翻译成一个扩展的StringNumberLiteral，那么ToNumber返回的
结果是NaN。
***** 注意1 本语法中终结符都是由BMP（Unicode Basic Multilingual Plane）字符构成。
      所以字符串中包含任何首位和尾位编码单元，无论匹配与否，ToNumber都会返回
      NaN。
  Syntax
    StringNumericLiteral :::
      StrWhiteSpace_opt
      StrWhiteSpace_opt StrNumericLiteral StrWhiteSpace_opt
    StrWhiteSpace :::
      StrWhiteSpaceChar StrWhiteSapce_opt
    StrWhiteSpaceChar :::
      WhiteSpace
      LineTerminator
    StrNumericLiteral :::
      StrDecimalLiteral
      NonDecimalIntegerLiteral_[~Sep]
    StrDecimalLiteral :::
      StrUnsignedDecimalLiteral
      + StrUnsignedDecimalLiteral
      - StrUnsignedDecimalLiteral
    StrUnsignedDecimalLiteral :::
      Infinity
      DecimalDigits_[~Sep] . DecimalDigits_[~Sep]_opt ExponentPart_[~Sep]_opt
      . DecimalDigits_[~Sep]_opt ExponentPart_[~Sep]_opt
      DecimalDigits_[~Sep] ExponentPart_[~Sep]_opt
  上面用到的没有明确定义的语法符号在字面数字的词法语法（12.8.3）中定义。
***** 注意2 StringNumericLiteral和NumericLiteral语义有些不同，需要注意
        . StringNumericLiteral可以在始末包含有限的空格或者换行符
        . StringNumericLiteral其实位值可以有任意个0
        . StringNumericLiteral可以包含+或-来指明符号
        . StringNumericLiteral可以是空的或者值包含空白符，被转换成+0_F
        . Infinity和-Infinity被时别为StringNumericLiteral，而不是NumericLiteral
        . StringNumericLiteral不能包含BigIntLiteralSuffix
***** 7.1.4.1.1 运行语义：MV
  String转化为Number值总体上与从字面数字得到Number值的规定相似，但是有些细节
是不同的，所以在这里给出从字符串数字到Number类型值的转换过程。这个值由两步
决定：首先，从字符串数字中派生数学值（MV）；其次，这个数学值按照下方的描述
进行修圆。不是在下方里，而是在其他语法符号中提及的MV，是在12.8.3.1中定义的
MV。
  . StringNumericLiteral ::: [empty]的MV是0
  . StringNumericLiteral ::: StrWhiteSpace的MV是0
  . StringNumericLiteral ::: StrWhiteSpace_opt StrNumericLiteral StrWhiteSpace_opt的MV
    是StrNumericLiter的MV，无论有多少空白或者没有空白
n  . StringNumericLiteral ::: - StrUnsignedDecimalLiteral的MV是负的
    StrUnsignedDecimalLiteral的MV。（注意如果StrUnsignedDecimalLiteral的MV是0，这个
    MV的负值仍然是0。下方的修圆规则处理这个无符号数值0到合适的+0_F或者-0_F
    浮点数）
  . StrUnsignedDecimalLiteral ::: Infinity的MV是10^10000（足够大以致于修圆到+∞_F）
  . StrUnsignedDecimalLiteral ::: DecimalDigits . DecimalDigits的MV是第一个
    DecimalDigits的MV加以(第二DecimalDigits的MV与10^-n的积)的和，其中n是第二个
    DecimalDigits的编码点数量
  . StrUnsignedDecimalLiteral ::: DecimalDigits . ExponentPart的MV是DecimalDigits的MV
    与10^e的积，其中e是ExponentPart的MV。
  . StrUnsignedDecimalLiteral ::: DecimalDigits . DecimalDigits ExponentPart的MV是(第一
    个DecimalDigits的MV加以(第二个DecimalDigits的MV与10^-n的积)的和）与10^e的积，
    其中n是第二个DecimalDigits的编码点数量，而e是ExponentPart的MV。
  . StrUnsignedDecimalLiteral ::: . DecimalDigits的MV是DecimalDigits的MV与10^-n的积，
    其中n是DecimalDigits的编码点数量
  . StrUnsignedDecimalLiteral ::: . DecimalDigits ExponentPart的MV是DecimalDigits的MV
    与10^(e-n)的积，其中n是DecimalDigits的编码点数量，而e是ExponentPart的MV。
  . StrUnsignedDecimalLiteral ::: DecimalDigits ExponentPart的MV是DecimalDigits的MV与
    10^e的积，其中e是ExponentPart的MV。
  一旦字符串字面量数字决定了确定的MV，随后被修圆到Number类型的值。如果MV是
0，会被修圆到+0_F，除非字符串字面量的第一个非空白符是"-"，这时会被修圆到
-0_F。其他情况，必须修圆到MV对应的Number值（按照在6.1.6.1中定义的含义），除非
是字面里包含StrUnsignedDecimalLiteral，而且包含了超过20个有意义数字的特殊情
况。在特殊情况里Number值可能是用0替换掉第20位之后的有意义数字的MV的Number
值，或者用0替换掉第20位之后的有意义数字后，再在第20位+1的MV的Number值。
  有意义数字是指不在ExponentPart里的，且
  . 不是"0"，或者
  . 左侧有非0数字，而且右侧有不在ExponentPart里的非0数字的"0"
*** 7.1.5 ToIntegerOrInfinity(argument)
  抽象操作ToIntegerOrInfinity接受参数argument。它将argument转换成整数、+∞或
-∞。被调用时执行下列步骤：
1. 让number是?ToNumber(argument)
2. 如果number是NaN、+0_F或者-0_F，返回0
3. 如果number是+∞_F，返回+∞
4. 如果number是-∞_F，返回-∞
5. 让integer是floor(abs(R(number)))
6. 如果number<+0_F，设置integer是-integer
7. 返回integer
*** 7.1.6 ToInt32(argument)
  抽象操作ToInt32接受参数argument。将argument转换为2^32的整数Number，范围在
[F(-2^31),F(2^31-1)]内。被调用时执行下列步骤：
1. 让number是?ToNumber(argument)
2. 如果number是NaN、+0_F、-0_F、+∞_F、-∞_F，返回+0_F
3. 让int是与number相同符号的数学值，规模是floor(abs(R(number)))
4. 让int32bit是int按2^32取模
5. 如果int32bit>=2^31,返回F(int32bit - 2^32)否则返回F(int32bit)
**** 注意 上述定义ToInt32
    . ToInt32抽象操作是向前强效的。如果被提供了一个它产生的结果，这个第二次
      使用需要值不变。
    . ToInt32(ToUnit32(x))与ToInt32(x)是相同值。（这是为了保留后面将+∞_F和-∞_F
      映射到+0_F的性质）
    . ToInt32映射-0_F到+0_F
*** 7.1.7 ToUint32(argument)
  抽象操作ToUint32接受参数argument。将argument转换为2^32的整数Number，范围在
[+0_F,F(2^32-1)]内。被调用时执行下列步骤：
1. 让number是?ToNumber(argument)
2. 如果number是NaN、+0_F、-0_F、+∞_F、-∞_F，返回+0_F
3. 让int是与number相同符号的数学值，规模是floor(abs(R(number)))
4. 让int32bit是int按2^32取模
5. 返回F(int32bit)
**** 注意 上述定义ToUint32
    . 只有第5步上ToUint32与ToInt32有差异
    . ToUint32抽象操作是向前强效的。如果被提供了一个它产生的结果，这个第二次
      使用需要值不变。
    . ToUnit32(ToInt32(x))与ToUint32(x)是相同值。（这是为了保留后面将+∞_F和-∞_F
      映射到+0_F的性质）
    . ToUint32映射-0_F到+0_F
*** 7.1.8 ToInt16(argument)
  抽象操作ToInt16接受参数argument。将argument转换为2^16的整数Number，范围在
[F(-2^15), F(2^15-1)]内。被调用时执行下列步骤：
1. 让number是?ToNumber(argument)
2. 如果number是NaN、+0_F、-0_F、+∞_F、-∞_F，返回+0_F
3. 让int是与number相同符号的数学值，规模是floor(abs(R(number)))
4. 让int16bit是int按2^16取模
5. 如果int16bit>=2^15,返回F(int16bi5 - 2^16)否则返回F(int16bit)
*** 7.1.9 ToUint16(argument)
  抽象操作ToUint16接受参数argument。将argument转换为2^16的整数Number，范围在
[F(+0_F), F(2^16-1)]内。被调用时执行下列步骤：
1. 让number是?ToNumber(argument)
2. 如果number是NaN、+0_F、-0_F、+∞_F、-∞_F，返回+0_F
3. 让int是与number相同符号的数学值，规模是floor(abs(R(number)))
4. 让int16bit是int按2^16取模
5. 返回F(int16bit)
**** 注意 上述定义ToUint16
    . ToUint16与ToUint32的唯一差别是在第4步，用2^16替代了2^32。
    . ToUint16映射-0_F到+0_F
*** 7.1.10 ToInt8(argument)
  抽象操作ToInt8接受参数argument。将argument转换为2^8的整数Number，范围在
[-128_F, 127_F]内。被调用时执行下列步骤：
1. 让number是?ToNumber(argument)
2. 如果number是NaN、+0_F、-0_F、+∞_F、-∞_F，返回+0_F
3. 让int是与number相同符号的数学值，规模是floor(abs(R(number)))
4. 让int8bit是int按2^8取模
5. 如果int8bit>=2^7,返回F(int8bit - 2^8)否则返回F(int8bit)
*** 7.1.11 ToUint8(argument)
  抽象操作ToUint8接受参数argument。将argument转换为2^8的整数Number，范围在
[+0_F, 255_F]内。被调用时执行下列步骤：
1. 让number是?ToNumber(argument)
2. 如果number是NaN、+0_F、-0_F、+∞_F、-∞_F，返回+0_F
3. 让int是与number相同符号的数学值，规模是floor(abs(R(number)))
4. 让int8bit是int按2^8取模
5. 返回F(int8bit)
*** 7.1.12 ToUint8Clamp(argument)
  抽象操作ToUint8Clamp接受参数argument。将argument转化为2^8的整数Number，范围在
[+0_F, 255_F]内。被调用时执行下列步骤：
1. 让number是?ToNumber(argument)
2. 如果number是NaN，返回+0_F
3. 如果R(number)<=0，返回+0_F
4. 如果R(number)>= 255，返回255_F
5. 让f是floor(R(number))
6. 如果f+0.5 < R(number)，返回F(f+1)
7. 如果R(number) < f + 0.5，返回F(f)
8. 如果f是odd，返回F(f+1)
9. 返回F(f)
**** 注意 不像其他ECMAScript的整数转换，ToUint8Clamp的修圆方式不同于截断整数
     也不是转换+∞_F到+0_F。ToUint8Clamp采用中间取偶的方式进行修圆。这也不同
     于Math.round的四舍五入方式。
*** 7.1.13 ToBigInt(argument)
  抽象操作ToBigInt接受参数argument。将argument转换为BigInt值，或者投掷异常如果
需要隐式的丛Number转换的话。被调用时执行下列步骤：
1. 让prim是?ToPrimitive(argument, number)
2. 按照表13，根据prim值进行返回。
| 参数类型  | 结果                                                                        |
| Undefined | 投掷TypeError异常                                                           |
| Null      | 投掷TypeError异常                                                           |
| Bollean   | 如果prim是true，则返回1n。如果prim是false，则返回0n                         |
| BigInt    | 返回prim                                                                    |
| Number    | 投掷TypeError异常                                                           |
| String    | 1. 让n是!StringToBigInt(prim)；2. 如果n是NaN，投掷SyntaxError异常；3. 返回n |
| Symbol    | 投掷TypeError异常                                                           |
*** 7.1.14 StringToBigInt(argument)
  应用7.1.4.1的算法，并进行随后的调整
. 替换StrUnsignedDecimalLiteral产出的DecimalDigits中禁止Infinity、小数点和指数部
. 如果NaN，返回NaN。否则返回准确表示MV的BigInt值，不需要修圆。
*** 7.1.15 ToBigInt64(argument)
  抽象操作ToBigInt64接受参数argument。将argument转换为2^64的BigInt值，范围在
[Z(-2^63),Z(2^63-1)]内。被调用是执行下列步骤：
1. 让n是?ToBigInt(argument)
2. 让int64bit是R(n)按2^64取模
3. 如果int64bit>=2^63，返回Z(int64bit - 2^64)；否则返回Z(int64bit)
*** 7.1.16 ToBigUint64(argument)
  抽象操作ToBigUint64接受参数argument。将argument转换为2^64的BigInt值，范围在
[0_Z, Z(2^64-1)]内。被调用时执行下列步骤：
1. 让n是?ToBigInt(argument)
2. 让int64bit是R(n)按2^64取模
3. 返回Z(int64bit)
*** 7.1.17 ToString(argument)
  抽象操作ToString接受参数argument。将argument按照表14转根据其类型转换为String
值。
| 参数类型  | 结果                                                                                       |
| Undefined | 返回"undefined"                                                                            |
| Null      | 返回"null"                                                                                 |
| Boolean   | 如果argument是true，返回"true"。如果argument是false，返回"false"                           |
| Number    | 返回!Number::toString(argument)                                                            |
| String    | 返回argument                                                                               |
| Symbol    | 投掷TypeError异常                                                                          |
| BigInt    | 返回!BigInt::toString(argument)                                                            |
| Object    | 应用随后的步骤：1. 让primValue是?ToPrimitive(argument, string) 2. 返回?ToString(primValue) |
*** 7.1.18 ToObject(argument)
  抽象操作ToObject接受参数argument。将argument按照表15根据其类型转换为Object
值。
| 参数类型  | 结果                                                                                      |
| Undefined | 投掷TypeError异常                                                                         |
| Null      | 投掷TypeError异常                                                                         |
| Boolean   | 返回一个新的Boolean对象，其内部占位\[\[BooleanData]]是argument。参看20.3Boolean对象的描述 |
| Number    | 返回一个新的Number对象，其内部占位\[\[NumberData]]是argument。参看21.1Number对象的描述    |
| String    | 返回一个新的String对象，其内部占位\[\[StringData]]是argument。参看22.1String对象的描述    |
| Symbol    | 返回一个新的Symbol对象，其内部占位\[\[SymbolData]]是argument。参看20.4Symbol对象的描述    |
| BigInt    | 返回一个新的BigInt对象，其内部占位\[\[BigIntData]]是argument。参看21.2Bigint对象的描述    |
| Object    | 返回argument                                                                              |
*** 7.1.19 ToPropertyKey(argument)
  抽象操作ToPropertyKey接受参数argument。将argument转换为能作为性质键的值。被调
用时执行下列步骤：
1. 让key是?ToPrimitive(argument,string)
2. 如果Type(key)是Symbol，那么
    a. 返回key
3. 返回!ToString(key)
*** 7.1.20 ToLength(argument)
  抽象操作ToLenght接受参数argument。将argument转换为适合作为像数组的对象的长度
的整数Number。被调用时执行下列步骤：
1. 让len是?ToIntegerOrInfinity(argument)
2. 如果len <= 0，返回+0_F
3. 返回F(min(len, 2^53-1))
*** 7.1.21 CanonicalNumericIndexString(argument)
  抽象操作CanonicalNumericIndexString接受参数argument。将argument转换为Number值，
如果是可以Number通过ToString产生的String值或者String"-0"。否则返回undefined。当
被调用时执行下列步骤：
1. Assert：Type(argument)是String
2. 如果argument是"-0"，返回-0_F
3. 让n是!ToNumber(argument)
4. 如果SameValue(!ToString(n), argument)是false，返回undefined
5. 返回n
  经典数字字符串是指不会让CanonicalNumericIndexString抽象操作返回undefined的
String值。
*** 7.1.22 ToIndex(value)
  抽象操作ToIndex接受参数value。将参数value转换为非负整数，如果value是有效的
整数索引值。被调用时执行下列步骤：
1. 如果value是undefined，那么
    a. 返回0
2. 否则
    a. 让integerIndex是F(?ToIntegerOrInfinity(value))
    b. 如果integerIndex < +0_F，投掷RangeError异常
    c. 让index是!ToLength(integerIndex)
    d. 如果!SameValue(integerIndex, index)是false，投掷RangeError异常
    e. 返回R(index)
** 7.2 检测和匹配操作
*** 7.2.1 RequireObjectCoercible(argument)（coerce强制）
  抽象操作RequireObjectCoercible接受参数argument。如果argument不能使用ToObject转换
成Object，会投掷异常。在表16中定义。
| 参数类型  | 结果              |
| Undefined | 投掷TypeError异常 |
| Null      | 投掷TypeError异常 |
| Bollean   | 返回argument      |
| Number    | 返回argument      |
| String    | 返回argument      |
| Symbol    | 返回argument      |
| BigInt    | 返回argument      |
| Oject     | 返回argument      |
*** 7.2.2 IsArray(argument)
  抽象操作IsArray接受参数argument。被调用时执行下列步骤：
1. 如果Type(Argument)不是Object，返回false
2. 如果argument是Array exotic对象，返回true
3. 如果arugment是Proxy exotic对象，那么
    a. 如果arugment.\[\[ProxyHandler]]是空，投掷TypeError异常
    b. 让target是argument.\[\[ProxyTarget]]
    c. 返回?IsArray(target)
4. 返回false
*** 7.2.3 IsCallable(argument)
  抽象操作IsCallable接受参数argument（ECMAScript语言值）。明确argument是一个带有
\[\[Call]]内置方法的可调用函数。被调用时执行下列步骤：
1. 如果Type(argument)不是Object，返回false
2. 如果argument有\[\[Call]]内置方法，返回true
3. 返回false
*** 7.2.4 IsConstrutor(argument)
  抽象操作IsConstructor接受参数argument（ECMAScript语言值）。明确argument是一个
带有\[\[Constructor]]内置方法的函数对象。被调用时执行下列步骤：
1. 如果Type(argument)不是Object，返回false
2. 如果argument有\[\[Constructor]]内置方法，返回true
3. 返回false
*** 7.2.5 IsExtensible(O)
  抽象操作IsExtensible接受参数O（一个Object）,返回Boolean值。明确额外的性质能
否被添加到O上。被调用时执行下列步骤：
1. Assert: Type(O)是Object
2. 返回?O.\[\[IsExtensible]]()
*** 7.2.6 IsIntegralNumber(argument)
  抽象操作IsIntegralNumber接受参数argument。明确argument是否以一个有限的整数
Number值。被调用时执行下列步骤：
1. 如果Type(argument)不是Number，返回false
2. 如果argument是NaN、+∞_F、-∞_F返回false
3. 如果floor(abs(R(argument))) != abs(R(argument))返回false
4. 返回true
*** 7.2.7 IsPropertyKey(argument)
  抽象操作IsPropertyKey接受参数argument（ECMAScript语言值）。明确argument是否可
以作为性质键。被调用时执行下列步骤：
1. 如果Type(argument)是String，返回true
2. 如果Type(argument)是Symbol，返回true
3. 返回false
*** 7.2.8 IsRegExp(argument)
  抽象操作IsRegExp接受参数argument。被调用时执行下列步骤：
1. 如果Type(argument)不是Object，返回false
2. 让matcher是?Get(argument, @@match)
3. 如果matcher不是undefined，返回!ToBoolean(matcher)
4. 如果argument有\[\[RegExpMatcher]]内部占位，返回true
5. 返回false
*** 7.2.9 IsStringPrefix(p,q) 
  抽象操作IsStringPrefix接受参数p（String）和q（String）。明确p是否是q的前缀。
被调用时执行下列步骤：
1. Assert：Type(p)是String
2. Assert：Type(q)是String
3. 如果q是p与其他String r拼接成的String，返回true，否则返回false。
**** 注意 任何String都是自身的前缀，因为r可以是空String
*** 7.2.10 SameValue(x,y)
  抽象操作SameValue接受参数x（ECMAScript语言值）和y（ECMAScript语言值），并返
回Boolean值。被调用时执行下列步骤：
1. 如果Type(x)与Type(y)不同，返回false
2. 如果Type(x)是Number或者BigInt，那么
    a. 返回!Type(x)::sameValue(x, y)
3. 返回!SameValueNonNumeric(x,y)
**** 注意 这个算法与严格相等算法不同，区别在如何处理零与NaN
*** 7.2.11 SameValueZero(x,y)
  抽象操作SameValueZero接受参数x（ECMAScript语言值）和y（ECMAScript语言值），
并返回Boolean值。被调用时执行下列步骤：
1. 如果Type(x)与Type(y)不同，返回false
2. 如果Type(x)是Number或者BigInt，那么
    a. 返回!Type::sameValueZero(x,y)
3. 返回!SameValueNonNumeric(x,y)
**** SameValueZero与SameValue的差异在于处理+0_F和-0_F上
*** 7.2.12 SameValueNonNumeric(x,y)
  抽象操作SameValueNonNumeric接受参数x（ECMAScript语言值）和y（ECMAScript语言值）
，并返回Boolean值。被调用时返回下列步骤：
1. Assert：Type(x)不是Number或BigInt
2. Assert：Type(x)与Type(y)相同
3. 如果Type(x)是Undefined，返回true
4. 如果Type(x)是Null，返回true
5. 如果Type(x)是String，那么
    a. 如果x和y有相同的编码单元（相同长度，相同索引的编码单元相同），返回
       true，否则返回false
6. 如果Type(x)是Boolean，那么
    a. 如果x和y都是true或者都是false，返回true；否则返回false
7. 如果Type(x)是Symbol，那么
    a. 如果x和y都是相同的Symbol值，返回true；否则返回false
8. 如果x和y是相同的Object，返回true；否则返回false
*** 7.2.13 抽象关系比较 <
  值x、y的比较式x < y产生true、false或者undefined（表明至少有个NaN参与了比
较）。除了x、y，这个算法还接受一个Boolean标记LeftFirst作为参数。这个标记用于
控制在操作有潜在副作用的x、y时的评估顺序。这是必要的，因为在ECMAScript明确
规定了从左到右评估表达式。LeftFirst的默认时值true，表明在表达式中的x代表的
表达式发生在y代表的表达式左侧（之前）。如果LeftFirst是false，那就是相反顺
序，y表达式的评估在x之前。比较按照下列步骤执行：
1. 如果LeftFirst是true，那么
    a. 让px是?ToPrimitive(x, number)
    b. 让py是?ToPrimitive(y, number)
2. 否则
    a. 注意: 评估顺序需要反过来，以保证比较按照从左到右的顺序评估
    b. 让py是?ToPrimitive(y, number)
    c. 让px是?ToPrimitive(x, number)
3. 如果Type(px)是String， Type(py)也是String，那么
    a. 如果IsStringPrefix(py, px)是true，返回false
    b. 如果IsStringPrefix(px, py)是true，返回true
    c. 让k是px中与py中对应位置编单元不同的最小非负整数。（必然有这样的k存
       在，即使都不是对方的前缀）
    d. 让m是px在k位的编码单元的数字的整数
    e. 让n是py在k位的编码单元的数字的整数
    f. 如果m<n，返回true。否则返回false
4. 否则
    a. 如果Type(px)是BigInt且Type(py)是String，那么
        i. 让ny是!StringToBigInt(py)
       ii. 如果ny是NaN，返回undefined
      iii. 返回BigInt::lessThan(px,ny)
    b. 如果Type(px)是String且Type(py)是BigInt，那么
        i. 让nx是!StringBoBigInt(px)
       ii. 如果nx是NaN，返回undefined
      iii. 返回BigInt::(nx,py)
    c. 注意因为px和py是基础值，评估顺序不重要
    d. 让nx是!ToNumeric(px)
    e. 让ny是!ToNumeric(py)
    f. 如果Type(nx)与Type(ny)相同，返回Type(nx)::lessThan(nx, ny)
    g. Assert：Type(nx)是BigInt时Type(ny)是Number，或者Type(nx)是Number时Type(ny)是
       BigInt
    h. 如果nx或者ny是NaN，返回undefined
    i. 如果nx是-∞_F或者ny是+∞_F，返回true
    j. 如果nx是+∞_F或者ny是-∞_F，返回false
    k. 如果R(nx) < R(ny)，返回true，否则返回false
**** 注意1 步骤3与+操作（13.15.3）中的步骤2.c是不同的，这里用逻辑与，而在+操作中用的是逻辑或
**** 注意2 字符串比较使用的是简单的按照编码单元的字典序。没有使用更加复杂的语义化的在Unicode标准
     中根据词或则字符串相等和核对的排序。因此符合最基本相等的String值在Unicode标准中也能相等。
     实际上本算法假设两个String都是标准化的形式。此外对于包含补充字符的字符串，使用编码单元的
     字典序与编码点的字典序不同。
*** 7.2.14 抽象相等比较 \=\=
  值x、y的比较式x==y产生true或者false。这个比较式执行时按照下列步骤：
1. 如果Type(x)与Type(y)相同，那么
    a. 返回执行严格相等比较x\=\=\=y的结果
2. 如果x是null，且y是undefined，返回true
3. 如果x是undefined，且y是null，返回true
4. 注意：这一步在B.3.7.2中被替换（
   1.如果Type(x)是Object，且x有\[\[IsHTMLDDA]]内部占位，而y是null或undefined，返回true
   2.如果x是null或undefined，同时Type(y)是Object且y有\[\[IsHTMLDDA]]占位，返回true
）
5. 如果Type(x)是Number而Type(y)是String，返回x==!ToNumber(y)结果
6. 如果Type(x)是String而Type(y)是Number，返回!ToNumer(x)==y结果
7. 如果Type(x)是BigInt而Type(y)是String，那么
    a. 让n是!StringToBigInt(y)
    b. 如果n是NaN，返回false
    c. 返回x==n的结果
8. 如果Type(x)是String而Type(y)是BigInt，返回y==x结果
9. 如果Type(x)是Boolean，返回!ToNumber(x)==y结果
10. 如果Type(y)是Boolean，返回x==!ToNumber(y)结果
11. 如果Type(x)是String、Number、BigInt或者Symbol之一，且Type(y)是Object，返回x==?ToPrimitive(y)结果
12. 如果Type(x)是Object，且Type(y)是String、Number、BigInt或者Symbol之一，返回?ToPrimitive(x)==y结果
13. 如果Type(x)是BigInt且Type(y)是Number，或饿着Type(x)是Number且Type(y)是BigInt，那么
     a. 如果x或y是NaN、-∞_F、+∞_F，返回false
     b. 如果R(x)=R(y)，返回true。否则返回false。
14. 返回false
*** 7.2.15 严格相等比较 \=\=\=
  值x、y的比较式x\=\=\=y产生true或者false。比较式执行时执行下列步骤
1. 如果Type(x)与Type(y)不同，返回false
2. 如果Type(x)是Number或者BigInt那么
    a. 返回!Type(x)::equal(x,y)
3. 返回!SameValueNonNumeric(x, y)
**** 注意 本算法在对待0和NaN时，与SameValue算法不同
** 7.3 Object上的操作
*** 7.3.1 MakeBasicObject(internalSlotsList)
  抽象操作MakeBasicObject接受参数internalSlotsList。这是所有算法创建ECMAScript对象的源，无论基本对象
或奇异对象。提出了所有对象在创建时需要的通用步骤，集中了对象的创建过程。被调用时执行下列步骤：
1. Assert：internalSlotsList是内置占位名称的List
2. 让obj是新创建的对象，且每个在internalSlotsList的名字都创建了相应的内部占位
3. 设置obj的必须内置方法是按照10.1规范定义的基本对象对应的默认值
4. Assert：如果调用方没有同时覆盖obj的\[\[GetPrototypeOf]]和\[\[SetPrototypeOf]]基础内置方法，那么
   internalSlotsList含有\[\[Prototype]]
5. Assert：如果调用方没有同时覆盖obj的\[\[SetPrototypeOf]]、\[\[IsExtensible]]
   和\[\[PreventExtensions]]基础内置方法，那么internalSlotsList含有\[\[Extensible]]
6. 如果internalSlotsList含有\[\[Extensible]]，设置obj.\[\[Extensible]]是true。
7. 返回obj
**** 注意 在本规范中，由例如ArrayCreate、BoundFunctionCreated等抽象操作创建的奇异对象，首先要调用
         MakeBasicObject获得一个基本对象，然后覆盖部分或者全部的内置方法。为了封装奇异对象的创建，对象
	 基础内置方法在这些操作外是不能修改的。
*** 7.3.2 Get(O,P)
  抽象操作Get接受参数O（对象）和P（性质键）。用于检索对象上指定性质的值。被调用时执行下列步骤：
1. Assert：Type(O)是Object
2. Assert：IsPropertyKey(P)是true
3. 返回 ?O.\[\[Get]](P,O)
*** 7.3.3 GetV(V,P)
  抽象操作GetV接受参数V（ECMAScript语言值）和P（性质健）。用于检索ECMAScript值的指定性质的值。如果V不是
对象，会将值封装为合适的对象再在其上执行键查找。被调用时执行下列步骤：
1. Assert：IsPropertyKey(P)是true
2. 让O是?ToObject(V)
3. 返回?O.\[\[Get]](P,V)
*** 7.3.4 Set(O,P,V,Throw)
  抽象操作Set接受参数O（Object），P（性质键），V（ECMAScript语言值）和Throw（Boolean）。用于在object
上设置指定性质的值。V是这个性质的新值。被调用时执行下列步骤：
1. Assert：Type(O)是Object
2. Assert：IsPropertyKey(P)是true
3. Assert：Type(Throw)是Boolean
4. 让success是?O.\[\[Set]](P,V,O)
5. 如果success是false而且Throw是true，投掷TypeError异常
6. 返回success
*** 7.3.5 CreateDataProperty(O,P,V)
  抽象操作CreateDataProperty接受参数O（Object）、P（性质键）和V（ECMAScript语言
值）。用于在对象上创建一个新的自有性质。被调用时执行下列步骤：
1. Assert：Type(O)是Object
2. Assert：IsPropertyKey(P)是true
3. 让newDesc是PropertyDescriptor { \[\[Value]]:V \[\[Writable]]:true,
   \[\[Enumerable]]:true, \[\[Configurable]]:true }
4. 返回?O.\[\[DefineOwnProperty]](P, newDesc)
**** 注意 本抽象操作创建的性质拥有的属性与ECMAScript语言中赋值语句创建的性质
           的属性相同。通常这个性质不在对象上。如果已经存在且不可设置的，
           或者O是不可扩展的，\[\[DefineOwnProperty]]会返回false
*** 7.3.6 CreateMethodProperty(O,P,V)
  抽象操作CreateMethodProperty接受参数O（Object）、P（性质键）和V（ECMAScript语言
值）。用于在对象上创建新的自有性质。被调用时执行下列步骤：
1. Assert：Type(O)是Object
2. Assert：IsPropertyKey(P)是true
3. 让newDesc是PropertyDescriptor { \[\[Value:V,\[\[Writable]]:true,
   \[\[Enumerable]]:false, \[\[Configurable]]:true }
4. 返回 ?O.\[\[DefineOwnProperty]](P, newDesc)
**** 注意 本抽象操作创建的性质拥有的属性与使用类声明语法的方法或者内置方法
           的属性相同。通常这个性质不在对象上。如果已经存在且不可设置的，
           或者O是不可扩展的，\[\[DefineOwnProperty]]会返回false
*** 7.3.7 CreateDataPropertyOrThrow(O,P,V)
  抽象操作CreateDataPropertyOrThrow恶疾首参数O（Object）、P（性质键）和V（
ECMAScript语言值）。在对象上创建新的性质。如果请求的性质修改不能执行，投掷
TypeError异常。被调用时执行下列步骤：
1. Assert：Type(O)是Object
2. Assert：IsPropertyKey(P)是true
3. 让success是?CreateDataProperty(O,P,V)
4. 如果success是false，投掷TypeError异常
5. 返回success
**** 注意 本抽象操作创建的性质拥有的属性与ECMAScript语言中赋值操作创建的性质
           的属性相同。通常这个性质不在对象上。如果已经存在且不可设置，或者
           O是不可扩展的，\[\[DefineOwnProperty]]会返回false，导致本操作投掷
           TypeError异常。
*** 7.3.8 DefinePropertyOrThrow(O,P,desc)
  抽象操作DefinePropertyOThrow接受参数O（Object）、P（性质键）和desc（
PropertyDescriptor）。被用于以在不能执行修改请求的性质时会投掷TypeError异常的
方式调用对象上\[\[DefineOwnProperty]]内部方法。被调用时执行下列步骤：
1. Assert：Type(O)是Object
2. Assert：IsPropertyKey(P)是true
3. 让success是?O.\[\[DefineOwnProperty]](P,desc)
4. 如果success是false，投掷TypeError异常
5. 返回success
*** 7.3.9 DeletePropertyOrThrow(O,P)
  抽象操作DeletePropertyOrThrow接受参数O（Object）、P（性质键）。被用于移除对
象上的指定的自有性质。如果性质不可设置，会投掷异常。被调用时执行下列步骤：
1. Assert：Type(O)时Object
2. Assert：IsPropertyKey(P)时true
3. 让success时?O.\[\[Delete]](P)
4. 如果success是false，投掷TypeError异常
5. 返回success
*** 7.3.10 GetMethod(V,P)
  抽象操作GetMethod接受参数V（ECMAScript语言值）和P（性质键）。被用于当性质的
值被期望是函数时，在ECMAScript语言值上取得指定性质值。被调用时执行下列步骤：
1. Assert：IsPropertyKey(P)是true
2. 让func是?GetV(V,P)
3. 如果func是undefined或null，返回undefined
4. 如果IsCallable(func)是false，投掷TypeError异常
5. 返回func
*** 7.3.11 HasProperty(O,P)
  抽象操作HasProperty接受参数O（Object）和P（性质键），返回Boolean。用于明确
对象是否有指定性质。性质可以是自有的或者继承的。被调用时执行下列步骤：
1. Assert：Type(O)是Object
2. Assert：IsPropertyKey(P)是true
3. 返回?O.\[\[HasProperty]]
*** 7.3.12 HasOwnProperty(O,P)
  抽象操作HasOwnProperty接受参数O（Object）和P（性质键），返回Boolean。用于明确
对象是否有指定自有性质。被调用时执行下列步骤：
1. Assert：Type(O)是Object
2. Assert：IsPropertyKey(P)是true
3. 让desc是?O.\[\[GetOwnProperty]](P)
4. 如果des是undefined，返回false
5. 返回true
*** 7.3.13 Call(F,V[,argumentsList])
  抽象操作Call接受参数F（ECMAScript语言值）、V（ECMAScript语言值）和可选参数
argumentsList（元素是ECMAScript语言值的List）。被用于调用函数对象的\[\[Call]]
内部方法。F是函数对象，V是作为\[\[Call]]的this值的ECMAScript语言值，而
argumentsList是传递给内部方法的相应参数值。如果argumentsList不存在，设置
一个新的空List。被调用时执行下列步骤：
1. 如果argumentsList不存在，设置argumentsList是一个新的空List
2. 如果IsCallable(F)是false，投掷TypeError异常
3. 返回?F.\[\[Call]](V, argumentsList)
*** 7.3.14 Construct(F[,argumentsList[,newTarget]])
  抽象操作Constructor接受参数F（函数对象）和可选参数arugmentsList和newTarget。
被用于调用函数对象的\[\[Constructor]]内置方法。argumentsList和newTarget是传递给
内部方法的行营参数值。如果argumentsList不存在，设置一个新的空List。如果
newTarget不存在，设置为F。被调用时执行下列步骤：
1. 如果newTarget不存在，设置newTaget为F
2. 如果argumentsList不存在，设置argumentsList是新的空List
3. Assert：IsConstructor(F)是true
4. Assert：IsConstructor(newTarget)是true
5. 返回?F.\[\[Constrcut]](argumentsList, newTarget)
**** 注意 如果newTarget不存在，本操作与new F(...argumentsList)等价
*** 7.3.15 SetIntegrityLevel(O,level)
  抽象操作SetIntegrityLevel接受参数O和level。用于固定对象的自有性质。被调用时
执行下列步骤：
1. Assert：Type(O)是Object
2. Assert：level是sealed或frozen
3. 让status是?O.\[\[PreventExtensions]]()
4. 如果status是false，返回false
5. 让keys是?O.\[\[OwnPropertyKeys]]()
6. 如果level是sealed，那么
    a. 遍历keys的每个元素key，执行
        i. 执行?DefinePropertyOrThrow(O,k,PropertyDescriptor{\[\[Configurable]]:false})
7. 否则
    a. Assert：level是frozen
    b. 遍历keys的每个元素key，执行
        i. 让currentDesc是?O.\[\[GeOwnProperty]](key)
       ii. 如果currentDec不是undefined，那么
            1. 如果IsAccessorDescriptor(currentDesc)是true，那么
                a. 让desc是PropertyDescriptor{\[\[Configurable]]:false}
            2. 否则
                a. 让desc是PropertyDescriptor{\[\[Configurable]]:false,
                   [\[Writable]]:false}
            3. 执行?DefinePropertyOrThrow(O,k,desc)
8. 返回true
*** 7.3.16 TestIntegrityLevel(O,level)
  抽象操作TestIntegrityLevel接受参数O和level。用于明确对象的自有性质是否已经固
定。被调用时执行下列步骤：
1. Assert：Type(O)是Object
2. Assert：level是sealed或frozen
3. 让extensible是?IsExtensible(O)
4. 如果extensible是true，返回false
5. 注意：如果对象是extensible，没有性质需要检查
6. 让keys是?O.\[\[OwnPropertyKeys]]()
7. 遍历keys的每个元素key，执行
    a. 让currentDesc是?O.\[\[GetOwnProperty]](key)
    b. 如果currentDesc不是undefined
        i. 如果currentDesc.\[\[Configurable]]是true，返回false
       ii. 如果level是frozen而且IsDataDescriptor(currentDesc)是true,那么
            1. 如果currentDesc.\[\[Writable]]是true，返回false
8. 返回true
*** 7.3.17 CreateArrayFromList(elements)
  抽象操作CreateArrayFromList接受List参数elements。用于创建元素是elemnts提供的
元素的Array对象。被调用时执行下列步骤
1. Assert：elments是一个List，元素都是ECMAScript语言值
2. 让array是!ArrayCreate(0)
3. 让n是0
4. 遍历elements的每个元素e，执行
    a. 执行!CreateDataPropertyOThrow(array, !ToString(F(n)), e)
    b. 设置n为n+1
5. 返回array
*** 7.3.18 LengthOfArrayLike(obj)
  抽象操作LengthOfArrayLike接受参数obj。返回貌似数组的对象的length性质（作为
非负整数）。被调用时执行下列步骤：
1. Assert：Type(obj)是Object
2. 返回 R(?ToLength(?Get(obj,"length")))
  貌似数组的对象是任何在执行本操作时返回整数而不是意外完结的对象
**** 注意1 通常貌似数组对象还有一些性质的名字是整数，但是不是本定义需要的。
**** 注意2 Array对象和String对象就是貌似数组对象的例子
*** 7.3.19 CreateListFromArrayLike(obj[,elementTypes])
  抽象操作CreateListFromArrayLike接受参数obj和可选参数elementTypes（有ECMAScript
类型的名称组成的List）。用于创建一个List，其元素是obj的索引键上的性质。
elementTypes包含其名称的ECMAScript语言类型的值可以被List接受。被调用时执行
下列步骤：
1. 如果elementTypes不存在，设置elementTypes是<<Undefined, Null, Boolean, String,
   Symbol, Number, BigInt, Object>>
2. 如果Type(obj)不是Object，投掷TypeError异常
3. 让len是?LengthOfArrayLike(obj)
4. 让list是新的空List
5. 让index是0
6. 当index < len时 重复，
    a. 让indexName时!ToString(F(index))
    b. 让next时?Get(obj, indexName)
    c. 如果Type(next)不是elementTypes的元素，投掷TypeRrror异常
    d. 附加next到list最后一个元素后
    e. 甚至index为index + 1
7. 返回list
*** 7.3.20 Invoke(V,P[,argumentsList])
  抽象操作Invoke接受参数V（ECMAScript语言值）、P（性质键）和可选参数
argumentList（ECMAScript语言值构成的List）。用于调用ECMAScript语言值上的方法性
质。V作为性质的检索点和调用的this值。argumentsList是传入方法的参数值。如果
argumentsList不存在，一个新的空List作为这个值。被调用时执行下列步骤：
1. Assert：IsPropertyKey(P)是true
2. 如果argumentsList不存在，设置arugmentsList是一个新的空List
3. 让func是?GetV(V,P)
4. 返回?Call(func,V,argumentsList)
*** 7.3.21 OrdinaryHasInstance(C,0)
  抽象操作OrdinaryHasInstance接受参数C（ECMAScript语言值）和O。实现了检测O继承
自某个继承了C的实例的默认算法。
1. 如果IsCallable(C)是false，返回false
2. 如果C有\[\[BoundTargetFunction]]内置占位那么
    a. 让BC是C.\[\[BoundTargetFunction]]
    b. 返回?InstanceOfOperator(O, BC)
3. 如果Type(O)不是Object，返回false
4. 让P是?Get(C,"prototype")
5. 如果Type(P)不是Object，投掷TypeError异常
6. 重复
    a. 设置O是?O.\[\[GetPrototypeOf]]()
    b. 如果O是null，返回false
    c. 如果SameValue(P,O)是true，返回true
*** 7.3.22 SpeciesConstructor(O, defaultConstructor)
  抽象操作SpeciesConstructor接受参数O（Object值）和defaultConstrucor（构造范）。
用于在用O派生新的对象时检索需要的构造范。在O中找不到@@species性质指定的构造
范时使用defaultConstructor构造范。被调用时执行下列步骤：
1. Assert：Type(O)时Object
2. 让C是?Get(O,"construcotr")
3. 如果C是undefined，返回defaultConstructor
4. 如果Type(C)不是Object，投掷TypeError异常
5. 让S是?Get(C,@@species)
6. 如果S是undefined或者null，返回defualtConstructor
7. 如果IsConstructor(S)是true，返回S
8. 投掷TypeError异常
*** 7.3.23 EnumerableOwnPropertyNames(O, kind)
  抽象操EnumerableOwnPropertyNames接受参数O（Object值）和kind（key,value或者
key+value).被调用时执行下列步骤
1. Assert：Type(O)是Object
2. 让ownKesy是?O.\[\[OwnPropertyKeys]]()
3. 让properties是新的空List
4. 遍历ownKeys的每个元素key，执行
    a. 如果Type(key)是String，那么
        i. 让desc是?O.\[\[GetOwnProperty]](key)
       ii. 如果desc不是undefined而且desc.\[\[Enumerable]]是true，那么
            1. 如果kind是key，追加key到properties
            2. 否则
                a. 让value是?Get(O,key)
                b. 如果kind是value，追加value到properties
                c. 否则
                    i. Assert：kind是key+value
                   ii. 让entry是!CreateArrayFromList(<<key,value>>)
                  iii. 追加entry到properties
5. 返回properties
*** 7.3.24 GetFunctionRealm(obj)
  抽象操作GetFunctionReale接受参数obj.被调用时执行下列步骤
1. Assert：!IsCallable(obj)是true
2. 如果obj有\[\[Realm]]内置占位
    a. 返回obj.\[\[Realm]]
3. 如果obj是绑定的函数对象，那么
    a. 让target是obj.\[\[BoundTargetFunction]]
    b. 返回?GetFunctionRealm(target)
4. 如果obj是Proxy对象，那么
    a. 如果obj.\[\[ProxyHandler]]是null，投掷TypeError异常
    b. 让proxyTarget是obj.\[\[ProxyTarget]]
    c. 然会?GetFunctionRealm(proxyTarget)
5. 返回当前的Realm记录
**** 注意 步骤5仅在对象是一个非标准的没有\[\[Realm]]内置占位的函数对象才会
           触发。
*** 7.3.25 CopyDataProperties(target, source, excludedItems)
  抽象操作CopyDataProperties接受参数target、source、excludedItems。被调用时执行
下列步骤：
1. Assert：Type(target)是Object
2. Assert：excludedItems是性质键组成的List
3. 如果source是undefined或null，返回target
4. 让from是!ToObject(source)
5. 让keys是?from.\[\[OwnPropertyKeys]]()
6. 遍历keys的每个元素nextKey，执行
    a. 让excluded是false
    b. 遍历excludedItems的每个元素e，执行
        i. 如果SameValue(e, nextKey)和true，那么
            1. 设置excluded是true
    c. 如果excluded是false，那么
        i. 让desc是?from\.\[GetOwnProperty]](nextKey)
       ii. 如果desc不是undefined且desc.\[\[Enumerable]]是true，那么
            1. 让propValue是?Get(from, nextKey)
            2. 执行!CreateDataPropertyOrThrow(target, nextKey, propValue)
7. 返回target
**** 注意 这里的target永远是新创建的对象，且是在投掷异常时无法直接访问的。
** 7.4 Iterator Objects上的操作
  参看通用遍历接口（27.1）
*** 7.4.1 GetIterator(obj[,hint[,method]])
  抽象操作GetIterator接受参数obj和可选参数hint、method。被调用时执行下列步骤：
1. 如果hint不存在，设置hint是sync
2. Assert: hint是sync或者async
3. 如果method不存在，那么
    a. 如果hint是async，那么
        i. 设置method是?GetMethod(obj, @@asyncIterator)
       ii. 如果method是undefined，那么
            1. 让syncMethod是?GetMethod(obj, @@iterator)
            2. 让syncIteratorRecord是?GetIterator(obj, sync, syncMethod)
            3. 返回!CreateAsyncFromSyncIterator(syncIteratorRecord)
    b. 否则，设置method是?GetMethod(obj, @@iterator)
4. 让iterator是?Call(method, obj)
5. 如果Type(iterator)不是Object，投掷TypeError异常
6. 让nextMethod是?GetV(iterator, "next")
7. 让iteratorRecord是Record {\[\[Iterator]]:iterator, \[\[NextMethod]]:nextMethod,
   \[\[Done]]:false }
8. 返回itratorRecord
*** 7.4.2 IteratorNext(iteratorRecord[,value])
  抽象操作IteratorNext接受参数iteratorRecord和可选参数value。被调用时执行下列
步骤：
1. 如果value不存在，那么
    a. 让result是?Call(iteratorRecord.\[\[NextMethod]], iteratorRecord.\[\[Iterator]])
2. 否则
    a. 让result是?Call(iteratorRecord.\[\[NextMethod]], iteratorRecord.\[\[Iterator]],
       <<value>>)
3. 如果Type(result)不是Object，投掷TypeError异常
4. 返回result
*** 7.4.3 IteratorComplete(iterResult)
  抽象操作IteratorComplete接受参数iterResult。被调用时执行下列步骤：
1. Assert：Type(iterResult)是Object
2. 返回!ToBoolean(?Get(iterResult,"done"))
*** 7.4.4 IteratorValue(iterResult)
  抽象操作IteratorValue接受参数iterResult。被调用时执行下列步骤
1. Assert：Type(iterResult)是Object
2. 返回?Get(iterResult,"value")
*** 7.4.5 IteratorStep(iteratorRecord)
  抽象操作IteratorStep接受参数iteratorRecord。通过iteratorRecord.\[\[NextMethod]]
请求iteratorRecord.\[\[Iterator]]的下一个值，如果iterator已经结束了，返回false，
否则返回IteratorResult对象。被调用时执行下列步骤：
1. 让result是?IteratorNext(iteratorRecord)
2. 让done是?IteratorComplete(result)
3. 如果done是true，返回false
4. 返回result
*** 7.4.6 IteratorClose(iteratorRecord, completion)
  抽象操作IteratorClose接受参数iteratorRecord和completion。被用于通知遍历器在到
达完结状态时照常执行任何动作。被调用时执行下列步骤：
1. Assert：Type(iteratorRecord.\[\[Iterator]])是Object
2. Assert：completion是CompletionRecord
3. 让iterator是iteratorRecord.\[\[Iterator]]
4. 让innerResult是GetMethod(iterator, "return")
5. 如果innerResult.\[\[Type]]是nromal，那么
    a. 让return是innerResult.\[\[Value]]
    b. 如果return是undefined，返回Completion(completion)
    c. 设置innerResult是Call(return, iterator)
6. 如果completion.\[\[Type]]是throw，返回Completion(completion)
7. 如果innerResult.\[\[Type]]是throw，返回Completion(innerResult)
8. 如果Type(innerResult.\[\[Value]])不是Object，投掷TypeError异常
9. 返回Completion(completion)
*** 7.4.7 AsyncIteratorClose(iteratorRecord, completion)
  抽象操作AsyncIteratorClose接受参数iteratorRecord和completion。被用于通知遍历
器在到达完结时照常执行任何动作。被调用时执行下列步骤：
1. Assert：Type(iteratorRecord.\[\[Iterator]])是Object
2. Assert：completion是CompletionRecord值
3. 让iterator是iteratorRecord.\[\[Iterator]]
4. 让innerResult是GetMethod(iterator,"return")
5. 如果innerResult.\[\[Type]]是normal，那么
    a. 让return是innerResult.\[\[Value]]
    b. 如果return是undefined，返回Completion(completion)
    c. 设置innerResult是Call(return, iterator)
    d. 如果innerResult.\[\[Type]]是normal，设置innerResult是
       Await(innerResult.\[\[Value]])
6. 如果completion.\[\[Type]]是throw，返回Completion(completion)
7. 如果innerResult.\[\[Type]]是throw，返回Completion(completion)
8. 如果Type(innerResult.\[\[Value]])不是Object，投掷TypeError异常
9. 返回Compeltion(completion)
*** 7.4.8 CreateIterResultObject(value, done)
  抽象操作CreateIteResultObject接受参数value和done。创建支持IteratorResult接口的
对象。被调用时执行下列步骤：
1. Assert：Type(donw)是Boolean
2. 让obj是!OrdinaryObjectCreate(%Object.prototype%)
3. 执行!CreateDataPropertyOrThrow(obj, "value", value)
4. 执行!CreateDataPropertyOrThrow(obj,"done",done)
5. 返回obj
*** 7.4.9 CreateListIteratorRecord(list)
  抽象操作CrateListIteratorRecord接受参数list。创建Iterator(27.1.1.2)对象记录，
其next方法返回list上连续的元素。被调用时执行下列步骤：
1. 让closure是新的没有因素的AbstrctClosure，捕获list，被调用时执行下列步骤：
    a. 遍历list的每个元素E，运行
        i. 执行?Yield(E)
    b. 返回undefined
2. 让iterator是!CreateIteratorFromClosure(closure, empty, %IteratorPrototype%)
3. 返回Record{ \[\[Iterator]]:iterator,
   \[\[NextMethod]]:%GeneratorFunction.prototype.prototype.next%, \[\[Done]]:false }
**** 注意 这里的list不能被ECMAScript代码直接访问到
*** 7.4.10 IterableToList(items[,method])
  抽象操作IterableToList接受参数items和可选参数method。被调用时执行下列步骤：
1. 如果method存在，那么
    a. 让iteratorRecord是?GetIterator(items, sync, method)
2. 否则
    a. 让iteratorRecord是?GetIterator(items, sync)
3. 让values是一个新的空List
4. 让next是true
5. 当next不是false时，重复运行
    a. 设置next是?IteratorStep(iteratorRecord)
    b. 如果next不是false，那么
        i. 让nextValue是?IteratorValue(next)
       ii. 附加nextValue到values（List）的末端
6. 返回value
* 8 Syntax-Direted Operations 面向句法的操作
  除了本节定义的之外，特定的面向句法的操作的定义贯穿本规范。
** 8.1 Scope Analysis 范围分析（我更倾向于将scope翻译为闭）
*** 8.1.1 静态语义：BoundNames
**** 注意 "*default*"在被规范中被用作人为的名称以表示使用export声明定义的
           可提升的匿名函数。
BindingIdentifier : Identifier
1. 返回一个只有Identifier的String值作元素的List

BindingIdentifier : yield
1. 返回一个只有"yeild"元素的List

BindingIdentifier : await
1. 返回一个只有"await"元素的List

LexicalDeclaration : LetOrConst BindingList ;
1. 返回BindingList的BoundNames

BindingList : BindingList , LexicalBinding
1. 让names是BingdingList的BoundNames
2. 将LexicalBinding的BoundNames的元素附加到names中。
3. 返回names

LexicalBinding : BindingIdentifier Initializer_opt
1. 返回BindingIdentifier的BoundNames

LexicalBinding : BindingPattern Initializer
1. 返回Bindingattern的BoundNames

VariableDeclarationList : VariableDeclarationList , VariableDeclaration
1. 让names是VariableDeclarationList的BoundNames
2. 将VariableDeclaration的BoundNames的元素附加到names中
3. 返回names

VariableDeclaration : BindingIdentifier Initializer_opt
1. 返回BindingIdentifier的BoundNames

VariableDeclaration : BindingPattern Initializer
1. 返回BindingPattern的BoundNames

ObjectBindingPattern : { }
1. 返回新的空List

ObjectBindingPattern : { BindingPropertyList , BindingRestProperty }
1. 让names是BindingPropertyList的BoundNames
2. 将BindingRestProperty的BoundNames的元素附加到names中
3. 返回names

ArrayBindingPattern : [ Elision_opt ]
1. 返回新的空List

ArrayBindingPattern : [ Elision_opt BindingRestElement ]
1. 返回BindingRestElement的BoundNames

ArrayBindingPattern : [ BindingElementList, Elision_opt ]
1. 返回BindingElementList的BoundNames

ArrayBindingPattern : [ BindingElementList , Elision_opt BindingRestElement ]
1. 让names是BindingElementList的BoundNames
2. 将BindingRestElement的BoundNames的元素附加到names中
3. 返回names

BindingPropertyList : BindingPropertyList , BindingProperty
1. 让names是BindingPropertyList的BoundNames
2. 将BindingProperty的BoundNames的元素附加到names中
3. 返回names

BindingElementList : BindingElementList , BindingElisionElement
1. 让names是BindingElementList的BoundNames
2. 将BindingElisionElement的BoundNames的元素附加到names中
3. 返回names

BindingElisionElement : Elision_opt BindingElement
1. 返回BindingElement的BoundNames

BindingProperty : PropertyName : BindingElement
1. 返回BindingElement的BoundNames

SingleNameBinding : BindingIdentifier Initializer_opt
1. 返回BindingIdentifier的BoundNames

BindingElement : BindingPattern Initializer_opt
1. 返回BindingPattern的BoundNames

ForDeclaration : LetOrConst ForBinding
1. 返回ForBinding的BoundNames

FunctionDeclaration : function BindingIdentifier ( FormalParameters ) { FunctionBody }
1. 返回BindingIdentifier的BoundNames

FunctionDeclaration : function （FormalParameters ) { FunctionBody }
1. 返回<<"*default*">>

FormalParameters : [empty]
1. 返回新的空List

FormalParameters : FormalParameterList , FunctionRestParameter
1. 让names是FormalParameterList的BoundNames
2. 将FunctionRestParameter的BoundNames的元素附加到names中
3. 返回names

FormalParameterList : FormalParameterList , FormalParameter
1. 让names是FormalParameterList的BoundNames
2. 将FormalParameter的BoundNames的元素附加到names中
3. 返回names

ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList
1. 让formals是CoverParenthesizedExpressionAndArraowParameterList的
   CoveredFormalsList
2. 返回formals的BoundNames

GeneratorDeclaration : function * BindingIdentifier ( FormalParameters ) { GeneratorBody }
1. 返回BindingIdentifier的BoundNames

GeneratorDeclaration : function * ( FormalParameters ) { GeneratorBody }
1. 返回<<"*default*">>

AsyncGeneratorDeclaration : async function * BindingIdentifier ( FormalParameters ) { AsyncGeneratorBody }
1. 返回BindingIdentier的BoundNames

AsyncGeneratorDeclaration : async function * ( FormalParameters ) { AsyncGeneratorBody }
1. 返回<<"*default*">>

ClassDeclaration : class BindingIdentifier ClassTail
1. 返回BindingIdentifier的BoundNames

ClassDeclaration : class ClassTail
1. 返回<<"*default*">>

AsyncFunctionDeclaration : async function BindingIdentifier ( FormalParameters ) { AsyncFunctionBody }
1. 返回BindingIdentifier的BoundNames

AsyncFunctionDeclaration : async function (FormalParameters ) { AsyncFunctionBody }
1. 返回<<"*default*">>

CoverCallExpressionAndAsyncArrowHead : MemberExpression Arguments
1. 让head是CoverCallExpressionAndAsyncArrowHead的CoveredAsyncArraowHead
2. 返回head的BoundNames

ImportDeclaration : import ImportClause FromClause ;
1. 返回ImportClause的BoundNames

ImportDeclaration : import ModuleSpecifier ;
1. 返回新的空List

ImportClause : ImportedDefaultBinding , NameSpaceImport
1. 让names是ImportedDefaultBinding的BoundNames
2. 将NameSpaceImport的BoundNames的元素附加到names中
3. 返回names

ImportClause : ImportedDefaultBinding , NamedImports
1. 让names是ImportedDefaultBinding的BoundNames
2. 将NamedImports的BoundNames的元素附加到names中
3. 返回names

NamedImports : { }
1. 返回新的空List

ImportsList : ImportsList , ImportSpecifier
1. 让names是ImportsList的BoundNames
2. 将IMportSpecifier的BoundNames的元素附加到names中
3. 返回names

ImportSpecifier : IdentifierNames as ImportedBinding
1. 返回ImportedBinding的BoundNames

ExportDeclaration :
    export ExportFromClause FromClause ;
    export NamedExports ;
1. 返回新的空List

ExportDeclaration : export VariableStatement
1. 返回VariableStatement的BoundNames

ExportDeclaration : export Declaration
1. 返回Declaration的BoundNames

ExportDeclaration : export default HostableDeclaration
1. 让declarationNames是HoistableDeclaration的BoundNames
2. 如果declarationNames没有包含"*default*"，将"*default*"附加到declarationNames
3. 返回declarationNames

ExportDeclaration : export default ClassDeclaration
1. 让declarationNames是ClassDeclaration的BoundNames
2. 如果declarationNames不含有"*default*"，将"*default*"附加到declarationNames
3. 返回declarationNames

ExportDeclaration : export default AssignmentExpression ;
1. 返回<<"*default*">>
*** 8.1.2 静态语义：DeclarationPart 
HoistableDeclaration : FunctionDeclaration
1. 返回 FunctionDeclaration

HoistableDeclaration : GeneratorDeclaration
1. 返回 GeneratorDeclaration

HoistableDeclaration : AsyncFunctionDeclaration
1. 返回 AsyncFunctionDeclaration

HoistableDeclaration : AsyncGeneratorDeclaration
1. 返回 AsyncGeneratorDeclaration

Declaration : ClassDeclaration
1. 返回 ClassDeclaration

Declaration : LexicalDeclaration
1. 返回 LexicalDeclaration
*** 8.1.3 静态语义：IsConstantDeclaration
LexicalDeclaration : LetOrConst BindingList ;
1. 返回LetOrConst的IsConstantDeclaration

LetOrConst : let
1. 返回false

LetOrConst : const
1. 返回 true

FunctionDeclaration :
    function BindingIdentifier ( FormalParameters ) { FunctionBody }
    function ( FormalParameters ) { FunctionBody }
GeneratorDeclaration :
    function * BidningIdentifer ( FormalParameters ) { GeneratorBody }
    function * ( FormalParameters ) { GeneratorBody }
AsyncGeneratorDeclaration : 
    async function * BindingIdentifier ( FormalParameters ) { AsyncGeneratorBody }
    async function * ( FormalParameters ) { AsyncGeneratorBody }
AsyncFunctionDeclaration :
    async function BindingIdentifier ( FormalParameters ) { AsyncFunctionBody }
    async function ( FormalParameters ) { AsyncFunctionBody }
1. 返回false

ClassDeclaration :
    class BindingIdentifier ClassTail
    class ClassTail
1. 返回false

ExportDeclaration :
    export ExportFromClause FromClause ;
    export NamedExports ;
    export default AssignmentExpression ;
1. 返回false
**** 注意 无须将export default AssignmentExpression作为常量声明。因为不存在这样
           的句法对module的default对象的内部名称进行赋值。
*** 8.1.4 静态语义：LexicallyDeclaredNames
Block : { }
1. 返回新的空List

StatementList : StatementList StatementListItem
1. 让names是StatementList的LexicallyDeclaredNames
2. 将StatementListItem的LexicallyDeclaredNames的元素附加到names中
3. 返回names

StatementListItem : Statement
1. 如果Statement是 Statement : LabelledStatement 返回 LabelledStatement的
   LexicallyDeclaredNames
2. 返回新的空List

StatementListItem : Declaration
1. 返回Declaration的BoundNames

CaseBlock : { }
1. 返回新的空List

CaseBlock : { CaseClauses_opt DefaultClause CaseClauses_opt }
1. 如果第一个CaseClauses存在，让names是第一个CaseClauses的LexicallyDeclaredNames
2. 否则names是新的空List
3. 将DefaultClause的LexicallyDeclaredNames的元素附加到names中
4. 如果第二个CaseClauses不存在，返回names
5. 返回将第二个CaseClauses的LexicallyDeclaredNames的元素附加到names后的结果

CaseClauses : CaseClauses CaseClause
1. 让names是CaseClauses的LexicallyDeclaredNames。
2. 将CaseClause的LexicallyDeclaredNames的元素附加到names中
3. 返回names

CaseClause : case Expression : StatementList_opt
1. 如果StatementList存在，返回StatementList的LexicallyDeclaredNames
2. 返回新的空List

DefaultClause : default : StatementList_opt
1. 如果StatementList存在，返回StatementList的LexicallyDeclaredNames
2. 返回新的空List

LabelledStatement : LabelIdentifier : LabelledItem
1. 返回LabelledItem的LexicallyDeclaredNames

LabelledItem : Statement
1. 返回新的空List

LabelledItem : FunctionDeclaration
1. 返回FunctionDeclaration的BoundNames

FunctionStatementList : [ empty ]
1. 返回新的空List

FunctionStatementList : StatementList
1. 返回StatementList的TopLevelLexicallyDeclaredNames

ConciseBody : ExpressionBody
1. 返回新的空List

AsyncConciseBody : ExpressionBody
1. 返回新的空List

ScriptBody : StatementList
1. 返回StatementList的TopLevelLexicallyDeclaredNames
**** 注意1 在Script的顶层，对待函数声明像var声明而不是像词法声明。
**** 注意2 Module的LexicallyDeclaredNames包含其引入的绑定信息。
ModuleItemList : ModuleItemList ModuleItem
1. 让names是ModuleItemList的LexicallyDeclaredNames
2. 将ModuleItem的LexicallyDeclaredNames的元素附加到names中
3. 返回names

ModuleItem : ImportDeclaration
1. 返回ImportDeclaration的BoundNames

ModuleItem : ExportDeclaration
1. 如果ExportDeclaration是export VariableStatement，返回新的空List
2. 返回ExportDeclaration的BoundNames

ModuleItem : StatementListItem
1. 返回StatementListItem的LexicallyDeclaredNames
**** 注意3 在Module的顶层，对待函数声明像词法声明而不是var声明
*** 8.1.5 静态语义：LexciallyScopedDeclarations
StatementList : StatementList StatementListItem
1. 让declarations是StatementList的LexicallyScopedDeclarations
2. 将StatementListItem的LexicallyScopedDeclarations的元素附加到declarations中
3.返回declarations

StatementListItem : Statement
1. 如果Statement是Statement : LabelledStatement，返回LabelledStatement的
   LexicallyScopedDeclarations
2. 返回新的空List

StatementListItem : Declaration
1. 返回仅有Declaration的DeclarationPart的List

CaseBlock : { }
1. 返回新的空List

CaseBlock : { CaseClauses_opt DefaultClasue CaseClauses_opt }
1. 如果第一个CaseClauses存在，让declarations是第一个CaseClauses的
   LexicallyScopedDeclarations
2. 否则让declarations是新的空List
3. 将DefaultClause的LexicallyScopedDeclarations的元素附加到declarations中
4. 如果第二个CaseClauses不存在，返回Declarations
5. 返回将第二个CaseClauses的LexicallyScopedDeclarations的元素附加到
   declarations中的结果

CaseClauses : CaseClauses CaseClause
1. 让declarations是CaseClauses的LexciallyScopedDeclarations
2. 将CaseClause的LexiclallyScopedDeclarations的元素附加到declarations中
3. 返回declarations

CaseClause : case Expression : StatementList_opt
1. 如果StatementList存在，返回StatementList的LexicallyScopedDeclarations
2. 返回新的空List

DefaultClause: default : StatementList_opt
1. 如果StatementList存在，返回StatementList的LexicallyScopedDeclarations
2. 返回新的空List

LabelledStatement : LabelIdentifier : LbelledItem
1. 返回LabelledItem的LexicallyScopedDeclarations

LabelledItem : Statement
1. 返回新的空List

LabelledItem : FunctionDeclaration
1. 返回只有FunctionDeclaration的List

FunctionStatementList : [ empty ]
1. 返回新的空List

FunctionStatementList : StatementList
1. 返回StatementList的TopLevelLexicallyScopedDeclarations

ConciseBody : ExpressionBody
1. 返回新的空List

AsyncConciseBody : ExpressionBody
1. 返回新的空List

ScriptBody : StatementList
1. 返回Statementist的TopLevelLexciallyScopedDeclarations

Module : [ empty ]
1. 返回新的空List

ModuleItemList : ModuleItemList ModuleItem
1. 让declarations是ModuleItemList的LexicallyScopedDeclarations
2. 将ModuleItem的LexicallyScopedDeclarations的元素附加到declarations
3. 返回declarations

ModuleItem : ImportDeclaration
1. 返回新的空List

ExportDeclaration :
    export ExportFromClause FromClause ;
    export NamedExports ;
    export VariableStatement
1. 返回新的空List

ExportDeclaration : export Declaration
1. 返回只有Declaration的DeclarationPart的List

ExportDeclaration : export default HoistableDeclaration
1. 返回只有HoistableDeclaration的DeclarationPart的List

ExportDeclaration : export default ClassDeclaration
1. 返回只有ClassDeclaration的List

ExportDeclaration : export default AssignmentExpression ;
1. 返回只有ExportDeclaration的List
*** 8.1.6 静态语义：VarDeclaredNames
Statement :
    EmptyStatement
    ExpressionStatement
    ContinueStatement
    BreakStatement
    ReturnStatement
    ThrowStatement
    DebuggerStatement
1. 返回新的空List

Block : { }
1. 返回新的空List

StatementList : StatementList StatementListItem
1. 让names是StatementList的VarDeclaredNames
2. 将StatementListItem的VarDeclaredNames的元素附加到names中
3. 返回names

StatementListItem : Declaration
1. 返回新的空List

StatementListItem : var VariableDeclarationList ;
1. 返回VariableDeclarationList的BoundNames

IfStatement : if ( Expression ) Statement else Statement
1. 让names是第一个Statement的VarDeclaredNames
2. 将第二个Statement的VarDeclaredNames的元素附加到names中
3. 返回names

IfStatement : if ( Expression ) Statement
1. 返回Statement的VarDeclaredNames

DoWhileStatement : do Statement while ( Expression ) ;
1. 返回Statement的VarDeclaredNames

WhileStatement : while ( Expression ) Statement
1. 返回Statement的VarDeclaredNames

ForStatement : for ( Expression_opt ; Expression_opt ; Expression_opt ) Statement
1. 返回Statement的VarDeclaredNames

ForInOfStatement
    for ( LeftHandSideExpression in Expression ) Statement
    for ( ForDeclaration in Expression ) Statement
    for ( LeftHandSideExpression of AssignmentExpression ) Statement
    for ( ForDeclaration of AssignmentExpression ) Statement
    for await ( LeftHandSideExpression of AssignmentExpression ) Statement
    for await ( ForDeclaration of AssignmentExpression ) Statement
1. 返回Statement的VarDeclaredNames

ForInOfStatement :
    for ( var ForBinding in Expression ) Statement
    for ( var ForBinding of AssignmentExpression ) Statement
    for await ( var ForBinding of AssignmentExpression ) Statement
1. 让names是ForBinding的BoundNames
2. 将Statement的VarDeclaredNames的元素附加到names中
3. 返回names
**** 注意 本节内容被附件B.3.6扩展了。
WithStatement : with ( Expression ) Statement 
1. 返回Statement的VarDeclaredNames

SwitchStatement : switch ( Expression ) CaseBlock
1. 返回CaseBlock的VarDeclaredNames

CaseBlock : { }
1. 返回新的空List

CaseBlock : { CaseClauses_opt DefaultClause CaseClauses_opt }
1. 如果第一个CaseClauses存在，让names是第一个CaseClauses的VarDeclaredNames
2. 否则names是新的空List
3. 将DefaultClause的VarDeclaredNames的元素附加到names中
4. 如果第二个CaseClauses不存在，返回names
5. 返回将第二个CaseClauses的VarDeclaredNames的元素附加到names后的结果

CaseClauses : CaseClauses CaseClause
1. 让names是CaseClauses的VarDeclaredNames。
2. 将CaseClause的VarDeclaredNames的元素附加到names中
3. 返回names

CaseClause : case Expression : StatementList_opt
1. 如果StatementList存在，返回StatementList的VarDeclaredNames
2. 返回新的空List

DefaultClause : default : StatementList_opt
1. 如果StatementList存在，返回StatementList的VarDeclaredNames
2. 返回新的空List

LabelledStatement : LabelIdentifier : LabelledItem
1. 返回LabelledItem的VarDeclaredNames

LabelledItem : FunctionDeclaration
1. 返回新的空List

TryStatement : try Block Catch
1. 让names是Block的VarDeclaredNames
2. 将Catch的VarDeclaredNames的元素附加到names中
3. 返回names

TryStatement : try Block Finally
1. 让names是Block的VarDeclaredNames
2. 将Finally的VarDeclaredNames的元素附加到names中
3. 返回names

TryStatement : try Block Catch Finally
1. 让names是Block的VarDeclaredNames
2. 将Catch的VarDeclaredNames的元素附加到names中
3. 将Finally的VarDeclaredNames的元素附加到names中
4. 返回names

Catch : catch ( CatchParameter ) Block
1. 返回Block的VarDeclaredNames

FunctionStatementList : [ empty ]
1. 返回新的空List

FunctionStatementList : StatementList
1. 返回StatementList的TopLevelVarDeclaredNames

ConciseBody : ExpressionBody
1. 返回新的空List

AsyncConciseBody : ExpressionBody
1. 返回新的空List

ScriptBody : StatementList
1. 返回StatementList的TopLevelVarDeclaredNames

Module : [empty]
1. 返回新的空List

ModuleItemList : ModuleItemList ModuleItem
1. 让names是ModuleItemList的VarDeclaredNames
2. 将ModuleItem的VarDeclaredNames的元素附加到names中
3. 返回names

ModuleItem : ImportDeclaration
1. 返回新的空List

ModuleItem : ExportDeclaration
1. 如果ExportDeclaration是export VariableStatement，返回ExportDeclaration的
   BoundNames
2. 返回新的空List
*** 8.1.7 静态语义：VarScopedDeclarations
Statement :
    EmptyStatement
    ExpressionStatement
    ContinueStatement
    BreakStatement
    ReturnStatement
    ThrowStatement
    DebuggerStatement
1. 返回新的空List

Block : { }
1. 返回新的空List

StatementList : StatementList StatementListItem
1. 让names是StatementList的VarScopedDeclarations
2. 将StatementListItem的VarScopedDeclarations的元素附加到names中
3. 返回names

StatementListItem : Declaration
1. 返回新的空List

VariableDeclarationList : VariableDeclaration
1. 返回只有VariableDeclaration的List

VariableDeclarationList : VariableDelarationList , VariableDeclaration
1. 让decalrations是VariableDeclarationList的VarScopedDeclarations
2. 将VariableDeclaration附加到declarations
3. 返回declarations

IfStatement : if ( Expression ) Statement else Statement
1. 让declarations是第一个Statement的VarScopedDeclarations
2. 将第二个Statement的VarScopedDeclarations的元素附加到declarations中
3. 返回declarations

IfStatement : if ( Expression ) Statement
1. 返回Statement的VarScopedDeclarations

DoWhileStatement : do Statement while ( Expression ) ;
1. 返回Statement的VarScopedDeclarations

WhileStatement : while ( Expression ) Statement
1. 返回Statement的VarScopedDeclarations

ForStatement : for ( Expression_opt ; Expression_opt ; Expression_opt ) Statement
1. 返回Statement的VarScopedDeclarations

ForStatement : 
    for ( var VariableDeclarationList ; Expression_opt ; Expresion_opt ) Statement
1. 让declarations是VariableDeclarationList的VarScopedDeclarations
2. 将Statement的VarScopedDeclarations的元素附加到declarations中
3. 返回declarations

ForStatement : for ( LexicalDeclaration Expression_opt ; Expression_opt ) Statement
1. 返回Statement的VarScopedDeclarations

ForInOfStatement :
    for ( LeftHandSideExpression in Expression ) Statement
    for ( ForDeclaration in Expression ) Statement
    for ( LeftHandSideExpression of AssignmenetExpression ) Statement
    for ( ForDeclaration of AssignmentExpression ) Statement
    for await ( LeftHandSideExpression of AssigmentExpression ) Statement
    for await ( ForDeclaration of AssignmentExpression ) Statement 
1. 返回Statement的VarScopedDeclarations

ForInOfStatement :
    for ( var ForBinding in Expression ) Statement
    for ( var ForBidning of AssignmentExpression ) Statement
    for await ( var ForBinding of AssignmentExpression ) Statement
1. 让declarations是只有ForBinding的List
2. 将Statement的VarScopedDeclarations的元素附加到declarations
3. 返回declarations
**** 注意 本节内容被附件B.3.6扩展了。
WithStatement : with ( Expression ) Statement 
1. 返回Statement的VarScopedDeclarations

SwitchStatement : switch ( Expression ) CaseBlock
1. 返回CaseBlock的VarScopedDeclarations

CaseBlock : { }
1. 返回新的空List

CaseBlock : { CaseClauses_opt DefaultClause CaseClauses_opt }
1. 如果第一个CaseClauses存在，让declarations是第一个CaseClauses的
   VarScopedDeclarations
2. 否则delcarations是新的空List
3. 将DefaultClause的VarScopedDeclarations的元素附加到declarations中
4. 如果第二个CaseClauses不存在，返回declarations
5. 返回将第二个CaseClauses的VarScopedDeclarations的元素附加到declarations后的结果

CaseClauses : CaseClauses CaseClause
1. 让declarations是CaseClauses的VarScopedDeclarations。
2. 将CaseClause的VarScopedDeclarations的元素附加到declarations中
3. 返回declarations

CaseClause : case Expression : StatementList_opt
1. 如果StatementList存在，返回StatementList的VarScopedDeclarations
2. 返回新的空List

DefaultClause : default : StatementList_opt
1. 如果StatementList存在，返回StatementList的VarScopedDeclarations
2. 返回新的空List

LabelledStatement : LabelIdentifier : LabelledItem
1. 返回LabelledItem的VarScopedDeclarations

LabelledItem : FunctionDeclaration
1. 返回新的空List

TryStatement : try Block Catch
1. 让declarations是Block的VarScopedDeclarations
2. 将Catch的VarScopedDeclarations的元素附加到declarations
3. 返回declarations

TryStatement : try Block Finally
1. 让declarations是Block的VarScopedDeclarations
2. 将Finally的VarScopedDeclarations的元素附加到declarations
3. 返回declarations

TryStatement : try Block Catch Finally
1. 让declarations是Block的VarScopedDeclarations
2. 将Catch的VarScopedDeclarations的元素附加到declarations
3. 将Finally的VarScopedDeclarations的元素附加到declarations
4. 返回declarations

Catch : catch ( CatchParameter ) Block
1. 返回Block的VarScopedDeclarations

FunctionStatementList : [ empty ]
1. 返回新的空List

FunctionStatementList : StatementList
1. 返回StatementList的TopLevelVarScopedDeclarations

ConciseBody : ExpressionBody
1. 返回新的空List

AsyncConciseBody : ExpressionBody
1. 返回新的空List

ScriptBody : StatementList
1. 返回Statementist的TopLevelVarScopedDeclarations

Module : [empty]
1. 返回新的空List

ModuleItemList : ModuleItemList ModuleItem
1. 让declarations是ModuleIemList的VarScopedDeclarations
2. 将ModuleItem的VarScopedDeclarations的元素附加到declarations中
3. 返回declarations

ModuleItem : ExportDeclaration
1. 如果ExportDeclaration是export VariableStatement，返回VariableStatement
   的VArScopedDeclarations
2. 返回新的空List
*** 8.1.8 静态语义：TopLevelLexicallyDeclaredNames
StatementList : StatementList StatementListItem
1. 让names是StatementList的TopLevelLexicallyDeclaredNames
2. 将StatementListItem的TopLevelLexciallyDeclaredNames的元素附加到names中
3. 返回names

StatementListItem : Statement
1. 返回新的空List

StatementListItem : Declaration
1. 如果Declaration是Declaration : HoistableDeclaration, 那么
    a. 返回<<>>
2. 返回Declaration的BoundNames
**** 注意 在function或Scipt的顶层，对待函数声明像var声明而不是词法声明
LabelledStatement : LabelIdentifier : LabelledItem
    1. 返回新的空List
*** 8.1.9 静态语义：TopLevelLexicallyScopedDeclarations
Block : { }
1. 返回新的空List

StatementList : StatementList StatementListItem
1. 让declarations是StatementList的TopLevelLexicallyScopedDeclarations
2. 将StatementListItem的TopLevelLexicallyScopedDeclarations的元素附加到declarations
3. 返回declarations

StatementListItem : Statement
1. 返回新的空List

StatementListItem : Declaration
1. 如果Declaration是 Declaration : HoistableDeclaration，那么
    a. 返回<<>>
2. 返回只有Declaration的List

LabelledStatement : LabelIdentifier : LabelledItem
1. 返回新的空List
*** 8.1.10 静态语义：TopLevelVarDeclaredNames
Block : { }
1. 返回新的空List

StatementList : StatementList StatementListItem
1. 让names是StatementList的TopLevelVarDeclaredNames
2. 将StatementListItem的TopLevelVarDeclaredNames的元素附加到names
3. 返回names

StatementListItem : Declaration
1. 如果Declaration是Declaration : HoistableDeclaration，那么
    a. 返回HoistableDeclaration的BoundNames
2. 返回新的空List

StatementListItem : Statement
1. 如果Statement是Statement : LabelledStatement，返回Statement的
   TopLevelVarDeclaredNames
2. 返回Statement的VarDeclaredNames
**** 在function和script的顶层，对待内部函数声明像var声明
LabelledStatement : LabelIdentifier : LabelledItem
1. 返回LabelledItem的TopLevelVarDeclaredNames

LabelledItem : Statement
1. 如果Statemnet是Statement : LabelledStatement，返回Statment的
   TopLevelVarDeclaredNames
2. 返回Statement的VarDeclaredNames

LabelledItem : FunctionDeclaration
1. 返回FunctionDeclaration的BoundNames
*** 8.1.11 静态语义：TopLevelVarScopedDeclarations
Block : { }
1. 返回新的空List

StatementList : StatementList StatementListItem
1. 让declarations是StatementList的TpLevelVarScopedDeclarations
2. 将StatementListItem的TopLevelVarScopedDeclarations的元素附加到declarations中
3. 返回declarations

StatementListItem : Statement
1. 如果Statement是 Statement : LabelledStatement，返回Statement的
   TopLevelVarScopedDeclarations
2. 返回Statement的VarScopedDeclarations

StatementListItem : Declaration
1. 如果Declaration是Declarations : HoistableDeclaration，那么
    a. 让declaration是HoistableDeclaration的DeclarationPart
    b. 返回<<declaration>>
2. 返回新的空List

LabelledStatement : LabelIdentifier : LabelledItem
1. 返回LabelledItem的TopLevelVarScopedDeclarations

LabelledItem : FunctionDeclaration
1. 返回只有FunctionDeclaration的List
** 8.2 Labels标签
*** 8.2.1 静态语义：ContainsDuplicateLabels
带有参数labelSet
Statement:
    VariableStatement
    EmptyStatement
    ExpressionStatement
    ContinueStatement
    BreakStatement
    ReturnStatement
    ThrowStatement
    DebuggerStatement
Block : { }
StatementListItem : Declaration
1. 返回false

StatementList : StatementList StatementListItem
1. 让hasDuplicates是StatementList带labelSet参数的ContainsDuplicatedLabels
2. 如果hasDuplicates是true，返回true
3. 返回StatementListItem带labelSet参数的ContinsDuplicateLabels

IfStateMent : if ( Expression ) Statement else Statement 
1. 让hasDuplicate是第一个Statement带labelSet参数的ContainsDuplicateLabels
2. 如果hasDuplicates是true，返回true
3. 返回第二个Statement带labelSet参数的ContainsDuplicateLabels

IfStatement : if ( Expression ) Statement
1. 返回Statement带labelSet参数的ContainsDuplicateLabels

DoWhileStatement : do Statement while ( Expression ) ;
1. 返回Statement带labelSet参数的ContainsDuplicateLabels

WhileStatement : while ( Expression ) Statement
1. 返回Statement带labelSet参数的ContainsDuplicateLabels

ForStatement :
    for ( Expression_opt ; Expression_opt ; Expression_opt ) Statement
    for ( var VariableDeclarationList ; Expression_opt ; Expression_opt ) Statement
    for ( LexicalDeclaration Expression_opt ; Expression_opt ) Statement
1. 返回Statement带labelSet参数的ContainsDuplicateLabels

ForInOfStatement :
    for ( LeftHandSideExpression in Expression ) Statement
    for ( var ForBinding in Expression ) Statement
    for ( ForDeclaration in Expression ) Statement
    for ( LeftHandSideExpression of AssignmentExpression ) Statement
    for ( var ForBinding of AssignmentExpression ) Statement
    for ( ForDeclaration of AssignmentExpression ) Statement
    for await ( LeftHandSideExpression of AssignmentExpreesion ) Statement
    for await ( var ForBinding of AssignmentExpreesion ) Statement
    for await ( ForDeclaration of AssignmentExpression ) Statement
1. 返回Statement带labelSet参数的ContainsDupicateLabels
**** 注意 本节被附录B.3.6扩展
WithStatement : with ( Expression ) Statement
1. 返回Statement带labelSet参数的ContainsDuplicateLabels

SwitchStatement : switch ( Expression ) CaseBlock
1. 返回CaseBlock带labelSet参数的ContainsDuplicateLabels

CaseBlock : { }
1. 返回false

CaseBlock : { CaseClauses_opt DefaultCaluse CaseClauses_opt }
1. 如果第一个CaseClauses存在，那么
    a. 让hasDuplicates是CaseClauses带labelSet参数的ContainsDuplicateLabels
    b. 如果hasDuplicates是true，返回true
2. 让hasDuplicates是DefaultClause带labelSet参数的ContainsDuplicateLabels
3. 如果hasDuplicates是true，返回true
4. 如果第二个CaseClauses不存在，返回false
5. 返回第二个CaseClauses带labelSet参数的ContainsDuplicateLabels

CaseClauses : CaseClauses CaseClause
1. 让hasDuplicates是CaseClauses带labelSet参数的ContainsDuplicateLabels
2. 如果hasDuplicates是true，返回true
3. 返回CaseClause带labelSet参数的ContainsDuplicateLabels

CaseClause : case Expression : StatementList_opt
1. 如果StatementList存在，返回StatementList带labelSet参数的ContainsDuplicateLabels
2. 返回false

DefaultClause : default : StatementList_opt
1. 如果StatementList存在，返回StatementList带labelSet参数的ContainsDuplicateLabels
2. 返回false

LabelledStatement : LabelIdentifier : LabelledItem
1. 让label是LabelIdentifier的Sting值
2. 如果label是labelSet的元素，返回true
3. 让newLabelSet是labeSet附加label后的复制
4. 返回LabelledItem带newLabelSet参数的ContainsDuplicateLabel

LabelledItem : FunctionDeclaration
1. 返回false

TryStatement : try Block Catch
1. 让hasDuplicates是Block带labelSet参数的ContainsDuplicateLabels
2. 如果hasDuplicates是true，返回true
3. 返回Catch带labelSet参数的ContainsDuplicateLabels

TryStatement : try Block Finally
1. 让hasDuplicates是Block带labelSet参数的ContainsDuplicateLabels
2. 如果hasDuplicates是true，返回true
3. 返回Finally带labelSet参数的ContainsDuplicateLabels

TryStatement : try Block Catch Finally
1. 让hasDuplicates是Block带labelSet参数的ContainsDuplicateLabels
2. 如果hasDuplicates是true，返回true
3. 让hasDuplicates是Catch带labelSet参数的ContainsDuplicateLabels
4. 如果hasDuplicates是true，返回true
5. 返回Finally带labelSet参数的ContainsDuplicateLabels

Catch : catch ( CatchParameter ) Block
1. 返回Block带labelSet参数的ContainsDuplicateLabels

FunctionStatementList : [empty]
1. 返回false

ModuleItemList : ModuleItemList ModuleItem
1. 让hasDuplicates是ModuleItemList带labelSet参数的ContainsDuplicateLabels
2. 如果hasDuplicates是true，返回true
3. 返回ModuleItem带labelSet参数的ContainsDuplicateLabels

ModuleItem : 
    ImportDeclaration
    ExportDeclaration
1. 返回false
*** 8.2.2 静态语义：ContainsUndefinedBreakTarget
带labelSet参数
Statement :
   VariableStatement
   EmptyStatement
   ExpressionStatement
   ContinueStatement
   ReturnStatement
   ThrowStatement
   DebuggerStatement
Block : { }
StatementListItem : Declaration
1. 返回false

StatementList : StatementList StatementListItem
1. 让hasUndefinedLabels是StatementList带labelSet参数的ContainsUndefinedBreakTarget
2. 如果hasUndefinedLabels是true，返回true
3. 返回StatementListItem带labelSet参数的ContainsUndefinedBreakTarget

IfStatement : if ( Expression ) Statement else Statement
1. 让hasUndefinedLabels是第一个Statement带labelSet参数的ContainsUndefinedBreakTarget
2. 如果hasUndefinedLabels是true，返回true
3. 返回第二个Statement带labelSet参数的ContainsUndefinedBreakTarget

IfStatement : if ( Expression ) Statement
1. 返回Statement带labelSet参数的ContainsUndefinedBreakTarget

DoWhileStatement : do Statement while ( Expression ) ;
1. 返回Statement带labelSet参数的ContainsUndefinedBreakTarget

WhileStatement : while ( Expression ) Statement
1. 返回Statement带labelSet参数的ContainsUndefinedBreakTarget

ForStatement:
    for ( Expression_opt ; Expression_opt ; Expression_opt ) Statement
    for ( var VariableDeclarationList ; Expression_opt ; Expression_opt ) Statement
    for ( LexicalDeclaration Expression_opt ; Expression_opt ) Statement
1. 返回Statement带labelSet参数的ContainsUndefinedBreakTarget

ForInOfStatement :
    for ( LeftHandSideExpression in Expression ) Statement
    for ( var ForBinding in Expression ) Statement
    for ( ForDeclaration in Expression ) Statement
    for ( LeftHandSideExpression of AssignmentExpression ) Statement
    for ( var ForBinding of AssignmentExpression ) Statement
    for ( ForDeclaration of AssignmentExpression ) Statement
    for await ( LeftHandSideExpression of AssignmentExpression ) Statement
    for await ( var ForBinding of AssignmentExpression ) Statement
    for await ( ForDeclaration of AssignmentExpression ) Statement
1. 返回Statement带labelSet参数的ContainsUndefinedBreakTarget
**** 注意  本节在附录B.3.6中被扩展
BreakStatement : break;
1. 返回false

BreakStatement : break LabelIdentifier ;
1. 如果LabelIdentifier的String值不在labelSet中，返回true
2. 返回false

WithStatement : with ( Expression ) Statement
1. 返回Statement带labelSet参数的ContainsUndefinedBreakTarget

SwitchStatement : switch ( Expression ) CaseBlock
1. 返回CaseBlock带labelSet参数的ContainsUndefinedBreakTarget

CaseBlock : { }
1. 返回false

CaseBlock : { CaseClauses_opt DefaultClause CaseClauses_opt }
1. 如果第一个CaseClauses存在，那么
    a. 让hasUndefinedLabels是第一个CaseClauses带labelSet参数的
       ContainsUndefinedBreakTarget
    b. 如果hasUndefinedLabels是true，返回true
2. 让hasUndefinedLabels是DefaultClause带labelSet参数的ContainsUndefinedBreakTarget
3. 如果hasUndefinedLabels是true，返回true
4. 如果第二个CaseClauses不存在，返回false
5. 返回第二个CaseClauses带labelSet参数的ContainsUndefinedBreakTarget

CaseClauses : CaseClauses CaseClause
1. 让hasUndefinedLabels是CaseClauses带labelSet参数ContainsUndefinedBreakTarget
2. 如果hasUndefinedLabels是true，返回true
3. 返回CaseClause带labelSet参数的ContainsUndefinedBreakTarget

CaseClause : case Expression : StatementList_opt
1. 如果StatementList存在，返回StatementList带labelSet参数的
   ContainsUndefinedBreakTarget
2. 返回false

DefaultClause : default : StatementList_opt
1. 如果StatementList存在，返回StatementList带labelSet参数的
   ContainsUndefinedBreakTarget
2. 返回false

LabelledStatement : LabelIdentifier : LabelledItem
1. 让label是LabelIdentifier的String值
2. 让newLabelSet是labelSet的复制，并附加label
3. 返回LabelledItem带newLabelSet参数的ContainsUndefinedBreakTarget

LabelledItem : FunctionDeclaration
1. 返回false

TryStatement : try Block Catch
1. 让hasUndefinedLabels是Block带labelSet参数的ContainsUndefinedBreakTarget
2. 如果hasUndefinedLabels是true，返回true
3. 返回Catch带labelSet参数的ContainsUndefinedBreakTarget

TryStatement : try Block Finally
1. 让hasUndefinedLabels是Block带labelSet参数的ContainsUndefinedBreakTarget
2. 如果hasUndefinedLabels是true，返回true
3. 返回Finally带labelSet参数的ContainsUndefinedBreakTarget

TryStatement : try Block Catch Finally
1. 让hasUndefinedLabels是Block带labelSet参数的ContainsUndefinedBreakTarget
2. 如果hasUndefinedLabels是true，返回true
3. 让hasUndefinedLabels是Catch带labelSet参数的ContainsUndefinedBreakTarget
4. 如果hasUndefinedLabels是true，返回true
5. 返回Catch带labelSet参数的ContainsUndefinedBreakTarget

Catch : catch ( CatchParameter ) Block
1. 返回Block带labelSet参数的ContainsUndefinedBreakTarget

FunctionStatementList : [empty]
1. 返回false

ModuleItemList : ModuleItemList ModuleItem
1. 让hasUndefinedLabels是ModuleItemList带labelSet参数的ContainsUndefinedBreakTarget
2. 如果hasUndefinedLabels是true，返回true
3. 返回ModuleItem带labelSet参数的ContainsUndefinedBreakTarget

ModuleItem :
    ImportDeclaration
    ExportDeclaration
1. 返回false
*** 8.2.3 静态语义：ContainsUndefinedContinueTarget
带iterationSet和labelSet参数
Statement :
   VariableStatement
   EmptyStatement
   ExpressionStatement
   BreakStatement
   ReturnStatement
   ThrowStatement
   DebuggerStatement
Block : { }
StatementListItem : Declaration
1. 返回false

BreakableStatement : IterationStatement
1. 让newIterationSet是iterationSet的复制，附加labelSet的全部元素
2. 返回IterationStatement带newIterationSet和<<>>参数的ContainsUndefinedContinueTarget

StatementList : StatementList StatementListItem
1. 让hasUndefinedLabels是StatementList带iterationSet和<<>>参数的
   ContainsUndefinedBreakTarget
2. 如果hasUndefinedLabels是true，返回true
3. 返回StatementListItem带iterationSet和<<>>参数的ContainsUndefinedBreakTarget

IfStatement : if ( Expression ) Statement else Statement
1. 让hasUndefinedLabels是第一个Statement带iteration和<<>>参数的
   ContainsUndefinedContinueTarget
2. 如果hasUndefinedLabels是true，返回true
3. 返回第二个Statement带iterationSet和<<>>参数的ContainsUndefinedContinueTarget

IfStatement : if ( Expression ) Statement
1. 返回Statement带iterationSet和<<>>参数的ContainsUndefinedContinueTarget

DoWhileStatement : do Statement while ( Expression ) ;
1. 返回Statement带iterationSet和<<>>参数的ContainsUndefinedContinueTarget

WhileStatement : while ( Expression ) Statement
1. 返回Statement带iterationSet和<<>>参数的ContainsUndefinedContinueTarget

ForStatement:
    for ( Expression_opt ; Expression_opt ; Expression_opt ) Statement
    for ( var VariableDeclarationList ; Expression_opt ; Expression_opt ) Statement
    for ( LexicalDeclaration Expression_opt ; Expression_opt ) Statement
1. 返回Statement带iterationSet和<<>>参数的ContainsUndefinedContinueTarget

ForInOfStatement :
    for ( LeftHandSideExpression in Expression ) Statement
    for ( var ForBinding in Expression ) Statement
    for ( ForDeclaration in Expression ) Statement
    for ( LeftHandSideExpression of AssignmentExpression ) Statement
    for ( var ForBinding of AssignmentExpression ) Statement
    for ( ForDeclaration of AssignmentExpression ) Statement
    for await ( LeftHandSideExpression of AssignmentExpression ) Statement
    for await ( var ForBinding of AssignmentExpression ) Statement
    for await ( ForDeclaration of AssignmentExpression ) Statement
1. 返回Statement带iterationSet和<<>>参数的ContainsUndefinedContinueTarget
**** 注意  本节在附录B.3.6中被扩展
ContinueStatement : continue;
1. 返回false

ContinueStatement : continue LabelIdentifier ;
1. 如果LabelIdentifier的String值不在iterationSet中，返回true
2. 返回false

WithStatement : with ( Expression ) Statement
1. 返回Statement带iterationSet和<<>>参数的ContainsUndefinedContinueTarget

SwitchStatement : switch ( Expression ) CaseBlock
1. 返回CaseBlock带iterationSet和<<>>参数的ContainsUndefinedContinueTarget

CaseBlock : { }
1. 返回false

CaseBlock : { CaseClauses_opt DefaultClause CaseClauses_opt }
1. 如果第一个CaseClauses存在，那么
    a. 让hasUndefinedLabels是第一个CaseClauses带iterationSet和<<>>参数的
       ContainsUndefinedContinueTarget
    b. 如果hasUndefinedLabels是true，返回true
2. 让hasUndefinedLabels是DefaultClause带iterationSet和<<>>参数的
   ContainsUndefinedContinueTarget
3. 如果hasUndefinedLabels是true，返回true
4. 如果第二个CaseClauses不存在，返回false
5. 返回第二个CaseClauses带iterationSet和<<>>参数的ContainsUndefinedContinueTarget

CaseClauses : CaseClauses CaseClause
1. 让hasUndefinedLabels是CaseClauses带iterationSet和<<>>参数
   ContainsUndefinedContinueTarget
2. 如果hasUndefinedLabels是true，返回true
3. 返回CaseClause带iterationSet和<<>>参数的ContainsUndefinedContinueTarget

CaseClause : case Expression : StatementList_opt
1. 如果StatementList存在，返回StatementList带iterationSet和<<>>参数的
   ContainsUndefinedContinueTarget
2. 返回false

DefaultClause : default : StatementList_opt
1. 如果StatementList存在，返回StatementList带iterationSet和<<>>参数的
   ContainsUndefinedContinueTarget
2. 返回false

LabelledStatement : LabelIdentifier : LabelledItem
1. 让label是LabelIdentifier的String值
2. 让newLabelSet是lebelSet的复制，并附加label
3. 返回LabelledItem带iterationSet和newLabelSet参数的ContainsUndefinedContinueTarget

LabelledItem : FunctionDeclaration
1. 返回false

TryStatement : try Block Catch
1. 让hasUndefinedLabels是Block带iterationSet和<<>>参数的
   ContainsUndefinedContinueTarget
2. 如果hasUndefinedLabels是true，返回true
3. 返回Catch带iterationSet和<<>>参数的ContainsUndefinedContinueTarget

TryStatement : try Block Finally
1. 让hasUndefinedLabels是Block带iterationSet和<<>>参数的
   ContainsUndefinedContinueTarget
2. 如果hasUndefinedLabels是true，返回true
3. 返回Finally带iterationSet和<<>>参数的ContainsUndefinedContinueTarget

TryStatement : try Block Catch Finally
1. 让hasUndefinedLabels是Block带iterationSet和<<>>参数的
   ContainsUndefinedContinueTarget
2. 如果hasUndefinedLabels是true，返回true
3. 让hasUndefinedLabels是Catch带iterationSet和<<>>参数的
   ContainsUndefinedContinueTarget
4. 如果hasUndefinedLabels是true，返回true
5. 返回Catch带iterationSet和<<>>参数的ContainsUndefinedContinueTarget

Catch : catch ( CatchParameter ) Block
1. 返回Block带iterationSet和<<>>参数的ContainsUndefinedContinueTarget

FunctionStatementList : [empty]
1. 返回false

ModuleItemList : ModuleItemList ModuleItem
1. 让hasUndefinedLabels是ModuleItemList带iterationSet和<<>>参数的
   ContainsUndefinedContinueTarget
2. 如果hasUndefinedLabels是true，返回true
3. 返回ModuleItem带iterationSet和<<>>参数的ContainsUndefinedContinueTarget

ModuleItem :
    ImportDeclaration
    ExportDeclaration
1. 返回false
** 8.3 函数名引用
*** 8.3.1 静态语义：HasName
PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList
1. 让expr是CoverParenthesizedExpressionAndArrowParameterList的
   CoveredParenthesizedExpression
2. 如果expr的IsFunctionDefinition是false，返回false
3. 返回expr的HasName

FunctionExpression : 
    function ( FormalParameters ) { FunctionBody }
GeneratorExpression :
    function * ( FormalParameters ) { GeneratorBody }
AsyncFunctionExpression :
    async function * ( FormalParameters ) { AsyncGeneratorBody }
AsyncFunctionExpression :
    Async function ( FormalParameters ) { AsyncFunctionBody }
ArrowFunction : 
    ArrowParameters => ConciseBody
AsyncArrowFunction :
    async AsyncArrowBindingIdentifier => AsyncConciseBody
    CoverCallExpressionAndAsyncArrowHead => AsyncConciseBody
ClassExpression : class ClassTail
1. 返回false
FunctionExpression : 
    function BindingIdentifier ( FormalParameters ) { FunctionBody }
GeneratorExpression :
    function * BindingIdentifier ( FormalParameters ) { GeneratorBody }
AsyncGeneratorExpression : 
    async function * BindingIdentifier ( FormalParameters ) { AsyncGeneratorBody }
AsyncFunctionExpression :
    async function BindingIdentifier ( FormalParameters ) { AsyncFunctionBody }
ClassExpression : class BindingIdentifier ClassTail
1. 返回true
*** 8.3.2 静态语义：IsFunctionDefinition
PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList
1. 让expr是CoverParenthesizedExpressionAndArrowParameterList的
   CoveredParenthesizedExpression
2. 返回expr的IsFunctionDefinition
PrimaryExpression :
    this
    IdentifierReference
    Literal
    ArrayLiteral
    ObjectLiteral
    RegularExpressionLiteral
    TemplateLiteral
MemberExpression :
    MemberExpression [ Expression ]
    MemberExpression . IdentifierName
    MemberExpression TemplateLiteral
    SuperProperty
    MetaProperty
    new MemberExpression Arguments
NewExpression :
    new NewExpression
LeftHandSideExpression : 
    CallExpression
    OptionalExpression
UpdateExpression :
    LeftHandSideExpression \+\+ 
    LeftHandSideExpression \-\-
    \+\+ UnaryExpression
    \-\- UnaryExpression
UnaryExpression :
    delete UnaryExpression
    void UnaryExpression
    typeof UnaryExpression
    \+ UnaryExpression
    \- UnaryExpression
    \~ UnaryExpression
    \! UnaryExpression
    AwaitExpression
ExponentiationExpression :
    UpdateExpression ** ExponentiationExpression
MultiplicativeExpression :
    MultiplicativeExpression MultiplicativeOperator ExponentiationExpression
AdditiveExpression :
    AdditiveExpression + MultiplicativeExpression
    AdditiveExpression - MultiplicativeExpression
ShifExpression :
    ShiftExpression \<\< AdditiveExpression
    ShiftExpression \>\> AdditiveExpression
    ShiftExpression \>\>\> AdditiveExpression
RelationalExression :
    RelationalExpression \< ShiftExpression
    RelationalExpression \> ShiftExpression
    RelationalExpression \<= ShiftExpression
    RelationalExpression \>= ShiftExpression
    RelationalExpression instanceof ShiftExpression
    RelationalExpression in ShiftExpression
EqualityExpression :
    EqualityExpression \=\= RelationalExpression
    EqualityExpression \!\= RelationalExpression
    EqualityExpression \=\=\= RelationalExpression
    EqualityExpression \!\==\= RelationalExpression
BitwiseANDExpression
    BitwiseANDExpression \& EqualityExpression
BitwiseXORExpression :
    BitwiseXORExpression \^ BitwiseANDEExpression
BitWiseORExpression :
    BitWiseORExpression \| BitwiseXORExpression
LogicalANDExpression :
    LogicalANDExpression && BitwiseORExpression
LogicalORExpression :
    LogicalORExpression || LogicalANDExpression
CoalesceExpression :
    CoalesceExpressionHead ?? BitwiseORExpression
ConditionalExpression :
    ShortCircuitExpression ? AssignmentExpression : AssignmentExpression
AssignmentExpression :
    YieldExpression
    LeftHandSideExpression = AssignmentExpression
    LeftHandSideExpression AssignmentOperator AssignmentExpression
    LeftHandSideExpression &&= AssignmentExpression
    LeftHandSideExpression ||= AssignmentExpression
    LeftHandSideExpression ??= AssignmentExpression
Expression :
    Expression , AssignmentExpression
1. 返回false
AssignmentExpression :
    ArrowFunction
    AsyncArrowFunction
FunctionExpression :
    function BindingIdentifier_opt ( FormalParameters ) { FunctionBody }
GeneratorExpression :
    function * BindingIdentifier_opt ( FormalParameters ) { GeneratorBody }
AsyncGeneratorExpression :
    async function * BindingIdentifier_opt ( FormalParameters ) { AsyncGeneratorBody }
AsyncFunctionExpression :
    async function BindingIdentifier_opt ( FormalParameters ) { AsyncFunctionBody }
ClassExpression : class BindingIdentifier_opt ClassTail
1. 返回true
*** 8.3.3 静态语义：IsAnonymousFunctionDefinition(expr)
  抽象操作IsAnonymousFunctionDefinition接受参数expr（AssignmentExpression的
ParseNode或者Initialize的ParseNode）。用于明确它的参数是否是一个没有绑定名称的
函数定义。被调用时执行下列步骤：
1. 如果expr的IsFunctionDefinition是false，返回false
2. 让hasName是expr的HasName
3. 如果hasName是true，返回false
4. 返回true
*** 8.3.4 静态语义：IsIdentifierRef
PrimaryExpression : IdentifierReference
1.返回true
PrimaryExpression :
    this
    Literal
    ArrayLiteral
    ObjectLiteral
    FunctionExpression
    ClassExpression
    GeneratorExpression
    AsyncFunctionExpression
    AsyncGeneratorExpression
    RegularExpressionLiteral
    TemplateLiteral
    CoverParenthesizedExpressionAndArrowParameterList
MemberExpression :
    MemberExpression [ Expression ]
    MemberExpression . IdentifierName
    MemberExpression TemplateLiteral
    SuperProperty
    MetaProperty
    new MemberExpression Arguments
NewExpression :
    new NewExpression
LeftHandSideExpression :
    CallExpression
    OptionalExpression
1. 返回 false.
*** 8.3.5 静态语义：NamedEvaluation
带name参数
PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList
1. 让expr是CoverParenthesizedExpressionAndArrowParameterList的
   CoveredParenthesizedExpression
2. 返回expr带name参数的NamedEvaluation

ParenthesizedExpression ( Expression )
1. Assert：IsAnonymousFunctionDefinition(Expression)是true
2. 返回Expression带name参数的NamedEvaluation

FunctionExpression : function ( FormalParameters ) { FunctionBody }
1. 返回FunctionExpression带name参数的InstantiateOrdinaryFunctionExpression

GeneratorExpression : function * ( FormalParameters ) { GeneratorBody }
1. 返回GeneratorExpression带name参数的InstantiateGeneratorFunctionExpression

AsyncGeneratorExpression : async function * ( FormalParameters ) { AsyncGeneratorBody }
1. 返回AsyncGeneratorExpression带name参数的InstantiateAsyncGeneratorFunctionExpression

AsyncFunctionExpression : async function ( FormalParameters ) { AsyncFunctionBody }
1. 返回AsyncFunctionExpression带name参数的InstantiateAsyncFunctionExpression

ArrowFunction : ArrowParameters => ConciseBody
1. 返回ArrowFunction带name参数的InstantiateArrowFunctionExpression

AsyncArrowFunction :
   async AsyncArrowBindingIdentifier => AsyncConciseBody
   CoverCallExpressionAndAsyncArrowedHead => AsyncConciseBody
1. 返回AsyncArrowFunction带name参数的InstantiateAsyncArrowFunctionExpression

ClassExpression : class ClassTail
1. 让value是ClassTail带name参数的ClassDefinitionEvaluation
2. ReturnIfAbrupt(value)
3. 设置value.\[\[SourceText]]是匹配ClassExpression的源文本
4. 返回value
** 8.4 Contains
*** 8.4.1 静态语义：Contains
带symbol参数
  本规范中不是下方列出的的产出备选的Contains隐式的含有如下定义。
1. 遍历这个ParseNode的每个子节点child，执行
    a. 如果child是symbol的实例，返回true
    b. 如果child是非终结符，那么
        i. 让contained是child才symbol参数的Contains
       ii. 如果contained是true，返回true
2. 返回false

FunctionDeclaration : 
    function BindingIdentifier ( FormalParameters ) { FunctionBody }
    function ( FormalParameters ) { FunctionBody }
FunctionExpression : 
    function BindingIdentifier_opt ( FormalParameters ) { FunctionBody }
GeneratorDeclaration :
    function * BindingIdentifier ( FormalParameters ) { GeneratorBody }
    function * ( FormalParameters ) { GeneratorBody }
GeneratorExpression :
    function * BindingIdentifier_opt ( FormalParameters ) { GeneratorBody }
AsyncGeneratorDeclaration :
    async function * BindingIdentifier ( FormalParameters ) { AsyncGeneratorBody }
    async function * ( FormalParameters ) { AsyncGeneratorBody }
AsyncGeneratorExpression :
    async function * BindingIdentifier_opt ( FormalParameters ) { AsyncGeneratorBody }
AsyncFunctionDeclaration :
    async function BindingIdentifier ( FormalParameters ) { AsyncFunctionBody }
    async function ( FormalParameters ) { AsyncFunctionBody }
AsyncFunctionExpression :
   async function BndingIdentifier_opt ( FormalParameters ) { AsyncFunctionBody }
1. 返回false
**** 注意1 依赖于下层建筑的静态语法的规则，一般不查看函数的定义内部。
ClassTail : ClassHeritage_opt { ClassBody }
1. 如果symbol是ClassBody，返回true
2. 如果symbol是ClassHeritage，那么
    a. 如果ClassHeritage存在，返回true，否则返回false
3. 让inHeritage是ClassHeritage带symbol参数的Contains
4. 如果inHeritage是true，返回true
5. 返回ClassBody带symbol参数的ComputedPropertyContains
**** 注意2 依赖于下层建筑的静态语法的规则，除了为了找PropertyName，不查看
            class内容。
ArrowFunciton : ArrowParameters => ConciseBody
1. 如果symbol不是NewTarget、SuperProperty、SuperCall、supper或this，返回false
2. 如果ArrowParameters带symbol参数的Contains是true，返回true
3. 返回ConciseBody带symbol参数的Contains

ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList
1. 让formals是CoverParenthesizedExpressionAndArrowParameterList的CoveredFormalsList
2. 返回formals带symbol参数的Contains

AsyncArrowFunction : async AsyncArrowBindingIdentifier => AsyncConciseBody
1. 如果symbol不是NewTarget、SuperProperty、SuperCall、super或this，返回false
2. 返回AsyncConciseBody带symbol参数的Contains

AsyncArrowFunction : CoverCallExpressionAndAsyncArrowHead => AsyncConciseBody
1. 如果symbol不是NewTarget、SuperProperty、SuperCall、super或this，返回false
2. 让head是CoverCallExpressionAndAsyncArrowHead
3. 如果head带symbol参数的Contains是true，返回true
4. 返回AsyncConciseBody带symbol参数的Contains
**** 注意3 Contains用于在ArrowFunction和AsyncArrowFunction中检查new.target、
            this和super。
PropertyDefinition : MethodDefinition
1. 如果symbol是MethodDefinition，返回true
2. 返回MethodDefinition带symbol参数的ComputedPropertyContains

LiteralPropertyName : IdentifierName
1. 返回false

MemberExpression : MemberExpression . IdentifierName
1. 如果MemberExpression带symbol的Contains是true，返回true
2. 返回false

SuperProperty : super . IdentifierName
1. 如果symbol是保留字super，返回true
2. 返回false

CallExpression : CallExpression . IdentifierName
1. 如果CallExpression带symbol参数的Contains是true，返回true
2. 返回false

OptionalChain : ?. IdentifierName
1. 返回false

OptionalChain : OptionalChain . IdentifierName
1. 如果OptionalChain带symbol参数的Contains是true，返回true
2. 返回false
*** 8.4.2 静态语义：ComputedPropertyContains
带symbol参数
PropertyName : LiteralPropertyName
1. 返回false

PropertyName : ComputedPropertyName
1. 返回ComputedPropertyName带symbol参数的Contains

MethodDefinition : 
    PropertyName ( UniqueFormalParameters ) { FunctionBody }
    get PropertyName ( ) { FunctionBody }
    set PropertyName ( PropertySetParameterList ) { FuncitonBody }
1. 返回PropertyName带symbol参数的ComputedPropertyContains

GeneratorMethod : * PropertyName ( UniqueFormalParameters ) { GeneratorBody }
1. 返回PropertyName带symbol参数的ComputedPropertyContains

AsyncGeneratorMethod :
    async * PropertyName ( UniqueFormalParameters ) { AsyncGeneratorBody }
1. 返回PropertyName带symbol参数的ComputedPropertyContains

ClassElementList : ClassElementList ClassElement
1. 让inList是ClassElementList带symbol参数的ComputedPropertyContains
2. 如果inList是true，返回true
3. 返回ClassElement带symbol参数的ComputedPropertyContains

ClassElement : 
1. 返回false

AsyncMethod : async PropertyName ( UniqueFormalParameters ) { AsyncFunctionBody }
1. 返回PropertyName带symbol参数的ComputedPropertyContains
** 8.5 Miscellaneous杂七杂八（我觉得可以用其他来翻译）
  这些操作用于本规范的多处地方。
*** 8.5.1 运行时语义：InstantiateFunctionObject
带scope参数
FunctionDeclaration :
    function BindingIdentifier ( FormalParameters ) { FunctionBody }
    function ( FormalParameters ) { FunctionBody }
1. 返回FunctionDeclaration带scope参数的?InstantiateOrdinaryFunctionObject

GeneratorDeclaration :
    function BindingIdentifier ( FormalParameters ) { GeneratorBody }
    function ( FormalParameters ) { GeneratorBody }
1. 返回GeneratorDeclaration带scope参数的?InstantiateGeneratorFunctionObject

AsyncGeneratorDeclaration :
    async function *  BindingIdentifier ( FormalParameters ) { AsyncGeneratorBody }
    async function * ( FormalParameters ) { AsyncGeneratorBody }
1. 返回AsyncGeneratorDeclaration带scope参数的?InstantiateAsyncGeneratorFunctionObject

AsyncFunctionDeclaration :
    async function BindingIdentifier ( FormalParameters ) { AsyncFunctionBody }
    async function ( FormalParameters ) { AsyncFunctionBody }
1. 返回AsyncFunctionDeclaration带scope参数的?InstantiateAsyncFunctionObject
*** 8.5.2 运行时语义：BindingInitialization
带value和environment参数
**** 注意 给environment传递undefined表明PutValue操作应该被赋予初始化值。这种情况发生在
         var语句和非严格模式下函数的形式参数中（见于10.2.10）。在这些情况中文法绑定被提升
	 了，而且在评估其初始化前就已经提前初始化了。
BindingIdentifier : Identifier
1. 让name是Identifier的String值
2. 返回?InitializeBoundName(name, value , environment)

BindingIdentifier : yield
1. 返回?InitializeBoundName("yield", value, environment)

BindingIdentifier : await
1. 返回?InitializeBoundName("await", value, environment)

BindingPattern : ObjectBindingPattern
1. 执行?RequireObjectCoercible(value)
2. 返回ObjectBindingPattern带value和environment参数的BindingInitialization的结果

BindingPattern : ArrayBindingPattern
1. 让iteratorRecord是?GetIterator(value)
2. 让result是ArrayBindingPattern带iteratorRecord和environment参数的
   IteratorBindingInitialization
3. 如果iteratorRecord.\[\[Done]]是false，返回?IteratorClose(iteratorRecord, result)
4. 返回result。

ObjectBindingPattern : { }
1. 返回NormalCompletion(empty)

ObjectBindingPattern : 
    { BindingPropertyList }
    { BindingPropertyList , }
1. 执行BindingPropertyList带value和environment参数的?PropertyBindingInitialization
2. 返回NromalCompletion(empty)

ObjectBindingPattern : { BindingRestProperty }
1. 让excludeNames是新的空List
2. 返回BindingRestProperty带value、environment和excludedNames参数的
   RestBindingInitialization

ObjectBindingPattern : { BindingPropertyList , BindingRestProperty }
1. 让excludedNames是BindingPropertyList带value和environment参数的
   ?PropertyBindingInitialization
2. 返回BindingRestProperty带value、environment和excludedNames参数的
   RestBindingInitialization
**** 8.5.2.1 InitializeBoundName(name, value, environment)
  抽象操作InitializeBoundName接受参数name、value和environment。被调用时执行下列步骤：
1. Assert：Type(name)是String
2. 如果environment不是undefined，那么
    a. 执行environment.InitializeBinding(name, value)
    b. 返回NormalCompletion(undefined)
3. 否则
    a. 让lhs是ResolveBinding(name)
    b. 返回?PutValue(lhs, value)
*** 8.5.3 运行时语义：IteratorBindingInitialization
带参数iteratorRecord和environment
**** 注意 给environment传递undefined表明PutValue操作应该被赋予初始化值。这种情况发生在
         非严格模式下函数的形式参数中。在这情况形式参数法绑定被提升了，而且在评估其初始化前
	 就已经提前初始化了。
ArrayBindingPattern : [ ]
1. 返回NormalCompletion(empty)

ArrayBindingPattern : [ Elision ]
1. 返回Elsion带iteratorRecord参数的IteratorDestructuringAssignmentEvaluation

ArrayBindingPattern : [ Elision_opt BindingRestElement ]
1. 如果Elision存在，那么
    a. 执行Elision带iteratorRecord参数的?IteratorDestructuringAssignmentEvaluation
2. 返回BindingRestElement带iteratorRecord和Environment参数的
   IteratorBindingInitialization

ArrayBindingPattern : [ bindingElementList , elision ]
1. 执行BindingElementList带iteratorRecord和environment参数的
   ?IteratorBindingInitialization
2. 返回Elision带iteratorRecord参数的IteratorDestructuringAssignmentEvaluation

ArrayBindingPattern : [ BindingElementList , Elision_opt BindingRestElement ]
1. 执行BindingElementList带iteratorrecord和environment的
   ？IteratorBindingInitialization
2. 如果Elision存在，那么
    a. 执行Elision带iteratorRecord参数的?IteratorDestructuringAssignmentEvaluation
3. 返回BindingRestElement带iteratorRecord和environment参数的
   IteratorBindingInitialization

BindingElementList : BindingElementList , BindingElisionElement
1. 执行BindingElementList带iteratorRecord和environment参数的
   ?IteratorBindingInitialization
2. 返回BindingElisionElement带iteratorRecord和environment参数的
   IteratorBindingInitialization

BindingElisionElement : Elision BindingElement
1. 执行Elision带iteratorRecord参数的?IteratorDestructuringAssignmentEvaluation
2. 返回BindingElement带iteratorRecord和environment参数的IteratorBindingInitialization

SingleNameBinding : BindingIdentifier Initializer_opt
1. 让bindingId是BindingIdentifier的String值
2. 让lhs是?ResolveBinding(bindingId, environment)
3. 如果iteratorRecord.\[\[Done]]是false，那么
    a. 让next是IteratorStep(iteratorRecord)
    b. 如果next是意外完结，设置iteratorRecord.\[\[Done]]是true
    c. ReturnIfAbrupt(next)
    d. 如果next是false，设置iteratorRecord.\[\[Done]]是true
    e. 否则
        i. 让v是IteratorValue(next)
       ii. 如果v是意外完结，设置iteratorRecord.\[\[Done]]是true
      iii. ReturnIfAbrupt(v)
4. 如果iteratorRecord.\[\[Done]]是true，让v是undefined
5. 如果Initializer存在，而且v是undefined，那么
    a. 如果IsAnonymousFunctionDefinition(initializer)是true，那么
        i. 设置v是Initializer带bindingId参数的NamedEvaluation
    b. 否则
        i. 让defaultValue是Initializer的评估结果
       ii. 设置v是?GetValue(defaultValue)
6. 如果environment是undefined，返回?PutValue(lhs, v)
7. 返回InitializeReferenceBinding(lhs, v)

BindingElement : BindingPattern Initializer_opt
1. 如果iteratorRecord.\[\[Done]]是false，那么
    a. 让next是IteratorStep(iteratorRecord)
    b. 如果next是意外完结，设置iterator.\[\[Done]]是true
    c. ReturnIfAbrupt(next)
    d  如果next是false，设置iteratorRecord.\[\[Done]]是true
    e. 否则
        i. 让v是IteratorValue(next)
       ii. 如果v是意外完结，设置iteratorRecord.\[\[Done]]是true
      iii. ReturnIfAbrupt(v)
2. 如果iteratorRecord.\[\[Done]]是true，让v是undefined
3. 如果Initializer存在，而且v是undefined，那么
    a. 让defaultValue是评估Initializer的评估
    b. 设置v是?GetValue(defaultValue)
4. 返回BindigPattern带v和environment参数的BindingInitialization

BindingRestElement : ...BindingIdentifier
1. 让lhs是?ResolveBinding(BindingIdentifier的String值，environment)
2. 让A是!ArrayCreate(0)
3. 让n是0
4. Repeat
    a. 如果iteratorRecord.\[\[Done]]是false，那么
        i. 让next是IteratorStep(iteratorRecord)
       ii. 如果next是意外完结，设置iteratorRecord.\[\[Done]]是true
      iii. ReturnIfAbrupt(next)
       iv. 如果next是false，设置iteratorRecord.\[\[Done]]是true
    b. 如果iteratorRecord.\[\[Done]]是true，那么
        i. 如果environment是undefined，返回?PutValue(lhrs, A)
       ii. 返回InitializeReferencedBinding(lhr, A)
    c. 让nextValue是IteratorValue(next)
    d. 如果nextValue是意外完结，设置iteratorRecord.\[\[Done]]是true
    e. ReturnIfAbrupt(nextValue)
    f. 执行!CreateDataPropertyOrThrow(A, !ToString(F(n)), nextValue)
    g. 设置n是n+1

BindingRestElement : ...BindingPattern
1. 让A是!ArrayCreate(0)
2. 让n是0
3. Repeat
    a. 如果iteratorRecord.\[\[Done]]是false，那么
        i. 让next是IteratorStep(iteratorRecord)
       ii. 如果next是意外完结，设置iteratorRecord.\[\[Done]]是true
      iii. ReturnIfAbrupt(next)
       iv. 如果next是false，设置iteratorRecord.\[\[Done]]是true
    b. 如果iteratorRecord.\[\[Done]]是true，那么
        i. 如果environment是undefined，返回?PutValue(lhrs, A)
       ii. 返回InitializeReferencedBinding(lhr, A)
    c. 让nextValue是IteratorValue(next)
    d. 如果nextValue是意外完结，设置iteratorRecord.\[\[Done]]是true
    e. ReturnIfAbrupt(nextValue)
    f. 执行!CreateDataPropertyOrThrow(A, !ToString(F(n)), nextValue)
    g. 设置n是n+1

FromalParameters : [empty]
1. 返回NormalCompletion(empty)

FormalParameters : FormalParameterList , FunctionRestParameter
1. 执行FormalParameterList带iteratorRecord和environment参数的
   ?IteratorBindingInitialization
2. 返回FunctionRestParameter带iteratorRecord和environment参数的
   IteratorBindingInitialization

FormalParameterList : FormalParameterList , FormalParameter
1. 执行FormalParameterList带iteratorRecord和environment参数的
   ?IteratorBindingInitialization
2. 返回FormalParameter带iteratorRecord和environment参数的IteratorBindingInitialization

ArrowParameters : BindingIndetifier
1. Assert：iteratorRecord.\[\[Done]]是false
2. 让next是IteratorStep(iteratorRecord)
3. 如果next是意外完结，设置iteratorRecord.\[\[Done]]是true
4. ReturnIfAbrupt(next)
5. 如果next是false，设置iteratorRecord.\[\[Done]]是true
6. 否则
    a. 让v是IteratorValue(next)
    b. 如果v是意外完结，设置iteratorRecord.\[\[Done]]是true
    c. ReturnIfAbrupt(v)
7. 如果iteratorRecord.\[\[Done]是true，让v是undefined
8. 返回BindingIdentifier带v和environment参数的BindingInitialization

ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList
1. 让formals是CoverParenthesizedExpressionAndArrowParameterList的CoveredFormalsLst
2. 返回formals带iteratorRecord和environment参数的IteratorBindingInitialization

AsyncArrowBindingIdentifier : BindingIdentifier
1. Assert：iteratorRecord.\[\[Done]]是false
2. 让next是IteratorStep(iteratorRecord)
3. 如果next是意外完结，设置iteratorRecord.\[\[Done]]是true
4. ReturnIfAbrupt(next)
5. 如果next是false，设置iteratorRecord.\[\[Done]]是true
6. 否则
    a. 让v是IteratorValue(next)
    b. 如果v是意外完结，设置iteratorRecord.\[\[Done]]是true
    c. ReturnIfAbrupt(v)
7. 如果iteratorRecord.\[\[Done]]是true，让v是undefined
8. 返回BindingIdentifier带v和environment参数的Bindinginitialization
*** 8.5.4 静态语义：AssignmentTargetType
IdentifierReference : identifier
1. 如果IdentifierReference在严格模式里，而且Identifier的String值是"eval"或"arguments"，
   返回invalid
2. 返回 simple

IdentifierReference : 
    yield
    await
CallExpression : 
    CallExpression [ Expression ]
    CallExpression . IdentifierName
MemberExpression :
    MemberExpression [ Expression ]
    MemberExpression . IdentifierName
    SuperProperty
1. Return simple

PrimaryExpression :
    CoverParenthesizedExpressionAndArrowParameterList
1. 让expr是CoverParenthesizedExpressionAndArrowParameterList
2. 返回expr的AssignmentTargetType

PrimaryExpression : 
    this
    Literal
    ArrayLiteral
    ObjectLiteral
    FunctionExpression
    ClassExpression
    GeneratorExpression
    AsyncFunctionExpression
    AsyncGeneratorExpression
    RegularExpressionLiteral
    TempalteLiteral
CallExpression :
    CoverCallExpressionAndAsyncArrowHead
    SuperCall
    ImportCall
    CallExpression Arguments
    CallExpression TempalteLiteral
NewExpression :
    new NewExpression
MemberExpression :
    memberExpression TempalteLiteral
    new MemberExpression Arguments
NewTarget :
    new . target
ImportMeta :
    import . meta
LeftHandSideExpression :
    OptionalExpression
UpdateExpression :
    LeftHandSideExpression ++
    LeftHandSideExpression --
    ++ UnaryExpression
    -- UnaryExpression
UnaryExpression :
    delete UnaryExpression
    void UnaryExpression
    typeof UnaryExpression
    + UnaryExpression
    - UnaryExpression
    ~ UnaryExpression
    ! UnaryExpression
    AwaitExpression
ExponentiationExpression :
    UpdateExpression ** ExponentiationExpression
MultiplicativeExpression :
    MultiplicativeExpression MultiplicativeOperator ExponentiationExpression
AdditiveExpression :
    AdditiveExpression + MultiplicativeExpression
    AdditiveExpression - MultiplicativeExpression
ShiftExpression :
    ShiftExpression \<\< AdditiveExpression
    ShiftExpression \>\> AdditiveExpression
    ShiftExpression \>\>\> AdditiveExpression
RelationalExpression :
    RelationalExpression \< ShiftExpression
    RelationalExpression \> ShiftExpression
    RelationalExpression \<\= ShiftExpression
    RelationalExpression \>\= ShiftExpression
    RelationalExpression instanceof ShiftExpression
    RelationalExpression in ShiftExpression
EqualityExpression : 
    EqualityExpression \=\= RelationalExpression
    EqualityExpression \!\= RelationalExpression
    EqualityExpression \=\=\= RelationalExpression
    EqualityExpression \=\=\= RelationalExpression
BitwiseANDExpression :
    BitwiseANDExpression & EqualityExpression
BitwiseXORExpression :
    BitwiseXORExpression ^ BitwiseANDExpreesion
BitwiseOrExpression :
    BitwiseORExpression | BitwiseXORExpression
LogicalANDExpression :
    LogicalANDExpression && BitwiseORExpression
LogicalORExpression :
    LogicalORExpression || LogicalANDExpression
CoalesceExpression :
    CoalesceExpressionHead ?? BitwiseORExpression
ConditionalExpression :
    ShortCircuitExpression ? AssignmentExpression : AssignmentExpression
AssignmentExpression :
    YieldExpression
    ArrowFunction
    AsyncArrowFunction
    LeftHandSideExpression = AssignmentExpression
    LeftHandSideExpression AssignmentOperator AssignmentExpression
    LefthandSideExpression &&= AssignmentExpression
    LeftHandSizeExpression ||= AssignmentExpression
    LeftHandSideExpression ??= AssignmentExpression
Expression :
    Expression, assignmentExpression
1. 返回invalid
*** 8.5.5 静态语义：PropName
PropertyDefinition : IdnetifierReference
1. 返回IdentifierRefrence的String值。

PropertyDefinition : ... AssignmentExpression
1. 返回empty

PropertyDefinition : Propertyname : AssignmentExpression
1. 返回PropertyName的PropName

LiteralPropertyName : IdentifierName
1. 返回StringLiteral的String值

LiteralPropertyName : NumericLiteral
1. 让nbr是NumericLiteral的numericValue
2. 返回!ToString(nbr)

ComputedPropertyName : [ AssignmentExpression ]
1. 返回empty

MethodDefinition : 
    PropertyName ( UniqueFormalParameters ) { FunctionBody }
    get PropertyName ( ) { FunctionBody }
    set PropertyName ( PropertySetParameterList ) { FunctionBody }
1. 返回PopertyName的PropName

GeneratorMethod : * PropertyName ( UniqueFormalParameters ) { GeneratorBody }
1. 返回PopertyName的PropName

AsyncGenratorMethod : 
    async * PropertyName ( UniqueFormalParameters ) { AsyncGeneratorBody }
1. 返回PopertyName的PropName

ClassElment : ;
1. 返回empty

Asyncmethod : async PropertyNae ( UniqueFormalParameters ) { AsyncFunctionBody }
1. 返回PopertyName的PropName
* 9 可执行代码与执行背景（执行上下文 Execution Contexts）
** 9.1 环境记录 Environment Records
  EnvironmentRecord是用在基于ECMAScript代码的词法嵌套结构上定义Identifiers与指定
的变量、函数的联结关系的规范类型。通常EnvironmentRecord被联结到ECMAScript代码
的特定句法结构，比如：FunctionDeclaration、blockStatement或者TryStatement的Catch
语句。这些代码每次被评估时，新的EnvironmentRecord就被创建出来记录被代码创建
处理的identifier的绑定关系。
  每个EnvironmentRecord都有一个\[\[OterEnv]]字段，可能是null或者一个指向外层
EnvironmentRecord的引用。（内层）EnvironmentRecord的这个外层引用指向逻辑上包围了
这个内层EnvironmentRecord的EnvironmentRecord，当然，这个外层EnvironmentRecord还有
自己的外层EnvironmentRecord。一个环境记录服务多个内层环境记录。例如，一个
FunctionDeclaration包含了两个嵌套的FunctionDelaration，那么每个嵌套函数的
EnvironmentRecord都由这个外层函数的当前评估的EnvironmentRecord作为自己的外层
EnvironmentRecord。
  EnvironmentRecord是纯粹的规范机制，没有必要与ECMAScript实现中的任何活一致。
ECMAScript程序不可以直接访问或者修改环境记录值。
*** 9.1.1 环境记录类型的层次体系
  EnvironmentRecord可以被认为是一个简单的面向对象的层级结构，其中
EnvironmentRecord是一个抽象类，有三个实现的子类：declarative EnvironmentRecord, 
object EnvironmentRecord, global EnvironmentRecord。function EnvironmentRecord和 module
EnvironmentRecord是declarative EnvironmentRecord的子类。
. EnvironmentRcord(抽象的）
    。declarative EnvironmentRecord是用于定义ECMAScript语言中例如
      FunctionDeclaration，VariableDeclaration和Catch语句等直接联结标识符与
      ECMAScript语言值的句法元素的效果。
        . function EnvironmentRecord与ECMAScript函数对象的调用一致，且包含这个
          函数内的顶层声明的绑定。可能建立一个新的this绑定。为了支持super
          方法的调用，还会捕获必要的状态。
        . module EnvironmentRecord包含了Module内的顶层声明的绑定。也包含了被
          Module显式引入的绑定。其\[\[OuterEnv]]是global EnvironmentRecord。
    。object EnvironmentRecord用于定义例如WithStatement这种用于联结标识符与某些
      对象性质的ECMAScript元素的效果。
    。global EnvironmentRecord用于Script的全局声明。它没有外层环境，其
      \[\[OuterEnv]]是null。它可以预填充标识符绑定，而且包括一个联结的全局对象
      其性质提供了这个全局环境的某些标识符绑定。当ECMAScript代码被执行了，
      额外的性质有可能被增加到全局对象中，而且其初始性质也会被修改。
  EnvironmentRecord抽象类包含了定义在表17中的抽象规范方法。这些抽象方法在每个
具体子类里有确切的具体算法。
| 方法                         | 目的                                                                                                                                                                                                                                                |
| HasBinding(N)                | 明确EnvironmentRecord是否含有String值N的绑定。如果有返回true，否则返回false                                                                                                                                                                         |
| CreateMutableBinding(N, D)   | 在EnvironmentRecord中创建一个新的没有初始化的可修改绑定。String值N是绑定的名称。Boolean参数D是true的话，这个绑定可能会被随后删除。                                                                                                                  |
| CreateImmutableBinding(N, S) | 在EnvironmentRecord中创建一个新的没有初始化的可修改绑定。String值N是绑定的名称。如果S是true的话，那么在其初始化之后试图赋值时会投掷异常，不管这个操作的严格模式设置。                                                                               |
| InitializeBinding(N, V)      | 在EnvironmentRecord中设置一个已经存在但是没有初始化的绑定的值。String值N是绑定的名称。ECMAScript语言类型值V是这个绑定的值。                                                                                                                         |
| SetMutableBinding(N, V, S)   | 在EnvironmentRecord中设置一个已经存在的可修改绑定。String值N是绑定的名称。ECMAScript语言类型值V是这个绑定的值。S是Boolean值标记。如果S是true，这个绑定不会因设置值而投掷TypeError异常                                                               |
| GetBindingValue(N, S)        | 返回EnvironmentRecord中一个已经存在的绑定的值。String值N是绑定的名称。S用于标识引用源于严格模式或这其他要求严格模式的语义。如果S是true，且绑定不存在，会投掷ReferenceError异常。如果绑定存在，但是没有初始化，无论S何值，都会投掷ReferenceError异常 |
| DeleteBinding(N)             | 从EnvironmentRecord中删除一个绑定。String值N是绑定的名称。如果绑定#N存在，能移除这个绑定，就返回true；不能移除就返回false。如果绑定不存在，返回true                                                                                                  |
| HasThisBinding()             | 明确EnvironmentRecord建立了this绑定。如果建立了返回true，否则返回false。                                                                                                                                                                            |
| HasSuperBinding()            | 明确EnvironmentRecord建立了super方法绑定。如果建立了返回true，否则返回false。                                                                                                                                                                       |
| WithBaseObject()             | 如果EnvironmentRecord联结的with语句，返回这个with对象，否则返回undefined。                                                                                                                                                                                              |
**** 9.1.1.1 Declarative Environment Records 
  每个DelcarativeEnvironmentRecord联结一个ECMAScript程序圈，包含：variable、
constant、let、class、module、import及function声明。DeclarativeEnvironmentRecord
绑定了这个圈内被声明定义的整套标识符。
  DeclarativeEnvironmentRecords的具体规范方法的行为在下方算法中定义。
***** 9.1.1.1.1 HasBinding(N)
  DeclarativeEnvironmentRecord envRec的HasBinding方法接受参数N（String）。明确
参数标识是否已经绑定在记录中。被调用时执行下列步骤：
1. 如果envRec有标识的名字与N一致，返回true。
2. 返回false。
***** 9.1.1.1.2 CreateMutalbeBinding(N, D)
  DeclarativeEnvironmentRecord envRec的CreateMutableBinding方法接受参数N（String）和
D（Boolean）。创建一个可变的名字为N的未初始化绑定。这个EnvironmentRecord必须要
没有名称N的绑定。如果D是true，这个新的绑定标记为可删除的。被调用时执行
下列步骤：
1. Assert：envRec没有绑定#N
2. 在envRec上创建可变绑定#N，并且记为未初始化的。如果D是true，记录这个新建的
   绑定会被随后的DeleteBinding调用删除。
3. 返回NormalCompletion(empty)
***** 9.1.1.1.3 CreateImmutableBinding(N, s)
  DeclarativeEnvironmentRecord envRec的CreateImmutableBinding方法接受参数N（String）
和S（Boolean）。创建一个不变的名字为N的未初始化绑定。这个EnvironmentRecord必须
没有名称N的绑定。如果S是true，这个新的绑定被标记为严格绑定。被调用时执行
下列步骤：
1. Assert：envRec没有绑定#N
2. 在envRec上创建不变绑定#N，并且记为未初始化的。如果S是true，记录这个新建的
   绑定是严格绑定。
3. 返回NormalCompletion(empty)
***** 9.1.1.1.4 InitializeBinding(N, V)
  DeclarativeEnvironmentRecord envRec的InitializeBinding方法接受参数N（String）和
V（ECMAScript语言值）。用于将绑定#N的值替换为V。未初始化的绑定#N必须已经存在。
被调用时执行下列步骤：
1. Assert：envRec必须有未初始化的绑定#N
2. 设置envRec上绑定#N的值为V
2. 记录envRec上绑定#N已经初始化。
3. 返回NormalCompletion(empty)
***** 9.1.1.1.5 SetMutableBinding(N, V, S)
  DeclarativeEnvironmentRecord envRec的SetMutableBinding方法接受参数N（String）、
V（ECMAScript语言值）和S（Boolean）。尝试将绑定#N的当前值替换为参数V的值。
绑定#N通常已经存在，但在罕见的情况下也可能没有。如果绑定#N是不变绑定，且
S是true，会投掷一个TypeError异常。被调用时执行下列步骤：
1. 如果envRec没有绑定#N，那么
    a. 如果S是true，投掷一个ReferenceError异常
    b. 执行envRec.CreateMutableBinding(N, true)
    c. 执行envRec.InitializeBinding(N, V)
    d. 返回 NormalCompletion(empty)
2. 如果envRec的绑定#N是严格绑定，设置S是true。
3. 如果envRec的绑定#N还没有初始化，投掷ReferenceError异常
4. 如果envRec的绑定#N是可变绑定，修改其值为V
5. 否则
    a. Assert：此时试图修改一个不变绑定的值
    b. 如果S是true，投掷TypeError异常
6. 返回NormalCompletion(empty)
****** 注意 会因为缺失绑定触发步骤1的ECMAScript代码：
             function f() { eval("var x; x = (delete x, 0);"); }
***** 9.1.1.1.6 GetBindingValue(N, S)
  DeclarativeEnvironmentRecord envRec的GetBindingValue方法接受参数N（String）和
S（Boolean）。返回envRec上绑定#N的值。如果绑定存在但是没有初始化，会投掷
ReferenceError异常，无论S的值。被调用时执行下列步骤：
1. Assert：envRec有绑定#N
2. 如果envRec的绑定#N没有初始化，投掷ReferenceError异常
3. 返回envRec的绑定#N的值。
***** 9.1.1.1.7 DeleteBinding(N)
  DeclarativeEnvironmentRecord envRec的DeleteBinding方法接受参数N（String）。只能删除
已经明确指定为可删除的绑定。被调用时执行下列步骤：
1. Assert：envRec有绑定#N
2. 如果envRec的绑定#N不可删除，返回false
3. 从envRec上移除绑定#N
4. 返回true
***** 9.1.1.1.8 HasThisBinding()
  DeclarativeEnvironmentRecord envRec的HasThisBinding方法不接受参数。被调用时执行
下列步骤：
1. 返回false。
****** 注意 一个合规的DeclarativeEnvironmentRecord（既不是FuncitonEnvironmentRecord
             也不是ModuleEnvironmentRecord）不会提供this的绑定
***** 9.1.1.1.9 HasSuperBinding()
  DeclarativeEnvironmentRecord envRec的HasSuperBinding方法不接受参数。被调用时执行
下列步骤：
1. 返回false。
****** 注意 一个合规的DeclarativeEnvironmentRecord（既不是FuncitonEnvironmentRecord
             也不是ModuleEnvironmentRecord）不会提供super的绑定
***** 9.1.1.1.10 WithBaseObject()
  DeclarativeEnvironmentRecord envRec的WithBaseObject方法不接受参数。被调用时执行
下列步骤：
1. 返回undefined。
**** 9.1.1.2 Object Environment Records
  每个ObjectEnvironmentRecord被联结到对象，这个对象称为绑定对象。一个
ObjectEnvironmentRecord绑定标识名称的集合，名称对应绑定绑定对象的性质名。性质
键不是字符串形式的标识名不包含在绑定标识中。自有的和继承的性质都包含这个
集合中无论其\[\[Enumrable]]属性是否。因为性质可以动态的在对象上添加和删除，
被ObjectEnvironmentRecord绑定的标识集合会潜在的变动，作为性质增加或删除的副
作用。任何因为这种负作用创建的绑定被认为是可修改的绑定，即使其
\[\[Writable]]属性是fasle。不变绑定不存在于ObjectEnvironmentRecord中。
  为with语句创建的ObjectEnvironmentRecord在函数调用中提供绑定对象作为隐式的
this值。这个能力受联结在ObjectEnvironmentRecord上的Boolean值withEnvrionment的控
制。其默认值是false。
  ObjectEnvironmentRecords的具体规范方法的行为在下方算法中定义。  
***** 9.1.1.2.1 HasBinding(N)
  ObjectEnvironmentRecord envRec的HasBinding方法接受参数N（String）。明确
参数标识是否已经绑定在记录中。被调用时执行下列步骤：
1. 让bindings是envRec的绑定对象
2. 让foundBinding是?HasProperty(bindings,N)
3. 如果foundBinding是false，返回false
4. 如果envRec.withEnvironment是false，返回true
5. 让unscopables是?Get(bindings, @@unscopables)
6. 如果Type(unscopables)是Object，那么
    a. 让blocked是!ToBoolean(?Get(unscopables, N))
    b. 如果blocked是true，返回true
7. 返回true
***** 9.1.1.2.2 CreateMutalbeBinding(N, D)
  ObjectEnvironmentRecord envRec的CreateMutableBinding方法接受参数N（String）和
D（Boolean）。在联结的绑定对象中创建一个名字为N，值为undefined的性质。如果
D是true，这个新性质的\[\[Configurable]]设为true，否则设为false。被调用时执行
下列步骤：
1. 让bindings是envRec的绑定对象
2. 返回?DefinePropertyOrThrow(bindings, N, PropertyDescriptor { \[\[Value]]:undefined,
   \[\[Wriable]]:true, \[\[Enumerable]]:true, \[\[Configurable]]:D }
****** 注意 通常envRec没有N绑定，但是如果有的话，DefinePropertyOrThrow的语义
             会导致已存在的绑定被替换、遮蔽，或者引发返回意外完结
***** 9.1.1.2.3 CreateImmutableBinding(N, S)
  ObjectEnvironmentRecord envRec的CreateImmutableBinding按照本规范不会被使用。
***** 9.1.1.2.4 InitializeBinding(N, V)
  ObjectEnvironmentRecord envRec的InitializeBinding方法接受参数N（String）和
V（ECMAScript语言值）。用于将绑定#N的值替换为V。未初始化的绑定#N必须已经存在。
被调用时执行下列步骤：
1. 返回?envRec.SetMutableBinding(N, V, false)
****** 注意 在本规范中，使用ObjectEnvironmentRecord的CreateMutableBinding时都会
             立即跟随InitializeBinding操作。因此本规范不用显式的追踪
             ObjectEnvironmentRecord上绑定的初始化状态。
***** 9.1.1.2.5 SetMutableBinding(N, V, S)
  ObjectEnvironmentRecord envRec的SetMutableBinding方法接受参数N（String）、
V（ECMAScript语言值）和S（Boolean）。尝试将EnvironmentRecord的绑定对象的性质N
的当前值替换为参数V的值。性质N通常已经存在，但是如果没有或者目前不可写，
由S决定错误如何处理。被调用时执行下列步骤：
1. 让bindings是envRec的绑定对象
2. 让stillExists时?hasProperty(bindings, N)
3. 如果stillExists是false且S是true，投掷ReferenceError异常
4. 返回?Set(bindings, N, V, S)
***** 9.1.1.2.6 GetBindingValue(N, S)
  ObjectEnvironmentRecord envRec的GetBindingValue方法接受参数N（String）和
S（Boolean）。返回绑定对象性质N的值。性质应该已经存在，如果没有，则结果依赖
S。被调用时执行下列步骤：
1. 让bindings是envRec的绑定对象
2. 让value是?HasProperty(bindings, N)
3. 如果value是false，那么
    a. 如果S是false，返回undefined，否则投掷ReferenceError异常
5. 返回?Get(bindings, N)
***** 9.1.1.2.7 DeleteBinding(N)
  ObjectEnvironmentRecord envRec的DeleteBinding方法接受参数N（String）。只能删除
绑定对象的性质N的\[\[Configurable]]是true的绑定。被调用时执行下列步骤：
1. 让bindings是envRec的绑定对象
2. 返回?bindings.\[\[Delete]](N)
***** 9.1.1.2.8 HasThisBinding()
  ObjectEnvironmentRecord envRec的HasThisBinding方法不接受参数。被调用时执行
下列步骤：
1. 返回false。
****** 注意 ObjectEnvironmentRecord不会提供this的绑定
***** 9.1.1.2.9 HasSuperBinding()
  ObjectEnvironmentRecord envRec的HasSuperBinding方法不接受参数。被调用时执行
下列步骤：
1. 返回false。
****** 注意 ObjectEnvironmentRecord不会提供super的绑定
***** 9.1.1.2.10 WithBaseObject()
  ObjectEnvironmentRecord envRec的WithBaseObject方法不接受参数。被调用时执行
下列步骤：
1. 如果envRec的withEnvironment标记是true，返回envRec的绑定对象
2. 否则，返回undefined。
**** 9.1.1.3 FunctionEnvironmentRecord
  FunctionEnvironmentRecord是一个DeclarativeEnvironmentRecord，用于标识一个函数的
顶层圈。如果函数不是ArrowFunction，提供一个this绑定。如果不是ArrowFunction，
而且引用了super，其FunctionEnvironmentRecord应该包含能够在函数内执行super方法
调用的状态。
  FunctionEnvironmentRecords有表18列出的额外状态字段。
| 字段名                  | 值                                            | 含义                                                       |
| \[\[ThisValue]]         | 任何值                                        | 这是函数调用时的this值                                     |
| \[\[ThisBindingStatus]] | lexical \vert initialized \vert uninitialized | 如果是lexical，这就是一个ArrowFunction，不需要本地的this值 |
| \[\[FunctionObject]]    | Object                                        | 因其调用导致本EnvironmentRecord创建的函数对象              |
| \[\[NewTarget]]         | Object \vert undefined                        | 如果本EnvironmentRecord被\[\[Construct]]内部方法创建的，则\[\[NewTarget]]是\[\[Construct]]的newTarget参数值。否则就是undefined。 |
  FunctionEnvironmentRecord支持DeclarativeEnvironmentRecord在表17列出的全部方法。
除了HasThisBinding和HasSuperBinding，其算法也与DeclarativeEnvironmentRecord的一致。
FunctionEnvironmentRecord还额外支持列在表19的方法。
| 方法             | 目的                                                                                                               |
| BindThisValue(V) | 设置\[\[ThisValue]]并记录为已经初始化的                                                                            |
| GetThisBinding() | 返回本EnvironmentRecords的this绑定。如果this绑定没有初始化，投掷ReferenceError异常                                 |
| GetSuperBase()   | 返回本EnvironmentRecord绑定作为super性质访问的基础的这个对象。如果是undefined，表明super性质访问会产生运行时错误。 |
  FunctionEnvironmentRecord的具体规范方法的行为定义如下列算法
***** 9.1.1.3.1 BindThisValue(V)
  FunctionEnvironmentRecord envRec的BindThisValue方法接受参数V（ECMAScript语言值）。
被调用时执行下列步骤：
1. Assert：envRec.\[\[ThisBindingStatus]]不是lexical
2. 如果envRec.\[\[ThisBindingStatus]]是initialized，投掷ReferenceError异常
3. 设置envRec.\[\[ThisValue]]为V
4. 设置envRec.\[\[ThisBindingStatus]]为initialized
5. 返回V
***** 9.1.1.3.2 HasThisBinding()
  FunctionEnvironmentRecord envRec的HasThisBinding方法不接受参数。被调用时执行
下列步骤：
1. 如果envRec.\[\[ThisBindingStatus]]是lexical，返回false；否则返回true
***** 9.1.1.3.3 HasSuperBinding()
  FunctionEnvironmentRecord envRec的HasSuperBinding方法不接受参数。被调用时执行
下列步骤：
1. 如果envRec.\[\[ThisBindingStatus]]是lexical，返回false
2. 如果envRec.\[\[FunctionObject]].\[\[HomeObject]]是undefined，返回false；
   否则返回true。
***** 9.1.1.3.4 GetThisBinding()
  FunctionEnvironmentRecord envRec的GetThisBinding方法不接受参数。被调用时执行
下列步骤：
1. Assert：envRec.\[\[ThisBindingStatus]]不是lexical
2. 如果envRec.\[\[ThisBindingStatus]]是uninitialized，投掷ReferenceError异常
3. 返回envRec.\[\[ThisValue]]
***** 9.1.1.3.5 GetSuperBase()
  FunctionEnvironmentRecord envRec的GetSuperBase方法不接受参数。被调用时执行
下列步骤：
1. 让home是envRec.\[\[FunctionObject]].\[\[HomeObject]]
2. 如果home是undefined，返回undefined
3. Assert：Type(home)是Object
4. 返回?home.\[\[GetPrototypeOf]]()
**** 9.1.1.4 Global Environment Record
  GlobalEnvironmentRecord用于表示最外层的被运行在普通领的ECMAScript的Script元素
共用的圈。GlobalEnvironmentRecord提供了内建global（条款19）的绑定，全局对象的
性质，和在Script中发生的顶层声明（见于8.1.9、8.1.11）
  GlobalEnvironmentRecord是逻辑上的单一记录，但是规定为ObjectEnvironmentRecord和
DeclarativeEnvironmentRecord的组合封装。ObjectEnvironmentRecord将联结的RealmRecord
的全局对象作为其基础的对象。这个全局对象是GlobalEnvironmentRecord的
GetThisBinding方法的返回值。GlobalEnvironmentRecord的ObjectEnvironmentRecord组件包
含所有内建global（条款19）的绑定和全局代码的FunctionDeclaration、
GeneratorDeclaration、AsyncFunctionDeclaration、AsyncGeneratorDeclaration或者
VariableStatement引入的绑定。至于全局代码的其他ECMAScript声明产生的绑定包含在
GlobalEnvironmentRecord的DeclarativeEnvironmentRecord组件里。
  可以直接在全局对象上创建性质。因此GlobalEnvironmentRecord的
ObjectEnvironmentRecord组件会包含被FunctionDeclaration、GeneratorDeclaration、
AsyncFunctionDeclaration、AsyncGeneratorDeclaration或者VariableDeclaration声明显式
创建的绑定和全局对象性质隐式创建的绑定。为了区分哪些是声明显式创建的绑
定，GlobalEnvironmentRecord维护了一个由使用CreateGlobalVarBinding和
CreateGlobalFunctionBinding方法绑定的名称构成的List。
  GlobalEnvironmentRecord还有列在表20的添加字段和列在表21的添加方法。
| 字段名                  | 值                           | 含义                                                                                                                                                                      |
| \[\[ObjectRecord]]      | ObjectEnvironmentRecord      | 其绑定对象是全局对象。包含联结领上的全局代码的FunctionDeclaration、GeneratorDeclaration、AsyncFunctionDeclaration、AsyncGeneratorDeclaration及VariableDeclaration产生的绑定 |
| \[\[GlobalThisValue]]   | Object                       | 由全局圈的this返回的值。主机可能返回任何ECMAScript对象值。                                                                                                                |
| \[\[DeclarativeRecord]] | DeclarativeEnvironmentRecord | 包含联结领上的全局代码的除FunctionDeclaration、GeneratorDeclaration、AsyncFunctionDeclaration、AsyncGeneratorDeclaration及BariableDeclaration外的声明产生的绑定 |
| \[\[VarNames]]          | List<String>                 | 联结领上的全局代码的FunctionDeclaration、GeneratorDeclaration、AsyncFunctionDeclaration、AsyncGeneratorDeclaration及VariableDeclaration产生的绑定的名称List |

| 方法                                 | 意图                                                                                                                                                                                                                                                                                                     |
| GetThisBinding()                     | 返回本EnvironmentRecord的this绑定                                                                                                                                                                                                                                                                        |
| HasVarDeclaration(N)                 | 明确本EnvironmentRecord的绑定#N是否由VariableDeclaration,FunctionDeclaration,GeneratorDeclaration,AsyncFunctionDeclaration,AsyncGeneratorDeclaration产生的。                                                                                                                                              |
| HasLexicalDeclaration(N)             | 明确本EnvironmentRecord的绑定#N是否由LexicalDeclaration或者ClassDeclaration产生的。                                                                                                                                                                                                                       |
| HasRestrictedGlobalProperty(N)       | 明确全局对象上的性质N能否被全局文法绑定遮蔽                                                                                                                                                                                                                                                              |
| CanDeclareGlobalVar(N)               | 明确相应的CreateGlobalVarBinding带参数N的调用能否成功                                                                                                                                                                                                                                                    |
| CanDeclareGlobalFunction(N)          | 明确相应的CreateGlobalFunctionBinding带参数N的调用能否成功                                                                                                                                                                                                                                               |
| CreteGlobalVarBinding(N, D)          | 用于在GlobalEnvironmentRecord的\[\[ObjectRecord]]组件上创建并初始化为undefined的全局var绑定。这是个可变绑定。相应的全局对象的性质有对var合适的属性。String值N是绑定的名称。如果D是true，这个绑定可以被删除。逻辑上与CreateMutableBinding紧接着SetMutableBinding的效果一样，但是它允许特殊对待var声明。   |
| CreateGlobalFunctionBinding(N, V, D) | 用于在GlobalEnvironmentRecord的\[\[ObjectRecord]]组件上创建并初始化一个全局function。这是个可变绑定。相应的全局对象的性质有对function合适的属性。String值N是绑定的名称。如果D是true，这个绑定可以被删除。逻辑上与CreateMutableBinding紧接着SetMutableBinding的效果一样，但是它允许特殊对待function声明。 |
  GlobalEnvironmentRecord的具体规范方法的行为由下列算法定义。
***** 9.1.1.4.1 HasBinding(N)
  GlobalEnvironmentRecord envRec的HasBinding方法接受参数N（String值）。明确本记
录是否有绑定的名称与参数值一致。被调用时执行下列步骤：
1. 让DclRec是envRec.\[\[DeclarativeRecord]]
2. 如果DclRec.HasBinding(N)是true，返回true
3. 让ObjRec是envRec.\[\[ObjectRecord]]
4. 返回?ObjRec.HasBinding(N)
***** 9.1.1.4.2 CreateMutableBinding(N, D)
  GlobalEnvironmentRecord envRec的CreateMutableBinding方法接受参数N（String值）和
D（Boolean）。创建一个新的名字为N的未初始化的可变绑定。创建在联结的
DeclarativeRecord中。执行前绑定#N不应存在于本DeclarativeRecord。如果D是true，
这个新的绑定可以被删除。被调用时执行下列步骤：
1. 让DclRec是envRec.\[\[DeclarativeRecord]]
2. 如果DclRec.HasBinding(N)是true，投掷TypeError异常
3. 返回DclRec.CreateMutableBinding(N, D)
***** 9.1.1.4.3 CreateImmutableBinding(N, S)
  GlobalEnvironmentRecord envRec的CreateImmutableBinding方法接受参数N（String值）和
S（Boolean值）。创建一个新的名字为N的未初始化的不变绑定。绑定#N不能已经存在
于本EnvironmentRecord中。如果S是true，这个新绑定是严格绑定。被调用时执行下列
步骤：
1. 让DclRec是envRec.\[\[DeclarativeRecord]]
2. 如果DclRec.HasBinding(N)是true，投掷TypeError异常
3. 返回DclRec.CreateImmutableBinding(N, S)
***** 9.1.1.4.4 InitializeBinding(N, V)
  GlobalEnvironmentRecord envRec的InitializeBinding方法接受参数N（String值）和V（
ECMAScript语言值）。将绑定#N的当前值为V。未初始化绑定#N必须已经存在。被调用
时执行下列步骤：
1. 让DclRec是envRec.\[\[DeclarativeRecord]]
2. 如果DclRec.HasBinding(N)是true，那么
    a. 返回DclRec.InitializeBinding(N, V)
3. Assert：若绑定#N存在，必在ObjectEnvironmentRecord中。
4. 让ObjRec是envRec.\[\[ObjectRecord]]
5. 返回?ObjRec.InitializeBinding(N, V)
***** 9.1.1.4.5 SetMutableBinding(N, V, S)
  GlobalEnvironmentRecord envRec的SetMutableBinding方法接受参数N（String值）、V（
ECMAScript语言值）和S（Boolean）。试图修改将绑定#N的当前值修改为V。如果是不变
绑定，当S是true时投掷TypeError。一般性质N已经存在，但是如果不存在或者当前不
可写，由S决定错误处理方式。被调用时执行下列步骤：
1. 让DclRec是envRec.\[\[DeclarativeRecord]]
2. 如果DclRec.HasBinding(N)是true，那么
    a. 返回DclRec.SetMutableBinding(N, V, S)
3. 让ObjRec是envRec.\[\[ObjectRecord]]
4. 返回?ObjRec.SetMutableBinding(N, V, S)
***** 9.1.1.4.6 GeBindingValue(N, S)
  GlobalEnvironmentRecord envRec的GetBindingValue方法接受参数N（String值）和S（
Boolean）。返回绑定#N。如果绑定#N没有初始化，投掷ReferenceError异常。一般
性质N已经存在，但是如果不存在或者当前不可写，由S决定错误处理方式。被调用
时执行下列步骤：
1. 让DclRec是envRec.\[\[DeclarativeRecord]]
2. 如果DclRec.HasBinding(N)是true，那么
    a. 返回DclRec.GetBindingValue(N, S)
3. 让ObjRec是envRec.\[\[ObjectRecord]]
4. 返回?ObjRec.GetBindingValue(N, S)
***** 9.1.1.4.7 DeleteBinding(N)
  GlobalEnvironmentRecord envRec的DeleteBinding方法接受参数N（String值）。只能删除
已经明确可删除的的绑定。被调用时执行下列步骤：
1. 让DclRec是envRec.\[\[DeclarativeRecord]]
2. 如果DclRec.HasBinding(N)是true，那么
    a. 返回DclRec.DeleteBinding(N)
3. 让ObjRec是envRec.\[\[ObjectRecord]]
4. 让globalObject是ObjRec的绑定对象
5. 让existingProp是?HasOwnProperty(globalObject, N)
6. 如果existingProp是true，那么
    a. 让status是?ObjRec.DeleteBinding(N)
    b. 如果status是true，那么
        i. 让varNames是envRec.\[\[VarNames]]
       ii. 如果N是varNames的元素，从varNames中移除N
    c. 返回status
7. 返回true
***** 9.1.1.4.8 HasThisBinding()
  GlobalEnvironmentRecord envRec的HasThisBinding方法不接受参数。被调用时执行下
列步骤：
1. 返回true。
****** GlobalEnvironmentRecord总是提供this绑定。
***** 9.1.1.4.9 HasSuperBinding()
  GlobalEnvironmentRecord envRec的HasSuperBinding方法不接受参数。被调用时执行
下列步骤：
1. 返回false。
****** GlobalEnvironmentRecord不提供super绑定。
***** 9.1.1.4.10 WithBaseObject()
  GlobalEnvironmentRecord envRec的WithBaseObject方法不接受参数。被调用时执行
下列步骤：
1. 返回undefined
***** 9.1.1.4.11 GetThisBinding()
  GlobalEnvironmentRecord envRec的GetThisBinding方法不接受参数。被调用时执行下
列步骤：
1. 返回envRec.\[\[GlobalThisValue]]
***** 9.1.1.4.12 HasVarDeclaration(N)
  GlobalEnvironmentRecord envRec的HasVarDeclaration方法接受参数N（String值）。明确
本记录中是否有绑定#N是由VariableStatement或者FunctionDeclaration创建的。被调用
时执行下列步骤：
1. 让varDeclaredNames是envRec.\[\[VarNames]]
2. 如果varDeclaredNames包含N，返回true
3. 返回false
***** 9.1.1.4.13 HasLexicalDeclaration(N)
  GlobalEnvironmentRecord envRec的HasLexicalDeclaration方法接受参数N（String值）。
明确本记录中是否有绑定#N是由类似LexicalDeclaration或者ClassDeclaration等词法
声明创建的。被调用时执行下列步骤：
1. 让DclRec是envRec.\[\[DeclarativeRecord]]
2. 返回DclRec.HasBinding(N)
***** 9.1.1.4.14 HasRestrictedGlobalProperty(N)
  GlobalEnvironmentRecord envRec的HasRestrictedGlobalProperty方法接受参数N（String
值）。明确全局对象的性质N没有被全局词法绑定遮蔽。被调用时执行下列步骤：
1. 让ObjRec是envRec.\[\[ObjectRecord]]
2. 让globalObject是ObjRec的绑定对象。
3. 让existingProp是?globalObject.\[\[GetOwnProperty]](N)
4. 如果existingProp是undefined，返回false
5. 如果existingProp.\[\[Configurable]]是true，返回false
6. 返回true
***** 9.1.1.4.15 CanDeclareGlobalVar(N)
  GlobalEnvironmentRecord envRec的CanDeclareGlobalVar方法接受参数N（String值）。
明确相应的CreateGlobalVarBinding(N)能否成功。多余的var声明和先存在的全局对象
性质的var声明都是允许的。被调用时执行下列步骤：
1. 让ObjRec是envRec.\[\[ObjectRecord]]
2. 让globalObject是ObjRec的绑定对象
3. 让hasProperty是?HasOwnProperty(globalObject, N)
4. 如果hasProperty是true，返回true
5. 返回?IsExtensible(globalObject)
***** 9.1.1.4.16 CanDeclareGlobalFunction(N)
  GlobalEnvironmentRecord envRec的CanDeclareGlobalFunction方法接受参数N（String
值）。明确相应的CreateGlobalFunctionBinding(N)能否成功。被调用时执行下列步骤：
1. 让ObjRec是envRec.\[\[ObjectRecord]]
2. 让globalObject是ObjRec的绑定对象
3. 让existingProp是?globalObject.\[\[GetOwnProperty]](N)
4. 如果existingProp是undefined，返回?IsExtensible(globalObject)
5. 如果existingProp.\[\[Configurable]]是true，返回true
6. 如果IsDataDescriptor(existingProp)是true而且existingProp.\[\[Writable]]是true
   existingProp.\[\[Enumerable]]也是true，返回true
7. 返回false
***** 9.1.1.4.17 CreateGlobalVarBinding(N, D)
  GlobalEnvironmentRecord envRec的CreateGlobalVarBinding方法接受参数N（String值）
和D（Boolean）。在联结的ObjectEnvironmentRecord上创建并初始化一个可变绑定#N，
并且绑定名称记录到联结的\[\[VarNames]] List中。如果已经存在绑定#N，会被复用
并且试图初始化。被调用时执行下列步骤：
1. 让ObjRec是envRec.\[\[ObjectRecord]]
2. 让globalObject是ObjRec的绑定对象
3. 让hasProperty是?HsOwnProperty(globalObject, N)
4. 让extensible是?IsExtensible(globalObject)
5. 如果hasProperty是false而且extensible是true，那么
    a. 执行?ObjRec.CreateMutableBinding(N, D)
    b. 执行?ObjRec.InitializeBinding(N, undefined)
6. 让varDeclaredNames是envRec.\[\[VarNames]]
7. 如果varDeclaredNames不含有N，那么
    a. 附加N到varDeclaredNames
8. 返回NormalCompletion(empty)
***** 9.1.1.4.18 CreateGlobalFunctionBinding(N, V, D)
  GlobalEnvironmentRecord envRec的CreateGlobalFunctionBinding方法接受参数N（String
值）、V（ECMAScript语言值）和D（Boolean值）。在联结的ObjectEnvironmentRecord上
创建并初始化一个可变绑定N，并将绑定名称记录到联结的\[\[VarNames]] List中。
如果绑定已经存在，会被替换。被调用时执行下列步骤：
1. 让ObjRec是envRec.\[\[ObjectRecord]]
2. 让globalObject是ObjRec的绑定对象
3. 让existingProp是?globalObject.\[\[GetOwnProperty]](N)
4. 如果existingProp是undefined或者existingProp.\[\[Configurable]]是true，那么
    a. 让desc是PropertyDescriptor { \[\[Value]]:V, \[\[Writable]]:true,
       \[\[Enumerable]]: true, \[\[Configurable]]:D }
5. 否则
    a. 让desc是PropertyDescriptor { \[\[Value]]:V }
6. 执行?DefinePropertyOrThrow(globalObject, N, desc)
7. 执行?Set(globalObject, N, V, false)
8. 让varDeclaredNames是envRec.\[\[VarNames]]
9. 如果varDeclaredNames不含有N，那么
    a. 附加N到varDeclaredNames
10. 返回NormalCompletion(empty)
****** 注意 全局的函数声明总是表示为全局对象的自有性质。如果可以，已存在
             性质被重设为一套标准属性。步骤7于调用InitializeBinding具体方法
             等价，而且如果globalObject是一个Proxy，会产生Proxy捕获器调用的相
             同序列。
**** 9.1.1.5 Module Environment Record
  ModuleEnvironmentRecord是一个DeclarativeEnvironmentRecord，用于描述ECMAScript的
Module值的外层圈。在普通的可变绑定和不变绑定外，ModuleEnvironmentRecord还提供
了不变引入绑定，用于间接访问存在于其他EnvironmentRecord的绑定。
  ModuleEnvironmentRecord提供列在表17中的DeclarativeEnvironmentRecord的所有方法，
还共用除了GetBindingValue、DeleteBinding、HasThisBinding和GetThisBinding外的算法。
而且ModuleEnvironmentRecord提供了列在表22中的方法。
| 方法                          | 目的                                                                                                     |
| CreateImportBinding(N, M, N2) | 在ModuleEnvironmentRecord创建不变间接绑定#N。M是一个ModuleRecord，N2是在M的ModuleEnvironmentRecord的绑定 |
| GetThisBinding()              | 返回本EnvironmentRecord的this绑定。                                                                             |
  ModuleEnvironmentRecord上额外的具体方法的行为在下方的算法中定义。
***** 9.1.1.5.1 GetBindingValue(N, S)
  ModuleEnvironementRecord envRec的GetBindingValue方法接受参数N（String值）和S（
Boolean值）。返回绑定#N的值。然而如果绑定#N是间接绑定，返回目标绑定的值。
如果绑定#N存在，但是没有初始化，投掷ReferenceError。被调用时执行下列步骤：
1. Assert：S是true
2. Assert：envRec有绑定#N
3. 如果绑定#N是间接绑定，那么
    a. 让M和N2是创建绑定#N时的间接值
    b. 让targetEnv时M.\[\[Environment]]
    c. 如果targetEnv是undefined，投掷ReferenceError异常
    d. 返回?targetEnv.GetBindingValue(N2, true)
4. 如果envRec的绑定#N没有初始化，投掷ReferenceError异常
5. 返回envRec的绑定#N
****** 注意 S总是true，因为Module总是严格模式代码。
***** 9.1.1.5.2 DeleteBinding(N)
  ModuleEnvironementRecord envRec的DeleteBinding方法永不会被用到。
****** 注意 ModuleEnvironmentRecord只用在严格模式，而且早期错误规则阻止了严格
             代码提供给ReferenceRecord会解释到ModuleEnvironmentRecord上某绑定的
             删除操作。
***** 9.1.1.5.3 HasThisBinding()
  ModuleEnvironementRecord envRec的HasThisBinding方法不接受参数。被调用时执行下
列步骤：
1. 返回true
****** 注意 ModuleEnvironmentRcord总是提同this绑定。
***** 9.1.1.5.4 GetThisBinding()
  ModuleEnvironementRecord envRec的GetThisBinding方法不接受参数。被调用时执行下
列步骤：
1. 返回undefined
***** 9.1.1.5.5 CreateImportBinding(N, M, N2)
  ModuleEnvironementRecord envRec的CreateImportBinding方法接受参数N（String值）、
M（ModuleRecord）和N2（String值）。创建一个新的初始化的不变间接绑定#N。绑定#N
不能已经存在于EnvironmentRecord中。N2是M的ModuleEnvironmentRecord的绑定的名称。
访问这个新的绑定会间接访问目标绑定的值。被调用时执行下列步骤：
1. Assert：envRec没有绑定#N
2. Assert：M是ModuleRecord
3. Assert：当M.\[\[Environment]]是已初始化的，它有间接绑定#N2
4. 在envRec创建间接绑定#N，引用M和N2作为其目标绑定，而且记录这个绑定已经
   初始化
5. 返回NormalCompletion(empty)
*** 9.1.2 Environment Record操作
  下列的抽象操作被用在本规范操作EnvironmentRecord。
**** 9.1.2.1 GetIdentifierReference(env, name, strict)
  抽象操作GetIdentifierReference接受参数env（EnvironmentRecord值或null）、name（
String值）和strict（Boolean值）。被调用时执行下列步骤：
1. 如果env是null，那么
    a. 返回ReferenceRecord { \[\[Base]]:unresolvable, \[\[ReferenceName]]:name,
       \[\[Strict]]:strict, \[\[ThisValue]]:empty]] }
2. 让exists是?env.HasBinding(name)
3. 如果exists是true，那么
    a. 返回ReferenceRecord { \[\[Base]]:env, \[\[ReferenceName]]:name,
       \[\[Strict]]:strict, \[\[ThisValue]]:empty]] }
4. 否则
    a. 让outer是env.\[\[OuterEnv]]
    b. 返回?GetIdentifierReference(outer, name, strict)
**** 9.1.2.2 NewDeclarativeEnvironment(E)
  抽象操作NewDeclarativeEnvironment接受参数E（EnvironmentRecord值）。被调用时执
行下列步骤：
1. 让env是一个新的不含任何绑定的DeclarativeEnvironmentRecord。
2. 设置env.\[\[OuterEnv]]是E
3. 返回env
**** 9.1.2.3 NewObjectEnvironment(O, E)
  抽象操作NewObjectEnvironment接受参数O（Object值）和E（EnvironmentRecord值）。
被调用时执行下列步骤：
1. 让env是一个新的不含任何绑定的ObjectEnvironmentRecord。
2. 设置env.\[\[OuterEnv]]是E
3. 返回env
**** 9.1.2.4 NewFunctionEnvironment(F, newTarget)
  抽象操作NewFunctionEnvironment接受参数F和newTarget。被调用时执行下列步骤：
1. Assert：F是一个ECMAScript函数
2. Assert：Type(newTarget)是undefined或者Object
3. 让env是一个新的不含任何绑定的FunctionEnvironmentRecord。
4. 设置env.\[\[FunctionObject]]是F
5. 如果F.\[\[ThisModle]]是lexical，设置env.\[\[ThisBindingStatus]]为lexial
6. 否则设置env.\[\[ThisBindingStatus]]为uninitialized
7. 设置env.\[\[NewTarget]]是newTarget
8. 设置env.\[\[OuterEnv]]是F.\[\[Environment]]
9. 返回env
**** 9.1.2.5 NewGlobalEnvrionment(G, thisValue)
  抽象操作NewGlobalEnvironment接受参数G和thisValue。被调用时执行下列步骤：
1. 让objRec是新的含有G作为绑定对象的ObjectEnvironmentRecord
2. 让dclRec是新的不含任何绑定的DeclarativeEnvironmentRecord
3. 让env是新的GlobalEnvironmentRecord
4. 设置env.\[\[ObjectRecord]]是objRec。
5. 设置env.\[\[GlobalThisValue]]是thisValue。
6. 设置env.\[\[DeclarativeRecord]]是dclRec。
7. 设置env.\[\[VarNames]]是新的空List。
8. 设置env.\[\[OuterEnv]]是null。
9. 返回env
**** 9.1.2.6 NewModuleEnvironment(E)
  抽象操作NewModuleEnvironment接受参数E（EnvironmentRecord值）。被调用时执行
下列步骤：
1. 让env是新的不含任何绑定ModuleEnvironmentRecord
2. 设置env.\[\[OuterEnv]]是E
3. 返回env
** 9.2 Realms 领
  所有的ECMAScript代码在评估前必须联结到一个领。在概念上，领包含一套内在对
象、ECMAScript全局环境、这个全局环境圈内的加载的所有ECMAScript代码和其他联结
的状态与资源。
  领在本规范中表示为RealRecord，其字段列在表23
| 字段名             | 值                                                         | 含义                                                                                                                                                                                                                                                                                                                      |
| \[\[Intrinsics]]   | Record值。其字段名是内在键，字段值是对象                   | 被联结到此领的代码使用的内在值                                                                                                                                                                                                                                                                                            |
| \[\[GlobalObject]] | Object                                                     | 此领的全局对象                                                                                                                                                                                                                                                                                                            |
| \[\[GlobalEnv]]    | GlobalEnvironmentRecord                                    | 此领的全局环境                                                                                                                                                                                                                                                                                                            |
| \[\[TempateMap]]   | List<Record { \[\[Site]]: ParseNode, \[\[Array]]:Object }> | Template对象是对每个领使用其RealRecord的\[\[TempateMap]]进行独立简化的。每个\[\[Site]]是TempalteLiteral的ParseNode。联结的\[\[Array]]值是相应的传递给标记函数的模板对象。注意：如果ParseNode变得不可及，则相应的\[\[Array]]也是不可及的，而且如果某实现将这对内容从\[\[TemplateMap]]上移除，这ParseNode会变成不可观察的。 |
| \[\[HostDefined]]  | 任何值，默认值是undefined                                  | 用于在RealRecord需要联结额外信息的主机的保留字段。                                                                                                                                                                                                                                                                        |
*** 9.2.1 CreateRealm()
  抽象操作CreateRealm不接受参数。被调用时执行下列步骤：
1. 让realmRec是新的RealmRecord
2. 执行CreateIntrinsics(realmRec)
3. 设置realmRec.\[\[GlobalObject]]是undefined
4. 设置realmRec.\[\[GlobalEnv]]是undefined
5. 设置realmRec.\[\[TemplateMap]]是新的空List
6. 返回realmRec
*** 9.2.2 CreateIntrinsics(realmRec)
  抽象操作CreateIntrinsics接受参数realmRec。被调用时执行下列步骤：
1. 让intrinsics是一个新的Record
2. 设置realmRec.\[\[Intrinsics]]是intrinsics
3. 按照表8在intrinsics中设置字段，字段名就是第一列中的名字。每个字段的值是
   新的对象，按照本规范条款19到条款28定义的完整的递归的填充性质。每个对象
   性质值都是新的对象值。所有的内置函数对象的值都是通过执行
   CreateBuiltinFunction(steps, length, name, slots, realmRec, prototype)产生的，
   steps是本规范中该函数的定义，name是函数的name性质的初始值，length是函数的
   length性质的初始值，slots是该函数规定的内部占位的名称列表，而prototype是
   该函数的\[\[Prototype]]内部占位的规定值。创建内核和其性质时，必须时有序
   的，以避免依赖未创建的对象。
4. 执行AddRestrictedFunctionProperties(intrinsics.\[\[%Function.prototype%]], realmRec)
5. 返回intrinsics
*** 9.2.3 SetRealmGlobalObject(realmRec, globalObj, thisValue)
  抽象操作SetRealmGlobalObject接受参数realmRec、globalObj和thisValue。被调用时
执行下列步骤：
1. 如果globalObj是undefined，那么
    a. 让intrinsics是realRec.\[\[Intrinsics]]
    b. 设置globalObj是!OrdinaryObjectCreate(intrinsics.\[\[%Object.prototype%]])
2. Assert：Type(globalObj)是Object
3. 如果thisValue是undefined，设置thisValue是globalObj
4. 设置realmRec.\[\[GlobalObject]]是globalObj
5. 让newGlobalEnv是NewGlobalEnvironment(globalObj, thisValue)
6. 设置realmRec.\[\[GlobalEnv]]是newGlobalEnv
7. 返回realmRec
*** 9.2.4 SetDefaultGlobalBindings(realmRec)
  抽象操作SetDefaultGlobalBindings接受参数realmRec。被调用时执行下列步骤：
1. 让global是realmRec.\[\[GlobalObject]]
2. 遍历在条款19中规定的GlobalObject的性质，实施
    a. 让name是性质名的String值
    b. 让desc是本性质完整填充的PropertyDescriptor，包含此性质特定的属性。
       列在19.2、19.3和19.4的性质的\[\[Value]]属性是realmRec上的相应内核对象
    c. 执行?DefinePropertyOrThrow(global, name, desc)
3. 返回global
** 9.3 Execution Contexts执行背景
  执行背景是ECMAScript实现用于跟踪代码运行时评估行为的规范设备。任何时刻，
每个评估代码的施动者最多有一个执行背景。这被认为施动者的运行时执行背景。
本规范中指向运行时背景的引用记作SurroundingAgent的RunningExecutionContext（密
接施动者的运行时执行背景）。
  ExecutionContextStack用于跟踪执行背景。运行时执行背景总是在栈的顶部。任何
时候，当控制权从联结到当前运行时执行背景的可执行代码传递给没有联结到执行
背景的可执行代码，新的执行背景就会被创建。新的执行背景会被压到栈上，成为
运行时执行背景。
  执行背景包含了跟踪其联结代码的执行进程所必需实现规定状态。每个执行背景
至少含有列在表24的状态组件。
| 组件                  | 目的                                                                                                                                       |
| code evaluation state | 用于执行、挂起和复苏联结在本执行背景的代码所需要的状态                                                                                     |
| Function              | 如果本执行背景在评估函数对象的代码，这个组件的值就是函数对象。如果是评估Script或者Module代码，值就是null                                   |
| Realm                 | 用于联结代码访问ECMAScript资源的RealmRecord                                                                                                |
| ScriptOrModule        | 联结代码创立的ModuleRecord或者ScriptRecord。如果没有起源脚本或者模块，比如在InitializeHostDefinedRealm创建的执行背景的起源，这个值就是null |
  在本规范中运行时执行背景的代码评估会在各种位置被挂起。一旦这个运行时执行
背景被挂起，一个不同的执行背景会成为运行时执行背景并着手评估自身的代码。
后来一个挂起的执行背景会再次称为运行时背景，并从之前被挂起的位值继续评估
其代码。执行背景中运行时执行背景的状态转变通常按照后入/先出的方式发生。然
而，有些ECMAScript特生需要非LIFO方式转换运行时执行背景。
  运行时背景的Realm组件的值也被称为CurrrentRealmRecord（当前领记录）。运行时执
行背景的Function组件也被称为ActiveFunctionObject（活跃函数、活跃函数对象）。
  ECMAScript代码的执行背景还有表25列出的额外状态组件。
| 组件               | 目的                                                 |
| LexicalEnvironment | 确认解释本执行背景的代码创建的标识引用需要的EnvrionmentRecord |
| VariablEnvironment | 确认持有本执行背景的代码用VariableStatements创建的绑定的EnvironmentRecord |
  执行背景的LexicalEnvironment和VariableEnvironment组件总是EnvironmentRecord。
  表示GeneratorObject评估的执行背景还有列在表26的额外组件。
| 组件      | 目的                                |
| Generator | 本执行背景正在评估的GeneratorObject |
  绝大多数情况只有运行时执行背景（ExecutionContextStack执行背景栈的顶）是被
本规范的算法直接操作的。因此当无限定的使用术语LexicalEnvironment和
VariableEnvironment时，他们都是指运行时执行环境上的。
  执行背景是纯粹的规范机制，无需对应任何ECMAScript实现的任何特定内容。
ECMAScript代码不能直接访问或察觉执行背景。
*** 9.3.1 GetActiveScriptOrModule()
  抽象操作GetActiveScriptOrModule不接受参数。用于明确基于运行时执行背景的正在
运行的Script或者Module。被调用时执行下列步骤：
1. 如果ExceuctionContextStack是空的，返回null
2. 让ec是ExecutionContextStack上ScriptOrModule组件不是null的最顶部ExecutionContext
3. 如果没有这种ExecutionContext存在，返回null。否则返回ec的ScriptOrModule
*** 9.3.2 ResolveBinding(name[, env])
  抽象操作ResolveBinding接受参数name（String值）和可选参数env（EnvironmentRecord
值）。用于明确绑定#name。env用于显式提供EnvironmentRecord来搜索绑定。
被调用时执行下列步骤：
1. 如果env不存在，或者env是undefined，那么
    a. 设置env是运行时执行背景的LexicalEnvironment
2. Asset：env是EnvironmentRecord
3. 如果句法产出对应的正在评估的代码被包含在严格模式代码中，让strict是true，
   否则让strict是false
4. 返回?GetIdentifierReference(env, name, strict)
**** 注意 ResolveBinding用于返回ReferenceRecord，其\[\[ReferencedName]]是name
*** 9.3.3 GetThisEnvironment()
  抽象操作GetThisEnvironment不接受参数。寻找当前提供this绑定的
EnvironmentRecord。被调用时执行下列步骤：
1. 让env是RunningExecutionContext的LexicalEnvironment
2. 重复
    a. 让exists是env.HasThisBinding()
    b. 如果exists是true，返回env
    c. 让outer是env.\[\[OuterEnv]]
    d. Assert：outer不是null
    e. 设置env是outer
**** 注意 循环的步骤2总是会终止，因为环境list会在在全局环境处终止，全局环境
           必然有this绑定。
*** 9.3.4 ResolveThisBinding()
  抽象操作ResolveThisBinding不接受参数。使用RunningExecutionContext的
LexicalEnvironment明确this绑定。被调用时执行下列步骤：
1. 让envRec是GetThisEnvironment()
2. 返回?envRec.GetThisBinding()
*** 9.3.5 GetNewTarget()
  抽象操作GetNewTarget不接受参数。使用RunningExecutionContext的LexicalEnvironment
明确NewTarget的值。被调用时执行下列步骤：
1. 让envRec是GetThisEnvironment()
2. Assert：envRec有\[\[NewTarget]]字段
3. 返回envRec.\[\[NewTaraget]]
*** 9.3.6 GetGlobalObject()
  抽象操作GetGlobalObject不接受参数。返回被当前运行时执行背景使用的全局对
象。被调用时执行下列步骤：
1. 让currentRealm是CurrentRealmRecord
2. 返回currentRealm.\[\[GlobalObject]]
** 9.4 Jobs and Host Operations to Enqueue Jobs Job和主机对Job队列的操作
  Job是一个无参数的AbstractClosure，在当前进程没有其他ECMAScript计算时初始化
一个ECMAScript计算。
  Job按ECMAScript主机实现的规划来执行。本规范描述了主机榫（HostHook）
HostEnqueuePromiseJob安排的一类Job，主机可能定义额外的抽象操作来安排job。
那些操作接受JobAbstractClosure作为参数，安排其在未来某时执行。这些实现必须
与下列的要求一致。
. 在未来某时，如果没有运行时执行背景而且ExecutionContextStack是空的，必须
  实现：
    1. 执行主机定义的准备步骤
    2. 调用JoAbstractClosure
    3. 执行主机定义的清理步骤。随后ExecutionContextStack必须是空的。
. 任何时刻只能有一个Job被激活经受评估
. 一旦Job的评估开始，在其他Job开始前必须完成运行
. AbstractClosure必须返回一个普通完结，实现自有的错误处理。
*** 注意1 在安排上主机环境不要求统一对待Job。比如网页浏览器与Node.js对待
           PromiseHandling较其他工作有较高优先级；未来特征会引入不那么高优先
           级的Job
  在任何指定时间，如果下列条件都成立，scriptOrModule（ScriptRecord、ModuleRecord
或者null）是活跃的Script或者Module:
. GetActiveScriptOrModule()是scriptOrModule
. 如果scriptOrModule是ScriptRecord或者ModuleRecord，让ec是ExecutionContextStack上
其ScriptOrModule是scriptOrModule的最顶部ExecutionContext。ec的Realm组件是
scriptOrModule.\[\[Realm]]
  在任何指定时间，如果下列条件都成立，某执行准备评估ECMAScript代码
. ExecutionContextStack不空
. ExecutionContextStack的最顶部ExecutionContext（RunningExecutionContext）的Real组件
是RealmRecord
*** 注意2 主机环境可能通过将执行背景压到ExecutionContextStack上的方式来准备
           执行评估代码。这个特殊步骤是实现自行定义的。
           Realm的指定选择是由主机环境运行的。当Job的回调函数，例如Promise
           句柄，被调用，这个调用推送自己的执行背景和Realm
  特定类型的Job有额外的遵循需求。
*** 9.4.1 JobCallback Records
  JobCallbackRecord是用于存放函数对象的Record值，也是一个主机定义的值。通过
主机排队的Job调用起的函数对象可能还有额外的主机定义的背景。为了传播这个
状态，JobAbstractClosures不能直接捕获和调用函数对象。应该分别使用
HostMakeJobCallback和HostCallJobCallback。
**** 注意 例如：WHATWG HTML规定使用主机定义的值来为Promise回调传播现任的设置
           对象。
  JobCallbackRecord有列在表27的字段
| 字段名            | 值                  | 含义                               |
| \[\[Callback]]    | 函数对象            | 当Job被调用时，这个Job会调用的函数 |
| \[\[HostDefined]] | 任何值，默认时empty | 保留给主机的字段                   |
*** 9.4.2 HostMakeJobCallback(callback)
  主机定义的抽象操作HostMakeJobCallback接受参数callback（函数对象）。
  HostMakeJobCallback的实现必须遵循下列要求：
. 必须总是常规完结（不会返回意外完结）
. 必须返回\[\[Callback]]是callback的JobCallbackRecord
  默认的HostMakeJobCallback实现被调用时执行下列步骤：
1. Assert： IsCallable(callback)是true
2. 返回JobCallbackRecord { \[\[Callback]]:callback, \[\[HostDefined]]:empty }
  不是网页浏览器的ECMAScript主机必须使用HostMakeJobCallback的默认实现。
**** 注意 这会在回调被传到负责最终安排和执行的函数时调用。例如
           promise.then(thenAction)代码，在调用Promise.prototype.then时调用
           MakeJobCallback(thenAction)，而不是在安排到回应Job的时候。
*** 9.4.3 HostCallJobCallback(jobCallback, V, argumentsList)
  主机定义的抽象操作HostCallJobCallback接受参数jobCallback（JobCallbackRecord）、
V（ECMASCript语言值）和argumentsList（ECMAScript语言值的List）
  HostCallJobCallback的实现必须遵循下列要求：
. 必须总是执行并返回Call(jobCallback.\[\[Callback]], V, argumentsList)
**** 注意 这个要求意味着主机不能修改函数对象在本规范中定义的\[\[Call]]行为
  HostCallJobCallback的默认实现被调用时执行下列步骤：
1. Assert：IsCallable(jobCallback.\[\[Callback]])是true
2. 返回?Call(jobCallback.\[\[Callback]], V, argumentsList)
  不是网页浏览器的ECMAScript主机必须使用HostCallJobCallback的默认实现。
*** 9.4.4 HostEnqueuePromiseJob(job, realm)
  主机定义的抽象操作HostEnqueuePromiseJob接受参数job（JobAbstractClosure）和
realm（RealmRecord或者null）。安排job在后续被执行。本算法中使用的
AbstractClosures被试图用于联系到Promise的处理，否则被安排到与Promise处理操作
同优先级。
  HostEnqueuePromiseJob的实现必须遵循9.4的要求和下列要求：
. 如果realm不是null，每次job被调用时，实现必须执行实现层定义的步骤，那些在
  job调用时被准备用于评估ECMAScript代码的执行。
. HostEnqueuePromiseJob被调用时，让scriptOrModule是GetActiveScriptOrModule()。如果
  realm不是null，每次job被调用，实现必须执行实现层定义的步骤，那些在job调
  用时scriptOrModule时活跃Script或者Module
. Job必须按照安排的HostEnqueuePromiseJob调用顺序执行。
**** 注意 被NewPromiseResolveThenableJob返回的job的realm通常是在then函数对象上调
           用GetFunctionRealm的结果。被NewPromiseReactionJob返回的job的realm通常
           是，在如果句柄不是undefined时，句柄调用GetFunctionRealm的结果。如果
           句柄是null，realm也是null。所有种类的Job，当GetFunctionRealm异常结束
           （在Proxy调用时触发），realm是GetFunctionRealm调用是的Realm。当realm是
           null，不能有用户的ECMAScript代码会被评估，也没有新的ECMAScript对象会
           被创建。例如WHATWG HTML规范使用realm去检查实例概念和运行脚本的能力
           。
** 9.5 InitializeHostDefinedRealm()
  抽象操作InitializeHostDefinedRealm不接受参数。被调用时执行下列步骤：
1. 让realm是CreateRealm()
2. 让newContext是新的执行背景
3. 设置newContext的Function是null
4. 设置newContext的Realm是realm
5. 设置newContext的ScriptOrModule是null
6. 推送newContext到ExecutionContextStack，newContext现在是RunningExecutionContext
7. 如果主机需要使用奇异对象作为realm的全局对象，让global是一个以主机定义的
   方式来创建的对象。否则global是undefined，表明应该创建一个基本对象作为全局
   对象。
8. 如果主机需要在realm的全局范围内this绑定返回其他全局对象，让thisValue是一
   个以主机定义的方式来创建的对象。否则让thisValue是undefined，表明realm的
   全局this绑定应该是全局对象。
9. 执行SetRealmGlobalObject(realm, global, thisValue)
10. 让globalObj是?SetDefaultGlobalBinding(realm)
11. 在globalObj上创建主机定义的全局对象性质
12. 返回NormalCompletion(empty)
** 9.6 Agents 施动者
  施动者是一套ECMAScript执行背景，ExecutionContextStack、RunningExecutionContext、
AgentRecord和ExecutingThread。除了ExecutionThread，其他组成是施动者独占的。
  agent的ExecutingThread在agent的独立于其他agent的执行背景上执行一个job，除了
ExecutingThread会被多个agent用作ExecutingThread外，前提是共用这个线程的agent有
一个\[\[CanBlock]]是true的AgentRecord
*** 注意 例如有些网页浏览器在多个无关的浏览窗口中共用一个执行线程
  当agent的ExecutingThread执行jobs，这个agent就是job代码的SurroundingAgent。代码
使用SurroundingAgent访问其含有的规范级别的执行对象：RunningExecutionContext、
ExecutionContextStack和其他AgentRecord的字段。
| 字段名                   | 值                       | 含义                                                                                                                                                  |
| \[\[LittleEndian]]       | Boolean                  | 被GetValueFromBuffer和StetValueInBuffer的算法需要的isLitterEndian的参数的值。这是实现定义的，且是实现最有效率的备选。一旦这个值被观察到就不可修改了。 |
| \[\[CanBlock]]           | Boolean                  | 明确施动者是否可以阻塞                                                                                                                                |
| \[\[Signifier]]          | 任何全局唯一值           | 在施动者集群中标识施动者                                                                                                                              |
| \[\[IsLockFree1]]        | Boolean                  | true表示单字节的原子操作是免锁的，其他是false                                                                                                          |
| \[\[IsLockFree2]]        | Boolean                  | true表示两字节的原子操作是免锁的，其他是false                                                                                                          |
| \[\[IsLockFree8]]        | Boolean                  | true表示八字节的原子操作是免锁的，其他是false                                                                                                          |
| \[\[CandidateExecution]] | CandidateExecutionRecord | 见于内存模型                                                                                                                                          |
| \[\[KeptAlive]]          | 对象的List               | 初始化是空List，表示直到当前Job结束前保持活性的对象的列表                                                                                             |
  一旦\[\[Signifier]]、\[\[IsLockFree1]]和\[\[isLockFree2]]被本集群中的任何施动者观察到，他们就
不能变动了。
*** 注意2 \[\[IsLockFree1]]和\[\[isLockFree2]]的值不必由硬件决定，但是会反映实现的选择，在不同
         实现或者不同时期发生变动。
         没有\[\[IsLockFree1]]性质，因为四字节的原子操作总是免锁的。
         在实践上，如果一个原子操作被实现为某步带锁的，这个操作不是免锁的。免锁不是免等待，完成一个
         免锁的原子操作需要多少机器步骤是没有上限的。
         原子级访问n的大小是无锁的，不意味任何关于非原子访问n的大小的原子性的意义，尤其是，非原子访问
         可能还会是执行一些离散的内存访问。见于ReadSharedemory和WriteSharedMemory。
*** 注意3 施动者是规范机制，无需对应任何ECMAScript实现的任何活。
*** 9.6.1 AgentSignifier()
  抽象操作AgentSignifier不接受参数。被调用时执行下列步骤：
1. 让AR是紧围施动者的AgentRecord
2. 返回AR.\[\Signifier]]
*** 9.6.2 AgentCanSuspend()
  抽象操作AgentCanSuspend不接受参数。被调用时执行下列步骤：
1. 让AR是紧围施动者的AgentRecord
2. 返回AR.\[\[CanBlock]]
**** 注意 在某些环境下可能没有理由让一个施动者挂起。比如在网页浏览器环境下，不让文档的主线程挂起就是
         就是合理的，同时其工作线程就是可以挂起的。
** 9.7 Agent Clusters
  AgentCLuster就是最大的可以通过公用内存进行通讯的agent集合。
*** 注意1 程序在不同的施动者间会通过不在规范内的方式公用内存。至少，
          SharedArrayBuffer对象的备份内存能够被集群中的施动者共用。
          同时施动者可以通过消息通讯那些不能共用内存的内容，而且这些施动者
          从来就没不在同一个集下。
  每个施动者都明确从属于一个AgentCluster。
*** 注意2 集群中的施动者完全不必同时存活。如果A创造了B，然后结束A，B创建C，
           如果B可以共享A的某些内存，C可以共享B的某些内存，则A、B、C都在同一
           个集群中。
  同一个集群下的施动者的AgentRecord必须有相同的\[\[LittleEndian]]性质
*** 注意3 如果同一集群下施动者有不同的\[\[LittleEndian]]值，多字节数据的共用会
           异常困难。
  同一个集群下的施动者的AgentRecord必须有相同的\[\[IsLockFree1]]性质，同样的
\[\[IsLockFree2]]也是如此。
  同一个集群下的施动者的AgentRecord必须有不同的\[\[Signifier]]性质
  存在嵌入逻辑可以灭活（停止前进进程）或者活化（继续前进进程）施动者而不要
此施动者的声明或配合。如果此嵌入逻辑触发，必须保证如果集群下有施动者被无
限期的灭活，集群下就不能有其他施动者是活化的。
*** 注意4 前面限制的目的是规避一种情况，即某个施动者发生死锁或者饥饿，因为
           其他施动者被灭火。例如在HTML中，共享的worker，在任何窗体中有独立于
           文档的生命周期，被允许分享内存给那些独立文档的专用worker，这个文档
           和其专用worker在其持有锁的时候被灭活（也就是说，文档被推送到窗体
           历史了），这个共享的worker试图获得这个锁，那么这个共享的worker就会
           被锁住直到那个专有worker重新活化。如此同时其他窗体的试图访问这个
           共享worker的其他worker会饥饿（没事干）。
           这个限制的含义是不可以在不属于遵循嵌入逻辑的同时挂起/唤醒的同一
           合集的施动者间共用内存。
  嵌入逻辑可以终止一个施动者，无需其所在集群的其他施动者之前的声明或者配
合。如果施动者不是因自己或者集群其他施动者的程序动作，而是因为集群外的强制
行为而终结，嵌入逻辑必须选择一个策略：1、终结掉集群内的全部施动者，2、提供
可靠的API允许集群的施动者配合，这样集群中至少存在一个成员能够侦测到这个终结
命令，通过终结数据包含足够识别施动者会被终结的信息。
*** 注意5 触发这种终结的例子：操作系统或者用户终止了在独立进程中运行的施动
           者；嵌入逻辑根据其他施动者终止了一个正在运行的施动者，当每个施动
           者的资源统计都表明那个施动者失控了。
  在集群的任何施动者评估ECMAScript代码之前，集群里的所有施动者的AgentRecord的
\[\[CandidateExecution]]字段被设置为特定初始化的CandidateExecution。这个初始化的
CandidateExecution是空的CandidateExecution，其\[\[EventsRecords]]是AgentEventsRecord的
List，每个AgentEventsRecord的\[\[AgentSignifier]]是其代表的施动者标记，而且
CandidateExecution的\[\[EventList]]和\[\[AgentSynchronizesWith]]字段都是空的List。
*** 注意6 同一集群下的全部施动者在其AgentRecord的\[\[CandidateExecution]]字段共用
           相同的CandidateExecution。CandidateExecution是用于内存模型的规范机制。
*** 注意7 施动者集群是一个规范机制，不对应任何ECMAScript实现的特定活。
** 9.8 Forward Progress 前进进程
  对于施动者引发前进进程是说它根据本规范执行了一步评估。
  施动者在其运行时执行背景等待同步的无限期的外部事件时会变成阻塞的。在这种
场景中，只有施动者的AgentRecord的\[\[CanBlock]]性质是true时才可以变成阻塞的。
无障施动者是不能被阻塞的。
  实现必须确保：
. 每个无锁施动者最终带着一个专用的执行线程来引发前进进程
. 在共用一个执行线程的施动者集合里，一个施动者最终引发前进进程
. 施动者除非使用提供的显式API来阻塞，否则不能让其他施动者变成阻塞的。
*** 注意 与内存模型的活性保证一起，这确保了所有的SeqCst写入最终都对施动者
          可见。
** 9.9 Processing Modle of WeakRef and FinalizationRegistry Objects
       终点注册对象和弱引用的进程模型
*** 9.9.1 Objectives 目标
  本规范没有关于对象被回收的任何保证。失活的对象可能会很久之后，甚至永不，
被释放。因为这个原因，本规范使用术语may来描述触发垃圾收集的行为。
  WeakRef与FinalizationReigstry对象的语义是基于发生在特定时间的两个操作的。
. 当WeakRef.prototype.deref被调用，被引（如果没有返回undefined）对象保持活性，
  这样随后的同步访问仍然返回这个对象。在同步工作完成时使用ClearKeptObject抽象
  操作来重置这个列表。
. 当一个向FinalizationRegistry注册的对象变得不可及时，在同步的ECMAScript执行完成
  后，FinalizationRegistry的清理行为的回调的调用可能最终被引发。
  FinalizationRegistry清理随着CleanupFinalizationRegistry抽象操作被执行。
  ClearKeptObjects或者CleanupFinalizationRegistry行为都不会中断同步的ECMAScript
执行。因为主机会试图延长同步ECMAScript执行的运行，本规范延缓规划
ClearKeptObjects和CleanupFinalizationRegistry到主机环境中。
  有些ECMAScript实现包含了后台运行垃圾收集的实现，包含ECMAScript停滞的情况。
让主机环境规划CleanupFinalizationRegistry，为了运行结束工作，允许其继续
ECMAScript执行，会释放持有的值，减少总体内存使用。
*** 9.9.2 Liveness 存活
  对于对象的某些集合S，就S而言，HypotheicalWeakRef-oblivious（假设弱引用无感知）
执行就是WeakRef的抽象操作WeakRefDeref的执行中获取S引用总是undefined。
**** 注意1 弱引用无感知，与Liveness一起，描述了两个观念。一是WeakRef
            本身不会保持对象存活，二是Liveness里的循环引用不表明对象是活的。
            实现上来说，如果明确对象的活性依赖于其他弱引用的obj2的活性，而
            obj2的活性不能假设obj的活性，因为其可能是循环的。
**** 注意2 弱引用无感知被定义在对象集合上，而不是独立的对象，来明确环。
            如果被定义在独立对象上，那么环里的对象会被认为是获得，即使这个
            对象值仅可以通过环里其他对象的WeakRef来观察到。
**** 注意3 一般如果包含对象的每个集合都是活的，我们说这个独立对象是获得。
  在评估的任何点，集合对象S被认为是存活的，如果下列条件满足之一：
. S中的任何元素被包含在施动者的\[\[KeptAlive]]列表里
. 对于S而言，存在有效的未来的HypotheticalWeakRef-oblivious执行能够观察到S中的
  任意对象值。
**** 注意4 上面的第二个条件试图描述这样直觉：就是对象如果能不通过WeakRef方式
            就观察的其标识的就是存活的。对象的标识可以被观测到通过观察到两个
            对象的严格相等比较或者观察到其被作为Map的键。
**** 注意5 对象是字段、内部占位或者是性质，不表明对象存活的。例如如果对象是
            请求的参数，再也不会返回到程序中，那么它不能被观察到。
            这处理WeakMap键，WeakSet成员，以及FinalizationRegistry单元记录的
            \[\[WeakRefTarget]]和\[\[UnregisterToken]]字段的。
            上述定义表明WeakMap的键是不存活的，那么其值也无需存活
**** 注意6 Liveness是保证WeakRef引擎不空的下限。这里定义Liveness是出乎意料的。
            事实上引擎使用保守的近似性比如可达性。这里被期望有显著的实现余
            地。
*** 9.9.3 Execution 执行
  任何时候，如果对象集合S失活，ECMAScript实现可能自动执行下列步骤
1. 遍历集合S的每个元素对象obj，做
    a. 遍历每个WeakRef，记做ref，如果ref.\[\[WeakRefTarget]]是obj，那么做
        i. 设置ref.\[\[WeakRefTarget]]是空
    b. 遍历每个FinalizationRegistry记作fg，如果fg.\[\[Cells]]包含一个Record，
       记作cell，且cell.\[\[WeakRefTarget]]是obj，那么做
        i. 设置cell.\[\[WeakRefTarget]]为空
       ii. 可选项：执行!HostEnqueueFinalizationRegistryCleanupJob(fg)
    c. 遍历每个WeakMap，记作map，如果map.\[\[WeakMapData]]包含一个Record，记作r，
       r.\[\[Key]]是obj，那么做
        i. 设置r.\[\[Key]]为空
       ii. 设置r.\[\[Value]]是空
    d. 遍历每个WeakSet，记作set，如果set.\[\[WeakSetData]]包含obj，那么做
        i. 替换set.\[\[WeakSetData]]上obj所在位置的值为空。
**** 注意1 和Liveness的定义一起，本条款提前描述了实现可能根据WeakRefs的合法优化。
          没有观察到对象的标识，也有可能访问到这个对象。所以像非转义对象（就是无法观察
	  到标识的对象）上的死亡变量清理和标量替换等优化都是允许的。这些优化这样被允许
	  到可观测空WeakRef上，WeakRef的点指向那些对象。
	  换句话说，如果对象的标识可以观察到，而且对象在WeakRef的内部占位
	  \[\[WeakRefTarget]]，像重新物化这种可观测的置空WeakRef的优化是禁止的。
	  因为调用HostEnqueueFinalizationRegistryCleanupJob是可选的，在
	  FinalizationRegistry注册的对象无需保持FinalizationRegistry存活。实现可能
	  会因为任何原因忽略finalizationRegistry的回调，比如FinalizationRegistry
	  本身死亡了，或者应用关闭了。
**** 注意2 实现没有义务清空WEakRefs以最大化非存活对象。
          如果实现选择了一个非存活集合S来置空WeakRefs，必须同时为S中的所有对象置空
	  WeakRef。也就是说，实现不能置空指向对象obj的WeakRef而不置空其外部的WeakRefs，
	  如果外部不空的话，因为外部WeakRef会让执行观察到obj的对象值。
*** 9.9.4 HostHooks 主机榫
*** 9.9.4.1 HostEnquueFinalizationRegistryCleanupJob(finalizationRegistry)
  抽象操作HostEnqueueFinalizationRegistryCleanupJob接受参数finalizationRegistry（
FinalizationRegistry实例）。HostEnqueueFinalizationRegistryCleanupJob是实现定义的
抽象操作，被期望在未来某些点上如果可能的话调用
CleanupFinalizationRegistry(finalizationReigstry)。主机负责保证这个调用不会中断
同步的ECMAScript代码执行。
** 9.10 ClearKeptObjects()
  抽象操作ClearKeptObject不接受参数。ECMAScript实现被期望在一个ECMAScript执行序列完成后
调用ClearKeptObjects。被调用时执行下列步骤：
1. 让agentRecord是外围施动者的AgentRecord
2. 设置agentRecord.\[\[KeptAlive]]是新的空List
** 9.11 AddToKeptObjects(object)
  抽象操作AddTokeptObjects接受参数object（Object值）。被调用时执行下列步骤：
1. 让agentRecord是外围施动者的AgentRecord
2. 将object追加到agentRecord.\[\[KeptAlive]]中
*** 注意 当抽象操作AddTokeptObject被调用于目标饮用上，将目标添加到一个列表中，这个列表会
        强指向这个对象，直到ClearKeptObjects被调用。
** 9.12 CleanupFinalizationRegistry(finalizationRegistry)
  抽象操作CleanupFinalizationRegistry接受参数finalizationRegistry（
FinalizationRegistry）。被调用时执行下列步骤：
1. Assert：finalizationRegistry有\[\[Cells]]和\[\[CleanupCallback]]内部占位
2. 让callback是finalizationRegistry.\[\[CleanupCallback]]
3. 当finalizationRegistry.\[\[Cells]]包含一个Record，记作cell，
   cell.\[\[WeakRefTarget]]是空的，实现可能会执行下列步骤：
    a. 选择cell
    b. 从finalizationRegistry.\[\[Cells]]中移除cell
    c. 执行?Call(callback, undefined, <<cell.\[\[heldValue]]>>)
4. 返回undefined
* 10 Ordinary and Exotic Ojbects Behaviours 基本与奇异对象的行为
** 10.1 Ordinary Object Internal Methods and Internal Slots
   基本对象的内部方法和内部占位
  所有的基本对象都有\[\[Prototype]]的内部占位。这个占位的值是null或者一个用于实现继承的
对象。\[\[Prototype]]对象的数据性质被继承（也就是会当作子对象的性质）于读取许可，但是没有
写入许可。访问性质被继承了读取和写入许可。
  每个基本对象都有一个布尔值的内部占位\[\[Extensible]]，用于实现规定在6.1.7.3中的扩展相关
的内部方法的不变性。按本意，一旦对象的\[\[Extensible]]的值是false，这个对象就不再能添加
性质，或者修改\[\[Prototype]]内部占位，或者随后修改\[\[Extensible]]为true。
  在随后的算法描述中，预设O是基本对象，P是性质键值，V是ECMAScript语言值，Desc是
PropertyDescriptorRecord
  基本对象的每个内部方法都代表了一个相似名称的抽象操作。如果某个抽象操作依赖于其他内部方法，
这个内部方法是以O来唤起的，而不是直接调用那个相似名称的抽象操作。这些语义确保了奇异对象能够
覆盖内在方法的调用，当基本对象的内部方法被申请给这些奇异对象。
*** 10.1.1 \[\[GetPrototypeOf]]()
  基本对象O的内部方法\[\[GetPrototypeOf]]不接受参数。被调用时执行下列步骤：
1. 返回!OrdinaryGetPrototypeof(O)
**** 10.1.1.1 OrdinaryGetPrototypeOf(O)
  抽象操作OrdianryGetPrototypeOf接受参数O（对象）。被调用时执行下列步骤：
1. 返回O.\[\[Prototype]]
*** 10.1.2 \[\[SetPrototypeOf]](V)
  基本对象O的内部方法\[\[SetPrototypeOf]]接受参数V（对象值或者null）。被调用时执行下列
步骤：
1. 返回!OrdianrySetPrototypeOf(O, V)
**** 10.1.2.1 OrdinarySetPrototypeOf(O, V)
  抽象操作OrdianrySetPrototypeOf接受参数O（对象）和V（ECMAScript语言值）。被调用时
执行下列步骤：
1. Assert：Type(V)是Object或者Type(V)是Null
2. 让current是O.\[\[Prototype]]
3. 如果SameValue(V, current)是true，返回true。
4. 让extensible是O.\[\[Extensible]]
5. 股弱extensible是false，返回false。
6. 让p是V
7. 让done是false
8. 当done是false时，重复
    a. 如果p是null，设置done是true。
    b. 如果SameValue(p, O)是true，返回false
    c. 否则
        i. 如果p.\[\[GetPrototypeOf]]不是定义在10.1.1的内部方法，设置done是true
       ii. 否则，设置p是p.\[\[Prototype]]
9. 设置O.\[\[Prototype]]是V
10. 返回true
***** 注意 步骤8的循环确保了在原型链上不会有循环，而且只含有使用基本对象定义的
          \[\[GetPrototypeOf]]和\[\[SetPrototypeOf]]的对象。
*** 10.1.3 \[\[IsExtensible]]()
  基本对象O的内部方法\[\[IsExtensible]]不接受参数。被调用时执行下列步骤：
1. 返回!OrdinaryIsExtensible(O)
**** 10.1.3.1 OrdinaryIsExtensible(O)
  抽象操作OrdinaryIsExtensible接受参数O（对象值）。被调用时执行下列步骤：
1. 返回O.\[\[Extensible]]
*** 10.1.4 \[\[PreventExtensions]]()
  基本对象O的内部方法\[\[PreventExtensions]]不接受参数。被调用时执行下列步骤：
1. 返回!OrdinaryPreventExtensions(O)
**** 10.1.4.1 OrdinaryPreventExtensions(O)
  抽象操作OrdinaryPreventExtensions接受参数O（对象值）。被调用时执行下列步骤：
1. 设置O.\[\[Extensible]]是false
2. 返回true。
*** 10.1.5 \[\[GetOwnProperty]](P)
  基本对象O的内部方法\[\[GetOwnProperty]]接受参数P（性质键）。被调用时执行下
列步骤：
1. 返回!OrdinaryGetOwnProperty(O, P)
**** 10.1.5.1 OrdinaryGetOwnProperty(O,P)
  抽象操作OrdinaryGetOwnProperty接受参数O（对象值）和P（性质键）。被调用时执
行下列步骤：
1. Assert：IsPropertyKey(P)是true
2. 如果O没有自有性质P，返回undefined
3. 让D是新建的PropertyDescriptor，没有任何字段
4. 让X是O的性质P
5. 如果X是数据性质，那么
    a. 设置D.\[\[Value]]是X.\[\[Value]]的值
    b. 设置D.\[\[Writable]]是X.\[\[Writable]]的值
6. 否则
    a. Assert：X是访问性质
    b. 设置D.\[\[Get]]是X.\[\[Get]]的值
    c. 设置D.\[\[Set]]是X.\[\[Set]]的值
7. 设置D.\[\[Enumerable]]是X.\[\[Enumerable]]的值
8. 设置D.\[\[Configurable]]是X.\[\[Configurable]]的值
9. 返回D
*** 10.1.6 \[\[DefineOwnProperty]](P, Desc)
  基本对象O的内部方法\[\[DefineOwnProperty]]接受参数P（性质键）和Desc（
PropertyDescriptor）。被调用时执行下列步骤：
1. 返回?OrdinaryDefineOwnProperty(O, P, Desc)
**** 10.1.6.1 OrdinaryDefineOwnProperty(O, P, Desc)
  抽象操作OrdinaryDefineOwnProperty接受参数O（对象值）、P（性质键）和Desc（
PropertyDescriptor）。被调用时执行下列步骤：
1. 让current是?O.\[\[GetOwnProperty]](P)
2. 让extensible是?IsExtensible(O)
3. 返回ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current)
**** 10.1.6.2 IsCompatiblePropertyDescriptor(Extensible, Desc, Current)
  抽象操作IsCompatiblePropertyDescriptor接受参数Extensible（Boolean）、Desc（
PropertyDescriptor）和Current（PropertyDescriptor）。被调用时执行下列步骤：
1. 返回ValidateAndApplyPropertyDescriptor(
  undefined, undefined, Extensible, Desc, Current
)
**** 10.1.6.3 ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current)
  抽象操作ValidateAndApplyPropertyDescriptor接受参数O（对象值或者undefined）、P（
性质键）、extensible（Boolean）、Desc（PropertyDescriptor）和current（
PropertyDescriptor）。被调用时执行下列步骤：
***** 注意 如果O是undefined，只执行校验，不修改任何对象。
1. Assert：如果O不是undefined，那么IsPropertyKey(P)必然是true
2. 如果current是undefined，那么
    a. 如果extensible是false，返回false
    b. Assert：extensible是true
    c. 如果IsGenericDescriptor(Desc)是true或者IsDataDescriptor(Desc)是true，那么
        i. 如果O不是undefined，根据Desc的\[\[Value]]、\[\[Writable]]、
           \[\[Enumerable]]和\[\[Configurable]]在对象O上创建自有数据性质P。如果
           Desc上的属性缺失，新性质的属性使用默认值。
    d. 否则
        i. Assert：!IsAccessorDescriptor(Desc)是true
       ii. 如果O不是undefined，根据Desc的\[\[Get]]、\[\[Set]]、\[\[Enumerable]]和
           \[\[Configurable]]在对象O上创建自有访问性质P。如果Desc上的属性缺失，
           新性质的属性使用默认值。
    e. 返回true
3. 如果Desc中需要的属性都缺失，返回true
4. 如果current.\[\[Configurable]]是false，那么
    a. 如果Desc.\[\[Configurable]]是true，返回false
    b. 如果Desc.\[\[Configurable]]存在，且!SameValue(Desc.\[\[Enumerable]],
       current.\[\[Enumerable]])是false，返回false。
5. 如果!IsGenericDescriptor(Desc)是true，那么
    a. 注意：不在需要继续校验了。
6. 否则，如果!SameValue(!IsDataDescriptor(current), !IsDataDescriptor(Desc))是false，
   那么
    a. 如果current.\[\[Configurable]]是false，返回false
    b. 如果IsDataDescriptor(current)是true，那么
        i. 如果O不是undefined，将O的P性质从数据性质转换到访问性质。保留
           \[\[Configurable]]和\[\[Enumerable]]的值，若缺失属性则使用默认值
    c. 否则
        i. 如果O不是undefined，将O的P性质从访问性质转换到数据性质。保留
           \[\[Configurable]]和\[\[Enumerable]]的值，若缺失属性则使用默认值
7. 否则，如果IsDataDescriptor(current)和IsDataDescriptor(Desc)都是true，那么
    a. 如果current.\[\[Configurable]]是false，且current.\[\[Writable]]是false，那么
        i. 如果Desc.\[\[Writable]]是true，返回false
       ii. 如果Desc.\[\[Value]]存在，且SameValue(Desc.\[\[Value]], current.\[\[Value]])
           是false，返回false
      iii. 返回true
8. 否则
    a. Assert：!IsAccessorDescriptor(current)和!IsAccessorDescriptor(Desc)都是true
    b. 如果current.\[\[Configurable]]是false，那么
        i. 如果Desc.\[\[Set]]存在，且SameValue(Desc.\[\[Set]], current.\[\[Set]])是
           false，返回false
       ii. 如果Desc.\[\[Get]]存在，且SameValue(Desc.\[\[Get]], current.\[\[Get]])是
           false，返回false
      iii. 返回true
9. 如果O不是undefined，那么
    a. 遍历Desc中的属性，将O的P性质对应的属性赋予相同的值
10. 返回true
*** 10.1.7 \[\[HasProperty]](P)
  基本对象O的内部方法\[\[HasProperty]]接受参数P（性质键）。被调用时执行下
列步骤：
1. 返回!OrdinaryHasProperty(O, P)
**** 10.1.7.1 OrdinaryHasProperty(O,P)
  抽象操作OrdinaryHasProperty接受参数O（对象值）和P（性质键）。被调用时执
行下列步骤：
1. Assert：IsPropertyKey(P)是true
2. 让hasOwn是?O.\[\[GetOwnProperty]](P)
3. 如果hasOwn不是undefined，返回true
4. 让parent是?O.\[\GetPrototypeOf]]()
5. 如果parent不是null，那么
    a. 返回?parent.\[\[HasProperty]](P)
6. 返回false
*** 10.1.8 \[\[Get]](P, Receiver)
  基本对象O的内部方法\[\[Get]]接受参数P（性质键）和Receiver（ECMAScript语言
值）。被调用时执行下列步骤：
1. 返回!OrdinaryGet(O, P, Receiver)
**** 10.1.8.1 OrdinaryGet(O,P,Receiver)
  抽象操作OrdinaryGet接受参数O（对象值）、P（性质键）和Receiver（ECMAScript语言
值）。被调用时执行下列步骤：
1. Assert：IsPropertyKey(P)是true
2. 让desc是?O.\[\[GetOwnProperty]](P)
3. 如果desc是undefined，那么
    a. 让parent是?O.\[\[GetPrototypeOf]]()
    b. 如果parent是null，返回undefined
    c. 返回?parent.\[\[Get]](P, Receiver)
4. 如果IsDataDescriptor(desc)是true，返回desc.\[\[Value]]
5. Assert：IsAccessorDescriptor(desc)是true
6. 让getter是desc.\[\[Get]]
7. 如果getter是undefined，返回undefined
8. 返回?Call(getter, Receiver)
*** 10.1.9 \[\[Set]](P, V, Receiver)
  基本对象O的内部方法\[\[Set]]接受参数P（性质键）、V（ECMAScript语言值）和
Receiver（ECMAScript语言值）。被调用时执行下列步骤：
1. 返回?OrdinarySet(O, P)
**** 10.1.9.1 OrdinarySet(O,P,V,Receiver)
  抽象操作OrdinarySet接受参数O（对象值）、P（性质键）、V（ECMAScript语言值）和
Receiver（ECMAScript语言值）。被调用时执行下列步骤：
1. Assert：IsPropertyKey(P)是true
2. 让ownDesc是?O.\[\[GetOwnProperty]](P)
3. 返回OrdinarySetWithOwnDescriptor(O,P,V,Reciver,ownDesc)
**** 10.1.9.2 OrdinarySetWithOwnDescriptor(O,P,V,Receiver,ownDesc)
  抽象操作OrdinarySet接受参数O（对象值）、P（性质键）、V（ECMAScript语言值）、
Receiver（ECMAScript语言值）和ownDesc（PropertyDescriptor或者undefined）。被调用时
执行下列步骤：
1. Assert：IsPropertyKey(P)是true
2. 如果ownDesc是undefined，那么
    a. 让parent是?O.\[\[GetPrototypeOf]]()
    b. 如果parent不是null，那么
        i. 返回?parent.\[\[Set]](P,V,Receiver)
    c. 否则
       ii. 设置ownDesc是PropertyDescriptor { \[\[Value]]:undefined,
           \[\[Writable]]:true, \[\[Enumerable]]:true, \[\[Configurable]]:true }
3. 如果IsDataDescriptor(ownDesc)是true，那么
    a. 如果ownDesc.\[\[Writable]]是false，返回false
    b. 如果Type(Receiver)不是Object，返回false
    c. 让existingDescriptor是?Receiver.\[\[GetOwnProperty]](P)
    d. 如果existingDescriptor不是undefined，那么
        i. 如果IsAccessorDescriptor(existingDescriptor)是true，返回false
       ii. 如果existingDescriptor.\[\[Writable]]是false，返回false
      iii. 让valueDesc是PropertyDescriptor{\[\[Value]]:V}
       iv. 返回?Receiver.\[\[DefineOwnProperty]](P, valueDesc)
    e. 否则
        i. Assert：Receiver现在没有性质P
       ii. 返回?CreateDataProperty(Receiver, P, V)
4. Assert：IsAccessorDescriptor(ownDesc)是true
5. 让setter是ownDesc.\[\[Set]]
6. 如果setter是undefined，返回false
7. 执行?Call(setter, Receiver, <<V>>)
8. 返回true
*** 10.1.10 \[\[Delete]](P)
  基本对象O的内部方法\[\[Delete]]接受参数P（性质键）。被调用时执行下列步骤：
1. 返回?OrdinaryDelete(O, P)
**** 10.1.10.1 OrdinaryDelete(O,P)
  抽象操作OrdinaryDelete接受参数O（对象值）和P（性质键）。被调用时执行下列
步骤：
1. Assert：IsPropertyKey(P)是true
2. 让desc是?O.\[\[GetOwnProperty]](P)
3. 如果desc是undefined，返回true
4. 如果desc.\[\[Configurable]]是true，那么
    a. 从O上移除性质P
    b. 返回true
5. 返回false
*** 10.1.11 \[\[OwnPropertyKeys]]()
  基本对象O的内部方法\[\[OwnPropertyKeys]]不接受参数。被调用时执行下列步骤：
1. 返回!OrdinaryOwnPropertyKeys(O)
**** 10.1.9.1 OrdinaryOwnPropertyKeys(O)
  抽象操作OrdinaryOwnPropertyKeys接受参数O（对象值）。被调用时执行下列步骤：
1. 让keys是新的空List
2. 遍历O的每个自有性质的键P，如果P是ArrayIndex，按照数字升序，做
    a. 追加P到keys中
3. 遍历O的每个自有性质的键P，如果Type(P)是字符串，且不是ArrayIndex，按照创建
   顺序升序，做
    a. 追加P到keys中
4. 遍历O的每个自有性质的键P，如果Type(P)是Symbol，按照创建顺序升序，做
    a. 追加P到keys中
5. 返回keys
*** 10.1.12 OrdinaryObjectCreate(proto[, additionalInternalSlotsList])
  抽象操作OrdinaryObjectCreate接受参数proto（对象值或者null）和可选参数
additionalInternalSlotsList（内部占位的名称的List）。用于规定在运行时创建新的
基本对象。additionalInternalSlotsList包含了创建对象时除了\[\[Prototype]]和
\[\[Extensible]]外的必须的内部占位的名字。如果additionalInternalSlotsList没有被
提供，一个新的空List被使用。被调用时执行下列步骤：
1. 让internalSlotsList时<<\[\[Prototype]],\[\[Extensible]]>>
2. 如果additionalInternalSlotsList存在，将其元素附加到internalSlotsList中
3. 让O是!MakeBasicObject(internalSlotsList)
4. 设置O.\[\[Prototype]]是proto
5. 返回O
**** 注意 尽管OrdinaryObjectCreate比调用MakeBasicObject多做了些事情，它表露的
           意图仍然是创建基本对象，而不是奇异对象。因此，在本规范内，它不会
           被任何会修改内部方法从而产生奇异对象的算法调用。产生奇异对象的
           操作直接调用MakeBasicObject。
*** 10.1.13 OrdinaryCreateFromConstructor(constructor, intrinsicDefaultProto[,
    interanlSlotsList])
  抽象操作OrdinaryCreateFromConstructor接受参数constructor和intrinsicDefaultProto和
可选参数internalSlotsList（内部占位名的List）。创建一个基本对象，其
\[\[Prototype]]是从constructor上检索到的"prototype"性质，如果存在的话。否则的话
使用intrinsicDefaultProto作为\[\[Prototype]]的值。internalSlotList包含了创建对象的
其他内部占位的名称。如果internalSlotList没有提供，使用新的空List。被调用时执
行下列步骤：
1. Assert：intrinsicDefaultProto是内在对象在本规范的名称的String值。对应的对象比
   须是用作对象的\[\[Prototype]]的固有对象。
2. 让proto是?GetPrototypeFromConstructor(constructor, intrinsicDefaultProto)
3. 返回!OrdinaryObjectCreate(proto, internalSlotsList)
*** 10.1.14 GetPrototypeFromConstructor(constructor, intrinsicDefaultProto)
  抽象操作GetPrototypeFromConstructor接受参数constructor和intrinsicDefaultProto。
明确用于创建对象的\[\[Prototype]]值是由指定的constructor对应的。这个值是从
constructor的"prototype"性质检索到的，如果存在的话。否则使用intrinsicDefaultProto
作为\[\[Prototype]]。被调用时执行下列步骤：
1. Assert：intrinsicDefaultProto是内在对象在本规范的名称的String值。对应的对象比
   须是用作对象的\[\[Prototype]]的固有对象。
2. Assert：IsCallable(constructor)是true
3. 让proto是?Get(constructor, "prototype")
4. 如果Type(proto)不是object，那么
    a. 让realm是?GetFunctionRealm(constructor)
    b. 设置proto是realm的名称为intrinsicDefaultProto的内在对象
5. 返回proto
**** 注意 如果constructor不提供\[\[Prototype]]值，默认值是从constructor函数的
           realm中取得默认值，而不是从运行时执行上下文。
*** 10.1.15 RequireInternalSlot(O, internalSlot)
  抽象操作RequireInternalSlot接受参数O和internalSlot。如果对象O没有给定的
internalSlot就投掷异常。被调用时执行下列步骤：
1. 如果Type(O)不是对象，投掷TypeError异常
2. 如果O没有internalSlot内部占位，投掷TypeError异常
** 10.2 ECMAScript Function Objects
  ECMAScripFunction对象封装了参数化的ECMAScript代码，闭合了词法环境，支持代码
的动态环境。一个ECMAScriptFunction对象是一个基本对象，有与其他基本对象相同的
内部占位和内部方法。ECMAScriptFunction对象的代码分为严格模式和非严格模式两
种。严格模式代码的ECMAScriptFunction对象称为严格函数。非严格模式代码的则称为
非严格函数。
  \[\[Extensible]]和\[\[Prototype]]之外，ECMAScript对象还有表29所列的内部占位
| 内部占位                 | 类型                              | 描述                                                                                                                                                                                               |
| \[\[Environment]]        | EnvironmentRecord                 | 函数对象闭合的EnvironmentRecord。作为评估函数时的外层环境。                                                                                                                                        |
| \[\[FormalParameters]]   | ParseNode                         | 定义函数形式参数的源文本的解析节点的根节点                                                                                                                                                         |
| \[\[ECMAScriptCode]]     | ParseNode                         | 定义函数体的源文本的解析节点的根节点                                                                                                                                                               |
| \[\[ConstructorKind]]    | base \vert derived                | 函数是否是派生的类构造函数                                                                                                                                                                         |
| \[\[Realm]]              | RealmRecord                       | 创建此函数的领，并为评估此函数时提供需要的固有对象                                                                                                                                                 |
| \[\[ScriptOrModule]]     | ScriptRecord 或者 ModuleRecord    | 函数所在的脚本或者模块                                                                                                                                                                             |
| \[\[ThisMode]]           | lexical \vert strict \vert global | 界定函数的形式参数与函数体的this如何解释。lexical意味着封闭在函数的词法this。strict意味着this就是此函数的调用。global意味着this是undefined或着null时，就解释成全局对象，否则使用ToObject转换后的值 |
| \[\[Strict]]             | Boolean                           | 如果是严格函数就是true，非严格函数是false                                                                                                                                                          |
| \[\[HomeObject]]         | Object                            | 如果函数使用了super，这就是其\[\[GEtPrototypeOf]]提供了查找super性质的开始位值的对象                                                                                                               |
| \[\[SourceText]]         | Unicode编码点序列                 | 定义函数的源文本                                                                                                                                                                                   |
| \[\[IsClassConstructor]] | Boolean                           | 指明此函数是否是一个类构造范。如果true，调用\[\[Call]]，会投掷一个TypeError异常                                                                                                                    |
  那找这里的定义，所有的ECMAScript函数对象都有\[\[Call]]内部方法。ECMAScript函
数对象有\[\[Construct]]内部方法时，也是一个构造范。
*** 10.2.1 \[\[Call]](thisArgument, argumentsList)
  ECMAScript函数对象F上的\[\[Call]]内部函数劫后参数thisArgument（ECMAScript语言
值）和argumentsList（List<ECMAScript语言值>）。被调用时执行下列步骤
1. Assert：F是ECMAScript函数对象
2. 让callerContext是运行时执行背景
3. 让calleeContext是PrepareForOrdinaryCall(F, undefined)
4. Assert：calleeContext现在是运行时执行背景
5. 如果F.\[\[IsClassConstructor]]是true，那么
    a. 让error是新创建的TypeError对象
    b. 注意：error是在calleeContext上带着F联结的RealmRecord被创建的
    c. 从ExecutionContextStack上移除calleeContext，并恢复callerContext作为运行时
       执行背景
    d. 返回ThrowCompletion(error)
6. 执行OrdinaryCallBindThis(F, calleeContext, thisArgument)
7. 让result是OrdinaryCallEvaluateBody(F, argumentsList)
8. 从ExecutionContextStack上移除calleeContext，并恢复callerContext作为运行时执行
   背景。
9. 如果result.\[\[Type]]是返回，返回NormalCompletion(result.\[\[Value]])
10. ReturnIfAbrupt(result)
11. 返回NormalCompletion(undefined)
**** 注意 当calleeContext在第8步被从ExecutionContextStack上移除后，如果它是被挂
           起并保留的，用于后来被可访问的Generator对象继续使用的话，它不能被
           摧毁。
**** 10.2.1.1 PrepareForOrdinaryCall(F, newTarget)
  抽象操作PrepareForOrdianryCall接受参数F（函数对象）和newTarget（ECMAScript语言
值）。被调用时执行下列步骤：
1. Assert：Type(newTarget)是Undefined或Object
2. 让callerContext是运行时执行背景
3. 让calleeContext是一个新的ECMAScript代码的执行背景
4. 设置calleeContext的Function是F
5. 让calleeRealm是F.\[\[Realm]]
6. 设置calleeContext的Realm是calleeRealm
7. 设置calleeContext的ScriptOrModule是F.\[\[ScriptOrModule]]
8. 让localEnv是NewFunctionEnvironment(F, newTarget)
9. 设置calleeContext的LexicalEnvironment是localEnv
10. 设置calleeContext的VariableEnvironment是localEnv
11. 如果callerContext没有挂起，挂起callerContext
12. 推送calleeContext到ExecutionContextStack；calleeContext现在是运行时执行背景
13. 注意：指由所有的异常对象都联结到calleeRealm
14. 返回calleeContext
**** 10.2.1.2 OrdinaryCallBindThis(F, calleeContext, thisArgument)
  抽象操作PrepareForOrdianryCall接受参数F（函数对象）、calleeContext（执行背景）
和thisArgument（ECMAScript语言值）。被调用时执行下列步骤：
1. 让thisMode是F.\[\[ThisMode]]
2. 如果thisMode是lexical，返回undefined
3. 让calleeRealm是F.\[\[Realm]]
4. 让localEnv是calleeContext的LexcicalEnvrionment
5. 如果thisMode是strict，让thisValue是thisArgument
6. 否则
    a. 如果thisArgument是undefined或着null，那么
        i. 让globalEnv是calleeRealm.\[\[GlobalEnv]]
       ii. Assert：globalEnv是全局环境记录
      iii. 让thisValue是globalEnv.\[\[GlobalThisValue]]
    b. 否则
        i. 让thisValue是!ToObject(thisArgument)
       ii. 注意：ToObject使用calleeRealm封装对象
7. Assert：localEnv是函数环境记录
8. Assert：下一步不会意外终结，因为localEnv.\[\[ThisBindingStatus]]没有初始化
9. 返回localEnv.BindThisValue(thisValue)
**** 10.2.1.3 Runtime Semantics: EvaluateBody
  带参数functionObject和argumentsList（List）
FunctionBody : FunctionStatementList
    1. 返回FunctionBody.?EvaluateFunctionBody(functionObject, argumentsList)
ConciseBody : ExpressionBody
    1. 返回ConciseBody.?EvaluateConciseBody(functionObject, argumentsList)
GeneratorBody : FunctionBody
    1. 返回GeneratorBody.?EvaluateGeneratorBody(functionObject, argumentsList)
AsyncGeneratorBody : FunctionBody
    1. 返回AsyncGeneratorBody.?EvaluateAsyncGeneratorBody(functionObject, argumentsList)
AsyncFunctionBody : FunctionBody
    1. 返回AsyncFunctionBody.?EvaluateAsyncFunctionBody(functionObject, argumentsList)
AsyncConciseBody : ExpressionBody
    1. 返回AsyncConciseBody.?EvaluateAsyncConciseBody(functionObject, argumentsList)
**** 10.2.1.4 OrdianryCallEvaluateBody(F, argumentsList)
  抽象操作OrdinaryCallEvaluateBody接受参数F（函数对象）和argumentsList（List）。
被调用时执行下列步骤：
1. 返回带参数F与argumentsList的F.\[\[ECMAScriptCode]]的已解析代码的EvaluateBody
*** 10.2.2 \[\[Construct]](argumentsList, newTarget)
  ECMAScript函数对象的内部方法\[\[Construct]]接受参数argumentsList（ECMAScript值
的List）和newTarget（构造范）。被调用时执行下列步骤：
1. Assert：F是ECMAScript函数对象
2. Assert：Type(newTarget)是Object
3. 让callerContext是运行时执行背景
4. 让kind是F.\[\[ConstructorKind]]
5. 如果kind是base，那么
    a. 让thisArgument是?OrdinaryCreateFromConstructor(newTarget, "%Object.prototype%")
6. 让calleeContext是PrepareForOrdianryCall(F, newTarget)
7. Assert：calleeContext现在是运行时执行背景
8. 如果kind是base，执行OrdinaryCallBindThis(F, calleeContext, thisArgument)
9. 让constructorEnv是caleeContext的LexicalEnvironment
10. 让result是OrdinaryCallEvaluateBody(F, argumentsList)
11. 从ExecutionContextStack移除calleeContext，恢复callerContext是运行时执行背景
12. 如果result.\[\[Type]]是return，那么
    a. 如果Type(result.\[\[Value]])是对象，返回NormalCompletion(result.\[\[Value]])
    b. 如果kind是base，返回NormalCompletion(thisArgument)
    c. 如果result.\[\[Value]]不是undefined，投掷TypeError异常
13. 否则 ReturnIfAbrupt(result)
14. 返回?constructorEnv.GetThisBinding()
*** 10.2.3 OrdinaryFunctionCreate(functionPrototype, sourceText, ParameterList, Body, 
thisMode, Scope)
  抽象操作OrdinaryFunctionCreate接受参数functionPrototype（Object），sourceText（
Unicode编码点序列），ParameterList（ParseNode），Body（ParseNode），thisMode（
lexical-this或者non-lexical-this）和Scope（环境记录）。sourceText是将创建的函数
的句法定义的源文件。被调用时执行下列步骤：
1. Assert：Type(functionPrototype)是Object
2. 让internalSlotsList是表29所列的内部占位
3. 让F是!OrdinaryObjectCreate(functionPrototype, internalSlotsList)
4. 设置F.\[\[Call]]是规范10.2.1的定义
5. 设置F.\[\[SourceText]]是sourceText
6. 设置F.\[\[FormalParameters]]是ParameterList
7. 设置F.\[\[ECMAScriptCode]]是Body
8. 如果Body的源文本是严格模式代码，让Strict是true，否则String是false
9. 设置F.\[\[Strict]]是Strict
10. 如果thisMode是lexical-this，设置F.\[\[ThisMode]]是lexical
11. 否则 如果Strict是true，设置F.\[\[ThisMode]]是strict
12. 否则 设置F.\[\[ThisMode]]是global
13. 设置F.\[\[IsCalassConstructor]]是false
14. 设置F.\[\[Environment]]是Scope
15. 设置F.\[\[ScriptOrModule]]是GetActiveScriptOrModule()
16. 设置F.\[\[Realm]]是当前的RealmRecord
17. 设置F.\[\[HomeObject]]是undefined
18. 让len是ParameterList的ExpectedArgumentCount
19. 执行!SetFunctionLength(F, len)
20. 返回F
*** 10.2.4 AddRestrictedFunctionProperties(F, realm)
  抽象操作AddRestrictedFunctionProperties接受参数F（函数对象）和realm（
RealmRecord）。被调用时执行下列步骤：
1. Assert：realm.\[\[Intrinsics]].\[\[%ThrowTypeError%]]存在且已经初始化。
2. 让thrower是realm.\[\[Intrinsics]].\[\[%ThrowTypeError%]]
3. 执行!DefinePropertyOrThrow(F, "caller", PropertyDescriptor { \[\[Get]]:thrower,
   \[\[Set]]:thrower, \[\[Enumerable]]:false, \[\[Configurable]]:true } )
4. 执行!DefinePropertyOrThrow(F, "arguments", PropertyDescriptor { \[\[Get]]:thrower,
   \[\[Set]]:thrower, \[\[Enumerable]]:false, \[\[Configurable]]:true } )
**** 10.2.4.1 %ThrowTypeError%()
  固有%ThrowTypeError%是匿名的内建函数对象，每个领都会定义一次。被调用时执
行下列步骤：
1. 投掷TypeError异常
  %ThrowTypeError%的\[\[Extensible]]是false
  %ThrowTypeError%的length性质的属性是{\[\[Wriable]]:false, \[\[Enumerable]]:false, 
\[\[Configurable]]:false }
  %ThrowTypeError%的name性质的属性是{\[\[Wriable]]:false, \[\[Enumerable]]:false, 
\[\[Configurable]]:false }
*** 10.2.5 MakeConstructor(F\[,writablePrototype\[,prototype]])
  抽象操作MakeConstructor接受参数F（函数对象）和可选参数writablePrototype（
Boolean）和prototype（对象）。将F转换为构造范。被调用时执行下列步骤：
1. Assert：F是ECMAScript函数对象或者内键函数对象
2. 如果F是ECMAScript函数对象，那么
    a. Assert：IsConstructor(F)是false
    b. Assert：F是可扩展对象，而且没有"prototype"自有性质
    c. 设置F.\[\[Construct]]是10.2.2中规定的定义
3. 设置F.\[\[ConstructorKind]]是base
4. 如果writablePrototype不存在，设置writablePrototype是true
5. 如果prototype不存在，那么
    a. 设置prototype是!OrdinaryObjectCreate(%Object.prototype%)
    b. 执行!DefinePropertyOrThrow(prototype, "constructor", PropertyDescriptor {
       \[\[Value]]:F, \[\[Writable]]:writablePrototype, \[\[Enumerable]]:false,
       \[\[Configurable]]:true })
6. 执行!DefinePropertyOrThrow(F, "prototype", PropertyDescriptor {
   \[\[Value]]:prototype, \[\[Writable]]:writablePrototype, \[\[Enumerable]]:false,
   \[\[Configurable]]:false })
7. 返回NormalCompletion(undefined)
*** 10.2.6 MakeClassConstructor(F)
  抽象操作MakeClassConstructor接受参数F。被调用时执行下列步骤：
1. Assert：F是ECMAScript函数对象
2. Assert：F.\[\[IsClassConstructor]]是false
3. 设置F.\[\[IsClassConstructor]]是true
4. 返回NormalCompletion(undefined)
*** 10.2.7 MakeMethod(F, homeObject)
  抽象操作MakeMethod接受参数F和homeObject。设置F为方法。被调用时执行下列步骤：
1. Assert：F是ECMAScript函数对象
2. Assert：Type(homeObject)是Object
3. 设置F.\[\[HomeObject]]是homeObject
4. 返回NormalCompletion(undefined)
*** 10.2.8 SetFunctionName(F,name \[,prefix])
  抽象操作SetFunctionName接受参数F和name（性质键）和可选参数prefix（String）。
在F上增加name性质。被调用时执行下列步骤：
1. Assert：F是可扩展对象，而且没有name自有性质
2. Assert：Type(name)是String或者Symbol
3. Assert：如果prefix存在，Type(prefix)是String
4. 如果Type(name)是Symbol，那么
    a. 让description是name的\[\[Description]]值
    b. 如果description是undefined，设置name是空字符串
    c. 否则，设置name是"["、description和"]"拼接的字符串
5. 如果F有\[\[InitialName]]的内部占位，那么
    a. 设置F.\[\[InitialName]]是name
6. 如果prefix存在，那么
    a. 设置name是prefix，0x0020和name的字符串拼接
    b. 如果F有\[\[InitialName]]内部占位，那么
        i. 可选的，设置F.\[\[InitialName]]是name
7. 返回!DefinePropertyOrThrow(F, "name", PropertyDescriptor { \[\[Value]]:name,
   \[\[Writable]]:false, \[\[Enumerable]]:false, \[\[Configurable]]:true })
*** 10.2.9 SetFunctionLength(F, length)
  抽象操作SetFunctionLength接受参数F（函数对象）和length（非负整数或者+∞）。
在F上添加"length"性质。被调用时执行下列步骤：
1. Assert：F是可扩展对象，而且没有length自有性质
2. 返回!DefinePropertyOrThrow(F, "length", PropertyDescriptor {
   \[\[Value]]:Number(length), \[\[Writable]]:false, \[\[Enumerable]]:false,
   \[\[Configurable]]:true })
*** 10.2.10 FunctionDeclarationInstantiation(func, argumentsList)
**** 注意1 当为评估ECMAScript函数的执行背景建立后，新的函数环境记录也创建完，
            而且在环境记录中绑定每个形式参数并初始化。在函数体的每个声明也
            初始化。如果函数的形式参数没有包含任何初始化值，那么函数体的声
            明也初始化到相同的环境记录中作为参数。如果参数的默认初始化值存
            在，为函数体声明创建第二个环境记录。形式参数和函数初始化为
            FunctionDeclarationInstantiation的某部分。其他的绑定都在评估函数体的
            时候初始化。
  抽象操作FunctionDeclarationInstantiation接受参数func（函数对象）和argumentsList。
func是正在为之建立执行背景的函数对象。被调用时执行下列步骤：
1. 让calleeContext是运行时执行背景
2. 让code是func.\[\[ECMAScriptCode]]
3. 让strict是func.\[\[Strict]
4. 让formals是func.\[\[FormalParameters]]
5. 让parameterNames是formals的BoundName
6. 如果parameterNames有重复实体，让hasDuplicates是true，否则hasDuplicates是false。
7. 让simpleParameterList是formals的IsSimpleParameterList
8. 让hasParameterExpressions是formals的ContainsExpression
9. 让varNames是code的VarDeclaredNames
10. 让varDeclarations是code的VarScopedDeclarations
11. 让lexicalNames是code的LexicallyDeclaredNames
12. 让functionNames是新的空List
13. 让functionsToInitialize是新的空List
14. 按照反序遍历varDeclarations的元素，记为d，做
    a. 如果d不是VariableDeclaration、ForBinding、BindingIdentifier那么
        i. Assert：d必然是FunctionDeclaration、GeneratorDeclaration、
           AsyncFunctionDeclaration或者AsyncGeneratorDeclaration之一
       ii. 让fn是d的BoundNames中的那个唯一元素。
      iii. 如果fn不是functionNames的元素，那么
            1. 将fn作为第一个元素插入到functionNames中。
            2. 注意：如果多个声明为相同名称的函数，最后一个生效
            3. 将d作为第一个元素插入到functionsToInitialize
15. 让argumentsObjectNeeded是true
16. 如果func.\[\[ThisMode]]是lexical，那么
    a. 注意：箭头函数没有arguments对象
    b. 设置argumentsObjectNeeded是false
17. 否则，如果arguments是parameterNames的元素，那么
    a. 设置argumentsObjectNeeded是false
18. 否则，如果hasParameterExpressions是false，那么
    a. 如果arguments是functionNames或者lexicalNames的元素，那么
        i. 设置argumentsObjectNeeded是false
19. 如果strict是true或者hasParameterExpressions是false，那么
    a. 注意：参数和顶层vars只需要一个环境记录
    b. 让env是caleeContext的LexicalEnvironment
20. 否则
    a. 注意：需要一个隔离的环境记录来确保在形式参数中的直接使用eval创建的
              绑定在参数声明的环境之外
    b. 让calleeEnv是calleeContext的LexicalEnvironmnet
    c. 让env是NewDeclarationEnvironment(calleeEnv)
    d. Assert：calleeContext的VariableEnvironment是calleeEnv
    e. 设置calleeContext的LexicalEnvironment是env
21. 遍历parameterNames的字符串，记为paramName，做
    a. 让alreadyDeclared是env.HasBinding(paramName)
    b. 注意：前期错误确保了重复的参数名只会发生在非严格函数里，那么就不会有
              参数默认值或者剩余参数
    c. 如果alreadyDeclared是false，那么
        i. 执行!env.CreateMutableBinding(paramName, false)
       ii. 如果hasDuplicate，那么
            1. 执行!env.InitializeBinding(paramName, undefined)
22. 如果argumentsObjectNeeded是true，那么
    a. 如果strict是true或者如果simpleParameterList是false，那么
        i. 让ao是CreateUnmappedArgumentsObject(argumentsList)
    b. 否则
        i. 注意：映射过的参数对象只提供给非严格函数，非严格函数没有剩余参
                  数、参数默认初始值和解构参数。
       ii. 让ao是CreateMappedArgumentsObject(func, formals, argumentsList, env)
    c. 如果strict是true，那么
        i. 执行!env.CreateImmutableBinding("arguments", false)
    d. 否则
        i. 执行!env.CreateMutableBinding("arguments", false)
    e. 调用env.InitializeBinding("arguments", ao);
    f. 让parameterBindings是List，其元素是parameterNames的元素拼接"arguments"
23. 否则
    a. 让parameterBindings是parameterNames
24. 让iteratorRecord是CreateListIteratorRecord(argumentsList)
25. 如果hasDuplicates是true，那么
    a. 为formals执行带iteratorRecord和undefined参数的?IteratorBindingInitialization
26. 否则
    a. 为formals执行带iteratorRecord和env参数的?IteratorBindingInitialization
27. 如果hasParameterExpressions是false，那么
    a. 注意：只需要一个环境记录就满足参数和顶层vars。
    b. 让instantiatedVarNames是parameterBindings List的复制
    c. 遍历varNames的元素记为n，做
        i. 如果n不是一个instantiatedVarNames的元素，那么
            1. 将n追加到instantiatedVarNames中
            2. 执行!env.CreateMutableBinding(n, false)
            3. 调用env.InitializeBinding(n, undefined)
    d. 让varEnv是env
28. 否则
    a. 注意：需要一个独立的环境记录确保：再形式参数的表达式创建的封闭不能
              访问到函数体内定义的声明。
    b. 让varEnv是NewDeclarativeEnvironment(env)
    c. 设置calleeContext的VariableEnvironment是varEnv
    d. 让instantiatedVarNames是新的空List
    e. 遍历varNames的元素记为n，做
        i. 如果n不是instantiatedVarNames的元素，那么
            1. 将n附加到instantiatedVarNames
            2. 执行!varEnv.CreateMutableBinding(n, false)
            3. 如果n不是parameterBindings的元素，或者n是functionNames的元素，让
               initialValue是undefined
            4. 否则
                a. 让initialValue是!env.GetBindingValue(n, false)
            5. 调用varEnv.InitializeBinding(n, initialValue)
            6. 注意：与形式参数里同名的变量有相同的初始化值
29. 注意：附件B.3.3.1在此处增加了额外的步骤。
30. 如果strict是false，那么
    a. 让lexEnv是NewDeclarativeEnvironment(varEnv)
    b. 注意：非严格函数为顶层词法声明使用独立环境记录，因此一个直接的eval
              能够明确由混淆有预先存在的顶层词法声明的eval代码中引入的任何
              变量声明的适用圈。对于严格函数使用严格的直接eval，总是将所有
              的声明放到新的环境记录里。
31. 否则让lexEnv是varEnv
32. 设置calleeXontext的LexicalEnvironment是lexEnv
33. 让lexDeclarations是code的LexicallyScopedDeclarations
34. 遍历lexDeclarations的元素记为d，做
    a. 注意：词法声明的名称不能与函数/生成器声明、形式参数或者变量的名字
              相同。词法声明的名称只能实例化，不能初始化。
    b. 遍历d的BoundNames的元素，记为dn，做
        i. 如果d的IsConstantDeclaration是true，那么
            1. 执行!lexEnv.CreateImmutableBinding(dn, true)
       ii. 否则
            2. 执行!lexEnv.CreateMutableBinding(dn, false)
35. 遍历functionsToInitialize的解析节点，记作f，做
    a. 让fn是f的BoundNames的独自元素
    b. 让fo是f的带lexEnv参数的InstantiateFunctionObject
    c. 执行!varEnv.SetMutableBinding(fn, fo, false)
36. 返回NormalCompletion(empty)
**** 注意2 B.3.3提供了一个扩展，以便兼容ECMAScript2015之前的ECMAScript的网页
            浏览器实现
**** 注意3 参数初始化可能包含直接eval的表达式。这种eval方式的顶层声明只能
            被本eval代码（11.2）察觉。这种声明产生的环境在8.5.3中描述。
** 10.3 内建函数对象Built-in Function Objects
  本规范定义的内建函数对象会被实现为ECMAScript函数对象（10.2），其行为使用
ECMAScript代码实现；或者实现为函数奇异对象，其行为以其他方式提供。在各自的
方式中，调用函数的效果必须遵循各自的规范内容。实现可能会提供额外的不是
本规范定义的内建函数对象。
  如果一个内建的函数对象被实现为一个奇异对象，必须有10.1中定义的基本对象的
行为。所有的这种函数奇异对象也要有\[\[Prototype]]、\[\[Extensible]]和\[\[Realm]]
内部占位。
  除非其他规定，每个内建函数对象都有%Function.prototype%对象，作为其
\[\[Prototype]]内部占位的初始化值。
  通过算法步骤或者其他方式对每个内建函数规定的行为是为函数的\[\[Call]]和
\[\[Construct]]调用的函数体时的行为的规范。然而\[\[Construct]]调用不被所有的
内建函数支持。每个内建函数，在由\[\[Call]]调用时，\[\[Call]]的thisArgument提供
this值，\[\[Call]]的argumentList提供命名了的参数，NewTarget值是undefined。当由
\[\[Construct]]调用时，this是未初始化的，\[\[Construct]]的argumentList提供命名了
的参数，newTarget参数提供了NewTarget值。如果内建函数是用ECMAScript函数对象的
方式实现，那么规定的行为必须被函数体的ECMAScript代码实现。ECMAScript函数对象
实现的内建函数必须是严格函数。如果内建的构造范的\[\[Call]]行为有投掷TypeError
异常之外的行为，这个函数的ECMAScript实现必须以不能导致函数的内部占位
\[\[IsClassConstructor]]为true的方式完成。
  没有被确定为构造范的内建函数对象不要实现\[\[Construct]]内部函数，除非在
特定的函数里另有规定。当内建的构造范被作为new表达式的一部分被调用时，被调
用的\[\[Construct]]内部方法的argumentsList参数提供了内建构造范的命名了的参数。
  不是构造范的内建函数没有prototype性质，除非在特定函数里另有规定。
  内建函数有\[\[InitialName]]内部占位。
  如果一个内建函数没有使用ECMAScript函数的方式方式来实现，必须提供遵循下列
定义的\[\[Call]]和\[\[Construct]]内部方法。
*** 10.3.1 \[\[Call]](thisArgument, argumentsList)
  内建函数F的\[\[Call]]内部方法接受参数thisArgument（ECMAScript语言值）和
argumentsList（元素是ECMAScript语言值的List）。被调用时执行下列步骤：
1. 让callerContext是运行时执行背景
2. 如果callerContext没有被挂起，挂起callerContext
3. 让calleeContext是新的执行背景
4. 设置calleeContext的Function是F
5. 让calleeRealm是F.\[\[Realm]]
6. 设置calleeContext的Realm是calleeRealm
7. 设置calleeContext的ScriptOrModule是null
8. 执行calleeContext初始化需要的实现定义
9. 将calleeContext压到ExecutionContextStack；calleeContext目前是运行时执行背景
10. 让result是与规范F一致方式评估F的完结记录。thisArgument是this值，argumentsList
    提供命名了的参数，NewTarget值是undefined。
11. 从ExecutionContextStack移除calleeContext，恢复callerContext作为运行时执行背景
12. 返回result
**** 注意： 当calleeContext被从ExecutionContextStack中移除后，它不能被销毁，如果
             它被一个可访问的生成器对象为了唤醒而挂起和保留的话。
*** 10.3.2 \[\[Construct]](arugmentsList, newTarget)
  内建方法F的\[\[Construct]]内部方法接受参数argumentsList（元素是ECMAScript
语言值的List）和newTarget（构造范）。执行步骤同\[\[Call]](10.3.1)，除了第10步：
10. 让result是与规范F一致方式评估F的完结记录。this值是未初始化的，
    argumentsList提供命名了的参数，newTarget作为NewTarget的值。
*** 10.3.3 CreateBuiltinFunction(steps, length, name, internalSlotsList\[, realm\[,
    prototype\[, prefix]]])
  抽象操作CreateBuiltinFunction接受参数steps、length、name和internalSlotsList（内部
占位的名称的List）与可选参数realm、prototype和prefix。internalSlotsList包含了作为
对象必须定义的其他内部占位的名字。操作创建内建的函数对象。被调用时执行下
列步骤：
1. Assert：steps是一套算法的步骤或者本规范提供的关于函数行为的其他定义。
2. 如果realm不存在或者realm是空，设置realm是当前的RealmRecord
3. Assert：realm是ReamlRecord
4. 如果prototype不存在，设置prototype是
   realm.\[\[Intrinsics]].\[\[%Function.prototype%]]
5. 让func是新的内建函数对象，被调用时执行steps描述的动作。新的函数对象有
   列在internalSlotsList的名称的内部占位和\[\[InitialName]]内部占位。
6. 设置func.\[\[Realm]]是realm
7. 设置func.\[\[Prototype]]是prototype
8. 设置func.\[\[Extensible]]是true
9. 设置func.\[\[InitialName]]是null
10. 执行!SetFunctionLength(func, length)
11. 如果prefix不存在，那么
    a. 执行!SetFunctionName(func, name)
12. 否则
    a. 执行!SetFunctionName(func, name, prefix)
13. 返回func
  每个本规范定义的内建函数是通过调用CreateBuiltinFunction抽象操作创建的。
** 10.4 内建奇异对象内部方法和占位
  本规范定义了几个内建的奇异对象。这些对象一般的行为类似基本对象，除了
少量特定情况。下列的奇异对象使用基本对象的内部方法，除了下列显示规定的
例外情况。
*** 10.4.1 Bound Function Exotic Objects 绑定了this的函数对象
  BoundFunctionExoticObject是包装了其他函数的函数对象。BoundFunctionExoticObject是
可调用的（有\[\[Call]]内部方法，也可能有\[\[Construct]]内部方法）。调用一个
BoundFunctionExoticObject一般导致它包装的函数被调用。
  如果对象的\[\[Call]]和\[\[Construct]]（如果有）的内部方法按照随后的实现方式，
其他的基本内部方法使用10.1中定义的方式，那它就是BoundFunctionExoticObject。这些
方法在BoundFunctionCreate中被安进来。
  BoundFunctionExoticObject没有列在表29的ECMAScript函数对象的内部占位。表30列出
的内部占位作为他们的替换，除了\[\[Prototype]]和\[\[Extensible]]
| 内部占位                  | 类型           | 描述                                 |
| \[\[BoundTargetFunction]] | 可调用的Object | 被包装的函数对象                     |
| \[\[BoundThis]]           | 任意           | 其值总是作为调用被包装函数时的this值 |
| \[\[BoundArguments]]      | 任意值的List   | 元素作为被包装函数调用时的第一个参数 |
**** 10.4.1.1 \[\[Call]](thisArgument, argumentsList)
  BoundFunctionExoticObject F的内部方法\[\[Call]]接受参数thisArgument（ECMAScript语
言值）和argumentsList（ECMAcript语言值的List）。被调用时执行下列步骤：
1. 让target是F.\[\[BoundTargetFunction]]
2. 让boundThis是F.\[\[BoundThis]]
3. 让boundArgs是F.\[\[BoundArguments]]
4. 让args是boundArgs的元素追加上argumentsList的元素的List
5. 返回?Call(target, boundThis, args)
**** 10.4.1.2 \[\[Construct]](argumentsList, newTarget)
  BoundFunctionExoticObject F的内部方法\[\[Construct]]接受参数argumentsList（
ECMAScript语言值的List）和newTarget（构造范）。被调用时执行下列步骤：
1. 让target是F.\[\[BoundTargetFunction]]
2. Assert：IsConstructor(target)是true
3. 让boundArgs是F.\[\[BoundArguments]]
4. 让args是boundArgs的元素追加上argumentsList的元素的List
5. 如果SameValue(F, newTarget)是true，设置newTarget为target
6. 返回?Construct(target, args, newTarget)
**** 10.4.1.3 BoundFunctionCreate(targetFunction, boundThis, boundArgs)
  抽象操作BoundFunctionCreate接受参数targetFunction、boundThis和boundArgs。用于规范
新的BoundFunctionExoticObject对象的创建行为。被调用时执行下列步骤：
1. Assert：Type(targetFunction)是Object
2. 让proto是?targetFunction.\[\[GetPrototypeOf]]()
3. 让internalSlotsList是表30列出的内部占位，加上\[\[Prototype]]和\[\[Extensible]]的
   List
4. 让obj是!MakeBasicObject(internalSlotsList)
5. 设置obj.\[\[Prototype]]是proto
6. 设置obj.\[\[Call]]是10.4.1.1中定义内容
7. 如果IsConstructor(targetFunction)是true，那么
    a. 设置obj.\[\[Construct]]是10.4.1.2中描述的内容
8. 设置obj.\[\[BoundTargetFunction]]是targetFunction
9. 设置obj.\[\[BoundThis]]是boundThis
10. 设置obj.\[\[BoundArguments]]是boundArguments
11. 返回obj
*** 10.4.2 Array Exotic Objects 数组奇异对象
  数组对象是一个奇异对象在处理ArrayIndex性质键（6.1.7）时给了特殊对待。性质的
名称是一个ArrayIndex的话，性质也被称作元素。每个数组对象有个一个不可设置的
length性质，它的值总是一个非负整数Number，其数学值小于2^32。length性质的值在
数字上大于所拥有的任何性质名称是ArrayIndex的性质键。无论何时，如果数组对象
创建或修改了自有性质，或者其他性质需要必要的调整以保证这个不变性。尤其是，
当增加一个名称是ArrayIndex的性质，length性质的值发生修改，如果必要，length值
比这个ArrayIndex的值大1；当length性变化的是，每个名称是ArrayIndex且没有小于
length的性质会被删除。这个限制仅提供给数组对象的自有性质，而从其原型上继承
的length和ArrayIndex性质则没有这种影响。
**** 注意 String性质名称P是ArrayIndex，当且仅当ToString(ToUint32(P))等与P，且
           ToUint32(P)b不是F(2^32-1)
  对象是ArrayExoticObject（简单的说，数组对象），其\[\[DefineOwnProperty]]内部方
法使用下列的实现，其他基本内部方法使用10.1的定义。这些方法在ArrayCreate中被
安装进来。
**** 10.4.2.1 \[\[DefineOwnProperty]](P, Desc)
  ArrayExoticObject A的内部方法\[\[DefineOwnProperty]]接受参数P（性质键）和Desc（
PropertyDescriptor）。被调用时执行下列步骤：
1. Assert：IsPropertyKey(P)是true
2. 如果P是length，那么
    a. 返回?ArraySetLength(A, Desc)
3. 否则，如果P是ArrayIndex，那么
    a. 让oldLenDesc是OrdinaryGetOwnProperty(A, "length")
    b. Assert：!IsDataDescriptor(oldLenDesc)是true
    c. Assert：oldLenDesc.\[\[Configurable]]是false
    d. 让oldLen是oldLenDesc.\[\[Value]]
    e. Assert：oldLen是一个非负整数Number
    f. 让index是!ToUint32(P)
    g. 如果index >= oldLen且oldLenDesc.\[\[Writable]是false，返回false
    h. 让succeeded是!OrdinaryDefineOwnProperty(A, P, Desc)
    i. 如果succeeded是false，返回false
    j. 如果index>=oldLen，那么
        i. 设置oldLenDesc.\[\[Value]]是index+1_F
       ii. 让succeeded是OrdinaryDefineOwnProperty(A "length", oldLenDesc)
      iii. Assert：succeeded是true
    k. 返回true
4. 返回OrdinaryDefineOwnProperty(A, P, Desc)
**** 10.4.2.2 ArrayCreate(length\[, proto])
  抽象操作ArrayCreate接受参数length（非负整数）和可选参数proto。用于规范新的
数组奇异对象的创建。被调用时执行下列步骤：
1. 如果length>2^32-1，投掷RangeError异常
2. 如果proto不存在，设置proto是%Array.prototype%
3. 设置A是!MakeBasicObject(<<\[\[Prototype]], \[\[Extensible]]>>)
4. 设置A.\[\[Prototype]]是proto
5. 设置A.\[\[DefineOwnProperty]]符合10.4.2.1中定义
6. 执行!OrdinaryDefineOwnProperty(A, "length", PropertyDescriptor {
   \[\[Value]]:F(length), \[\[Writable]]:true, \[\[Enumerable]]:false,
   \[\[Configurable]]:false })
7. 返回A
**** 10.4.2.3 ArraySpeciesCreate(originalArray, length)
  抽象操作ArraySpeciesCreate接受参数originalArray和length（非负整数）。用于规范从
originalArray派生的构造范创建一个新的Array对象的过程。被调用时执行下列步骤：
1. 让isArray是?IsArray(originalArray)
2. 如果isArray是false，返回?ArrayCreate(length)
3. 让C是?Get(originalArray, "constructor")
4. 如果IsConstructor(C)是true，那么
    a. 让thisRealm是当前的RealmRecord
    b. 让realmC是?GetFunctionRealm(C)
    c. 如果thisRealm和reamlC不相同，那么
        i. 如果SameValue(C, realmC.\[\[Intrinsics]].\[\[%Array%]])是true，
           设置C是undefined
5. 如果Type(C)是Object，那么
    a. 设置C是?Get(C,@@species)
    b. 如果C是null，设置C是undefined
6. 如果C是undefined，返回?ArrayCreate(length)
7. 如果IsConstructor(C)是false，投掷TypeError异常
8. 返回?Constructor(C, <<F(length)>>0)
***** 注意 如果originalArray是用标准内建Array构造范为不是运行时执行背景的领而
            创建的，那么新的Array使用运行时执行背景的领进行创建。这维护了网页
            浏览器的兼容性，以往有用Array.prototype方法的行为，而现在用
            ArraySpeciesCreate
**** 10.4.2.4 ArraySetLength(A, Desc)
  抽象操作ArraySetLength接受参数A（数组对象）和Desc（PropertyDescriptor）。被调用
时执行步骤：
1. 如果缺少Desc.\[\[Value]]，那么
    a. 返回OrdinaryDefineOwnProperty(A, "length", Desc)
2. 让newLenDesc是Desc的备份
3. 让newLen是?ToUint32(Desc.\[\[Value]])
4. 让numberLen是?ToNumber(Desc.\[\[Value]])
5. 如果newLen与numberLen不相同，投掷RangeError异常
6. 设置newLenDesc.\[\[Value]]是newLen
7. 让oldLenDesc是OrdinaryGetOwnProperty(A, "length")
8. Assert：!IsDataDescriptor(oldLenDesc)是true
9. Assert：oldLenDesc.\[\[Configurable]]是false
10. 让oldLen是oldLenDesc.\[\[Value]]
11. 如果 newLen>= oldLen，那么
    a. 返回OrdinaryDefineOwnProperty(A, "length", newLenDesc)
12. 如果oldLenDesc.\[\[Writable]]是false，返回false
13. 如果缺少newLenDesc.\[\[Writable]]或者其值是true，让newWritable是true
14. 否则
    a. 注意：设置\[\[Writable]]属性是false，暗示了其性质不能被删除。
    b. 让newWritable是false
    c. 设置newLenDesc.\[\[Writable]]是true
15. 让succeeded是!OrdinaryDefineOwnProperty(A, "length", newLenDesc)
16. 如果succeeded是false，返回false
17. 遍历A上是ArrayInde的自有性质，记作P，且其数学值大于或等与newLen（这里
    不能使用不小于，因为有非数字键），按照数字降序，做：
    a. 让deleteSucceeded是!A.\[\[Delete]](P)
    b. 如果deleteSucceeded是false，那么
        i. 设置newLenDesc.\[\[Value]]是!ToUint32(P)+1_F
       ii. 如果newWritable是false，设置newLenDesc.\[\[Writable]]是false
      iii. 执行!OrdinaryDefineOwnProperty(A, "length", newLenDesc)
       iv. 返回false
18. 如果newWritable是false，那么
    a. 让succeeded是!OrdinaryDefineOwnProperty(A, "lenfth", PropertyDescriptor {
       \[\[Writable]]:false } )
    b. Assert：succeeded是true
19. 返回true
***** 注意 步骤3和4，如果Desc.\[\[Value]]是对象，其valueOf会执行两次。这是本
            规范从第二版开始规定的遗留行为。
*** 10.4.3 String Exotic Objects
  String对象是一个封装了String值的奇异对象，而且暴露了虚拟的整数索引的数据性
质，对应检索String值的编码单元。String奇异对象总是有数据性质length，其值表示
封装的String值的编码单元数量。编码单元数据性质和length性质都是不可修改与
不可设置的。
  如果对象的\[\[GetOwnProperty]]、\[\[DefineOwnProerty]]和\[\[OwnPropertyKeys]]的内部
方法使用随后的实现，且其他基本内部方法使用10.1中的定义，对象就是String奇异对
象（简单说String对象）。在StringCreate中安装这些方法。
  String奇异对象与基本对象有相同的内部占位。他们都有\[\[StringData]]内部占位。
**** 10.4.3.1 \[\[GetOwnProperty]](P)
  StringExoticObject S的\[\[GetOwnProperty]]内部方法接受参数P（性质键）。被调用时
执行下列步骤：
1. Assert：IsPropertyKey(P)是true
2. 让desc是OrdinaryGetOwnProperty(S, P)
3. 如果desc不是undefined，返回desc
4. 返回!StringGetOwnProperty(P, Desc)
**** 10.4.3.2 \[\[DefineOwnProperty]](P, Desc)
  StringExoticObject S的\[\[DefineOwnProperty]]内部方法接受参数P（性质键）和Desc（
PropertyDescriptor）。被调用时执行下列步骤：
1. Assert：IsPropertyKey(P)是true
2. 让stringDesc是!StringGetOwnProperty(S, P)
3. 如果stringDesc不是undefined，那么
    a. 让extensible是S.\[\[Extensible]]
    b. 返回!IsCompatiblePropertyDescriptor(extensible, Desc, stringDesc)
4. 返回!OrdinaryDefineOwnProperty(S, P, Desc)
**** 10.4.3.3 \[\[OwnPropertyKeys]]()
  StringExoticObject O的\[\[OwnPropertyKeys]]内部方法不接受参数P。被调用时执行
下列步骤：
1. 让keys是新的空List
2. 让str是O.\[\[StringData]]
3. Assert：Type(str)是String
4. 让len是str的长度
5. 从0开始便到len，记作i，i<len，按照升序做：
    a. 追加!ToString(F(i))到keys
6. 遍历O的自有性质，记作P，如果P是ArrayIndex，且!ToIntegerOrInfinity(P)>=len，
   那么按照升序，做
    a. 追加P到keys
7. 遍历O的自有性质，记作P，若Type(P)是String且P不是ArrayIndex，按照创建时间
   升序，做
    a. 追加P到keys
8. 遍历O的自有性质，记作P，若Type(P)是Symbol，按照创建时间升序，做
    a. 追加P到keys
9. 返回keys
**** 10.4.3.4 StringCreate(value, prototype)
  抽象操作StringCreate接受参数value（String）和prototype。用于规范
StringExoticObject的创建过程。被调用时执行下列步骤：
1. 让S是!MakeBasicObject(<<\[\[Prototype]], \[\[Extensible]], \[\[StringData]]>>)
2. 设置S.\[\[Prototype]]是prototype
3. 设置S.\[\[StringData]]是value
4. 设置S.\[\[GetOwnProperty]]是10.4.3.1中定义
5. 设置S.\[\[DefineOwnProperty]]是10.4.3.2中定义
6. 设置S.\[\[OwnPropertyKeys]]是10.4.3.3中定义
7. 让length是value的编码单元数量
8. 执行!DefinePropertyOrThrow(S, "length", PropertyDescriptor { \[\[Value]]:F(length),
   \[\[Writable]]:false, \[\[Enumerable]]:false, \[\[Configurable]]:false] })
9. 返回S
**** 10.4.3.5 StringGetOwnProperty(S, P)
  抽象操作StringGetOwnProperty接受参数S和P。被调用时执行下列步骤：
1. Assert：S是有\[\[StringData]]内部占位的对象
2. Assert：IsPropertyKey(P)是true
3. 如果Type(P)不是String，返回undefined
4. 让index是!CanonicalNumericIndexString(P)
5. 如果index是undefined，返回undefined
6. 如果IsIntegralNumber(index)是false，返回undefined
7. 如果index是-0_F，返回undefined
8. 让str是S.\[\[StringData]]
9. Assert：Type(str)是String
10. 让len是str的长度
11. 如果R(index)<0或者len<=R(index)返回undefined
12. 让resultStr是一个长度1，包含str上处于R(index)的一个编码单元。
13. 返回PropertyDescriptor { \[\[Value]]:resultStr, \[\[Writable]]:false,
    \[\[Enumerable]]:true, \[\[Configurable]]:false }
*** 10.4.4 Arguments Exotic Objects
  大多数函数制作一个其函数体代码可见的参数对象。依赖于函数定义的特性，这个
参数对象是基本对象或者参数奇异对象。参数奇异对象是奇异对象，其ArrayIndex性质
映射到调用其联结的ECMAScript函数的形式参数。
  如果对象使用下方实现了其内部方法，其他内部方法使用10.1的定义实现，就是
参数奇异对象。CreateMappedArgumentsObject安装这些方法。
**** 注意1 CreateUnmappedArgumentsObject也安装到了本条款，用于创建基本对象，而不
            是参数奇异对象。
  参数奇异对象与基本对象有相同的内部占位。还有\[\[ParameterMap]]内部占位。基
本参数对象也有一个\[\[ParameterMap]]内部占位，其值总是undefined。对于基本参数
对象，\[\[ParameterMap]]内部占位仅用于Object.prototype.toString（20.1.3.6）来辨别
他们。
**** 注意2 ArgumentsExoticObject的名称数学值比对应函数对象的形式参数的索引小的
           整数索引的数据性质在初始化共享函数在执行上下文的实际参数的绑定。
           这意味正修改性质会修改实参的值，反过来也一样。这种一致性会在被
           破坏，如果这样的性质被删除后又增加进来，或者修改为访问性质。如果
           参数对象是基本对象，性质的值应该是参数传递进来的简单复制，就不会
           有性质值与形式参数值的动态链接。
**** 注意3 ParameterMap对象和其性质被用于明确说明参数对象与参数绑定一致的设
           备。ParameterMap对象和其性质的值的对象不能被ECMAScript代码直接访问
           到。ECMASCript实现可以不实际创建这个对象来实现规定的语义。
**** 注意4 基本参数对象定义了一个不可设置的访问性质，名称是callee，在访问时
            会投掷异常。这个callee对于ArgumentExotic对象有更多特殊的汉所以，
            仅会为某些非严格函数类来创建。在基本不变性中关于本性质的定义
            用于确保它不会被任何ECMAScript一致实现以任何方式定义。
**** 注意5 ArgumentsExoticObject的ECMAScript实现有一个历史遗留性质caller。2017
            之前的版本，规范在OrdinaryArgumentsObject中包含了一个会投掷异常的
            caller性质。既然实现不在包含本扩展，ECMAScript2017移除了这个投掷
            异常的caller要求
**** 10.4.4.1 \[\[GetOwnProperty]](P)
  ArgumentsExoticObject args的内部方法\[\[GetOwnProperty]]接受参数P（性质键）。被
调用时执行下列步骤：
1. 让desc是OrdinaryGetOwnProperty(args, P)
2. 如果desc是undefined，返回desc
3. 让map是args.\[\[ParamterMap]]
4. 让isMapped是!HasOwnProperty(map, P)
5. 如果isMapped是true，那么
    a. 设置desc.\[\[Value]]是Get(map,P)
6. 返回desc
**** 10.4.4.2 \[\[DefineOwnProperty]](P, Desc)
  ArgumentsExoticObject args的内部方法\[\[DefineOwnProperty]]接受参数P（性质键）和
Desc（PropertyDescriptor）。被调用时执行下列步骤：
1. 让map是args.\[\[ParamterMap]]
2. 让isMapped是HasOwnProperty(map,P)
3. 让newArgDesc是Desc
4. 如果isMapped是true，而且IsDataDescriptor(Desc)是true，那么
    a. 如果Desc.\[\[Value]]不存在，而且Desc.\[\[Writable]]存在，且值是false，那么
        i. 设置newArgDesc是Desc的备份
       ii. 设置newArgDesc.\[\[Value]]是Get(map, P)
5. 让allowed是?OrdinaryDefineOwnProperty(args, P, newArgDesc)
6. 如果allowed是false，返回false
7. 如果isMapped是true，那么
    a. 如果IsAccessorDescriptor(Desc)是true，那么
        i. 调用map.\[\[Delete]](P)
    b. 否则
        i. 如果Desc.\[\[Value]]存在，那么
            1. 让setStatus是Set(map, P, Desc.\[\[Value]], false)
            2. Assert：setStatus是true。因为参数对象映射的形式参数总是可写的。
       ii. 如果Desc.\[\[Writable]]存在，且是false，那么
            1. 调用map.\[\[Delete]](P)
8. 返回true
**** 10.4.4.3 \[\[Get]](P, Receiver)
  ArgumentsExoticObject args的内部方法\[\[GetOwnProperty]]接受参数P（性质键）和
Receiver(ECMAScript语言值）。被调用时执行下列步骤：
1. 让map是args.\[\[ParamterMap]]
2. 让isMapped是!HasOwnProperty(map,P)
3. 如果isMapped是false，那么
    a. 返回?OrdinaryGet(args, P, Receiver)
4. 否则
    a. Assert：map包含形式参数P
    b. 返回Get(map, P)
**** 10.4.4.4 \[\[Set]](P, V, Receiver)
  ArgumentsExoticObject args的内部方法\[\[Set]]接受参数P（性质键）、V（ECMAScript
语言值）和Receiver（ECMAScript语言值）。被调用时执行下列步骤：
1. 如果SameValue(args, Receiver)是false，那么
    a. 让isMapped是false
2. 否则
    a. 让map是args.\[\[ParameterMap]]
    b. 让isMapped是!HasOwnProperty(map, P)
3. 如果isMapped是true，那么
    a. 让setStatus是Set(map, P, V, false)
    b. Assert：setStatus是true。因为参数对象映射的形式参数总是可写的
4. 返回?OrdinarySet(args, P, V, Receiver)
**** 10.4.4.5 \[\[Delete]](P)
  ArgumentsExoticObject args的内部方法\[\[Delete]]接受参数P（性质键）。被调用时
执行下列步骤：
1. 让map是args.\[\[ParameterMap]]
2. 让isMapped是!HasOwnProperty(map,P)
3. 让result是?OrdinaryDelete(args, P)
4. 如果result是true，而且isMapped是true，那么
    a. 调用map.\[\[Delete]](P)
5. 返回result
**** 10.4.4.6 CreateUnmappedArgumentsObject(argumentsList)
  抽象操作CreateUnmappedArgumentsObject接受参数argumentsList。被调用时执行下列步
骤：
1. 让len是argumentsList的元素数量
2. 让obj是!OrdinaryObjectCreate(%ObjectPrototype%, <<\[\[ParameterMap]]>>)
3. 设置obj.\[\[ParameterMap]]是undefined
4. 执行DefinePropertyOrThrow(obj, "length", PropertyDescriptor { \[\[Value]]:F(len),
   \[\[Writable]]:true, \[\[Enumerable]]:false, \[\[Configurable]]:true })
5. 让index是0
6. 当index < len时，重复
    a. 让val是arugmentsList[index]
    b. 执行!CreateDataPropertyOrThrow(obj, !ToString(F(index)), val)
    c. 设置index是index+1
7. 执行!DefinePropertyOrThrow(obj, @@iterator, PropertyDescriptor( {
   \[\[Value]]:%Array.prototype.values%, \[\[Writable]]:true, \[\[Enumerable]]:false,
   \[\[Configurable]]:true } )
8. 执行!DefinePropertyOrThrow(obj, "callee", PropertyDescriptor( {
   \[\[Get]]:%ThrowTypeError%, \[\[Set]]:%ThrowTypeError%, \[\[Enumerable]]:false,
   \[\[Configurable]]:false } )
9. 返回obj
**** 10.4.4.7 CreateMappedArgumentsObject(func, formals, argumentsList, env)
  抽象操作CreateMappedArgumentsObject接受参数func（Object）、formals（ParseNode）、
argumentsList（List）和env（EnvironmentRecord）。被调用时执行下列步骤：
1. Assert：formals不包含剩余参数，绑定模式，或者初始化值。有可能包含重复的
   标记。
2. 让len是arugmentsList的元素数量
3. 让obj是!MakeBasicObject(<<\[\[Prototype]],\[\[Extensible]],\[\[ParamterMap]]>>)
4. 设置obj.\[\[GetOwnProperty]]是10.4.4.1中定义
5. 设置obj.\[\[DefineOwnProperty]]是10.4.4.2中定义
6. 设置obj.\[\[Get]]是10.4.4.3中定义
7. 设置obj.\[\[Set]]是10.4.4.4中定义
8. 设置obj.\[\[Delte]]是10.4.4.5中定义
9. 设置obj.\[\[Protptype]]是%Object.prototype%
10. 让map是!OrdinaryObjectCreate(null)
11. 设置obj.\[\[ParameterMap]]是map
12. 让parameterNames是formals的BoundNames
13. 让numberOfParamters是parameterNames的元素数量
14. 让index是0
15. 当index<len时，重复
    a. 让val是argumentsList\[index]
    b. 执行!CreateDataPropertyOrThrow(obj, !ToString(F(index)), val)
    c. 设置index是index+1
16. 执行!DefinePropertyOrThrow(obj, "length", PropertyDescriptor { \[\[Value]]:F(len),
    \[\[Writable]]:true, \[\[Enumerable]]:false, \[\[Configurable]]:true })
17. 让mappedNames是新的空List
18. 让index是numberOfParameters-1
19. 当index>=0是，重复
    a. 让name是parameterNames[index]
    b. 如果name不是mappedNames的元素，那么
        i. 增加name作为mappedNames的元素
       ii. 如果index<len，那么
            1. 让g是MakeArgGetter(name, env)
            2. 让p是MakeArgSetter(name, env)
            3. 执行map.\[\[DefineOwnProperty]](!ToString(F(index)), PropertyDescriptor {
               \[\[Set]]:p, \[\[Get]]:g, \[\[Enumerable]]:false,
               \[\[Configurable]]:true })
    c. 设置index是index-1
20. 执行!DefinePropertyOrThrow(obj, @@iterator, PropertyDescriptor {
    \[\[Value]]:%Array.prototype.values%, \[\[Writable]]:true, \[\[Enumerable]]:false,
    \[\[Configurable]]:true })
21. 执行!DefinePropertyOrThrow(obj, "callee", PropertyDescriptor { \[\[Value]]:func,
    \[\[Writable]]:true, \[\[Enumerable]]:false, \[\[Configurable]]:true })
22. 返回obj
***** 10.4.4.7.1 MakeArgGetter(name, env)
  抽象操作MakeArgGetter接受参数name（String）和env（EnvironmentRecord）。创建一个
内建函数，执行时返回env上name绑定的值。被调用时执行下列步骤：
1. 让steps是随后规定的ArgGetter函数的步骤
2. 让length是随后规定的ArgGetter函数不可选参数的数量
3. 让getter是!CreateBuiltinFunction(steps, length, "",<<\[\[Name]], \[\[Env]]>>)
4. 设置getter.\[\[Name]]是name
5. 设置getter.\[\[Env]]是env
6. 返回getter
  ArgGetter函数是一个匿名内建函数，有\[\[Name]]和\[\[Env]]内部占位。当不期望
参数的ArgGetter被调用时，执行下列步骤：
1. 让f是活跃函数对象
2. 让name是f.\[\[Name]]
3. 让env是f.\[\[Env]]
4. 返回env.GetBindingValue(name, false)
****** 注意 ArgGetter永远不会被ECMAScript代码直接访问到。
***** 10.4.4.7.2 MakeArgSetter(name, env)
  抽象操作MakeArgSetter接受参数name（String）和env（EnvironmentRecord）。创建一个
内建函数，执行时设置env上name绑定的值。被调用时执行下列步骤：
1. 让steps是随后规定的ArgSetter函数的步骤
2. 让length是随后规定的ArgSetter函数不可选参数的数量
3. 让setter是!CreateBuiltinFunction(steps, length, "",<<\[\[Name]], \[\[Env]]>>)
4. 设置setter.\[\[Name]]是name
5. 设置setter.\[\[Env]]是env
6. 返回setter。
  ArgSetter函数是一个有\[\[Name]]和\[\[Env]]内部占位的匿名内建函数。当ArgSetter被
带value参数调用时，执行下列步骤：
1. 让f是活跃函数对象
2. 让name是f.\[\[Name]]
3. 让env是f.\[\[Env]]
4. 返回env.SetMutableBinding(name, value, false)
****** 注意 ArgSetter永远不会被ECMAScript代码直接访问到。
*** 10.4.5 Integer-Indexed Exotic Object 整数索引奇异对象
  整数索引奇异对象是值会特殊处理整数索引性质键的奇异对象。
  整数索引奇异对象有基本对象的内部占位，还有\[\[ViewedArrayBuffer]]、
\[\[ArrayLength]]、\[\[ByteOffset]]、\[\[ContentType]]和\[\[TypedArrayName]]内部占
位。
  如果一个对象\[\[GetOwnProperty]]、\[\[HasProperty]]、\[\[DefineOwnProperty]]、
\[\[Get]]、\[\[Set]]、\[\[Delete]]和\[\[OwnPropertyKey]]内部方法使用本节定义，其
它的基础内部方法使用10.1中定义，这就是整数索引奇异对象。这些方法在
IntegerIndexedObjectCreate中被安装。
**** 10.4.5.1 \[\[GetOwnProperty]](P)
  IntegerIndexedExoticObject O的\[\[GetOwnProperty]]内部方法接受参数P（性质键）。
被调用时执行下列步骤：
1. Assert：IsPropertyKey(P)是true
2. Assert：O是IntegerIndexedExoticObject
3. 如果Type(P)是String，那么
    a. 让numericIndex是!CanonicalNumericIndexString(P)
    b.  如果numericIndex不是undefined，那么
        i. 让value是!IntegerIndexedElementGet(O, numericIndex)
       ii. 如果value是undefined，返回undefined
      iii. 返回PropertyDescriptor { \[\[Value]]:value, \[\[Writable]]:true,
           \[\[Enumerable]]:true, \[\[Configurable]]:true }
4. 返回OrdinaryGetOwnProperty(O, P)
**** 10.4.5.2 \[\[HasProperty]](P)
  IntegerIndexedExoticObject O的\[\[HasProperty]]内部方法接受参数P（性质键）。
被调用时执行下列步骤：
1. Assert：IsPropertyKey(P)是true
2. Assert：O是IntegerIndexedExoticObject
3. 如果Type(P)是String，那么
    a. 让numericIndex是!CanonicalNumericIndexString(P)
    b. 如果numericIndex不是undefined，返回!IsValidIntegerIndex(O, numericIndex)
4. 返回?OrdinaryHasProperty(O, P)
**** 10.4.5.3 \[\[DefineOwnProperty]](P, Desc)
  IntegerIndexedExoticObject O的\[\[DefineOwnProperty]]内部方法接受参数P（性质键）
和Desc（PropertyDescriptor）。被调用时执行下列步骤：
1. Assert：IsPropertyKey(P)是true
2. Assert：O是IntegerIndexedExoticObject
3. 如果Type(P)是String，那么
    a. 让numericIndex是!CanonicalNumericIndexString(P)
    b. 如果numericIndex不是undefined，那么
        i. 如果!IsValidIntegerIndex(O, numericIndex)是false，返回false
       ii. 如果Desc有\[\[Configurable]]字段，且是false，返回false
      iii. 如果Desc有\[\[Enumerable]]字段，且是false，返回false
       iv. 如果!IsAccessorDescriptor(Desc)是true，返回false
        v. 如果Desc有\[\[Writable]]字段，切实false，返回false
       vi. 如果Desc有\[\[Value]]字段，执行?IntegerIndexedElementSet(O, numericIndex,
           Desc.\[\[Value]])
      vii. 返回true
4. 返回?OrdinaryDefineOwnProperty(O, P)
**** 10.4.5.4 \[\[Get]](P, Receiver)
  IntegerIndexedExoticObject O的\[\[Get]]内部方法接受参数P（性质键）和Receiver（
ECMAScript语言值）。被调用时执行下列步骤：
1. Assert：IsPropertyKey(P)是true
2. 如果Type(P)是String，那么
    a. 让numericIndex是!CanonicalNumericIndexString(P)
    b. 如果numericIndex不是undefined，那么
        i. 返回!IntegerIndexedElementGet(O, numericIndex)
3. 返回?OrdinaryGet(O, P, Receiver)
**** 10.4.5.5 \[\[Set]](P, V, Receiver)
  IntegerIndexedExoticObject O的\[\[Set]]内部方法接受参数P（性质键）、V（ECMAScript
语言值）和Receiver（ECMAScript语言值）。被调用时执行下列步骤：
1. Assert：IsPropertyKey(P)是true
2. 如果Type(P)是String，那么
    a. 让numericIndex是!CanonicalNumericIndexString(P)
    b. 如果numericIndex不是undefined，那么
        i. 执行!IntegerIndexedElementSet(O, numericIndex)
       ii. 返回true
3. 返回?OrdinarySet(O, P, V, Receiver)
**** 10.4.5.6 \[\[Delete]](P)
  IntegerIndexedExoticObject O的\[\[Delete]]内部方法接受参数P（性质键）。被调用时
执行下列步骤：
1. Assert：IsPropertyKey(P)是true
2. Assert：O是IntegerIndexedExoticObject
3. 如果Type(P)是String，那么
    a. 让numericIndex是!CanonicalNumericIndexString(P)
    b. 如果numericIndex不是undefined，那么
        i. 如果!IsValidIntegerIndex(O, numericIndex)是false，返回true，否则返回false
4. 返回?OrdinaryDelete(O, P)
**** 10.4.5.7 \[\[OwnPropertyKeys]]
  IntegerIndexedExoticObject O的\[\[OwnPropertyKeys]]内部方法不接受参数。被调用时
执行下列步骤：
1. 让keys是新的空List
2. Assert：O是IntegerIndexedExoticObject
3. 如果IsDetachedBuffer(O.\[\[ViewedArrayBuffer]])是false，那么
    a. 按照升序遍历[0, O.\[\[ArrayLength]])上的整数，记作i，做
        i. 在keys上追加!ToString(F(i))
4. 遍历O上自有性质，性质键P，满足Type(P)是String，而且P不是IntegerIndex，按照
   创建时间升序，做：
    a. 在keys上追加P
5. 遍历O上自有性质，性质键P，满足Type(P)是Symbol，按照创建时间升序，做：
    a. 在keys上追加P
6. 返回keys
**** 10.4.5.8 IntegerIndexedObjectCreate(prototype)
  抽象操作IntegerIndexedObjectCreate接受参数prototype。用于规定创建新的
IntegerIndexedExoticObject的过程。被调用时执行下列步骤：
1. internalSlotsList是<<\[\[Prototype]], \[\[Extensible]], \[\[ViewedArrayBuffer]], 
   \[\[TypedArrayName]], \[\[ContentType]], \[\[ByteLength]], \[\[ByteOffset]], 
   \[\[ArrayLength]], >>
2. 让A是!MakeBasicObject(internalSlotsList)
3. 设置A.\[\[GetOwnProperty]]是10.4.5.1中定义
4. 设置A.\[\[HasProperty]]是10.4.5.2中定义
5. 设置A.\[\[DefineOwnProperty]]是10.4.5.3中定义
6. 设置A.\[\[Get]]是10.4.5.4中定义
7. 设置A.\[\[Set]]是10.4.5.5中定义
8. 设置A.\[\[Delete]]是10.4.5.6中定义
9. 设置A.\[\[OwnPropertyKeys]]是10.4.5.7中定义
10. 设置A.\[\[Prototype]]是prototype
11. 返回A
**** 10.4.5.9 IsValidIntegerIndex(O, index)
  抽象操作IsVaidIntegerIndex接受参数O和index（Number）。被调用时执行下列步骤：
1. Assert：O是IntegerIndexedExoticObject
2. 如果IsDetachedBuffer(O.\[\[ViewedArrayBuffer]])是true，返回false
3. 如果!IsIntegeralNumber(index)是false，返回false
4. 如果index是-0_F，返回false
5. 如果R(index)<0或者R(index)>=O.\[\[ArrayLength]]，返回false
6. 返回true
**** 10.4.5.10 IntegerIndexedElementGet(O, index)
  抽象操作IntegerIndexedElementGet接受参数O和index（Number）。被调用时执行下列
步骤：
1. Assert：O是IntegerIndexedExoticObject
2. 如果!IsValidIntegerIndex(O, index)是false，返回undefined
3. 让offset是O.\[\[ByteOffset]]
4. 让arrayTypeName是O.\[\[TypedArrayName]]的String
5. 让elementSize是arrayTypeName按照表60规定的元素大小值
6. 让indexedPosition是(R(index)*elementSize)+offset
7. 让elementType是arrayTypeName在表60规定的元素类型值
8. 返回GetValueFromBuffer(O.\[\[ViewedArrayBuffer]], indexedPosition, elementType, true,
   Unordered)
**** 10.4.5.11 IntegerIndexedElementSet(O, index, value)
  抽象操作IntegerIndexedElementSet接受参数O、index（Number）和value。被调用时执
行下列步骤：
1. Assert：O是IntegerIndexedExoticObject
2. 如果O.\[\[ContentType]]是BigInt，让numValue是?ToBigInt(value)
3. 否则让numValue是?ToNumber(value)
4. 如果!IsValidIntegerIndex(O, index)是true，那么
    a. 让offset是O.\[\[ByteOffset]]
    b. 让arrayTypeName是O.\[\[TypedArrayName]]的String值
    c. 让elementSize是arrayTypeName按照表60规定的元素大小的值
    d. 让indexedPosition是(R(index)*elementSize)+offset
    e. 让elementType是arrayTypeName在表60的元素类型值
    f. 执行SetValueBuffer(O.\[\[ViewedArrayBuffer]], indexedPosition, elementType,
       numValue, true, unordered)
5. 返回NormalCompletion(undefined)
***** 注意 这个操作总是成功，但是试图在TypedArray末端写入的时候，或者在某个已
            脱离的ArrayBuffer支持的TypedArray上写入的时候，没有任何效果。
*** 10.4.6 Module Namespace Exotic Object 模块命名空间奇异对象
  ModuleNamespaceExoticObject是一个暴露从ECMAScript模块（16.2.3）导出的绑定的奇异
对象。Module导出的绑定名称与ModuleNamespaceExoticObject的String键的自有性质是1-1
映射。每个String值的性质键就是对应导出的绑定名称的String值。在
ModuleNamespaceExoticObject只有String键的性质。每个性质都有属性{ 
\[\[Writable]]:true, \[\[Enumerable]]:true, \[\[Configurable]]:false }。
ModuleNamespaceExoticObject都是不可扩展的。
  如果对象的\[\[SetPrototypeOf]]、\[\[IsExtensible]]、\[\[PreventExtensions]]、
\[\[GetOwnProperty]]、\[\[DefineOwnProperty]]、\[\[HasProperty]]、\[\[Get]]、
\[\[Set]]、\[\[Delete]]和\[\[OwnPropertyKeys]]内部方法使用本节定义，其他基本内部
方法使用10.1中的定义，这对象就是ModuleNamespaceExoticObject。这些方法在
ModuleNamespaceCreate中安装。
  ModuleNamespaceExoticObject有表31中的内部占位。
| 内部占位        | 类型         | 描述                                                                                                                                             |
| \[\[Module]]    | ModuleRecord | 导出这个命名空间的ModuleRecord                                                                                                                   |
| \[\[Exports]]   | List<String> | 作为本对象的性质被导出的名称的String值组成的List。本List被排序时，像String值数组一样用undefined作为comparefn调用%Array.prototype.sort%进行排序。 |
| \[\[Prototype]] | Null         | 本占位总是null（10.4.6.1）                                                                                                                       |
  ModuleNamespaceExoticObject在上述内部方法中，除了\[\[GetPrototypeOf]]使用10.1.1中
的定义，其他的特定的备选定义。
**** 10.4.6.1 \[\[SetPrototypeOf]](V)
  ModuleNamespaceExoticObject O的\[\[SetPrototypeOf]]内部方法接受参数V（Object或者
null）。被调用时执行下列步骤：
1. 返回?SetImmutablePrototype(O, V)
**** 10.4.6.2 \[\[IsExtensible]]()
  ModuleNamespaceExoticObject O的\[\[IsExtensible]]内部方法不接受参数。被调用时执
行下列步骤：
1. 返回false
**** 10.4.6.3 \[\[PreventExtensions]]()
  ModuleNamespaceExoticObject O的\[\[PreventExtensions]]内部方法不接受参数。被调用
时执行下列步骤：
1. 返回true
**** 10.4.6.4 \[\[GetOwnProperty]](P)
  ModuleNamespaceExoticObject O的\[\[GetOwnProperty]]内部方法接受参数P（性质键）。
被调用时执行下列步骤：
1. 如果Type(P)是Symbol，返回OrdinaryGetOwnProperty(O, P)
2. 让exports是O.\[\[Exports]]
3. 如果P不是exports中元素，返回undefined
4. 让value是?O.\[\[Get]](P, O)
5. 返回PropertyDescriptor { \[\[Value]]:value, \[\[Writable]]:true,
   \[\[Enumerable]]:true, \[\[Configurable]]:false }
**** 10.4.6.5 \[\[DefineOwnProperty]](P, Desc)
  ModuleNamespaceExoticObject O的\[\[DefineOwnProperty]]内部方法接受参数P（性质键）
和Desc（PropertyDescriptor）。被调用时执行下列步骤：
1. 如果Type(P)是Symbol，返回OrdinaryDefineOwnProperty(O, P, Desc)
2. 让current是?O.\[\[GetOwnProperty]](P)
3. 如果current是undefined，返回false
4. 如果Desc.\[\[Configurable]]存在且是true，返回false
5. 如果Desc.\[\[Enumerable]]存在且是false，返回false
6. 如果!IsAccessorDescriptor(Desc)是true，返回false
7. 如果Desc.\[\[Writable]]存在且是false，返回false
8. 如果Desc.\[\[Value]]存在，返回SameValue(Desc.\[\[Value]], current.\[\[Value]])
9. 返回true
**** 10.4.6.6 \[\[HasProperty]](P)
  ModuleNamespaceExoticObject O的\[\[HasProperty]]内部方法接受参数P（性质键）。被
调用时执行下列步骤：
1. 如果Type(P)是Symbol，返回OrdinaryHasProperty(O, P)
2. 让exports是O.\[\[Exports]]
3. 如果P是exports的元素，返回true
4. 返回false
**** 10.4.6.7 \[\[Get]](P,Receiver)
  ModuleNamespaceExoticObject O的\[\[Get]]内部方法接受参数P（性质键）和Receiver
（ECMAScript语言值）。被调用时执行下列步骤：
1. Assert：IsPropertyKey(P)是true
2. 如果Type(P)是Symbol，那么
    a. 返回?OrdinaryGet(O, P, Receiver)
3. 让exports是O.\[\[Exports]]
4. 如果P不是exports元素，返回undefined
5. 让m是O.\[\[Module]]
6. 让binding是!m.ResolveExport(P)
7. Assert：binding是ResolveBindingRecord
8. 让targetModule是binding.\[\[Module]]
9. Assert：targetModule不是undefined
10. 如果binding.\[\[BindingName]]是"*namespace*"，那么
    a. 返回?GetModuleNamespace(targetModule)
11. 让targetEnv四targetModule.\[\[Environment]]
12. 如果targetEnv是undefined，投掷ReferenceError异常
13. 返回?targetEnv.GetBindingValue(binding.\[\[BindingName]], true)
***** 注意 ResolveExport是没有副作用的。每次带着特定exportName和resolveSet参数
            调用本操作，必须返回相同的结果。实现会选择为每个
            ModuleNamespaceExoticObject的\[\[Exports]]预先计算或者缓存ResolveExport
            结果。
**** 10.4.6.8 \[\[Set]](P,V, Receiver)
  ModuleNamespaceExoticObject O的\[\[Set]]内部方法接受参数P（性质键）、V（
ECMAScript语言值）和Receiver（ECMAScript语言值）。被调用时执行下列步骤：
1. 返回false
**** 10.4.6.9 \[\[Delete]](P)
  ModuleNamespaceExoticObject O的\[\[Delete]]内部方法接受参数P（性质键）。被调用
时执行下列步骤：
1. Assert：IsPropertyKey(P)是true
2. 如果Type(P)是Symbol，那么
    a. 返回?OrdinaryDelete(O, P)
3. 让exports是O.\[\[Exports]]
4. 如果P是exports元素，返回false
5. 返回true
**** 10.4.6.10 \[\[OwnPropertyKeys]]()
  ModuleNamespaceExoticObject O的\[\[OwnPropertyKeys]]内部方法不接受参数。被调用时
执行下列步骤：
1. 让exports是O.\[\[Exports]]的副本
2. 让symbolKeys是!OrdinaryOwnPropertyKeys(O)
3. 追加symbolKeys的全部元素到exports中
4. 返回exports
**** 10.4.6.11 ModuleNamespaceCreate(module, exports)
  抽象操作ModuleNamespaceCreate接受参数module和exports。用于规范创建
ModuleNamespaceExoticObject的过程。被调用时执行下列步骤：
1. Assert：module是ModuleRecord
2. Assert：module.\[\[Namespace]]是undefined
3. Assert：exports是String的List
4. 让internalSlotsList是表31中列出内部占位列表
5. 让M是!MakeBasicObject(internalSlotsList)
6. 设置M的基本内部方法遵循10.4.6的定义规范
7. 设置M.\[\[Prototype]]是null
8. 设置M.\[\[Module]]是module
9. 让sortedExports是exports元素的list，按照数组使用undefined作为comparefn调用
   %Array.prototype.sort%的方式排序。
10. 设置M.\[\[Exports]]是sortedExports
11. 遵循28.3中定义创建M的自有性质
12. 设置module.\[\[Namespace]]是M
13. 返回M
*** 10.4.7 Immutable Prototype Exotic Object
  ImmutablePrototypeExoticObject是奇异对象，其\[\[Prototype]]内部占位在初始化后
不能变动。
  如果一个对象的\[\[SetPrototypeOf]]内部方法使用随后的实现，这个对象就是
ImmutablePrototypeExoticObject。（其他的基本内部方法可以使用任意实现，依赖于
请求ImmutablePrototypeExoticObject的规定）
**** 注意 不想其他奇异对象，没有指明为创建ImmutablePrototypeExoticObject定义的
           抽象操作。因为他们仅被%Object.prototype%、host环境，在host环境内使
           用，联结的对象潜在的也是奇异对象，所以需要各自指明的创建过程。
**** 10.4.7.1 \[\[SetPrototypeOf]](V)
  ImmutablePrototypeExoticObject O的\[\[SetPrototypeOf]]内部方法接受参数V（Object或
null）。被调用时执行下列步骤：
1. 返回?SetImmutablePrototype(O, V)
**** 10.4.7.2 SetImmutablePrototype(O, V)
  抽象操作SetImmutablePrototype接受参数O和V。被调用时执行下列步骤：
1. Assert：Type(V)是Object或者Null
2. 让current是?O.\[\[GetPrototypeOf]]()
3. 如果SameValue(V, current)是true，返回true
4. 返回false
** 10.5 Proxy Object Internal Methods And Internal Slots
  ProxyObject是奇异对象，部分基本内部方法使用ECMAScript代码实现。每个
ProxyObject都有\[\[ProxyHandler]]内部占位。\[\[ProxyHandler]]是一个对象，被称为
代理的HandlerObject，也可能是null。HandlerObject的Methods（表32）会被用于扩大
一个或者多个ProxyObject内部方法的实现。每个ProxyObject还有一个内部占位
\[\[ProxyTarget]]，是对象或者null。这个对象称为代理的TargetObject。
  如果一个对象的基本内部方法（包括\[\[Call]]和\[\[Construct]]，如果提供了）
使用本节的定义，这个对象就是ProxyExoticObject。使用ProxyCreate安装这些方法。
| 内部方法                | 顾问方法                 |
| \[\[GetPrototypeOf]]    | getPrototypeOf           |
| \[\[SetPrototypeOf]]    | setPrototypeOf           |
| \[\[IsExtensible]]      | isExtensible             |
| \[\[PreventExtensions]] | preventExtensions        |
| \[\[GetOwnProperty]]    | getOwnPropertyDescriptor |
| \[\[DefineOwnProperty]] | defineProperty           |
| \[\[HasProperty]]       | has                      |
| \[\[Get]]               | get                      |
| \[\[Set]]               | set                      |
| \[\[Delete]]            | delete                   |
| \[\[OwnProperty]]       | ownKeys                  |
| \[\[Call]]              | apply                    |
| \[\[Construct]]         | construct                |
  顾问方法被调用于以提供代理对象的内部方法时，代理目标对象会作为一个参数
传递给顾问方法。代理顾问对象不需要对应每个基本内部方法。调用代理的内部方
法会导致调用代理目标对象上对应的内部方法，如果顾问对象没有方法对应这种
捕获的话。
  代理对象的\[\[ProxyHandler]]和\[\[ProxyTarget]]内部占位总是在对象创建的时候进
行初始化，一般也是不能修改的。有些代理对象以一种允许被随即调用的方式进行
创建。当调用代理的时候，而它的\[\[ProxyHandler]]和\[\[ProxyTarget]]内部占位还被
设置为null，会导致随即调用代理对象的内部方法投掷TypeError一场。
  因为代理对象允许使用任意ECMAScript代码实现这些内部方法，可能定义了一个代理
对象的顾问方法违反了6.1.7.3中定义的不变性。6.1.7.3中定义的一些内部方法不变性
是基本的完好不变形。这些不变性被在本节规定的代理对象的内部方法显式的强制
使用。ECMAScript实现必须在任何可能的破坏不变性下保持强壮。
  在随后的算法声明中，假设O是ECMAScript对象，P是性质键，V是ECMAScript语言值和
Desc是PropertyDescriptor记录。
*** 10.5.1 \[\[GetPrototypeOf]]()
  ProxyExoticObject O的\[\[GetPrototypeOf]]内部方法不接受参数。被调用时执行下列
步骤：
1. 让handler是O.\[\[ProxyHandler]]
2. 如果handler是null，投掷TypeError异常
3. Assert：Type(handler)是对象
4. 让target是O.\[\[ProxyTarget]]
5. 让trap是?GetMethod(handler, "getPrototypeOf")
6. 如果trap是undefined，那么
    a. 返回?target.\[\[GetPrototypeOf]]()
7. 让handlerProto是?Call(trap, handler, <<target>>)
8. 如果Type(handlerProto)不是Object或者Null，投掷TypeError异常
9. 让extensibleTarget是?IsExtensible(target)
10. 如果extensibleTarget是true，返回handlerProto
11. 让targetProto是?target.\[\[GetPrototypeOf]]()
12. 如果SameValue(handlerProto,targetProto)是false，投掷TypeError异常
13. 返回handlerProto
**** 注意 代理对象的\[\[GetPrototypeOf]]强制执行下列不变性：
           . \[\[GetPrototypeOf]]的结果必须是Object或者null
           . 如果目标对象不是可扩展的，在代理对象上调用\[\[GetPrototypeOf]]必须
           与在代理目标上调用\[\[GetPrototyOf]]返回相同结果。
*** 10.5.2 \[\[SetPrototypeOf]](V)
  ProxyExoticObject O的\[\[SetPrototypeOf]]内部方法接受参数V（Object或者null）。
被调用时执行下列步骤：
1. Assert：Type(V)是Object或者Null
2. 让handler是O.\[\[ProxyHandler]]
3. 如果handler是null，投掷TypeError异常
4. Assert：Type(handler)是Object
5. 让target是O.\[\[ProxyTarget]]
6. 让trap是?GetMethod(handler, "setPrototypeOf")
7. 如果trap是undefined，那么
    a. 返回?target.\[\[SetPrototypeOf]](V)
8. 让booleanTrapResult是!ToBoolean(?Call(trap, handler, <<target, V>>))
9. 如果booleanTrapResult是false，返回false
10. 让extensibleTarget是?IsExtensible(target)
11. 如果extensibleTarget是true，返回true
12. 如果targetProto是?target.\[\[GetPrototypeOf]]()
13. 如果SameValue(V,targetProto)是false，投掷TypeError异常
14. 返回true
**** 注意 代理对象的\[\[SetPrototypeOf]]必须强制执行下列不变性：
           . \[\[SetPrototypeOf]]的结果是Boolean值
           . 如果目标对象不是可扩展的，参数值必须与目标对象的\[\[GetPrototype]]
             结果一致。
*** 10.5.3 \[\[IsExtensible]]()
  ProxyExoticObject O的\[\[IsExtensible]]内部方法不接受参数。被调用时执行下列
步骤：
1. 让handler是O.\[\[ProxyHandler]]
2. 如果handler是null，投掷TypeError异常
3. Assert：Type(handler)是Object
4. 让target是O.\[\[ProxyTarget]]
5. 让trap是?GetMethod(handler, "isExtensible")
6. 如果trap是undefined，那么
    a. 返回?IsExtensible(target)
7. 让booleanTrapResult是!ToBoolean(?Call(trap, handler, <<target>>))
8. 让targetResult是?IsExtensible(target)
9. 如果SameValue(booleanTrapResult, targetResult)是false，投掷TypeError异常
10. 返回booleanTrapResult
**** 注意 代理对象的\[\[IsExtensible]]必须强制执行下列不变性：
           . \[\[IsExtensible]]的结果是Boolean值
           . 提供给代理对象\[\[IsExtensible]]必须与代理目标的\[\[IsExtensible]]
             一致。参数相同，结果相同。
*** 10.5.4 \[\[PreventExtensions]]()
  ProxyExoticObject O的\[\[PreventExtensions]]内部方法不接受参数。被调用时执行
下列步骤：
1. 让handler是O.\[\[ProxyHandler]]
2. 如果handler是null，投掷TypeError异常
3. Assert：Type(handler)是Object
4. 让target是O.\[\[ProxyTarget]]
5. 让trap是?GetMethod(handler, "preventExtensions")
6. 如果trap是undefined，那么
    a. 返回?target.\[\[PreventExtensions]]()
7. 让booleanTrapResult是!ToBoolean(?Call(trap, handler, <<target>>))
8. 如果booleanTrapResult是true，那么
    a. 让extensibleTarget是?IsExtensible(target)
    b. 如果extensibleTarget是true，投掷TypeError异常
9. 返回booleanTrapResult
**** 注意 代理对象的\[\[PreventExtensions]]必须强制执行下列不变性：
           . \[\[PreventExtensions]]的结果是Boolean值
           . 提供给代理对象\[\[PreventExtensions]]只有在代理目标的
             \[\[IsExtensible]]是false时，返回true。
*** 10.5.5 \[\[GetOwnProperty]](P)
  ProxyExoticObject O的\[\[GetOwnProperty]]内部方法接受参数P（性质键）。
被调用时执行下列步骤：
1. Assert：IsPropertyKey(P)是true
2. 让handler是O.\[\[ProxyHandler]]
3. 如果handler是null，投掷TypeError异常
4. Assert：Type(handler)是Object
5. 让target是O.\[\[ProxyTarget]]
6. 让trap是?GetMethod(handler, "getOwnPropertyDescriptor")
7. 如果trap是undefined，那么
    a. 返回?target.\[\[GetOwnProperty]]()
8. 让trapResultObj是?Call(trap, handler, <<target, P>>)
9. 如果Type(trapResultObj)不是Object和Undefined，投掷TypeError异常
10. 让targetDesc是?target.\[\[GetOwnProperty]](P)
11. 如果trapResultObj是undefined，那么
    a. 如果targetDesc是undefined，返回undefined
    b. 如果targetDesc.\[\[Configurable]]是false，投掷TypeError异常
    c. extensibleTarget是?IsExtensible(target)
    d. 如果extensibleTarget是false，投掷TypeError异常
    e. 返回undefined
12. 让extensibleTarget是?IsExtensible(target)
13. 让resultDesc是?ToPropertyDescriptor(resultDesc)
14. 调用CompletePropertyDescriptor(resultDesc)
**** 注意 代理对象的\[\[IsExtensible]]必须强制执行下列不变性：
           . \[\[IsExtensible]]的结果是Boolean值
           . 提供给代理对象\[\[IsExtensible]]必须与代理目标的\[\[IsExtensible]]
             一致。参数相同，结果相同。
*** 10.5.5 \[\[DefineOwnProperty]](P, Desc)
  ProxyExoticObject O的\[\[SetPrototypeOf]]内部方法接受参数V（Object或者null）。
被调用时执行下列步骤：
**** 注意 代理对象的\[\[IsExtensible]]必须强制执行下列不变性：
           . \[\[IsExtensible]]的结果是Boolean值
           . 提供给代理对象\[\[IsExtensible]]必须与代理目标的\[\[IsExtensible]]
             一致。参数相同，结果相同。
*** 10.5.7 \[\[HasProperty]](P)
  ProxyExoticObject O的\[\[SetPrototypeOf]]内部方法接受参数V（Object或者null）。
被调用时执行下列步骤：
**** 注意 代理对象的\[\[IsExtensible]]必须强制执行下列不变性：
           . \[\[IsExtensible]]的结果是Boolean值
           . 提供给代理对象\[\[IsExtensible]]必须与代理目标的\[\[IsExtensible]]
             一致。参数相同，结果相同。
*** 10.5.8 \[\[Get]](P, Receiver)
  ProxyExoticObject O的\[\[SetPrototypeOf]]内部方法接受参数V（Object或者null）。
被调用时执行下列步骤：
**** 注意 代理对象的\[\[IsExtensible]]必须强制执行下列不变性：
           . \[\[IsExtensible]]的结果是Boolean值
           . 提供给代理对象\[\[IsExtensible]]必须与代理目标的\[\[IsExtensible]]
             一致。参数相同，结果相同。
*** 10.5.9 \[\[Set]](P, V, Receiver)
  ProxyExoticObject O的\[\[SetPrototypeOf]]内部方法接受参数V（Object或者null）。
被调用时执行下列步骤：
**** 注意 代理对象的\[\[IsExtensible]]必须强制执行下列不变性：
           . \[\[IsExtensible]]的结果是Boolean值
           . 提供给代理对象\[\[IsExtensible]]必须与代理目标的\[\[IsExtensible]]
             一致。参数相同，结果相同。
*** 10.5.10 \[\[Delete]](P)
  ProxyExoticObject O的\[\[SetPrototypeOf]]内部方法接受参数V（Object或者null）。
被调用时执行下列步骤：
**** 注意 代理对象的\[\[IsExtensible]]必须强制执行下列不变性：
           . \[\[IsExtensible]]的结果是Boolean值
           . 提供给代理对象\[\[IsExtensible]]必须与代理目标的\[\[IsExtensible]]
             一致。参数相同，结果相同。
*** 10.5.11 \[\[OwnPropertyKeys]]()
  ProxyExoticObject O的\[\[IsExtensible]]内部方法不接受参数。被调用时执行下列
步骤：
**** 注意 代理对象的\[\[IsExtensible]]必须强制执行下列不变性：
           . \[\[IsExtensible]]的结果是Boolean值
           . 提供给代理对象\[\[IsExtensible]]必须与代理目标的\[\[IsExtensible]]
             一致。参数相同，结果相同。
*** 10.5.12 \[\[Call]](thisArgument, argumentsList)
  ProxyExoticObject O的\[\[SetPrototypeOf]]内部方法接受参数V（Object或者null）。
被调用时执行下列步骤：
**** 注意 代理对象的\[\[IsExtensible]]必须强制执行下列不变性：
           . \[\[IsExtensible]]的结果是Boolean值
           . 提供给代理对象\[\[IsExtensible]]必须与代理目标的\[\[IsExtensible]]
             一致。参数相同，结果相同。
*** 10.5.13 \[\[Construct]](argumentsList, newTarget)
  ProxyExoticObject O的\[\[SetPrototypeOf]]内部方法接受参数V（Object或者null）。
被调用时执行下列步骤：
**** 注意 代理对象的\[\[IsExtensible]]必须强制执行下列不变性：
           . \[\[IsExtensible]]的结果是Boolean值
           . 提供给代理对象\[\[IsExtensible]]必须与代理目标的\[\[IsExtensible]]
             一致。参数相同，结果相同。
*** 10.5.14 ProxyCreate(target, handler)
* 11 ECMAScript Language: Source Code
** 11.1 Source Text
Syntax
SourceCharacter::
  any Unicode code pint
* 25
** 25.1


