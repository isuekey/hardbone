
* 待办
** 将来会使用LaTex进行处理.
* 约定
** 若干 表示一个或者多个
** 有限 表示零个、一个或者多个
** 可数 表示零个、一个、多个或者无限个
** 所有英文为原文内容，作为专用词汇表示特定含义，比如类型、参数、概念等。
** 领 表示realm
** 域 表示domain
** 规模 表示某数的模。或者在这里进行约定。数x的模就是x的绝对值|x|
** 性质 表示property
** 属性 表示attribute
** List<some> 表示列表的元素有some特性。
** 相同值 表示两个值是同一个
** 构造范 表示constructor
** 合集 表示collection
** R域 表示R适用的所有值的集合
** 字位 一个二进制位
** 字节 8个连续的二进制位。至于大小端，如果没有明确说明，就不考虑。
** 修圆 指用有限精度数字描述准确数字的处理过程。
*** 根据编译原理，大小端由其他编译层处理。
* 第一章
* 第二章
* 第三章
* 第四章
* 第五章 记号约定
** 5.1句法与词法（语句的与词汇的语法）
*** 5.1.1上下文无关语法（context-free grammar 可能就是通用的语法描述约定）
  "context-free grammar"由若干"productions"组成。每个产出是一个树，有两个支干
left-hand side 和 right-hand side，在"left-hand side"是一个抽象标记记为
"nonterminal", 在"right-hand side" 是一个队列，由可数个标记（"nonterminal"或
"terminal"）构成的序列。各个语法的"terminal"用特定字母描述。形式如NXn, 
X属于{N,T},n为非负整数，差不多类似/N[NT]*/。
  "chain product"是只有一个"right-side nonterminal"和可数个"terminal"
构成的序列组成的产出。（一定还有一个left-hand side nontermial）。
  一个语句从开始由仅一个区分出的称为"goal symbol"的"nontermimal"和一个给定
的语法描述（context-free grammar)构成。语句具体指明一个"language"，即一组可数
的"terminal symbol"序列（数学意义上的可数：有限的或无限的）。这个序列可以
通过将语句中所有的"production left-hand side nonterminal"替换为
"production right-hand side"的方式，递归获得。
**** 这里其实蕴含了序的概念。这是按照输入顺序进行语法组织的。
*** 5.1.2词汇与正则的语法
  ECMAScript的"lexical grammar"在12章详解。本语法与它的"terminal symbols"的Unicode
编码一致，符合11.1定义的源码字符规则。定义了若干产出，从"goal symbol"开始有
InputElementDiv, InputElementTemplateTail, InputElementRegExp, 
InputElementRegExpOrTemplateTail，这些产出描述了如何将输入的字符码转换为
输入元素
  除了空白符与注释的输入元素组成了ECMAScript的句法语法的"termial symbols"，
称为ECMAScript tokens。这些token是保留词、标识符、文本和ECMAScript语言符号。
同时换行符通常不被认为是token，尽管是输入元素流的一部分，引导进程自动插入
分好。简单的空白符和单行注释是被舍弃的，不会出现在句法语法的输入元素
流中。多行注释（就是/*...*/形式的注释，与占用几行无关）中如果没有换行符，
会被舍弃掉；如果含有一个或多个换行符，将被替换为一个换行符的，然后作为
语句语法输入元素流的一部分
  ECMAScript的RegExp语法在22.2.1中给出。该文法还将源字符定义的代码点作为
"terminal symbols"其终结符。从"goal symbol Pattern"开始定义了若干产出描述了
如何将字符码转换为正则表达式。
  词汇与正则语法的产出用两个冒号"::"作为分隔符号。词汇与正则语法共享部分
产出。
*** 5.1.3 数字语法
  还有一种语法是将字符串转换成数字值。这个语法与词汇语法中处理数字的部分
内容相似。语法的"terminal symbol"是源码。在7.1.4.1中详细描述。
  数字语法的产出用三个冒号":::"作为符号来标志。
*** 5.1.4 语句语法
  ECMAScript的语句语法在13至16章给出。这语法有被词汇语法定义为
"terminal symbols"的"ECMAScript tokens"。它定义了一套产出，从两个目标符号" 
Script and Module"的某个开始，描述了token序列如何沟组成ECMAScript程序的
语句的正确的独立的组件。
  当一个编码流被解析成ECMAScript的"Script"或者"Module"时，它先通过反复运用
词法语法转换成输入元素流，这个输入元素流在被解析成一个单独的语句语法的
运用。如果输入流的全部token不能被解析成一个单独的"goal nontermial Script 或
Module"，这个输入流就在语句语法上错了。
  当解析成功后，构造出了一个"parse tree"，他是一个有根的树结构，每个节点
都是"Parse Node"。每个解析节点在语法上是一个"symbol"的实例，他代表一串从
那个"symbol"派生出的源文本。这个解析树的根节点，则代表全部的源文本，是解
析的"goal symbol"的实例。如果某个解析节点是一个"nonterminal"的实例，他同时也
是某个将其"nonterminal"作为"left-hand side"的产出的实例。而且他有可数的子元
素，每个子元素对应产出的"right-hand side"的一个"symbol"，每个子元素是解析
节点，是相应"symbol"的实例。
  每次调用解析都是实例出新的解析节点，在每次解析间不重用节点，即使是同样
的源文本。解析节点当且仅当在相同解析调用中，同一个语法"symbol"的实例，代表
相同源文本串的时候才被认为是相同的解析节点。
**** 备注1 多次解析相同字符串导致不同的解析节点。例如：
let str = "1 + 1";
eval(str)
eval(str)
每次调用eval将str的值转换成ECMAScript源码，然后执行具有隔离的解析树的独立的
解析。这些树是截然不同的即使这些解析操作的源文本来自相同的字符值。
**** 备注2 解析树是本规范的方式，实现没有必要一定用相似的数据结构
  语句语法的产出使用一个冒号":"作为符号进行区别。
  13-16章出现的句法语法不是被"ECMAScript Script or Module"正确接受全部的内容。
某些额外的"token"同样被正确接受，即，那些仅当分号放在特定位置（例如换行符
前）才被语法描述的"token"。此外，某些本语法描述的"token"序列，如果换行符
出现在某些“尴尬”位置后，就不被认为可接受的。
  在某些场景内，为了规避歧义，句法语法使用笼统产出，也就是说允许"token"序列
不能组成有效的"ECMAScript Script or Module"。举例来说，这个技术被用在对象字面
量与对象结构模式上。在相应的案例中，提供了一个更严格的补充语法，用于进一
步限制这个可接受的"token"序列。典型的，有个"early error"规则会定义一个错误
条件如果"P不能覆盖N"，P是解析节点（普通的产出实例），而N是从补充来的
"nonterminal"。这样原本被P匹配的"token"序列被用N再次解析作为"goal symbol"。（
如果N用了语法性质的参数，他们就会被设置成相同的值，如果P是起初就解析的）
如果"token"序列不能作为一个N的实例来解析，且没有"token"剩下，会导致错误发
生。
  后来，算法会使用"N被P覆盖"语句访问这个解析的结果。既然任何解析失败会
被"early error"规则侦测到，这就总是一个解析节点（一个N实例对应一个给定P）。
*** 5.1.5 语法符号
  terminal symbols用等宽加黑（这里我也不知道如何表示）字体表示，无论是在语法
产出还是在文档规范里，只要文字直接表示一个terminal symbol。这会像所写的一样
出现在脚本。以这种方式指明的全部终端符代码符都被认为是恰当的Unicode代码，
包含基本的拉丁字符，而不是那些在Unicode范围内相似外形的编码。终端符不能用
\UnicodeEscapeSequence表示
  nonterminal用斜体表示。一个nonterminal（其实就是产出）的定义以跟随若干冒号
的名称开始介绍。冒号的数量表明产出属于那种语法。本产出的若干可替换的
"right-hand sides"跟随在下一行。比如一个语句定义：
WhileStatement:
    while ( Expression ) Statement
声明了WhileStatement nonterminal表示while token、(、一个Exression、)、一个Statement
组成的序列。Expression和Statement上发生他们自己的nonterminal。再举一个语句定义
的例子：
ArgumentList:
    AssignmentExpression
    ArgumentList , AssignmentExpression
声明了ArgumentList可能表示一个单独的AssignmentExpression或者一个由一个
ArgumentList、,、一个AssignmentExpression构成的序列。这个ArgumentList定义是递归
的，因为它的定义需要本身。于是ArgumenList可以包含若干参数，参数用,分隔，
每个参数表达式就是AssignmentExpression。这种nonterminal的递归定义很常见。
  下标后缀opt，出现在terminal或nonterminal后，声明一个可选标志。这种包含可选
标志的替换实际是指明两种right-hand sides，一种是缺失可选元素的，一种是包含
可选元素的。如下所示：
VariableDeclaration:
    BindingIdentifier Initializer_opt
是下列定义的简便缩写：
VariableDeclaration:
    BindingIdentifier
    BindingIdentifier Initializer
，更进一步：
ForStatement:
    for ( LexicalDeclaration Expression_opt ; Expression_opt ) Statement
是下列定义的简便缩写：
ForStatement:
    for ( LexicalDeclaration ; Expression_opt ) Statement
    for ( LexicalDeclaration Expression ; Expression_opt ) Statement
是如下的缩写：
ForStatement:
    for ( LexicalDeclaration ; ) Statement
    for ( LexicalDeclaration ; Expression ) Statement
    for ( LexicalDeclaration Expression ; ) Statement
    for ( LexicalDeclaration Expression ; Expression ) Statement
所以，在这个例子里，noterminal ForStatement有四个可替换的right-hand sides
  产出可以通过增加"[parameters]"形式的标注的方式参数化，这个标注后缀在一个
产出定义的nonterminal标志上。其中"parameters"可以一个名称或者用都号分隔的
名称列表。一个参数化的产出是一套通过在被参数化的nonterminal symbol后拼接
下划线_和参数名称的方式的所有组合的速记。例如：
StatementList_[Return]:
    ReturnStatement
    ExpressionStatement
是下列定义的简便缩写:
StatementList:
    ReturnStatement
    ExpressionStatement
StatementList_Return:
    ReturnStatement
    ExpressionStatement
，更进一步有：
StatementList_[Return, In]:
    ReturnStatement
    ExpressionStatement
是如下的缩写：
StatementList:
    ReturnStatement
    ExpressionStatement
StatementList_Return:
    ReturnStatement
    ExpressionStatement
StatementList_In:
    ReturnStatement
    ExpressionStatement
StatementList_Return_In:
    ReturnStatement
    ExpressionStatement
多个参数产生的产出组合，不全是完整语法定义需要的。
  涉及到产出right-hand side的nonterminal也同样可以使用参数。例如：
StatementList:
    ReturnStatement
    ExpressionStatement_[+In]
等价于：
StatementList:
    ReturnStatement
    ExpressionStatement_In
而
SatementList:
    ReturnStatement
    ExpressionStatement_[~In]
等价于：
SatementList:
    ReturnStatement
    ExpressionStatement
  一个nonterminal引用可能同时包含参数列表和"opt"后缀。例如:
VariableDeclaration:
    BindingIdentifier Initializer_[+In]_opt
是下面声明的缩写：
VariableDeclaration:
    BindingIdentifier
    BindingIdentifier Initializer_In
  在一个right-hand side nonterminal引用的参数上增加?前缀，表示这个参数是否
出现在依赖于是否出现在当前产出的left-hand side标识上。例如：
VariableDeclaration_[In]:
    BindingIdentifier Initializer_[?In]
是下面声明的缩写：
VariableDeclaration:
    BindingIdentifier Initializer
VariableDeclaration_In:
    BindingIdentifier Initializer_In
  如果right-hand分支上含有前缀"[+parameter]"，那么这个分支仅在这个参数名出现
在其产出的nonterminal标识上时可用。与之相反"[~parameter]"，则在其产出的
nonterminal标识上不含有参数名时，参数分支可用。例如：
StatementList_[Return]:
    [+Return]ReturnStatement
    ExpressionStatement
是下面声明的缩写：
StatementList:
    ExpressionStatement
StatementList_Return:
    ReturnStatement
    ExpressionStatement
，再者：
StatementList_[Return]:
    [~Return]ReturnStatement
    ExpressionStatement
是下面声明的缩写：
StatementList:
    ReturnStatement
    ExpressionStatement
StatementList_Return:
    ExpressionStatement
  当词汇one of跟随在语法定义的冒号":"后时，表明随后若干行的没给terminal标识
都是一个可选定义。例如，ECMAScript的词法语法包含产出：
NonZeroDigit:: one of
    1 2 3 4 5 6 7 8 9
这仅仅是下面声明的简写：
NonZeroDigit:: one of
    1
    2
    3
    4
    5
    6
    7
    8
    9
  如果短语"[empty]"出现在产出的right-hand side中，表明产出的right-hand side没有
任何terminal或者nonterminal
  如果短语"[lookahead=seq]"出现在产出的right-hand side，表明这个产出可能仅用在
这个token序列seq是随后的token序列的前置代号，也就是说随后的token序列以seq起始。
类似的"[lookahead∈set]"，其中set是一个有限的非空的token序列的集合，表明这个
产出仅在set中的某些元素是随后token序列的前置代号。为了方便这个集合可以被写
成一个nonterminal，这表示，这个nonterminal展开为这个集合的全部token序列。如果
这个nonterminal可以被展开成无穷的不同token序列，那他被认为是一个编者的错误。
**** 就是写错了。
  有些情况需要反向定义。"[lookahead≠seq]"表明产出仅在seq不是随后token序列的
前置代号时才可能被采用，"[lookahead∉set]"表明仅在没有set中的元素是随后的token
序列的前置代号时产出才会被采用。
  举例说明，前置定义：
DecimalDigit:: one of
    0 1 2 3 4 5 6 7 8 9
DecimalDigits
    DecimalDigit
    DecimalDigits DecimalDigit
定义：
LookaheadExample::
    n [lookahead ∉ {1, 3, 5, 7, 9}] DecimalDigits
    DecimalDigit [lookahead ∉ DecimalDigit]
会匹配n跟随若干偶数或者仅一位数字形式的源文本。
  需要注意这些短语被用在语句语法的时候，可能无法准确的识别跟随的token序列
，因为确定后续的token需要知道哪个词法goal symbol在随后的位置使用。因此，如果
这些短语被用在句法语法时，会被认为是编者的错误，因为如果一个token序列seq
出现在lookahead限制（包括作为一组序列的一部分）里，如果要用的词法goal symbol
是不定的无论seq是否是结果token序列的前置代号。
  如果短语"[no LineTerminator here]"出现在语句语法的产出的right-hand side，表明
这个产出是一个被限制的产出，他不可以被用在那些LineTerminator出现在指定位置
的输入流。例如产出：
ThrowStatement:
    throw [no LineTerminator here] Expression;
指明这个产出不能用在LineTerminator出现在throw token与Expression之间的输入流上。
  除非LineTerminator是被限制产出明确禁止的，任意个LineTerminator可以在输入元素
流里任何两个连续的token间出现，不影响这个脚本的合理性。
  当在词法与数字产出出现在一个多码的token中时，这表示对应的代码序列要构成
一个对应的token。
  产出right-hand有可能会用短语"but not"来限制某种展开，表明不包含这种展开。例
如产出：
Identifier::
    IdentifierName but not ReservedWord
意味着nonterminal Identifier可以是被那些提供的编码不能替换为ReservedWord的
IdentifierName替换。
**** 简单来说就是集合IdentifierName - 集合ReseredWord
  最后有少些nonterminal被描述短语"sans-serif"描述的标识难以列举所有的选项：
SourceCharacter::
    any Unicode code point
** 5.2 算法约定
  本规范经常使用若干列表指明算法步骤。这些算法被用于精确指明ECMAScript
语言结构的需要语义。算法不是意图暗示任何实现技术。事实上，鼓励用更有效
的算法实现给定的特性。
  算法可能被用一个有序的、逗号分隔的别名序列参数化，这些参数名会被用在
算法步骤里，代表在相应位置传进来的数据。可选的参数被方括号包含（如
[,name]），但是在算法步骤上没有差异。剩余形式的参数需要在参数列表的末端，
以省略号开始（,...name）。剩余形式的参数捕获在必须参数和可选参数后的提供
的所有参数放到一个List中。如果没有这种额外的参数，这个List是空的。
  算法步骤可能需要再分为有序的子步骤。子步骤是缩进的，并可能继续拆分到
缩进的子步骤中。第一层用数字标记步骤，第一层的子步骤（第二层）用小写字母
标记，第二层的子步骤（第三层）用小写的罗马数字标记。如果还有更多的层级
需要标记那就从第四层重复这个规则。例如：
1. Top-level step
    a. Substep
    b. Substep
        i. Subsubstep
        ii.Subsubstep
            1. Subsubsubstep
                a. Subsubsubsubstep
                    i. Subsubsubsubsubstep
  步骤或者子步骤会使用"if"表明本步骤需要的条件。这时只有条件是true是，这个
步骤才会被采用。如果步骤或者子步骤用"else"开始，这表明当之前同级"if"过程得
到相反结果时，此步骤才会被采用。
  步骤会有迭代的子步骤。
  以"Assert"/"断言"开始的步骤认定为此算法的恒定条件。这种声明被用于明确的
算法条件，否则就是内含的条件。并没有增加额外的语义要求，因此也无需实现
检查。他们只是让算法清晰。
  算法步骤会用"Let x be someValue"的形式定以一些别名。这些别名与"x"和
"someValue"一样是某些根本数据的引用，一个修改了内容，别的也都可见。算法步骤
想避免这种引用行为时，会使用"Let x be a copy of someValue"来浅复制someValue。
  一旦声明了别名，后续任意步骤都可以引用此别名，但是之前的步骤不行。别名
可以通过"Set x to someOtherValue"的方式修改别名指向。
*** 5.2.1 抽象操作
  为了便利一些算法在本规范的不同部分使用，称这些算法为抽象操作，被命名和
定义为带参数的函数形式，以便于被其他算法用名称的方式引用。抽象操作通常的
引用方式是函数调用，类似OperationName(arg1, arg2)。在一些class-like的规范抽象
的部分抽象操作被当作多态处理的方法。这些方法样子的抽象操作一般引用方式是
someValue.OperationName(arg1, arg2)。
*** 5.2.2 面向句法的操作
  面向句法的操作是一个命名的操作，包含若干算法，每个算法联系若干ECMAScript
语法产出。产出还有多个备选定义，但是每个备选有明确的算法。当算法联结到
语法产出后，算法可能会通过参数的方式引用产出备选的终结和非终结符。用这种
方式时，非终结符指向一个从源文本解析出的实际的备选定义。语法产出匹配的源
文本是源码的一部分，这部分源码从参与匹配的第一个终结符开始，结束到参与匹
配的最后一个终结符结束。
  当算法联结到产出备选，这个备选一般不会有任何"[]"，这种语法注解。这种注解
应该仅用于句法识别备选，而且不能对联结的备选的语义有任何作用。
  在下面的算法中的1、3、4约定的步骤中，带着解析节点和可选的参数，面向句法
的操作会被调用：
1. 让status是SomeNonTerminal的SyntaxDirectedOperation
2. 让someParseNode是某些源码的解析
3. 执行someParseNode的SyntaxDirectedOperation
4. 传递value作为参数，执行someParseNode的SyntaxDirecteOperation
  除非显式声明，否则所有的链环产出对于每个操作都有一个隐式定义，这个会被
当作产出的left-hand side的非终止符。如果有上述非终止符，这个隐式的定义就简
单的重复提交相同的操作和相同的参数，给链环产出的right-hand side非终止符，然
后返回这个结果。比如，假设算法有一步骤是：“返回评估Block的结果”，就会有
这样的一个产出：
Block:
    { StatementList }
但是评估操作不会联结算法与产出。这样，评估操作隐式的包含如下形式的联结：
Runtime Semantics: Evaluation
Block: { StatementList }
    1. 返回StatementList的评估结果。
**** 评估是运行语义的行为。
*** 5.2.3 运行语义
  描述只在运行时被调用的语义的算法称为运行语义。运行语义被定义为抽象操作
或者面向语句的操作。都会返回一个结束记录。
**** 5.2.3.1 隐式结束值
  本规范的算法通常隐式的返回结束记录，其Type是normal。除非语境中有其
他明显的形式，算法语句才会返回一个不是结束记录的值，例如：
1. Return "Infinity"
意味着同下：
1. Return NormalCompletion("Infinity")
  然而，如果return语句的表达式的值是一个结束记录的构造语句，返回结束记录的
结果。如果是抽象操作，返回语句就是简单返回抽象操作产生的结束记录。
  抽象操作Completion(completionRecord)用于强调返回之前计算的结束记录。Completion
抽象操作接受一个参数completionRecord，按照下述步骤执行：
1. 断言completionRecord是结束记录
2. 将completionRecord作为这个抽象操作的结束记录返回。
  算法步骤中"return"语句没有值，意味着：
1. 返回NormalCompletionRecord(undefined)
  如果完结记录不是意外完结，在语境中又没有明确要求是完整的完结记录，那么
任何完结记录的引用的值是指完结记录的Value字段。
**** 5.2.3.2 投掷异常
  算法会投掷异常，例如：
1. Throw a TypeError exception
意味着：
1. Return ThrowCompletion(a newly created TypeError object)
**** 5.2.3.3 意外就返回
  算法步骤有如下或等价描述：
1. ReturnIfAbrupt(argument)
意味着：
1. 如果argument是一个意外完结，返回argument
2. 否则如果argument是一个完结记录，以argument的Value覆盖argument
  算法步骤有如下或等价描述：
1. ReturnIfAbrupt(AbstractOperation())
意味着：
1. 让hygienicTemp是AbstractOperation()
2. 如果hygienicTemp是意外完结，返回hygienicTemp
3. 否则如果hygienicTemp是完结记录，以hygienicTemp的Value覆盖hygienicTemp
这里hygienicTemp是短暂的，仅被ReturnIfAbrupt适用的步骤可见。
  算法步骤有如下或等价描述：
1. 让result是AbstractOperation(ReturnIfAbrupt(argument))
意味着：
1. 如果argument是意外完结，返回argument
2. 如果argument是完结记录，以argument的Value覆盖argument
3. 让result是AbstractOperation(argument)
**** 5.2.3.4 意外就返回的简写
  调用的抽象操作和面向句法的操作有前缀"?"，表明意外就返回被用在计算完结记
录上。例如步骤：
1. ?OperationName()
等价于：
1. ReturnIfAbrupt(OperationName())
类似的，方法运用形式的步骤：
1. ?someValue.OperationName()
等价于：
1. ReturnIfAbrupt(someValue.OperationName())
  类似的，前缀"!"被用于表明后续调用抽象或面向句法的操作绝对不会返回一个意
外完结，而且完结记录的Value备用作操作的返回值。例如步骤：
1. 让val是!OperationName()
等价于如下步骤：
1. 让val是OperationName()
2. 断言val不是意外完结
3. 如果val是完结记录，让val的Value覆盖val
  运行语义的面向句法的操作调用使用!和?这种前缀简写：
4. Perform !SyntaxDirectedOperation of NonTerminal
*** 5.2.4 静态语义
  上下文无关语法没有足够的能力表达定义在被评估的Script或Module的输入元素流的
所有规则。在这些情况下，需要额外的规则来表达ECMAScript算法约定或者散文要
求。这种规则总是联结到一个语法产出，被称作产出的静态语义。
  静态语义规则有名字，通常使用算法定义。命名的静态语义规则联结到语法产出，
产出有多个备选定义，每个备选针对提供的命名的静态语法规则有明确的算法。
  一类特殊的静态语法规则是前期错误规则。前期错误规则定义了前期错误条件，联
结到特定的语法产出。大多数的前期错误的评估不是在本规范的的算法内被显示调用
的。一个一致实现必须，在首次评估Script或Module前，校验Script或者Module解析的产
出的所有前期错误规则。任何前期错误规则被违反，这个Script或者Module就是无效的
且不能被评估。
*** 5.2.5 数学操作
  本规范给各种数字值相应的引用方式：
1. 数学值 Mathematical values: 任意实数，作为默认数字类型
2. 扩展数学值 Extended mathematical values: 包含+∞和-∞的Mathematical values
3. Numbers: IEEE 754-2019双精度浮点数值
4. BigInts: ECMAScript值准确表示任意有限整数
  本规范的语言中，使用下标后缀明确各种不同数字类型的数值。下标F表示浮点
数，下标Z表示BigInt，不带下标则是数学值。
  数学操作符如：+、*、=和≥指那些与运算符一致的操作。就是如果被提供了数学
值，这些操作符指的就是那些常用的数学运算。如果提供了Numbers，这些操作符指
的就是IEEE 754-2019内相应的操作。如果被提供了BigInt，这些操作符指将BigInt转
换为数学值后再应用常用的数学运算。
   通常，在本规范引用数字值的时候，例如短语"the length of y"或者"the integer 
represented by the four hexadecimal digits ..."，没有任何显式的数字类型声明，这个
短语表示的是数学值。短语需要显示声明使用的是指Numbers或者BigInt，例如，"the
Number value for the number of code points in ..."或者"the BigInt value for ..."。
   没有定义含有混合类型运算（比如Numbers与数学值）的数字操作符，应当被认为
是本规范的编辑错误。
   本规范中绝大多数数值使用十进制；有时会是Ox跟随0-9或和A-F的形式的16进制
数。
   本规范中如果使用integer术语，除非另有声明，指的是整数集上的数学值。如果
是integer Number术语，指的是其数学值在整数集上的Numbers。
   本文档里数学值与Numbers或BigInt之间的转换总是显式的。从数学值或者扩展数
值到Numbers的转换被明示为"the Number value for x"或者F(x)，在[[6.1.6.1]]有明确定义。
从整数x到BigInt的转换被明示为"the BigInt value for x"或者Z(x)。从Numbers或
者BigInt到数学值的转换被明示为"the mathematical value of x"或者R(x)。+0和-0的数
学值是数学值0。无穷的数学值没有定义。有限值x的扩展数学值x就是x的有限数学
值，+∞和-∞依次是+∞_F和-∞_F的值。NaN没有定义的数学值。
  数学函数abs(x)产生x的绝对值，如果x<0，就是-x否则就是x本身。数学函数min(x1,
x2,...,xN)产生x1到xN中数学意义上最小的。数学函数max(x1,x2,...,xN)产生x1到xN中
数学意义上最大的。这些数学函数的定义域是扩展数学值。
  "x modulo y"（y是有限的非零的）记法，计算一个与y（或者0）同号的k，满足
abs(k) < abs(y)且x-k = q * y，其中q是整数值。
  短语"the result of clamping x between lower and upper"（x是扩展整数值，lower和
upper是数学值，而且lower≤upper），如果x<lower，产生lower，如果x>upper，产生
upper，其他产生x。
  数学函数floor(x)产生不超过x的最大的整数，如果x是+∞，就是最接近+∞的整数。
  数学函数min,max,abs,floor没有为Numbers和BigInt定义，任何非数学值应用了这些
方法，都是一个编辑错误。
**** floor(x) = x - (x modulo 1)
*** 5.2.6 值记法
  本规范中，ECMAScript语言值用粗体显示。例如null，true或者"hello"。这些区别于
更长的ECMAScrpit代码序列比如：Function.prototype.apply或者let n = 42;
  本规范内部的，不能被ECMAScript代码直接察觉的值用sans-serif字体表示。例如，
完结记录的Type字段的值像normal、return、或者throw。
* 第六章
  本规范的算法操作的值都有一个联结的类型。可能的值类型在本条款确定。Type
进一步细分为ECMAScript语言的类型和规范的类型。
  在本规范，记号"Type(x)"用于简化"the type of x"，其中type指本条款定义的
ECMAScript语言的类型和规范的类型。"empty"术语用于声明一个值时，等于说"no 
value of any type"
** 6.1 用于ECMAScript语言的类型
ECMAScript语言的类型与ECMAScript语言编写的ECMAScript程序操作的值一致。ECMAScript
语言的类型有Undefined、Null、Boolean、String、Symbol、Number、BigInt和Object。
ECMAScript语言的值必然是被ECMAScript语言类型描述的。
*** 6.1.1 Undefined类型
  Undefined类型就一个值，即undefined。任何变量没有被赋值前都有undefined值。
*** 6.1.2 Null类型
  Null类型就一个值，即null。
*** 6.1.3 Boolean类型
  表示逻辑实体的Boolean类型有两个值，即true和false。
*** 6.1.4 String类型
  String类型是所有0到2^53-1个16位二进制无符号数（元素）构成的有序序列的集
合。在运行中的ECMAScript程序中String类型用于表示文本数据，这种情景下每个
String元素被当作UTF-16的编码单元值。在序列中，每个元素被认为占据一个位置。
位置使用非负整数索引。第一个元素（如果有）索引是0，随后元素（如果有）是1，
依次类推。String的长度就是他含有的元素数量。空String长度是0，因此也就没有元
素。
  不会翻译String内容的ECMAScript操作不提供任何延伸语义。翻译String值的操作把
每个元素当作UTF-16编码单元。然而ECMAScript不会限制这些编码单元的值或者关系，
所以将String内容作为Unicode编码单元翻译的操作必须考虑从错误格式的自序列。
这些操作需要对每个在[0xD800,0xDBFF]区间的编码单元（在Unicode标准中，作为首
位，或者通用的说法高位编码单元）和每个在[0xDC00,0xDFFF]区间的编码单元（被定
以为尾位，或者通用的说法低位编码单元）依据如下规则提供特殊的处理：
1. 一个编码单元既不是首位也不是尾位，按照原本值翻译。
2. 有两个编码单元的序列，如果第一个编码单元c1是首位，第二个编码单元c2是尾
位，这就是一个编码对，需要按照一个编码点进行翻译，编码点的值是
(c1 - 0xD800)*0x400+(c2-0xDC00)+0x10000
3. 如果编码单元是首位或者尾位，但是按照编码对出现，就按照原本值翻译。
**** 我觉得在组织编码时，这里有个注意事项，就是需要连续独立显示首位和尾位
     时，中间需要增加隔离符号。
  函数String.prototype.normalize(见于22.1.3.13)备用显式的规范String值。
String.prototype.localeCompare(见于22.1.3.10)内部规范String值，但是其他操作不会在
操作内容上隐式的规范String值。只有那些显式指明是语言或者地域敏感的操作产出
语言敏感的结果。
**** 这种设计的深层原因是让String的实现尽可能简单和高效。如果ECMAScript源文本
是C规范的，字符串原文被确保是规范的，只要没有包含任意的Unicode。
  本规范里，短语"the string-concatenation of A,B,..."（每个参数都是String值、编
码单元、或者编码单元序列），表示按照参数顺序依次拼接参数的编码单元序列形
成的编码单元序列的String值。
  短语"the substring of S from inclusiveStart to exclusiveEnd"（S是一个编码单元序列
的String值，inclusiveStart和exclusiveEnd是整数），表示S单元序列上[inclusiveStart,
exclusiveEnd)区间（如果inclusiveStart==exclusiveEnd，会是空集）上的编码单元的
String值。如果缺省了"to"，S的长度作为exclusiveEnd。
**** 6.1.4.1 StringIndexOf(string, searchValue, fromIndex)
  抽象操作StringIndexOf使用参数string（String值）,searchValue（String值）和
fromIndex（非负整数）。被调用时按照下列步骤执行：
1. Assert：Type(string)是String
2. Assert：Type(searchValue)是String
3. Assert：formIndex是非负整数
4. 让len是string的长度
5. 如果searchValue是空String，而且fromIndex≤len，返回fromIndex
6. 让searchLen是searchValue的长度
7. 每个从fromIndex开始到的i，且i≤len-searchLen的整数，按照升序依次执行
    a. 让candidate是substring of string from i to i+searchLen
    b. 如果candidate与searchValue有相同的编码序列，返回i
8. 返回 -1
**** 注意。如果searchValue而且fromIndex不大于string的长度时返回fromIndex。这用
空String可以在string的任何位置被找到。
**** 如果fromIndex > string的长度，算法返回-1
*** 6.1.5 Symbol类型
  Symbol类型是所有可以被用于Object属性的键，且不是Sring值的集合。
  每个Symbol值是唯一且无法修改的。
  每个Symbol值不可修改的联结到一个被称为Description的值，undefined或者是String
值。
**** 6.1.5.1 既有Symbols
  既有symbol是内置的Symbol值，用于显式引用本规范的算法。他们通常被用于属性
的键，对应的属性值作为本规范的算法的扩展点。除非特殊说明，所有的既有symbol
在全部领下可用。
  本规范内，既有symbol使用@@name形式的标注来引用，name是下表的值。
| Specification Name   | Description                     | Value and Purpose                                                                                     |
| @@asyncIterator      | "Symbol.asyncIterator"      | 为对象返回一个默认的AsyncIterator方法。被语句for-await-of语义调用                                     |
| @@hasInstance        | "Symbol.hasInstance"        | constructor对象识别一个对象是否是自身实例的方法。被instanceOf操作符调用                               |
| @@isConcatSpreadable | "Symbol.isConcatSpreadable" | 属性值是Boolean。如果true，表明对象应该被Array.prototype.concat展平为其数组元素                       |
| @@iterator           | "Symbol.iterator"           | 为对象返回默认Iterator的方法。被for-of语句的语义调用。                                                |
| @@match              | "Symbol.match"              | 正则表达式用于匹配字符串的方法。被String.prototype.match方法调用                                      |
| @@matchAll           | "Symbol.matchAll"           | 正则表达式返回一个遍历器的方法，遍历器提供表达式匹配字符串的结果。被String.prototype.matchAll方法调用 |
| @@replace            | "Symbol.replace"            | 正则表达式替换字符串上匹配的子串的方法。被String.prototype.replace方法调用                            |
| @@search             | "Symbol.search"             | 正则表达式返回字符串上匹配的位置索引。被String.prototype.search方法调用                               |
| @@species            | "Symbol.species"            | 其属性值是constructor函数，用于创建衍生对象                                                           |
| @@split              | "Symbol.split"              | 正则表达式用于将字符串在匹配的位置索引上进行拆分的方法。被String.prototype.split方法调用              |
| @@toPrimitive        | "Symbol.toPrimitive"        | 用于将对象转换为基础值的方法。被ToPrimitive抽象操作调用                                               |
| @@toStringTag        | "Symbol.toStringTag"        | 属性值是String值，用于创建对象的默认描述。被内置方法Object.prototype.toString访问                     |
| @@unscopables        | "Symbol.unscopables"        | 属性值是对象，对象自有或继承的属性名称是被联结对象绑定的with环境排除的属性名                          |
*** 6.1.6 数值类型
  ECMAScript有两种内置的数值类型：Number和BigInt。本规范任意数值类型T包含乘法
标识记为T::unit。本规范类型也有跟随的抽象操作，就像规范名称op上的给定操作
记为T::op。所有参数是T。"Result"列显示返回的类型，如果调用操作可能会返回意
外完结，"Result"会有标示。
| 调用概要                  | 源文件示例                               | 调用者的评估语义所属                                                     | Result                           |
| T::unaryMinus(x)          | - x                                      | Unary - Operator                                                         | T                                |
| T::bitwiseNOT(x)          | ~ x                                      | 按位非操作符( ~ )                                                        | T                                |
| T::exponentiate(x, y)     | x ** y                                   | 幂运算操作和Math.pow(base, exponent)                                     | T,可能会投掷范围异常             |
| T::multiply(x, y)         | x * y                                    | 乘法算符                                                                 | T                                |
| T::divide(x, y)           | x / y                                    | 乘法算符                                                                 | T,可能会投掷范围异常             |
| T::remiander(x, y)        | x % y                                    | 乘法算符                                                                 | T,可能会投掷范围异常             |
| T::add(x, y)              | x \+\+, \+\+ x, x + y                    | 后自增算符，前自增算符和加法算符                                         | T                                |
| T::subtract(x, y)         | x--, --x, x - y                          | 后自减算符，前自减算符和减法算符                                         | T                                |
| T::leftShift(x, y)        | x << y                                   | 左移算符（<<）                                                           | T                                |
| T::signRightShift(x, y)   | x >> y                                   | 有符号右移算符（>>）                                                     | T                                |
| T::unsignRightShift(x, y) | x >>> y                                  | 无符号右移算符（>>>）                                                    | T，可能会投掷类型错误            |
| T::lessThan(x, y)         | x < y, x > y, x <= y, x >= y             | 关系算符，通过抽象关系比较                                               | Boolean或者undefined（无序输入） |
| T::equal(x, y)            | x \=\= y, x !\= y, x \=\=\= y, x !\=\= y | 相等算符，通过严格相等比较                                               | Boolean                          |
| T::sameValue(x, y)        |                                          | Object内部方法，通过SameValue(x, y)检测相等性                            | Boolean                          |
| T::sameValueZero(x, y)    |                                          | Array、Map和Set方法，通过SameValueZero(x, y)检测相等性，忽略+0与-0的差别 | Boolean                          |
| T::bitwiseAND(x, y)       | x & y                                    | 二进制按位操作符                                                         | T                                |
| T::bitwiseXOR(x, y)       | x ^ y                                    | 二进制按位操作符                                                         | T                                |
| T::bitwiseOR(x, y)        | x \vert y                                | 二进制按位操作符                                                         | T                                |
| T::toString(x)            | String(x)                                | 很多表达式或者内置函数，通过ToString(argument)                           | String                           |
  T::unit值和T::op运算不是ECMAScript语言的部分，在这里定义它们，仅仅就是帮助
ECMAScript语言的语义规范。其他抽象操作通过本规范定义。
  因为数字类型在转换时通常会丢失精度或者截断，所以ECMAScript语言在这个类型
间不提供隐式的转换。程序员必须显式调用Number和BigInt函数来转换类型，如果调
用的函数需要不同的类型时。
**** 注意 从第一版ECMAScript开始，针对某些操作，已经提供了隐式的会丢失精度
的数值转换。这些合法的转换被保留在后续的兼容里，但是支持BigInt，以便减少
程序错误的几率，和在未来版本保留通用值类型的选项。
**** 6.1.6.1 Number类型
  Number类型有18,437,736,874,454,810,627（就是2^64 - 2^53 + 3）个值，表示IEEE 
754-2019的双精度64位格式值，在IEEE标准中为二进制浮点数代数而规定的，除了
9,007,199,254,740,990（就是2^53 - 2）个被识别为IEEE标准中的"Not-a-Number"值。
这些"Not-a-Number"值在ECMAScript中被用一个特殊NaN值表示。（注意NaN值是被程序
表达式NaN产生的）。在某些实现中，扩展代码可能侦测到不同Not-a-Number值的差
异，但是这种行为是实现定义的。ECMAScript代码所有的NaN是不区分。
***** 注意在ArrayBuffer（见于[[25.1]]）或者SharedArrayBuffer（监狱[[25.2]]）中，一个
Number值被存储到其中后，可能侦测到这种位模式值（能够区分的NaN），这种
位模式没有必要与ECMAScript实现使用内部表示Number值的行为一致。
  有两个特殊的值：正无穷与负无穷。为了方便，这些值依次用说明性更好的符号
\+∞_F和\-∞_F表示（这两种Number值用+Infinity或者简单的Infinity和-Infinity产生）。
  其他18,437,736,874,454,810,624(就是2^64 - 2^53)值被称为有限值。一半正数，一半
负数。每个有限的正Numbr值都有一个对应的相同规模的负值。
  注意这里有一个正0一个负0。为了简便，这些值依次用说明性更好的符号+0_F和
-0_F的方式表示（这两种零Number值被程序表达式+0或0和-0产生）。
  这18,437,736,874,454,810,622（就是2^64 - 2^53 - 2）个非零有限值分类两类：
18,428,729,675,200,069,632（2^64 - 2^54 ）是正常化的，具有 s * m * 2^e 的形式
其中s是1或-1，m是在[2^52, 2^53)上的整数，e是[-1074,971]上的整数。剩下的
9,007,199,254,740,990（2^53 - 2）个数是非正常化的，也具有 s * m * 2 ^e 的形式，
其中s是1或-1，m是在(0, 2^52)上的整数，e是-1074.
  注意所有Number类型的整数的规模不会超过2^53。整数0有两种Number类型：+0_F和
-0_F。
  按照上述形式表达的非零有限值，如果m是奇数，这个数有奇数精度。否则是偶数
精度。
  本规范中，短语"x的Number值"，其中x表示一个实数（包括pai这种无理数），意味
Number值按照下列方式选中。（Number值都是有限精度的有理数）。构建一个包含除
-0_F以外的有限值和两个不被有限Number类型表示的特殊值，即2^1024（1*2^53*2^971）
和-2^1024（-1*2^53*2^971），的集合。在其中选择一个数最接近x的元素。如果有两个
与x一样，那么选择是偶数精度，因此2^1024与-2^1024被认为是偶数精度。如果选中
2^1024，替换为\+∞_F；如果是选中-2^1024，替换为-∞_F；如果选中+0，且x<0，替换为
-0；其他选中保持不便。这个结果就是"x的Number值"。（这个产出与IEEE 754-2019的
向偶数近似模式严格一致）。
  \+∞的Number值是\+∞_F，\-∞的Number值是\-∞_F。
  有些ECMAScript操作只能处理在[-2^31,2^31-1]或者[0,2^16-]上的整数。这些算符接受
全部的Number值，但是算法第一步会转换为期望范围内的整数。数字转换的细节描述
在[[7.1]]。
  Number::unit的值是1_F
***** 6.1.6.1.1 Number::unaryMinus(x)
  抽象操作Number::unaryMinus接受参数Number值x，被调用时执行下列两步：
1. 如果x是NaN，返回NaN。
2. 返回相反的x；就是带有相反符号但是相同规模的Number值。
***** 6.1.6.1.2 Number::bitwiseNOT(x)
  抽象操作Number::bitwiseNOT接受参数Number值x，被调用时执行下列两步：
1. 让oldValue是!ToInt32(x).
2. 返回oldValue的二进制补码。结果的数学值可以准确表示为32位二进制补码的字
符串。
***** 6.1.6.1.3 Number::exponentiate(base, exponent)
  抽象操作Number::exponentiate接受参数Number值base与exponent，返回一个基于实现的
近似于base上幂乘exponent的结果（也就是说相同算式在不同实现上结果可能不同）。
被调用时按照如下步骤执行：
1. 如果exponent是NaN，返回NaN。
2. 如果exponent是+0_F或者-0_F，返回1_F。
3. 如果base是NaN，返回NaN。
4. 如果base是+∞_F，那么：
    a. 如果exponent>+0_F，返回+∞，否则返回+0_F。
5. 如果base是-∞_F，那么：
    a. 如果exponent>+0_F，那么：
        i. 如果exponent是奇数Number，返回-∞_F。否这返回+∞_F。
    b. 否则
        i. 如果exponent是奇数Number，返回-0_F。否则返回+0_F。
6. 如果base是+0_F，那么：
    a. 如果exponent > +0_F，返回+0_F。否则返回+∞_F。
7. 如果base是-0_F，那么：
    a. 如果exponent>+0_F，那么：
        i. 如果exponent是奇数Number，返回-0_F，否则返回+0_F。
    b. 否则
        i. 如果exponent是奇数Number，返回-∞_F，否则返回+∞_F。
8. Assert：base是有限的，而且不是+0_F和-0_F。
9. 如果exponent是+∞_F，那么：
    a. 如果abs(R(base))>1，返回+∞_F。
    b. 如果abs(R(base))是1，返回NaN。
    c. 如果abs(R(base))<1，返回+0_F。
10. 如果exponent是-∞_F，那么：（-∞_F在规范中被看作是偶数）
    a. 如果abs(R(base))>1，返回+0_F。
    b. 如果abs(R(base))是1，返回NaN。
    c. 如果abs(R(base))<1，返回+∞_F。
11. Assert： exponent是有限的，而且不是+0_F和-0_F。
12. 如果 base < +0_F，而且exponent不是整数Number，返回NaN。
13. 返回表示R(base)幂乘R(exponent)结果的实现近似值。
****** 注意 base ** exponent的结果在 base 是1_F或者-1_F且exponent是+∞_F或者-∞_F
，和base是1_F且exponent是NaN时与IEEE 754-2019不同。在最早ECMAScript版本中规定为
NaN，而在最新的IEEE 754-2019中规定为1_F。为了兼容，历史ECMAScript行为被保留了
下来。
***** 6.1.6.1.4 Number::multiply(x, y)
  抽象操作Number::multiply接受Number值参数：x, y。依据IEEE 754-2019中二进制双精
度算术规则执行乘法，产生x和y的乘积。被调用时，执行下列步骤：
1. 如果x或y是NaN，返回NaN。
2. 如果x是+∞_F或者-∞_F，
    a. 如果y是+0_F或者-0_F，返回NaN。
    b. 如果y > +0_F，返回x。
    c. 返回-x。
3. 如果y是+∞_F或者-∞_F，
    a. 如果x是+0_F或者-0_F，返回NaN。
    b. 如果x > +0_F，返回y。
    c. 返回-x。
4. 返回F(R(x)*R(y))
****** 有限精度乘法满足交换律，但是不满足结合律。
***** 6.1.6.1.5 Number::divide(x,y)
  抽象操作Number::divide接受Number值参数：x, y。依据IEEE 754-2019中二进制双精
度算术规则执行乘法，产生x除以y的商。被调用时，执行下列步骤：
1. 如果x是NaN或者y是NaN，返回NaN。
2. 如果x是+∞_F或者-∞_F，那么：
    a. 如果y是+∞_F或者-∞_F，返回NaN。
    b. 如果y是+0_F或者y>+0_F，返回x。
    c. 返回-x。
3. 如果y是+∞_F，那么
    a. 如果x是+0_F或者x>+0_F，返回+0_F。否则返回-0_F。
4. 如果y是-∞_F，那么
    a. 如果x是+0_F或者x>+0_F，返回-0_F。否则返回+0_F。
5. 如果x是+0_F或者-0_F，那么
    a. 如果y是+0_F或者-0_F，返回NaN。
    b. 如果y>+0_F，返回x。
    c. 返回-x。
6. 如果y是+0_F，那么
    a. 如果x>+0_F，返回+∞_F。否则返回-∞_F。
7. 如果y是-0_F，那么
    a. 如果x>+0_F，返回-∞_F。否则返回-∞_F。
8. 返回F(R(x)/R(y))
***** 6.1.6.1.6 Number::remainder(n,d)
  抽象操作Number::remainder接受Number值参数：n, d。从隐含的n除以d计算获得余数。
被调用时，执行下列步骤：
1. 如果n是NaN，或者d是NaN，返回NaN。
2. 如果n是+∞_F或者-∞_F，返回NaN。
3. 如果d是+∞_F或者-∞_F，返回n。
4. 如果d是+0_F或者-0_F，返回NaN。
5. 如果n是+0_F或者-0_F，返回n。
6. Assert：n和d是有限非零的。
7. 让r是R(n)-(R(d)*q)。q是整数，如果n与d不同号，q是负数。q的规模不超过
R(n)/R(y)的规模的情况下尽可能大。
8. 返回F(r)。
****** 注意1 C与C++在remainder操作中只接受整数，而ECMAScript中也接受浮点数。
****** 注意2 浮点数通过%计算获得的余数与IEEE 754-2019定义的不同。在IEEE 754-2019
中余数采用四舍五入商计算，而不是结算商，所以其行为与常用的整数求余不同。
相较于C库中的函数fmod，ECMAScript语言的%在浮点数上的的计算与Java的整数求余的
行为更相似。
***** 6.1.6.1.7 Number::add(x, y)
  抽象操作Number::add接受Number值参数：x, y。依据IEEE 754-2019中二进制双精
度算术规则执行加法，产生x与y的和。被调用时，执行下列步骤：
1. 如果x是NaN，或者y是NaN，返回NaN。
2. 如果x是+∞_F，且y是-∞_F，返回NaN。
3. 如果x是-∞_F，且y是+∞_F，返回NaN。
4. 如果x是+∞_F或者-∞_F，返回x。
5. 如果y是+∞_F或者-∞_F，返回y。
6. Assert：x和y是都是有限的。
7. 如果x是-0_F，且y是-0_F，返回-0_F。
8. 返回F(R(x)+R(y))。
****** 有限精度加法符合交换律，但是不符合结合律。
***** 6.1.6.1.8 Number::subtract(x,y)
  抽象操作Number::subtract接受Number值参数：x, y。执行减法，产生x减以y的结果。
被调用时，执行下列步骤：
1. 返回 Number::add(x, Number::unaryMinus(y))
****** 注意 x - y的结果总是与 x + (- y) 的结果一致。
***** 6.1.6.1.9 Number::leftShift(x, y)
  抽象操作Number::leftShift接受Number值参数：x，y。被调用时，执行下列步骤：
1. 让lnum是!ToInt32(x)
2. 让rnum是!ToUint32(y)
3. 让shiftCount是R(rnum)对于32的模，R(rnum)%32
4. 返回lnum左移shiftCount位的结果。结果的数学值准确表示这个32位的2禁止字符串。
***** 6.1.6.1.10 Number::signedRightShift(x,y)
  抽象操作Number::signedRightShift接受两个Number值参数：x、y。被调用时，执行
下列步骤：
1. 让lnum是!ToUint32(x)
2. 让rnum是!ToUint32(y)
3. 让shiftCount是R(rnum)在32上的模
4. 返回lnum按符号右移shiftCount位的结果。空位用符号位值填充。结果的数学值准
确表示结果的32位二进制补码串
***** 6.1.6.1.11 Number::unsignedRightShift(x,y)
  抽象操作Number::unsignedRightShift接受两个Number值参数：x、y。被调用时，执行
下列步骤：
1. 让lnum是!ToUint32(x)
2. 让rnum是!ToUint32(y)
3. 让shiftCount是R(rnum)在32上的模
4. 返回保留符号位lnum右移shiftCount位以0填充的结果。空位用0填充。结果的数学值
准确表示结果的32位无符号二进制串。
***** 6.1.6.1.12 Number::lessThan(x,y)
  抽象操作Number::lessThan接受两个Number值参数：x、y。被调用时，执行下列步骤：
1. 如果x是NaN，返回undefined
2. 如果y是NaN，返回undefined
3. 如果x、y是相同的Number值，返回false
4. 如果x是+0_F，y是-0_F，返回false
5. 如果x是-0_F，y是+0_F，返回false
6. 如果x是+∞_F，返回false
7. 如果y是+∞_F，返回true
8. 如果y是-∞_F，返回false
9. 如果x是-∞_F，返回true
10. Assert：x和y都是有限的非零Number值
11. 如果R(x)<R(y)，那么返回true。否则返回false。
***** 6.1.6.1.13 Number::equal(x,y)
  抽象操作Number::equal接受两个Number值参数：x、y。被调用时，执行下列步骤：
1. 如果x是NaN，返回false
2. 如果y是NaN，返回false
3. 如果x、y是相同的Number值，返回true
4. 如果x是+0_F，y是-0_F，返回true
5. 如果x是-0_F，y是+0_F，返回true
6. 返回false
***** 6.1.6.1.14 Number::sameValue(x,y)
  抽象操作Number::sameValue接受两个Number值参数：x、y。被调用时，执行下列步骤：
1. 如果x是NaN，而且y也是NaN，返回true
2. 如果x是+0_F，y是-0_F，返回false
3. 如果x是-0_F，y是+0_F，返回false
4. 如果x、y是相同的Number值，返回true
5. 返回false
***** 6.1.6.1.15 Number::sameValueZero(x,y)
  抽象操作Number::sameValueZero接受两个Number值参数：x、y。被调用时，执行下列
步骤：
1. 如果x是NaN，而且y也是NaN，返回true
2. 如果x是+0_F，y是-0_F，返回true
3. 如果x是-0_F，y是+0_F，返回true
4. 如果x、y是相同的Number值，返回true
5. 返回false
***** 6.1.6.1.16 NumberBitwiseOp(op, x, y)
  抽象操作NumberBitwiseOp接受参数op（Unicode字符串）、Number值x和Number值y。被调
用时执行下列步骤：
1. Assert：op是"&"、"^"或者"|"
2. 让lnum是!ToInt32(x)
3. 让rnum是!ToInt32(y)
4. 让lbits是表示R(lnum)的32位2进制补码字符串
5. 让rbits是表示R(rnum)的32位2进制补码字符串
6. 如果op是&，让result是在lbits和rbits上使用按位与（AND）操作的结果
7. 如果op是^，让result是在lbits和rbits上使用按位异或（XOR）操作的结果
8. 如果op是|，让result是在lbits和rbits上使用按位或（OR）操作的结果
9. 返回result代表的整数的Number值
***** 6.1.6.1.17 Number::bitwiseAND(x,y)
  抽象操作Number::bitwiseAND接受两个Number值参数：x、y。被调用时，执行下列步
骤：
1. 返回NumberBitwiseOp('&', x, y)
***** 6.1.6.1.18 Number::bitwiseXOR(x,y)
  抽象操作Number::bitwiseXOR接受两个Number值参数：x、y。被调用时，执行下列步
骤：
1. 返回NumberBitwiseOp('^', x, y)
***** 6.1.6.1.19 Number::bitwiseOR(x,y)
  抽象操作Number::bitwiseOR接受两个Number值参数：x、y。被调用时，执行下列步
骤：
1. 返回NumberBitwiseOp('|', x, y)
***** 6.1.6.1.20 Number::toString(x)
  抽象操作Number::toString接受一个Number值参数x。转换x为字符串格式。被调用
时，执行下列步骤：
1. 如果x时NaN，返回字符串"NaN"
2. 如果x是+0_F或者-0_F，返回字符串"0"
3. 如果x<+0_F，返回"-"与!Number::toString(-x)的拼接字符串
4. 如果x是+∞_F，返回字符串"Infinity"
5. 让n、k和s是整数，且满足k>=1，10^(k-1)<= s < 10^k, s* 10^(n-k)是R(x)，而且k
尽可能小。k与s的十进制位数相等，s不能被10整除，s的最低位数字没必要由本
标准确定
6. 如果k <= n <= 21，返回下列字符串的拼接：
    。十进制s的k位数字（按顺序，非0开始）
    。n-k个0x0030（数字0）
7. 如果0 < n <= 21，返回下列字符串的拼接：
    。十进制s的n个高位部数字
    。0x002E（小数点）
    。十进制s剩余的k-n位数字
8. 如果-6 < n <= 0，返回下列字符串的拼接：
    。0x0030（数字0）
    。0x002E（小数点）
    。-n个0x0030（数字0）。注意n<0，所以取-n。
    。十进制s的k位数字
9. 如果k是1，返回下列字符串的拼接：
    。s的数字
    。0x0065（小写字母e）
    。0x002B（+）或者0x002D（-）与n-1的正负号相同
    。n-1绝对值的十进制数字（非0开始）
10. 返回下列字符串的拼接：
    。十进制s的最高位数字
    。0x002E（小数点）
    。十进制s的低位部k-1个数字
    。0x0065（小写字母e）
    。0x002B（+）或者0x002D（-）与n-1的正负号相同
    。n-1绝对值的十进制数字（非0开始）
****** 注意 如下推论可能对实现有帮助，但不是本标准的规范要求。
。如果x是Number值，且大于-0_F，那么ToNumber(ToString(x))与x的Number值相同
。本规范的第五步决定了，s的最低位非唯一
****** 注意 如果实现提供了更精确的转换，推荐第5步符合如下指导
  5. 让n、k和s是整数，且满足k>=1，10^(k-1)<= s < 10^k, s* 10^(n-k)是R(x)，而且
k尽可能小。如果由多个s，选择s*10^(n-k)最接近R(x)的。如果由两个可选的s，那么
选择偶数。k是十进制s的位数，s不能被10整除。
****** 注意 ECMAScript的实现可以在David M. Gay关于二进制浮点数转换的相关论文
中找到有用的内容和代码。
http://ampl.com/REFS/abstracts.html#rounding 近似展示数字。
http://netlib.sandia.gov/fp/dtoa.c 这是部分代码
http://netlib.sandia.gov/fp/g_fmt.c 这是其他部分代码。
这些内容也可以在netlib镜像找到。
***** 6.1.6.2 BigInt 类型
  BigInt类型表示整数值。这个值可以是任何大小，也没有二进制宽度限制（任何
大小好理解。二进制宽度限制估计是表示不限制位16的倍数。但是我估计仍然会是8
的倍数）。如果没有说明，这里的操作都返回准确数学值结果。对于二进制操作，
BigInt被作为二进制补码字符串处理，负数的话认为左侧有无穷位。
  BigInt::unit的值是1_Z。
***** 6.1.6.2.1 BigInt::unaryMinus(x)
  抽象操作BigInt::unaryMinus接受一个BigInt参数：x。被调用时执行下列步骤：
1. 如果x是0_Z，返回0_Z
2. 返回表示负的R(x)的BigInt值。
***** 6.1.6.2.2 BigInt::bitwiseNOT(x)
  抽象操作BigInt::bitwiseNOT(x)接受一个BigInt参数。返回x的补码表示的BigInt，也
就是-x-1_Z
***** 6.1.6.2.3 BigInt::exponentiate(base, exponent)
  抽象操作BigInt::exponentiate接受BigInt参数：base、exponent。被调用时执行下
列步骤：
1. 如果exponent < 0_Z。抛出异常。
2. 如果base是0_Z而且exponent是0_Z，返回1_Z。
3. 返回表示R(base)幂乘R(exponent)的结果的BigInt值。
***** 6.1.6.2.4 BigInt::multiply(x, y)
  抽象操作BigInt::multiply接受BigInt参数：x、y。返回x乘以y的结果的BigInt值。
****** 注意 即使结果远超输入规模，准确的数学值结果也应该返回。
***** 6.1.6.2.5 BigInt::divide(x,y)
  抽象操作BigInt::divide接受BigInt参数：x、y。被调用时执行下列步骤：
1. 如果y是0_Z，投掷RangeError异常。
2. 让quotient是R(x)/R(y)
3. 返回quotient向0取整的整数的BigInt值。
***** 6.1.6.2.6 BigInt::remainder(n, d)
  抽象操作BigInt::remainder接受BigInt参数：n、d。被调用时执行下列步骤：
1. 如果d是0_Z，投掷RangeError异常
2. 如果n是0_Z，返回0_Z
3. 让r是被算式r=n-(d*q)决定的BigInt值。q是BigInt，且与n/d同正负号，在不超过n
除以d的商的规模下，尽可能大
4. 返回r
****** r的符号与n的符号一致。
***** 6.1.6.2.7 BigInt::add(x,y)
  抽象操作BigInt::add接受BigInt参数：x、y。返回x与y的和的BigInt值。
***** 6.1.6.2.8 BigInt::subtract(x,y)
  抽象操作BigInt::subtract接受BigInt参数：x、y。返回x减以y的差的BigInt值。
***** 6.1.6.2.9 BigInt::leftShift(x,y)
  抽象操作BigInt::leftShift接受BigInt参数：x、y。被调用时执行下列步骤：
1. 如果y < 0_Z，那么：
    a. 计算R(x)/(2^-y)近似到最接近的整数，包括负数。返回这个整数的BigInt值
2. 返回表示R(x)*(2^y)的BigInt值
****** 语义上等价于按位左移，只是把BigInt值看作是无限长的二进制补码串。
***** 6.1.6.2.10 BigInt::signedRightShift(x,y)
  抽象操作BigInt::signedRightShift接受BigInt参数：x、y。被调用时执行下列步骤：
1. 返回BigInt::leftShift(x,-y)
***** 6.1.6.2.11 BigInt::unsignedRightShift(x,y)
  抽象操作BigInt::unsignedRightShift接受BigInt参数：x、y。被调用时执行下列步骤：
1. 投掷TypeError异常。BigInt值被看作是无限长的二进制补码串，转换没有意义。
***** 6.1.6.2.12 BigInt::lessThan(x,y)
  抽象操作BigInt::lessThan接受BigInt参数：x、y。当R(x)<R(y)时返回true，否则
返回false。
***** 6.1.6.2.13 BigInt::equal(x,y)
  抽象操作BigInt::equal接受BigInt参数：x、y。当R(x)==R(y)时返回true，否则返回
false。
***** 6.1.6.2.14 BigInt::sameValue(x,y)
  抽象操作BigInt::sameValue接受BigInt参数：x、y。被调用时执行下列步骤：
1. 返回BigInt::equal(x,y)
***** 6.1.6.2.15 BigInt::sameValueZero(x,y)
  抽象操作BigInt::sameValueZero接受BigInt参数：x、y。被调用时执行下列步骤：
1. 返回BigInt::equal(x,y)
***** 6.1.6.2.16 BinaryAnd(x,y)
  抽象操作BinaryAnd接受BigInt参数：x、y。被调用时执行下列步骤：
1. Assert：x是0或者1
2. Assert：y是0或者1
3. 如果x是1且y是1，返回1
4. 否则返回0
***** 6.1.6.2.17 BinaryOr(x,y)
  抽象操作BinaryOr接受BigInt参数：x、y。被调用时执行下列步骤：
1. Assert：x是0或者1
2. Assert：y是0或者1
3. 如果x是1或者y是1，返回1
4. 否则返回0
***** 6.1.6.2.18 BinaryXor(x,y)
  抽象操作BinaryXor接受BigInt参数：x、y。被调用时执行下列步骤：
1. Assert：x是0或者1
2. Assert：y是0或者1
3. 如果x是1且y是0，返回1
4. 如果x是0且y是1，返回1
5. 否则返回0
***** 6.1.6.2.19 BigIntBitwiseOp(op,x,y)
  抽象操作BigIntBitwiseOp接受参数op（Unicode字符串）、BigInt值x和BigInt值y。被调
用时执行下列步骤：
1. Assert：op是"&"、"^"或者"|"
2. 置x为R(x)
3. 置y为R(y)
4. 让result是0
5. 让shift是0
6. 重复执行，直到x是0或-1，而且y是0或-1：
    a. 让xDigit是 x modulo 2
    b. 让yDigit是 y modulo 2
    c. 如果op是'&'，置result为 result + (2^shift) * BinaryAnd(xDigit, yDigit)
    d. 如果op是'|'，置result为 result + (2^shift) * BinaryOr(xDigit, yDigit)
    e. 否则
        i. Assert: op 是'^'
        ii. 置result为 result + (2^shift) * BinaryXor(xDigit, yDigit)
    f. 置shift为shift+1
    g. 置x位 (x - xDigit)/2
    h. 置y位 (y - yDigit)/2
7. 如果op是'&'，让tmp是BinaryAnd(x modulo 2, y modulo 2)
8. 如果op是'|'，让tmp是BinaryOr(x modulo 2, y modulo 2)
9. 否则
    a. Assert：op是'|'
    b. 让tmp是BinaryXor(x modulo 2, y modulo 2)
10. 如果tmp!=0，那么
    a. 置result为 result - (2^shift)
    b. 注意：这就保证了符号一致。
11. 返回result的BigInt值
***** 6.1.6.2.20 BigInt::bitwiseAND(x,y)
  抽象操作BigInt::bitwiseAND接受BigInt参数：x、y。被调用时执行下列步骤：
1. 返回BigIntBitwiseOp(&,x,y)
***** 6.1.6.2.21 BigInt::bitwiseXOR(x,y)
  抽象操作BigInt::bitwiseXOR接受BigInt参数：x、y。被调用时执行下列步骤：
1. 返回BigIntBitwiseOp(^,x,y)
***** 6.1.6.2.22 BigInt::bitwiseOR(x,y)
  抽象操作BigInt::bitwiseOR接受BigInt参数：x、y。被调用时执行下列步骤：
1. 返回BigIntBitwiseOp(|,x,y)
***** 6.1.6.2.23 BitInt::toString(x)
  抽象操作BigInt::toString接受BigInt参数：x。转换x到字符串形式。被调用时执行
下列步骤：
1. 如果x < 0_Z，返回"-"与!BigInt::toString(-)的字符串拼接
2. 返回表示x十进制数字的字符串。
**** 6.1.7 Object类型
  Object逻辑上是若干性质的聚集。性质分为数据性质与访问性质：
. 数据性质指一个键值伴随一个ECMAScript语言值，和描述属性集合
. 访问性质指一个键值伴随一个或者两个访问方法，和描述属性集合
访问方法用于存储或者取回这个属性联结的ECMAScript语言值。
  性质用键值识别。键值类型是ECMAScript的String值或者Symbol值。所有的String或者
Symbol值都是有效的性质键，包括空字符串。性质名称就是性质键的String值。
  整数索引是String值的性质键，是最简的数字String，其数字值在[+0_F, 2^53-1]之
间。但是数组的索引在[+0_F,2^32-1)之间。
  性质键用于访问性质和其值。有两种访问方式：get与set，对应用于取回值和赋
值。通过get与set访问的性质包括对象直接含有的自有性质和通过原型访问的其他
对象的继承性质。继承性质是继承对象的自有性质或者继承性质。每个对象下的自有
性质的键是相互区别的。
  所有对象逻辑上都是若干性质的聚集，但是根据语义访问和操作性质的不同，有多
种对象的形式。请参考6.1.7.2关于定义对象的若干形式。
***** 6.1.7.1 性质的属性
  在本规范中性质用于定义和解释Object性质的状态。数据性质每个键值联结下表
Table3 所示的属性。
| 属性名       | 值域                 | 详细描述                                                                                                    |
| Value        | 任何ECMAScript语言值 | get访问性质获取的值                                                                                         |
| Writable     | Boolean              | 如果false，在ECMAScript代码试图通过set对Value进行赋值时，不会成功                                           |
| Enumerable   | Boolean              | 如果true，性质可以被for-in方式枚举到。否则，这个性质是不可枚举的                                            |
| Configurable | Boolean              | 如果false，那么下列行为会失败：删除性质、修改性质为访问性质、修改属性（除了Value，和Writable由true到false） |
  访问性质每个键值联结下表 Table4 所示的属性
| 属性名       | 值域                | 详细描述                                                                                               |
| Get          | Object或者undefined | 如果是Object那么必然是一个函数对象。函数内部call方法在每次取回性质值时被调同，其参数为空               |
| Set          | Object或者undefined | 如果是Object那么必然是一个函数对象。每次对性质值进行赋值时，函数内部call方法被调用，参数仅为要赋予的值 |
| Enumerable   | Boolean             | 如果true，性质可以被for-in方式枚举到。否则，这个性质是不可枚举的                                       |
| Configurable | Boolean             | 如果false，那么下列行为会失败：删除性质、修改性质为数据性质、修改属性。                                |
  如果初始化时没有显示的按照本规范声明性质的属性，默认属性设置按照下表
Table5 所示
| 属性名       | 默认值    |
| Value        | undefined |
| Get          | undefined |
| Set          | undefined |
| Writable     | false     |
| Enumerable   | false     |
| Configurabel | false     |
***** 6.1.7.2 Object内部方法与内部占位
  在ECMAScript，对象的实际语义是通过被称为内部方法的算法规范的。在ECMAScript
引擎中的每个对象都联结了一套内部方法，这些方法定义了其运行时的行为。这些
内部方法不是ECMAScript语言的内容。他们在本规范中被定义仅仅是为了用于解释。
然而，在ECMAScript实现中的对象表现必须与指定的联结的内部方法表现一致。其实际
完成的方式由实现决定。
  内部方法名称是多态的。这个不同对象值在调用一个通用的方法的时候可能会使用
不同的算法。方法调用时的实际背景对象是内部方法的"target"值。如果，运行时，
实现的算法试图使用某个对象不支持的内部方法，会投掷TypeError异常。
  内部占位对应联结对象的内部状态，被各ECMAScript实现算法使用。内部占位不是
对象性质，也不能被继承。根据内部占位实现的规范，其状态值可能是任何ECMAScript
语言类型或者ECMAScript规范类型。除非显示指明，内部占位在创建对象的过程就被
联结，而且可能不可以动态的增加。除非显示指明，内部占位的初始值是undefined。
本规范的各种算法创建的对象都有内部占位。然而ECMAScript语言不提供联结到对象
的直接途径。
  本规范定义的内部方法和内部占位的名字使用双方括号包裹的形式\[\[]]
  Table6 描述了用于本规范创建和修改对象是使用的基础内部方法。每个对象都要有
所有基础内部方法的算法。然而不同对象的内部方法的算法可能不同。
  基本对象是满足下列所有标准的对象
. 在Table6中列举的内部方法，对象使用在10.1中的定义
. 如果对象有\[\[Call]]内部方法，使用10.2.1的定义
. 如果对象由\[\[Construct]]内部方法，使用10.2.2的定义。
  不是基本对象的对象都是奇异对象。
  本规范通过其对象的内部方法识别不同的奇异对象。对象只有奇异对象的部分行为
（比如Array奇异对象或者绑定函数对象），但是没有其指明的全部内部方法，是不被
认为是对应的奇异对象。
  Table6 和其他类似表格 的签名列描述了每个内部方法的调用模式。调用模式通常
插入包含描述参数名称的列表。如果参数名与ECMAScript类型名相同，表示这里需要
相同类型的值作为参数。如果内部方法显示返回值，其参数列表后会跟随"->"符号和
返回值的类型名。在签名中使用类型名引用了章节6定义的类型和额外的any。any意味
其值可以是任何ECMAScript语言类型。
  除了其参数列表，还有一个内部方法经常访问对象，就是方法调用的对象。
  内部方法隐式返回一个完结记录，或者包含调用模式指明的返回类型对应的值的
普通完结，或者投掷完结。
| 内置方法                | 签名                                               | 描述                                                                                                                                                                |
| \[\[GetPrototypeOf]]    | ()->Object \vert Null                              | 明确为当前对象提供继承性质的对象。null表示没有继承性质                                                                                                              |
| \[\[SetPrototypeOf]]    | (Object \vert Null)-> Boolean                      | 为本对象联结其他对象以提供继承性质。传递null表示没有继承性质。返回true表示本操作成功，false表示本操作没有成功。                                                     |
| \[\[IsExtensible]]      | ()-> Boolean                                       | 明确本对象是否允许增加性质。                                                                                                                                        |
| \[\[PreventExtensions]] | ()-> Boolean                                       | 控制本对性能否增加新性质。操作成功返回true，否则返回false。                                                                                                         |
| \[\[GetOwnProperty]]    | (propertyKey)-> Undefined \vert PropertyDescriptor | 返回propertyKey对应的自有性质的PropertyDescriptor。如果不存在这个自有性质，就会返回undefined                                                                        |
| \[\[DefineOwnProperty]] | (propertyKey, PropertyDescriptor)-> Boolean        | 创建或者修改propertyKey对应的自有性质，其状态由PropertyDescriptor描述。如果操作成功返回true，否则返回false。                                                        |
| \[\[HasProperty]]       | (propertyKey) -> Boolean                           | 返回对象的自有性质或者继承性质的键是propertyKey。                                                                                                                   |
| \[\[Get]]               | (propertyKey, Receiver)->any                       | 从本对象返回propertyKey对应性质的值。如果任何ECMAScript代码必然被执行来取回这个性质值，那么在执行代码时Receiver被用作this的值。                                     |
| \[\[Set]]               | (propertyKey, value, Receiver)-> Boolean           | 设置propertyKey性质的值为value。如果任何ECMAScript代码必然被执行来设置这个性质值，那么执行代码时Receiver被用作this的值。如果性质被设置了新值返回true，否则返回false |
| \[\[Delete]]            | (propertyKey) -> Boolean                           | 从本对象中移除propertyKey对应的自有性质。如果没有删除，且性质继续存在返回false。如果删除成功，或者性质不存在，返回true。                                            |
| \[\[OwnPropertyKeys]]   | () -> List<propertyKey>                            | 返回本对象所有自有性质的键的列表                                                                                                                                    |
  Table7 描述了对象被作为函数被调用时需要的额外的基本内部方法。函数对象就是
支持\[\[Call]]内部方法的对象。构造范是支持\[\[Constructor]]内部方法的对象。任何
支持\[\[Constructor]]的对象都需要支持\[\[Call]]，因为每个构造范都是函数对象。
因此构造范也被认为是构造函数或者构造函数对象。
| 内置方法          | 签名                         | 描述                                                                                                                                                                                                                                                   |
| \[\[Call]]        | (any, List<any>)->any        | 执行本对象联结的代码。通过函数调用表达式被调用。传递给本内部方法的参数是this值和List<any>。List<any>是调用表达式执行时传递的参数列表。实现了这个内部方法的对象是可调用的。                                                                             |
| \[\[Constructor]] | (List<any>, Object)-> Object | 创建一个对象。通过new操作符或者super调用被调用。第一个参数是表达式调用时传递的值列表。第二个参数是在是使用new操作符是提供的初始值。实现了这个内部方法的对象被称为构造范。函数对象没必要是构造范，所以非构造范的函数对象没有\[\[Constructor]]内部方法。 |
  基本对象和标准奇异对象的基础内部方法的语义在第十章具体说明。奇异对象的
内部方法的具体使用没有被实现支持，当尝试调用时应该投掷TypeError异常。
***** 6.1.7.3 基础内部方法的恒定部分
  ECMAScript引擎对象的内部方法必须满足下列的恒定规定。基本ECMAScript对象与本
规范中的所有标准奇异对象维护这些恒定内容。ECMAScript代理对象维护这些恒定内
容是指在调用这个\[\[ProxyHandler]]对象时运行全部的检查。
  任何实现提供的任何奇异对象必须维护这些恒定内容。违反这些恒定内容会导致
ECMAScript代码有不可预测的行为和导致安全问题。然而违反这些恒定内容绝对不能
妥协实现的内存安全。
  实现不能允许这些恒定内容以任何方式被绕过，比如提供备选接口实现了基础内部
方法的功能但是没有强化恒定内容。
  定义：
. 内部方法的目标是这个内部方法在其上被调用的对象。
. 如果目标的\[\[IsExtensible]]返回false，或者\[\[PreventExtensions]]返回true，这个
目标是不可扩展的。
. 非存在性质是一个不可扩展对象上没有作为自有性质存在的性质。
. 所有SameValue的引用都依赖于SameValue算法的定义。
  返回值
内部方法返回的值必然是一个完结记录，携带下列之一：
. \[\[Type]]=normal, \[\[Target]]=empty而且\[\[Value]]为如下列内部方法返回的“正常
返回值”
. \[\[Type]]=normal, \[\[Target]]=empty而且[\[Value]]为任意ECMAScript语言值。
****** 注意1 内部方法不能返回\[\[Type]]是continue、break或return的完结记录
****** 6.1.7.3.1 \[\[GetPrototypeOf]]()
. 常规返回的类型是Object或者null
. 如果target是不可扩展的，而且\[\[GetPrototypeOf]]返回了一个值V，随后调用
\[\[GetPrototypeOf]]都应该返回V的相同值。
****** 注意2 对象的原型链需要是有限长度的（这就是说从任何对象开始，递归的调
用\[\[GetPrototypeOf]]内部方法，最终的结果必须是明确的null）。然而，这个要求并
不强求原型链上某个原型是没有使用标准对象\[\[GetPrototypeOf]]定义的奇异对象的
对象。这种环形原型链可能会在访问对象性质的时候导致无限循环。
****** 6.1.7.3.2 \[\[SetPrototypeOf]](V)
. 常规返回类型是Boolean
. 如果对象是不可扩展的，而且V与目标上\[\[GetPrototypeOf]]的结果不是SameValue，
那么\[\[SetPrototypeOf]]必须返回false。
****** 6.1.7.3.3 \[\[IsExtensible]]()
. 常规返回类型是Boolean
. 如果\[\[IsExtensible]]返回了false，后续目标上所有\[\[IsExtensible]]调用都要返回
false。
****** 6.1.7.3.4 \[\[PreventExtensions]]()
. 常规返回类型是Boolean
. 如果\[\[PreventExtensions]]返回true，后续目标上所有\[\[IsExtensible]]调用需要返
回false，而且目标被认为是不可扩展的。
****** 6.1.7.3.5 \[\[GetOwnProperty]](P)
. 常规返回类型是PropertyDescriptor或者Undefined
. 如果返回值类型是PropertyDescriptor，那么这个值必须是完整填充的
PropertyDescriptor
. 如果P描述的是不可设置或者不可写的自有数据性质，后续调用
\[\[GetOwnProperty]](P)返回PropertyDescriptor的\[\[Value]]必须与P的\[\[Value]]属性
是相同值
. 如果P除了\[\[Writable]]外的其他属性会在后续的过程中修改，甚至P性质可能会被
删除，那么此时P的\[\[Configurable]]属性必须是true
. P的\[\[Writable]]属性可能从false修改到true，那么\[\[Configurable]]属性必须是
true
. 如果target是不可扩展的，而且P是非存在性质，那么后续在这target上调用
\[\[GetOwnProperty]](P)必须描述P是非存在的（例如必须返回undefined）
****** 注意三
作为第三个不变性的后果，一个数据性质可能在不同时间返回不同值。那么要求其
\[\[Writable]]和\[\[Configurable]]必须都是true，即使没有暴露其他通过基本内部
方法修改这个值的机制。
****** 6.1.7.3.6 \[\[DefineOwnProperty]](P,Desc)
. 常规返回类型是Boolean
. 如果P在之前已经发现是目标的不可设置的自有性质，那么必须按照下列情况返回
    1. P是可写的数据性质。不可设置的可写数据性质变更成不可设置的不可写数据
性质。此时返回true。
    2. Desc的所有属性与P的属性全部是相同值。此时返回true。
    3. 其他情况发挥false。
. 如果目标是不可扩展的，P是非存在性质，那么\[\[DefineOwnProperty]](P,Desc)必须
返回false。其实就是不可扩展的目标对象不能扩展新的性质。
****** 6.1.7.3.7 \[\[HasProperty]](P)
. 常规返回类型是Boolean
. 如果P在之前已经发现是目标的不可设置的自有的数据或者访问性质，
\[\[HasProperty]]必须返回true
****** 6.1.7.3.8 \[\[Get]](P,Receiver)
. 常规返回类型是任意ECMAScript语言类型
. 如果P在之前发现是目标的带有值V的不可设置的或不可写的自有数据性质，那么
\[\[Get]]必须返回V的相同值
****** 6.1.7.3.9 \[\[Set]](P,V,Receiver)
. 常规返回类型是Boolean
. 如果P在之前已经发现是目标的不可设置的或不可写的自有数据性质，那么
    .如果P的\[\[Value]]属性与V是相同值，返回true
    .否则返回false
. 如果P在之前已经发现是目标的不可设置的自有访问性质，而且P的\[\[Set]]属性是
undefined，那么\[\[Set]](P,V,Receiver)操作必须返回false
****** 6.1.7.3.10 \[\[Delete]](P)
. 常规返回类型是Boolean
. 如果P在之前已经发现是目标的不可设置的自有的数据或者访问性质，\[\[Delete]]
操作必须返回false
****** 6.1.7.3.11 \[\[OwnPropertyKess]]()
. 常规返回类型是List
. 返回的List不允许包含重复的实例
. 返回的List的每个元素类型的要么是String，要么是Symbol
. 返回的List至少要包含之前已经发现的所有不可设置的自有性质的键
. 如果目标是不可扩展的，返回的List必须只能包含目标通过\[\[GetOwnProperty]]发现
的所有自有性质的键
****** 6.1.7.3.12 \[\[Call]]()
. 常规返回类型是任意ECMAScript语言类型
****** 6.1.7.3.13 \[\[Construct]]()
. 常规返回类型是Object
. 目标必须同时有\[\[Call]]内部方法
***** 6.1.7.4 常用的固有Object
  常用的固有是基于本规范算法显示引用的对象进行内建，通常也有领内标识。除非
特殊说明每个固有对象实际上对应一套相似对象，每个领一个。
  在本规范里用%name%标识一个固有对象，联结到当前领，对应这个name。类似
%name.a.b%这种用法表示，在评估ECMAScript代码前，已经访问了%name%内部对象的"a"
性质的"b"性质。本领的规定和其固有对象在9.3中描述。常用固有对象列在下表8中。
| 固有对象名称                     | 全局名称             | ECMAScript语言联结                                                 |
| %AggregateError%                 | AggregateError       | AggregateError构造范（20.5.7.1）                                   |
| %Array%                          | Array                | Array构造范（23.1.1）                                              |
| %ArrayBuffer%                    | ArrayBuffer          | ArrayBuffer构造范（25.1.3）                                        |
| %ArrayIteratorPrototype%         |                      | Array遍历器对象的原型（23.1.5）                                    |
| %AsyncFromSyncIteratorPrototype% |                      | 异步-从-同步遍历器对象的原型（27.1.4）这个完全不了解，无法有效翻译 |
| %AsyncFunction%                  |                      | 异步函数对象的构造范（27.7.1）                                     |
| %AsyncGeneratorFunction%         |                      | 异步遍历器对象的构造范（27.4.1）                                   |
| %AsyncIteratorPrototype%         |                      | 所有标准的内置异步构造器都间接的继承自这个对象                     |
| %Atomics%                        | Atomics              | Atomics对象（25.4）                                                |
| %BigInt%                         | BigInt               | BigInt构造范（21.2.1）                                             |
| %BigInt64Array%                  | BigInt64Array        | BigInt64Array构造范（23.2）                                        |
| %BigUint64Array%                 | BigUint64Array       | BigUint64Array构造范（23.2）                                       |
| %Boolean%                        | Boolean              | Boolean构造范（20.3.1）                                            |
| %DataView%                       | DataView             | DataView构造范（25.3.2）                                           |
| %Date%                           | Date                 | Date构造范（21.4.2）                                               |
| %decodeURI%                      | decodeURI            | decodeURI函数（19.2.6.2）                                          |
| %decodeURIComponent%             | decodeURIComponent   | decodeURIComponent函数（19.2.6.3)                                  |
| %encodeURI%                      | encodeURI            | encodeURI函数（19.2.6.4）                                          |
| %encodeURIComponent%             | encodeURIComponent   | encodeURIComponent函数（19.2.6.5）                                 |
| %Error%                          | Error                | Error构造范（20.5.1）                                              |
| %eval%                           | eval                 | eval函数（19.2.1）                                                 |
| %EvalError%                      | EvalError            | EvalError构造范（20.5.5.1）                                        |
| %FinalizationRegistry%           | FinalizationRegistry | FinalizationRegistry构造范（26.2.1）                               |
| %Float32Array%                   | Float32Array         | Float32Array构造范（23.2）                                         |
| %Float64Array%                   | Float64Array         | Float64Array构造范（23.2）                                         |
| %ForInIteratorPrototype%         |                      | For-In遍历器对象的原型（14.7.5.10）                                |
| %Function%                       | Function             | Function构造范（20.2.1）                                           |
| %GeneratorFunction%              |                      | generator对象的构造范（27.3.1）                                    |
| %Int8Array%                      | Int8Array            | Int8Array构造范（23.2）                                            |
| %Int16Array%                     | Int16Array           | Int16Array构造范（23.2）                                           |
| %Int32Array%                     | Int32Array           | Int32Array构造范（23.2）                                           |
| %isFinite%                       | isFinite             | isFinite函数（19.2.2）                                             |
| %isNaN%                          | isNaN                | isNaN函数（19.2.3）                                                |
| %IteratorPrototype%              |                      | 所有标准的内置遍历器对象都间接的继承自这个对象                     |
| %JSON%                           | JSON                 | JSON对象（25.5）                                                   |
| %Map%                            | Map                  | Map构造范（24.1.1）                                                |
| %MapIteratorPrototype%           |                      | Map遍历器对象的原型（24.1.5）                                      |
| %Math%                           | Math                 | Math对象（21.3）                                                   |
| %Number%                         | Number               | Number构造范（21.1.1）                                             |
| %Object%                         | Object               | Object构造范（20.1.1）                                             |
| %parseFloat%                     | parseFloat           | parseFloat函数（19.2.4）                                           |
| %parseInt%                       | parseInt             | parseInt函数（19.2.5）                                             |
| %Promise%                        | Promise              | Promise构造范（27.2.3）                                            |
| %Proxy%                          | Proxy                | Proxy构造范（28.2.1）                                              |
| %RangeError%                     | RangeError           | RangeError构造范（20.5.5.2）                                       |
| %ReferenceError%                 | ReferenceError       | ReferenceRrror构造范（20.5.5.3）                                   |
| %Reflect%                        | Reflect              | Reflect对象（28.1）                                                |
| %RegExp%                         | RegExp               | RegExp构造范（22.2.3）                                             |
| %RegExpStringIteratorPrototype%  |                      | RegExp字符串遍历器对象的原型（22.2.7）                             |
| %Set%                            | Set                  | Set构造范（24.2.1）                                                |
| %SetIteratorPrototype%           |                      | Set遍历器对象的原型（24.2.5）                                      |
| %SharedArrayBuffer%              | SharedArrayBuffer    | SharedArrayBuffer构造范（25.2.2）                                  |
| %String%                         | String               | String构造范（22.1.1）                                             |
| %StringIteratorPrototype%        |                      | String遍历器对象的原型（22.1.5）                                   |
| %Symbol%                         | Symbol               | Symbol构造范（20.4.1）                                             |
| %SyntaxError%                    | SyntaxError          | SyntaxError构造范（20.5.5.4）                                      |
| %ThrowTypeError%                 |                      | 无条件投掷一个新的%TypeError%实例的函数对象                        |
| %TypeArray%                      |                      | 所有类型化数组的构造范的父类（23.2.1）                             |
| %TypeError%                      | TypeError            | TypeError构造范（20.5.5.5）                                        |
| %Uint8Array%                     | Uint8Array           | Uint8Array构造范（23.2）                                           |
| %Uint8ClampedArray%              | Uint8ClampedArray    | Uint8ClampedArray构造范（23.2）                                    |
| %Uint16Array%                    | Uint16Array          | Uint16Array构造范（23.2）                                          |
| %Uint32Array%                    | Uint32Array          | Uint32Array构造范（23.2）                                          |
| %URIError%                       | URIError             | URIError构造范（20.5.5.6）                                         |
| %WeakMap%                        | WeakMap              | WeakMap构造范（24.3.1）                                            |
| %WeakRef%                        | WeakRef              | WeakRef构造范（26.1.1）                                            |
| %WeakSet%                        | WeakSet              | WeakSet构造范（24.4.1）                                            |
****** 注意 额外的实例在表82
** 6.2 用于ECMAScript规范类型
  规范类型与元值一致，用于描述ECMAScrpt语言构造和ECMAScript语言类型的算法语义
。规范类型包括Reference、List、Completion、PropertyDescriptor、EnvironmentRecord、
AbstrctCloure和DataBlock。规范类型是本规范制作的，不对应任何ECMAScript实现的任
何特定实例。规范类型的值可以被用于描述ECMAScript表达式评估的中间结果，但是
这种值不能存储为对象的性质或者个变量的值。
*** 6.2.1 List和Record规范类型
  List类型是用于解释在new表达式、在函数调用和其他需要简单的有序的值的算法
的参数列表评估。List类型的多值是简单有序的List元素序列，元素拥有独立的多值
。序列可能是任意长度。List元素会被按照0原点索引随机访问。为了表示的方便用
类似数组的语法访问List元素。比如argument[2]就是argument List的第三个元素的缩
写。
  为了表示着方便，一个文法语法被用于表示一个新的List值。比如<<1,2>>定义了
一个List值，它有两个元素，没有按照顺序初始为指定值。一个新的空List被表示
为<< >>。
  Record类型用于描述本规范的算法中的数据聚合。一个Record类型值包含一个或者
多个以命名的字段。每个字段的值要么是ECMAScript值要么是表示联结到一个Record
类型的名字的抽象值。字段的名字通常用双方括号包含起来例如\[\[Value]]。
  为了表示着方便，类似对象的文法语法被用于表示一个Record值。比如
{ \[\[Field1]]:42, \[\[Field2]:false, \[\[Field3]]:empty } 定义了一个拥有三个字段
的Record值，每个字段被初始化为指定值。字段名字的顺序没有意义。任何没有显式
列出的字段被认为是缺失的。
  在规范的文本与算法中，.符号被用于引用Record值的指定字段。例如，如果R表示
之前段落说的Record值，那么R.\[\[Field2]是“R中名称为Field2的字段”的缩写。
  常用的Receord字段组合提纲会被命名，这个名字被用作文法Record值的前缀，用于
标识按照描述的指定类型的聚合。例如 PropertyDescriptor { \[\[Value]]:42,
\[\[Writable]]:false, \[\[Configurable]]:true }
*** 6.2.2 Set和Relation规范类型
  Set类型是用于在内存模型中解释无序的元素合集。Set类型的值就是元素的简单合
集，且没有元素出现一次以上。元素可以在Set中增加与删除。集合间可以进行合
并、取交与差操作。
  Relation类型是用于解释Set上的约束。Relation类型的值是值域上的一套有序值对。
比如，事件上的Relation是一组有序的事件对。一个Relation R和R域上的a、b两个值，
a R B是R的成员有序对(a,b)的简写。Relation至少要表示某些条件，当它是满足
这些条件的最小Releation时。
  严格偏序是一种Relation值R，满足如下要求：
. R域上的任意值a, b, c
    . 没有a R a, 且
    . 如果a R b 和b R c，那么a R c
**** 上述两个性质分别是非反身性和传递性。
  严格全序是满足如下要求的Releation值R
. R域上的任意值a, b, c
    . a 与 b相同, a R b, b R a 三者之一，且
    . 没有 a R a， 且
    . 如果a R b 和b R c，那么a R c
**** 上述三个性质分别是完全性、非反身性和传递性。
**** 注意 
上面关系内容其实与抽象代数中关系的描述是一致的，相关的名词以数学名词为准。
这里就是随意翻译了一下。
*** 6.2.3 Completion Record规范类型
  Completion类型是一个Record，用于解释运行时值的传播和流程控制，比如语句（
break, continue, return 和 throw）的行为，会产生控制本地外的传递。
  Completion类型的值是Record值，其字段在表9中定义。这些值合起来就是Completion
Record
| 字段名称     | 值                                         | 含义                     |
| \[\[Type]]   | 必须normal,break,continue,return,throw之一 | 产生的Completion的类型   |
| \[\[Value]]  | ECMAScript语言值或者空                     | 产生的值                 |
| \[\[Target]] | ECMAScript字符串或者空                     | 直接的控制传输的目标标签 |
  术语abrupt completion（意外完结）指\[\[Type]]不是normal的Completion实例。
**** 6.2.3.1 Await
   算法步骤
 1. 让completion是Await(value)
   与下列步骤意味着相同的含意
 1. 让asyncContext是运行时执行上下文（running execution context）
 2. 让promise是?PromiseResolve(%Promise%, value)
 3. 让stepsFulfilled是定义在Await Fulfilled Functions的算法步骤
 4. 让lengthFulfilled是定义在Await Fulfilled Functions的函数需要的必要参数的数量
 5. 让onFulfilled是!CreateBuiltinFunction(stepsFulfilled, lengthFulfilled,\'''\', <<\[\[AsyncContext\]\]>>)
 6. 设置onFulfilled.\[\[AsyncContext]]为asyncContext
 7. 让stepsRejected是定义在Await Rejected Functions的算法步骤
 8. 让lengthRejected是定义在Await Rejected Functions的函数需要的必要参数的数量
 9. 让onRejected是!CreateBuiltinFunction(stepsRejected, lengthRejected, \'''\',<<\[\[AysncContext]]>>)
 10. 设置onRejected.\[\[AsyncContext]]为asyncContext
 11. 运行!PerformPromiseThen(promise, onFulfilled, onRejected)
 12. 从execution context stack中移除asyncContext，将在execution context stack顶部的execution context
     恢复为running execution context
 13. 设置asyncContext像那些带着完结completion继续的评估的代码评估状态是completion，这样跟随在Await
     算法之后的步骤就会执行下去
 14. 返回
 15. 注意：本返回到评估的操作在asyncContext中是最优先继续评估的。
 上述步骤中的别名，和预期的completion，都是瞬时的，而且仅在Await的算法步骤中可见。
***** 注意 Await可以组合?和!前缀，例如： 1. 让result是?Await(value)
      意味着下面行为：
 1. 让result是Await(value)
 2. ReturnIfAbrupt(result)
***** 6.2.3.1.1 Await Fulfilled Functions
    Await fulfilled函数是匿名内建函数，是Await规范的一部分，用于将promise fulfillment值
  作为普通完结派发到调用者。每个Await fulfilled函数有一个内置的\[\[AsyncContext\]\]
    当Await fulfilled函数被带着value调用时，下列步骤会被执行
  1. 让F是active function object
  2. 让asyncContext是F.\[\[AsyncContext]]
  3. 让prevContext是running execution context
  4. 挂起prevContext
  5. 将asyncContext压到execution context stack；asyncContext就是现在的运行时执行背景
  6. 继续asyncContext上已经挂起的评估，用NormalCompletion(value)作为这个导致挂起的操作的结果。
  7. Assert：当到达这步的时候，asyncContext已经从execution context stack中移除，而且
     prevContext是当前的运行时执行背景
  8. 返回undefined
    Await fulfilled函数的length性质是1_F
***** 6.2.3.1.2 Await Rejected Functions
    Await rejected函数是匿名内建函数，是Await规范的一部分，用于将promise rejection原因
  作为投掷完结派发给调用者。每个Await rejected函数有一个内置的\[\[AsyncContext]]
    当Await rejected函数被带着reason调用时，下列步骤会被执行
  1. 让F是active function object
  2. 让asyncContext是F.\[\[AsyncContext]]
  3. 让prevContext是running execuction context
  4. 挂起prevContext
  5. 将asyncContext压到execution context stack；asyncContext就是现在的运行时执行背景
  6. 继续asyncContext上已经挂起的评估，用ThrowCompletion(reason)作为这个导致挂起的操作的
  结果。
  7. Assert：当到达这步的时候，asyncContext已经从execution context stack中移除，而且
     prevContext是当前的运行时执行背景
  8. 返回undefined
    Await rejected函数的length性质是1_F
**** 6.2.3.2 NormalCompletion
  抽象操作NormalCompletion有单一参数argument，比如：
1. 返回 NormalCompetion(argument)
  是下列定义的简写：
1. 返回 Completion {\[\[Type]]:normal, \[\[Value]]:argument, \[\[Target]]:empty}
**** 6.2.3.3 ThrowCompletion
  抽象操作ThrowCompletion有单一参数argument，比如：
1. 返回 ThrowCompetion(argument)
  是下列定义的简写：
1. 返回 Completion {\[\[Type]]:throw, \[\[Value]]:argument, \[\[Target]]:empty}
**** 6.2.3.2 UpdateEmpty(completionRecord, value)
  抽象操作UpdateEmpty接受两个参数completionRecord和value。被调用时，执行下列步
骤：
1. Assert：completionRecord.\[\[Type]]如果是throw或者return，那么
completionRecord.\[\[Value]]必然不空
2. 如果completionRecord.\[\[Type]]不空，返回Completion(completionRecord)
3. 否则返回Completion {
  \[\[Type]]:completionRecord.\[\[Type]],
  \[\[Value]]:value,
  \[\[Target]]:completionRecord.\[\[Target]]
}
*** 6.2.4 ReferenceRecord规范类型
  ReferenceRecord类型是用于解释例如delete、typeof、赋值、super关键词和其他语言特
性等操作的行为。举例：赋值语句中的左侧的操作项就被期望产生一个
ReferenceRecord。
  ReferenceRecord是一个已解决的名称或性质的绑定，它的字段在表10中定义
| 字段名称             | 值                                                                                  | 含义                                                                                         |
| \[\[Base]]           | 三者之一：除null和undefined的ECMAScript语言的值；Environment Record; unresolvable。 | 占据这个绑定的值或者Environment Record。\[\[Base]]如果是unresolvable表明这个绑定不能被解决。 |
| \[\[ReferencedName]] | String或者Symbol                                                                    | 这个绑定的名称。如果\[\[Base]]值是Evironment Record，那么总是String。                        |
| \[\[Strict]]         | Boolean                                                                             | 如果这个ReferenceRecord来源自严格模式的代码，它就是true，否则就是false                       |
| \[\[ThisValue]]      | 任何ECMAScript语言的值，或者empty                                                   | 如果不空，这个ReferenceRecord表示一个用super关键词表示的性质绑定；它被称为SuperReferenceRecord，而且\[\[Base]]值永不会是EnvironmentRecord。在这种案例里\[\[ThisValue]]是创建ReferenceRecord时的this值。 |
  下列抽象操作被用在本规范里以操作上述的Reference。
**** 6.2.4.1 IsPropertyReference(V)
  抽象操作IsPropertyReference接受参数V。被调用时执行下列步骤：
1. Assert: V是一个ReferenceRecord
2. 如果V.\[\[Base]]是unresolvable，返回false
3. 如果V.\[\[Base]]是Boolean、String、Symbol、BigInt、Number或者Object返回true，
否则返回false
**** 6.2.4.2 IsUnresolvableReference(V)
  抽象操作IsUnresolvableReference接受参数V。被调用时执行下列步骤：
1. Assert: V是一个ReferenceRecord
2. 如果V.\[\[Base]]是unresolvable，返回true，否则返回false。
**** 6.2.4.3 IsSuperReference(V)
  抽象操作IsSuperReference接受参数V。被调用时执行下列步骤：
1. Assert: V是一个ReferenceRecord
2. 如果V.\[\[ThisValue]]非空，返回true，否则返回false。
**** 6.2.4.4 GetValue(V)
  抽象操作GetValue接受参数V。被调用时执行下列步骤：
1. ReturnIfAbrupt(V)
2. 如果V不是ReferenceRcord返回V
3. 如果IsUnresolvableReference(V)是true，那么投掷一个ReferenceError异常
4. 如果IsPropertyReference(V)是true，那么
    a. 让baseObj是!ToObject(V.\[\[Base]])
    b. 返回?baseObj.\[\[Get]](V.\[\[ReferenceName]], GetThisValue(V))
5. 否则
    a. 让base是V.\[\[Base]]
    b. Assert：base是一个EnvironmentRecord
    c. 返回 ?base.GetBindingValue(V.\[\[ReferenceName]], V.\[\[String]])（见9.1）
**** 6.2.4.5 PutValue(V, W)    
  抽象操作PutValue接受参数V和W。被调用时执行下列步骤：
1. ReturnIfAbrupt(V)
2. ReturnIfAbrupt(W)
3. 如果V不是ReferenceRecord，投掷一个ReferenceError异常
4. 如果IsUnresolvableReference(V)是true，那么
    a. 如果V.\[\[Strict]]是true，投掷一个ReferenceError异常
    b. 让globalObj是GetGlobalObject()
    c. 返回?Set(globalObj, V.\[\[ReferencedName]], W, false)
5. 如果IsPropertyReference(V)是true，那么
    a. 让baseObj是!ToObject(V.\[\[Base]])
    b. 让succeeded是?baseObj.\[\[Set]](V.\[\[ReferencedName]], W, GetThiValue(V))
    c. 如果succeeded是false，而且V.\[\[Strict]]是true，投掷一个类型异常
    d. 返回
6. 否则
    a. 让base是V.\[\[Base]]
    b. Assert：base是EnvironmentRecord
    c. 返回 ?base.SetMutableBinding(V.\[\[ReferencedName]], W, V.\[\[Strict]])（见
9.1）
***** 注意 步骤5.a可能创建一个对象，除了上述抽象操作和基本对象的\[\[Set]]内部
方法外的其他行为不能访问这个对象。实现可以选择规避实际创建这个对象。
**** 6.2.4.6 GetThisValue(V)
  抽象操作GetThisValue接受参数V。被调用时执行下列步骤：
1. Assert：IsPropertyReference(V)是true
2. 如果IsSuperReference(V)是true，returV.\[\[ThisValue]]；否则返回V.\[\[Base]]
**** 6.2.4.7 InitializeReferenceBinding(V,W)
  抽象操作InitializeReferenceBinding接受参数V和W。被调用时执行下列步骤：
1. ReturnIfAbrupt(V)
2. ReturnIfAbrupt(W)
3. Assert：V是ReferenceRecord
4. Assert：IsUnresolvableReference(V)是false
5. 让base是V.\[\[Base]]
6. Assert：base 是一个EnvironmentRecord
7. 返回base.InitializeBinding(V.\[\[ReferencedName]], W)
*** 6.2.5 Property Descriptor规范类型
  Property Descriptor类型是用于解释操作和物化Object性质的属性。Property
Descriptor类型的值是Record类型。每个字段的名称就是属性的名称，它的值与
6.1.7.1中确定的属性的值一致。另外，任何字段都可能出现或缺失。在本规范中
为了标记Property Descriptor记录的文法描述，使用PropertyDescriptor作为纲要名称。
  依据某些字段的存在或使用情况，Property Descriptor值可以被进一步划分为
数据Property Descriptor和访问Property Descriptor。数据Property Descriptor含有
\[\[Value]]或者\[\[Writable]]字段。访问Property Descriptor含有\[\[Get]]或者
\[\[Set]]字段。Property Descriptor还会含有\[\[Enumerable]]和\[\[Configurable]]。
Property Descriptor不能同时是数据Property Descriptor或者访问Property Descriptor，
然而可以两者都不是，这时就是一个普通的Property Descriptor。一个完整填充的
Property Descriptor必须是两者之一，其属性与对应的表3或者表4一致。
  随后的抽象操作被用在本规范来操作Property Descriptor值。
**** 6.2.5.1 IsAccessorDescriptor(Desc)
  抽象操作IsAccessorDescriptor接受参数Desc（Property Descriptor值或者undefined）。
被调用时执行下列步骤：
1. 如果Desc是undefined，返回false。
2. 如果Desc.\[\[Get]]和Desc.\[\[Set]]都缺失，返回false。
3. 返回true。
**** 6.2.5.2 IsDataDescriptor(Desc)
  抽象操作IsDataDescriptor接受参数Desc（Property Descriptor值或者undefined）。
被调用时执行下列步骤：
1. 如果Desc是undefined，返回false。
2. 如果Desc.\[\[Value]]和Desc.\[\[Writable]]都缺失，返回false。
3. 返回true。
**** 6.2.5.3 IsGenericDescriptor(Desc)
  抽象操作IsGenericDescriptor接受参数Desc（Property Descriptor值或者undefined）。
被调用时执行下列步骤：
1. 如果Desc是undefined，返回false。
2. 如果IsAccessorDescriptor(Desc)和IsDataDescriptor(Desc)都是false，返回true。
3. 返回false。
**** 6.2.5.4 FromPropertyDescriptor(Desc)
  抽象操作FromPropertyDescriptor接受参数Desc(Property Descriptor值货主undefined)。
被调用时执行下列步骤：
1. 如果Desc是undefined，返回undefined。
2. 让obj是!OrdinaryObjectCreate(%Object.prototype%)
3. Assert: obj是可扩展的不含性质的基础对象
4. 如果Desc有\[\[Value]]字段，那么
    a. 执行!CreateDataPropertyOrThrow(obj, "value", Desc.\[\[Value]])
5. 如果Desc有\[\[Writable]]字段，那么
    a. 执行!CreateDataPropertyOrThrow(obj, "writable", Desc.\[\[Writable]])
6. 如果Desc有\[\[Get]]字段，那么
    a. 执行!CreateDataPropertyOrThrow(obj, "get", Desc.\[\[Get]])
7. 如果Desc有\[\[Set]]字段，那么
    a. 执行!CreateDataPropertyOrThrow(obj, "set", Desc.\[\[Set]])
8. 如果Desc有\[\[Enumerable]]字段，那么
    a. 执行!CreateDataPropertyOrThrow(obj, "enumerable", Desc.\[\[Enumerable]])
9. 如果Desc有\[\[Configurable]]字段，那么
    a. 执行!CreateDataPropertyOrThrow(obj, "configurable", Desc.\[\[Configurable]])
10. 返回obj
**** 6.2.5.5 ToPropertyDescriptor(Obj)
  抽象操作ToPropertyDescriptor接受参数Obj，被调用时执行下列步骤：
1. 如果Type(Obj)不是Object，投掷TypeError异常
2. 让desc是新的Property Descriptor且没有初始化任何字段
3. 让hasEnumerable是?HasProperty(Obj, "enumerable")
4. 如果hasEnumerable是true，那么
    a. 让enumerable是!ToBoolean(?Get(Obj, "enumerable"))
    b. 设置desc.\[\[Enumerable]]是enumerable
5. 让hasConfigurable是?HasProperty(Obj, "confirgurable")
6. 如果hasConfigurable是true，那么
    a. 让configurable是!ToBoolean(?Get(Obj, "configurable"))
    b. 设置desc.\[\[Configurable]]是configurable
7. 让hasValue是?HasProperty(Obj, "value")
8. 如果hasValue是true，那么
    a. 让value是?Get(Obj, "value")
    b. 设置desc.\[\[Value]]是value
9. 让hasWritable是?HasProperty(Obj, "writable")
10. 如果hasWritable是true，那么
    a. 让writable是!ToBoolean(?Get(Obj, "writable"))
    b. 设置desc.\[\[Writable]]是writable
11. 让hasGet是?HasProperty(Obj, "get")
12. 如果hasGet是true，那么
    a. 让getter是?Get(Obj, "get")
    b. 如果IsCallable(getter)是false，而且getter不是undefined，投掷TypeError异常
    c. 设置desc.\[\[Get]]是getter
13. 让hasSet是?HasProperty(Obj, "set")
14. 如果hasSet是true，那么
    a. 让setter是?Get(Obj, "set")
    b. 如果IsCallable(setter)是false，而且setter不是undefined，投掷TypeError异常
    c. 设置desc.\[\[Set]]是setter
15. 如果desc.\[\[Get]]存在或者desc.\[\[Set]]存在，那么
    a. 如果desc.\[\[Value]]存在或者desc.\[\[Writable]]存在，投掷TypeError异常
16. 返回desc
**** 6.2.5.6 CompletePropertyDescriptor(Desc)
  抽象操作CompletePropertyDescriptor接受参数Desc（一个PropertyDescriptor）。被调用
时执行下列步骤：
1. Assert: Desc是一个PropertyDescriptor
2. 让like是Record {\[\[Value]]:undefined, \[\[Writable]]:undefined, \[\[Get]]:undefined,
\[\[Set]]:undefined, \[\[Enumerable]]:undefined, \[\[Configurable]]:undefined, }
3. 如果IsGenericDescriptor(Desc)是true，或者IsDataDescriptor(Desc)是true，那么
    a. 如果Desc没有\[\[Value]]字段，那么设置Desc.\[\[Value]]是like.\[\[Value]]
    b. 如果Desc没有\[\[Writable]]字段，那么设置Desc.\[\[Writable]]是
like.\[\[Writable]]
4. 否则
    a. 如果Desc没有\[\[Get]]字段，那么设置Desc.\[\[Get]]是like.\[\[Get]]
    b. 如果Desc没有\[\[Set]]字段，那么设置Desc.\[\[Set]]是like.\[\[Set]]
5. 如果Desc没有\[\[Enumerable]]字段，那么设置Desc.\[\[Enumerable]]是
like.\[\[Enumerable]]
6. 如果Desc没有\[\[Configurable]]字段，那么设置Desc.\[\[Configurable]]是
like.\[\[Configurable]]
7. 返回Desc
*** 6.2.6 Environment Record规范类型
  Environment Record类型是用于解释在函数和块中解释名称的行为。这个类型和其上
的操作在9.1中定义。
*** 6.2.7 Abstract Closure规范类型
  Abstract Closure规范类型用于描述连同值合集的若干算法步骤。Abstract Colsure值
是元值，用函数应用的方式调用，例如closure(arg1, arg2)。和抽象操作类似，调用时
按照Abstract Closure描述的算法步骤执行。
  在会创建Abstract Closure的算法步骤中，捕获的值用"capture"后跟随的别名列表
表示。当Abstract Closure被创建了，同时它捕获这些别名联结的值。在Abstract
Closure被调用时执行的指定算法的步骤，捕获的值仍然用捕获时的别名引用。
  如果Abstract Closure返回一个完结记录，这个完结记录的\[\[Type]]要么时normal，
要么是throw。
  Abstract Closure在行内创建，作为其他算法的组成，例如：
1. 让addend是 41
2. 让closure是新的Abstract Closure，带有parameters(x)捕获addend，并且被调用时
   执行随后的步骤:
    a. 返回 x + addend;
3. 让val时closure(1)
4. Assert: val时42
*** 6.2.8 Data Blocks规范类型
  Data Block规范类型用于描述确切的可修改的字节数值（8位数值）序列。一个字节
值是一个[0,255]内的整数。每个创建的Data Block值都有固定的字节数，每个字节都
初始化为0。
  为了在本规范中表示着方便，适用类似数组的语法访问Data Block中独立的字节。
这种记法将Data Block表示成一个零原点的整数索引的字节序列。例如，如果db是一个
5字节的Data Block值，那么db[2]表示其第三个字节的内容。
  一个data blcok驻留在内存里，可以被多个代理访问到的话，被定为Shared Data
Block。Shared Data Block有一个标识（为了检测Shared Data Block值是否相等），这个
标识是无地址的，也就是说它没有绑定到这个块映射在任何进程中的虚拟地址，而
是这个块在内存中的地址集。两个Data Block相等的唯一条件是其包含的地址集相
等，否则他们不相等，而且它们包含的地址集没有交集。最后，Shared Data Block要
能区别于Data Block。
  Shared Data Block的语义在内存模型中使用Shared Data Block事件中定义。下面的
抽象操作介绍了Shared Data Block事件，和作为评估语义与内存模型的事件语义间的
界面。事件构成了备选执行，内存模型在备选执行上作为过滤程序。请咨询内存
模型获得完整的语义。
  Shared Data Block事件用Record模型，在内存模型中定义。
  随后的抽象操作在本规范中用于Data Block值上的操作。
**** 6.2.8.1 CreateByteDataBlock(size)
  抽象操作CreateByteDataBlock接受参数size（整数）。被调用时执行下列步骤：
1. Assert：size >= 0
2. 让db是新的Data Block值，包含size个字节。如果无法创建这样的Data Block，
投掷一个RangeError异常
3. 是指db上所有的字节都是0
4. 返回db
**** 6.2.8.2 CreateSharedByteDataBlock(size)
  抽象操作CreateSharedByteDataBlock接受参数size（非负整数）。被调用时执行下列
步骤：
1. Assert：size >= 0
2. 让db是新的Shared Data Block值，包含size个字节。如果无法创建这样的Shared 
Data Block，投掷一个RangeError异常
3. 让execution是环境代理的环境记录的\[\[CandidateExecution]]字段。
4. 让eventList是execution.\[\[EventsRecords]]里满足\[\[AgentSignifier]]是
   AgentSignifier()的元素的\[\[EventList]]字段。
5. 让zero是<<0>>
6. 遍历db的每个索引i，执行
    a. 向eventList中附加WriteShareMemory { \[\[Order]]:Init, \[\[NoTear]]:true,
       \[\[Block]]:db, \[\[ByteIndex]]:i, \[\[ElementSize]]:1, \[\[Payload]]:zero }
7. 返回db
**** 6.2.8.3 CopyDataBlockBytes(toBlock, toIndex, fromBlock, fromIndex, count)
  抽象操作CopyDataBlockBytes接受参数toBlock、toIndex(非负整数）、fromBlock、
fromIndex（非负整数）和count（非负整数）。被调用时执行下列步骤：
1. Assert：fromBlock和toBlock是不同的Data Block或者Shared Data Block值。
2. 让fromSize是fromBlock的字节数
3. Assert：fromIndex + count <= fromSize
4. 让toSize是toBlock的字节数
5. Assert：toIndex + count <= toSize
6. 当count > 0时，重复执行
    a. 如果fromBlock是Shared Data Block 那么
        i. 让execution是环境代理的代理记录的\[\[CandidateExecution]]字段
       ii. 让eventList是execution.\[\[EventsRecords]]里满足\[\[AgentSignifier]]是
           AgentSignifier()的元素的\[\[EventList]]字段。
      iii. 让bytes是一个列表，只有一个未确定选定的字节值。
       iv. 注意：在实现中，bytes是底层硬件上的非原子读取指令的结果。这种
           未确定性是内存模型中描述这种弱一致性的监察硬件行为的语义处方。
        v. 让readEvent是 ReadSharedMemory { \[\[Order]]:Unordered, \[\[NoTear]]:true,
           \[\[Block]]:fromBlock, \[\[ByteIndex]]:fromIndex, \[\[ElementSize]]:1}
       vi. 在eventList上追加readEvent
      vii. 在execution.\[\[ChosenValues]]中附加Chosen Value Record {
           \[\[Event]]:readEvent, \[\[ChosenValue]]:bytes }
     viii. 如果toBlock是Shared Data Block，那么
            1. 在eventList上追加 WriteSharedMemory { \[\[Order]]:Unordered,
               \[\[NoTear]]:true, \[\[Block]]:toBlock, \[\[ByteIndex]]:toIndex,
               \[\[ElementSize]]:1, \[\[Payload]]:bytes}
       ix. 否则
            1. 设置toBlock[toIndex]是bytes[0]
    b. 否则
        i. Assert：toBlock不是Shared Data Block
       ii. 设置toBlock[toIndex]是fromBlock[fromIndex]
    c. 设置toIndex是toIndex+1
    d. 设置fromIndex是fromIndex+1
    e. 设置count是count-1.
7. 返回NormalCompletion(empty)
***** 注意 有可能有从data block到shared data block的操作。这里没有禁止有可能
在别的地方处理了。
* 7 抽象操作
  这些操作不是ECMAScript语言的部分；在这里定义他们，只是帮助ECMAScript语言的
语义规范。而且贯穿本规范还有更多的特定抽象操作被定义了。
** 7.1 类型转换    
  ECMAScript语言在需要的时候隐式的自动执行类型转换。为了明晰某种结构的语义，
很需要定义一套转换的抽象操作。转换的抽象操作是多态的，他们可以接受任意的
ECMAScript语言类型的值。但是规范类型值不能在这些操作中适用。
  在ECMAScript语言中BigInt没有隐式的转换，程序必须调用BigInt来显示的转换到其
他类型。
*** 7.1.1 ToPrimitive(input[, preferredType])
  抽象操作ToPrimitive接受参数input和可选参数preferredType。将input参数转换为一个
非对象类型。如果一个对象是可以转换为多个原生类型的，它可能需要提示选项
preferredType到想要的类型。被调用时执行下列步骤：
1. Assert：input是ECMAScript语言类型
2. 如果Type(input)是对象，那么
    a. 让exoticToPrim是?GetMethod(input, @@toPrimitive)
    b. 如果exoticToPrim不是undefined，那么
        i. 如果不存在preferredType，让hint是"default"
       ii. 不然如果preferredType是string，让hint是"string"
      iii. 否则
            1. Assert：preferredType是number
            2. 让hint是"number"
       iv. 让result是?Call(exoticToPrim, input, <<hint>>)
        v. 如果Type(result)不是对象，返回result
       vi. 投掷TypeError异常
    c. 如果preferredType不存在，让preferredType是number
    d. 返回?OrdinaryToPrimitive(input, prferredType)
3. 返回input
**** 注意 当ToPrimitive被不带提示的调用时，它的行为跟hint是number时是一样的
     然而，对象可以通过重写@@toPrimitive方法来覆盖这个行为。在本规范中只有
     Date对象（详见21.4.4.45）和Symbol对象（详见20.4.3.5）重写了ToPrimitive行为。
     Date对象对待空hint为string。
**** 7.1.1.1 OrdinaryToPrimitive(O, hint)
  抽象操作OrdinaryToPrimitive接受参数O和hint。被调用时执行下列步骤：
1. Assert：Type(O)是对象
2. Assert：hint是number或者string
3. 如果hint是string那么
    a. 让methodNames是<<"toString", "valueOf">>
4. 否则
    a. 让methodNames是<<"valueOf", "toString">>
5. 遍历methodNames的元素name，执行
    a. 让method是?Get(O, name)
    b. 如果IsCallable(method)是true，那么
        i. 让result是?Call(method, O)
       ii. 如果Type(result)不是Object，返回resut
6. 投掷TypeError异常
*** 7.1.2 ToBoolean(argument)
  抽象操作ToBoolean接受参数argument。它根据表11将argument转换成Boolean类型的值
| 参数类型  | 结果                                                                       |
| Undefined | 返回false                                                                  |
| Null      | 返回false                                                                  |
| Boolean   | 返回argument                                                               |
| Number    | 如果argument是+0_F、-0_F或者NaN，返回false。其他返回true                   |
| String    | 如果argument是空字符串（即length是0），返回false。其他返回true             |
| Symbol    | 返回true                                                                   |
| BigInt    | 如果argument是0_Z，返回false。其他返回true。                               |
| Object    | 返回true。注意：一个关联到内置\[\[IsHTMLDDA]]的备选算法在B.3.7.1中强制执行 |
*** 7.1.3 ToNumeric(value)
  抽象操作ToNumeric接受参数value。它返回value转换成的Number或者BigInt。被调用时
执行下列步骤：
1. 让primValue是?ToPrimitive(value, number)
2. 如果Type(primValue)是BitInt，返回primValue
3. 返回?ToNumber(primValue)
*** 7.1.4 ToNumber(argument)
  抽象操作ToNumber接受参数argument。它根据表12将argument转换为Number值。
| 参数类型  | 结果                                                                                      |
| Undefined | 返回NaN                                                                                   |
| Null      | 返回+0_F                                                                                  |
| Boolean   | 如果argument是true，返回1_F。如果argument是false，返回+0_F                                |
| Number    | 返回argument（不转换）                                                                    |
| String    | 参看按照下方的语法和转换算法                                                              |
| Symbol    | 投掷TypeError异常                                                                         |
| BigInt    | 投掷TypeError异常                                                                         |
| Object    | 执行下列步骤：1. 让primValue是?ToPrimitive(argument, number)；2. 返回?ToNumber(primValue) |
**** 7.1.4.1 接受了String类型的ToNumber行为
  ToNumber处理String值时将String解释成UTF-16编码点序列后使用后续的语法。如果
这里的语法无法将String值翻译成一个扩展的StringNumberLiteral，那么ToNumber返回的
结果是NaN。
***** 注意1 本语法中终结符都是由BMP（Unicode Basic Multilingual Plane）字符构成。
      所以字符串中包含任何首位和尾位编码单元，无论匹配与否，ToNumber都会返回
      NaN。
  Syntax
    StringNumericLiteral :::
      StrWhiteSpace_opt
      StrWhiteSpace_opt StrNumericLiteral StrWhiteSpace_opt
    StrWhiteSpace :::
      StrWhiteSpaceChar StrWhiteSapce_opt
    StrWhiteSpaceChar :::
      WhiteSpace
      LineTerminator
    StrNumericLiteral :::
      StrDecimalLiteral
      NonDecimalIntegerLiteral_[~Sep]
    StrDecimalLiteral :::
      StrUnsignedDecimalLiteral
      + StrUnsignedDecimalLiteral
      - StrUnsignedDecimalLiteral
    StrUnsignedDecimalLiteral :::
      Infinity
      DecimalDigits_[~Sep] . DecimalDigits_[~Sep]_opt ExponentPart_[~Sep]_opt
      . DecimalDigits_[~Sep]_opt ExponentPart_[~Sep]_opt
      DecimalDigits_[~Sep] ExponentPart_[~Sep]_opt
  上面用到的没有明确定义的语法符号在字面数字的词法语法（12.8.3）中定义。
***** 注意2 StringNumericLiteral和NumericLiteral语义有些不同，需要注意
        . StringNumericLiteral可以在始末包含有限的空格或者换行符
        . StringNumericLiteral其实位值可以有任意个0
        . StringNumericLiteral可以包含+或-来指明符号
        . StringNumericLiteral可以是空的或者值包含空白符，被转换成+0_F
        . Infinity和-Infinity被时别为StringNumericLiteral，而不是NumericLiteral
        . StringNumericLiteral不能包含BigIntLiteralSuffix
***** 7.1.4.1.1 运行语义：MV
  String转化为Number值总体上与从字面数字得到Number值的规定相似，但是有些细节
是不同的，所以在这里给出从字符串数字到Number类型值的转换过程。这个值由两步
决定：首先，从字符串数字中派生数学值（MV）；其次，这个数学值按照下方的描述
进行修圆。不是在下方里，而是在其他语法符号中提及的MV，是在12.8.3.1中定义的
MV。
  . StringNumericLiteral ::: [empty]的MV是0
  . StringNumericLiteral ::: StrWhiteSpace的MV是0
  . StringNumericLiteral ::: StrWhiteSpace_opt StrNumericLiteral StrWhiteSpace_opt的MV
    是StrNumericLiter的MV，无论有多少空白或者没有空白
n  . StringNumericLiteral ::: - StrUnsignedDecimalLiteral的MV是负的
    StrUnsignedDecimalLiteral的MV。（注意如果StrUnsignedDecimalLiteral的MV是0，这个
    MV的负值仍然是0。下方的修圆规则处理这个无符号数值0到合适的+0_F或者-0_F
    浮点数）
  . StrUnsignedDecimalLiteral ::: Infinity的MV是10^10000（足够大以致于修圆到+∞_F）
  . StrUnsignedDecimalLiteral ::: DecimalDigits . DecimalDigits的MV是第一个
    DecimalDigits的MV加以(第二DecimalDigits的MV与10^-n的积)的和，其中n是第二个
    DecimalDigits的编码点数量
  . StrUnsignedDecimalLiteral ::: DecimalDigits . ExponentPart的MV是DecimalDigits的MV
    与10^e的积，其中e是ExponentPart的MV。
  . StrUnsignedDecimalLiteral ::: DecimalDigits . DecimalDigits ExponentPart的MV是(第一
    个DecimalDigits的MV加以(第二个DecimalDigits的MV与10^-n的积)的和）与10^e的积，
    其中n是第二个DecimalDigits的编码点数量，而e是ExponentPart的MV。
  . StrUnsignedDecimalLiteral ::: . DecimalDigits的MV是DecimalDigits的MV与10^-n的积，
    其中n是DecimalDigits的编码点数量
  . StrUnsignedDecimalLiteral ::: . DecimalDigits ExponentPart的MV是DecimalDigits的MV
    与10^(e-n)的积，其中n是DecimalDigits的编码点数量，而e是ExponentPart的MV。
  . StrUnsignedDecimalLiteral ::: DecimalDigits ExponentPart的MV是DecimalDigits的MV与
    10^e的积，其中e是ExponentPart的MV。
  一旦字符串字面量数字决定了确定的MV，随后被修圆到Number类型的值。如果MV是
0，会被修圆到+0_F，除非字符串字面量的第一个非空白符是"-"，这时会被修圆到
-0_F。其他情况，必须修圆到MV对应的Number值（按照在6.1.6.1中定义的含义），除非
是字面里包含StrUnsignedDecimalLiteral，而且包含了超过20个有意义数字的特殊情
况。在特殊情况里Number值可能是用0替换掉第20位之后的有意义数字的MV的Number
值，或者用0替换掉第20位之后的有意义数字后，再在第20位+1的MV的Number值。
  有意义数字是指不在ExponentPart里的，且
  . 不是"0"，或者
  . 左侧有非0数字，而且右侧有不在ExponentPart里的非0数字的"0"
*** 7.1.5 ToIntegerOrInfinity(argument)
  抽象操作ToIntegerOrInfinity接受参数argument。它将argument转换成整数、+∞或
-∞。被调用时执行下列步骤：
1. 让number是?ToNumber(argument)
2. 如果number是NaN、+0_F或者-0_F，返回0
3. 如果number是+∞_F，返回+∞
4. 如果number是-∞_F，返回-∞
5. 让integer是floor(abs(R(number)))
6. 如果number<+0_F，设置integer是-integer
7. 返回integer
*** 7.1.6 ToInt32(argument)
  抽象操作ToInt32接受参数argument。将argument转换为2^32的整数Number，范围在
[F(-2^31),F(2^31-1)]内。被调用时执行下列步骤：
1. 让number是?ToNumber(argument)
2. 如果number是NaN、+0_F、-0_F、+∞_F、-∞_F，返回+0_F
3. 让int是与number相同符号的数学值，规模是floor(abs(R(number)))
4. 让int32bit是int按2^32取模
5. 如果int32bit>=2^31,返回F(int32bit - 2^32)否则返回F(int32bit)
**** 注意 上述定义ToInt32
    . ToInt32抽象操作是向前强效的。如果被提供了一个它产生的结果，这个第二次
      使用需要值不变。
    . ToInt32(ToUnit32(x))与ToInt32(x)是相同值。（这是为了保留后面将+∞_F和-∞_F
      映射到+0_F的性质）
    . ToInt32映射-0_F到+0_F
*** 7.1.7 ToUint32(argument)
  抽象操作ToUint32接受参数argument。将argument转换为2^32的整数Number，范围在
[+0_F,F(2^32-1)]内。被调用时执行下列步骤：
1. 让number是?ToNumber(argument)
2. 如果number是NaN、+0_F、-0_F、+∞_F、-∞_F，返回+0_F
3. 让int是与number相同符号的数学值，规模是floor(abs(R(number)))
4. 让int32bit是int按2^32取模
5. 返回F(int32bit)
**** 注意 上述定义ToUint32
    . 只有第5步上ToUint32与ToInt32有差异
    . ToUint32抽象操作是向前强效的。如果被提供了一个它产生的结果，这个第二次
      使用需要值不变。
    . ToUnit32(ToInt32(x))与ToUint32(x)是相同值。（这是为了保留后面将+∞_F和-∞_F
      映射到+0_F的性质）
    . ToUint32映射-0_F到+0_F
*** 7.1.8 ToInt16(argument)
  抽象操作ToInt16接受参数argument。将argument转换为2^16的整数Number，范围在
[F(-2^15), F(2^15-1)]内。被调用时执行下列步骤：
1. 让number是?ToNumber(argument)
2. 如果number是NaN、+0_F、-0_F、+∞_F、-∞_F，返回+0_F
3. 让int是与number相同符号的数学值，规模是floor(abs(R(number)))
4. 让int16bit是int按2^16取模
5. 如果int16bit>=2^15,返回F(int16bi5 - 2^16)否则返回F(int16bit)
*** 7.1.9 ToUint16(argument)
  抽象操作ToUint16接受参数argument。将argument转换为2^16的整数Number，范围在
[F(+0_F), F(2^16-1)]内。被调用时执行下列步骤：
1. 让number是?ToNumber(argument)
2. 如果number是NaN、+0_F、-0_F、+∞_F、-∞_F，返回+0_F
3. 让int是与number相同符号的数学值，规模是floor(abs(R(number)))
4. 让int16bit是int按2^16取模
5. 返回F(int16bit)
**** 注意 上述定义ToUint16
    . ToUint16与ToUint32的唯一差别是在第4步，用2^16替代了2^32。
    . ToUint16映射-0_F到+0_F
*** 7.1.10 ToInt8(argument)
  抽象操作ToInt8接受参数argument。将argument转换为2^8的整数Number，范围在
[-128_F, 127_F]内。被调用时执行下列步骤：
1. 让number是?ToNumber(argument)
2. 如果number是NaN、+0_F、-0_F、+∞_F、-∞_F，返回+0_F
3. 让int是与number相同符号的数学值，规模是floor(abs(R(number)))
4. 让int8bit是int按2^8取模
5. 如果int8bit>=2^7,返回F(int8bit - 2^8)否则返回F(int8bit)
*** 7.1.11 ToUint8(argument)
  抽象操作ToUint8接受参数argument。将argument转换为2^8的整数Number，范围在
[+0_F, 255_F]内。被调用时执行下列步骤：
1. 让number是?ToNumber(argument)
2. 如果number是NaN、+0_F、-0_F、+∞_F、-∞_F，返回+0_F
3. 让int是与number相同符号的数学值，规模是floor(abs(R(number)))
4. 让int8bit是int按2^8取模
5. 返回F(int8bit)
*** 7.1.12 ToUint8Clamp(argument)
  抽象操作ToUint8Clamp接受参数argument。将argument转化为2^8的整数Number，范围在
[+0_F, 255_F]内。被调用时执行下列步骤：
1. 让number是?ToNumber(argument)
2. 如果number是NaN，返回+0_F
3. 如果R(number)<=0，返回+0_F
4. 如果R(number)>= 255，返回255_F
5. 让f是floor(R(number))
6. 如果f+0.5 < R(number)，返回F(f+1)
7. 如果R(number) < f + 0.5，返回F(f)
8. 如果f是odd，返回F(f+1)
9. 返回F(f)
**** 注意 不像其他ECMAScript的整数转换，ToUint8Clamp的修圆方式不同于截断整数
     也不是转换+∞_F到+0_F。ToUint8Clamp采用中间取偶的方式进行修圆。这也不同
     于Math.round的四舍五入方式。
*** 7.1.13 ToBigInt(argument)
  抽象操作ToBigInt接受参数argument。将argument转换为BigInt值，或者投掷异常如果
需要隐式的丛Number转换的话。被调用时执行下列步骤：
1. 让prim是?ToPrimitive(argument, number)
2. 按照表13，根据prim值进行返回。
| 参数类型  | 结果                                                                        |
| Undefined | 投掷TypeError异常                                                           |
| Null      | 投掷TypeError异常                                                           |
| Bollean   | 如果prim是true，则返回1n。如果prim是false，则返回0n                         |
| BigInt    | 返回prim                                                                    |
| Number    | 投掷TypeError异常                                                           |
| String    | 1. 让n是!StringToBigInt(prim)；2. 如果n是NaN，投掷SyntaxError异常；3. 返回n |
| Symbol    | 投掷TypeError异常                                                           |
*** 7.1.14 StringToBigInt(argument)
  应用7.1.4.1的算法，并进行随后的调整
. 替换StrUnsignedDecimalLiteral产出的DecimalDigits中禁止Infinity、小数点和指数部
. 如果NaN，返回NaN。否则返回准确表示MV的BigInt值，不需要修圆。
*** 7.1.15 ToBigInt64(argument)
  抽象操作ToBigInt64接受参数argument。将argument转换为2^64的BigInt值，范围在
[Z(-2^63),Z(2^63-1)]内。被调用是执行下列步骤：
1. 让n是?ToBigInt(argument)
2. 让int64bit是R(n)按2^64取模
3. 如果int64bit>=2^63，返回Z(int64bit - 2^64)；否则返回Z(int64bit)
*** 7.1.16 ToBigUint64(argument)
  抽象操作ToBigUint64接受参数argument。将argument转换为2^64的BigInt值，范围在
[0_Z, Z(2^64-1)]内。被调用时执行下列步骤：
1. 让n是?ToBigInt(argument)
2. 让int64bit是R(n)按2^64取模
3. 返回Z(int64bit)
*** 7.1.17 ToString(argument)
  抽象操作ToString接受参数argument。将argument按照表14转根据其类型转换为String
值。
| 参数类型  | 结果                                                                                       |
| Undefined | 返回"undefined"                                                                            |
| Null      | 返回"null"                                                                                 |
| Boolean   | 如果argument是true，返回"true"。如果argument是false，返回"false"                           |
| Number    | 返回!Number::toString(argument)                                                            |
| String    | 返回argument                                                                               |
| Symbol    | 投掷TypeError异常                                                                          |
| BigInt    | 返回!BigInt::toString(argument)                                                            |
| Object    | 应用随后的步骤：1. 让primValue是?ToPrimitive(argument, string) 2. 返回?ToString(primValue) |
*** 7.1.18 ToObject(argument)
  抽象操作ToObject接受参数argument。将argument按照表15根据其类型转换为Object
值。
| 参数类型  | 结果                                                                                      |
| Undefined | 投掷TypeError异常                                                                         |
| Null      | 投掷TypeError异常                                                                         |
| Boolean   | 返回一个新的Boolean对象，其内部占位\[\[BooleanData]]是argument。参看20.3Boolean对象的描述 |
| Number    | 返回一个新的Number对象，其内部占位\[\[NumberData]]是argument。参看21.1Number对象的描述    |
| String    | 返回一个新的String对象，其内部占位\[\[StringData]]是argument。参看22.1String对象的描述    |
| Symbol    | 返回一个新的Symbol对象，其内部占位\[\[SymbolData]]是argument。参看20.4Symbol对象的描述    |
| BigInt    | 返回一个新的BigInt对象，其内部占位\[\[BigIntData]]是argument。参看21.2Bigint对象的描述    |
| Object    | 返回argument                                                                              |
*** 7.1.19 ToPropertyKey(argument)
  抽象操作ToPropertyKey接受参数argument。将argument转换为能作为性质键的值。被调
用时执行下列步骤：
1. 让key是?ToPrimitive(argument,string)
2. 如果Type(key)是Symbol，那么
    a. 返回key
3. 返回!ToString(key)
*** 7.1.20 ToLength(argument)
  抽象操作ToLenght接受参数argument。将argument转换为适合作为像数组的对象的长度
的整数Number。被调用时执行下列步骤：
1. 让len是?ToIntegerOrInfinity(argument)
2. 如果len <= 0，返回+0_F
3. 返回F(min(len, 2^53-1))
*** 7.1.21 CanonicalNumericIndexString(argument)
  抽象操作CanonicalNumericIndexString接受参数argument。将argument转换为Number值，
如果是可以Number通过ToString产生的String值或者String"-0"。否则返回undefined。当
被调用时执行下列步骤：
1. Assert：Type(argument)是String
2. 如果argument是"-0"，返回-0_F
3. 让n是!ToNumber(argument)
4. 如果SameValue(!ToString(n), argument)是false，返回undefined
5. 返回n
  经典数字字符串是指不会让CanonicalNumericIndexString抽象操作返回undefined的
String值。
*** 7.1.22 ToIndex(value)
  抽象操作ToIndex接受参数value。将参数value转换为非负整数，如果value是有效的
整数索引值。被调用时执行下列步骤：
1. 如果value是undefined，那么
    a. 返回0
2. 否则
    a. 让integerIndex是F(?ToIntegerOrInfinity(value))
    b. 如果integerIndex < +0_F，投掷RangeError异常
    c. 让index是!ToLength(integerIndex)
    d. 如果!SameValue(integerIndex, index)是false，投掷RangeError异常
    e. 返回R(index)
** 7.2 检测和匹配操作
*** 7.2.1 RequireObjectCoercible(argument)（coerce强制）
  抽象操作RequireObjectCoercible接受参数argument。如果argument不能使用ToObject转换
成Object，会投掷异常。在表16中定义。
| 参数类型  | 结果              |
| Undefined | 投掷TypeError异常 |
| Null      | 投掷TypeError异常 |
| Bollean   | 返回argument      |
| Number    | 返回argument      |
| String    | 返回argument      |
| Symbol    | 返回argument      |
| BigInt    | 返回argument      |
| Oject     | 返回argument      |
*** 7.2.2 IsArray(argument)
  抽象操作IsArray接受参数argument。被调用时执行下列步骤：
1. 如果Type(Argument)不是Object，返回false
2. 如果argument是Array exotic对象，返回true
3. 如果arugment是Proxy exotic对象，那么
    a. 如果arugment.\[\[ProxyHandler]]是空，投掷TypeError异常
    b. 让target是argument.\[\[ProxyTarget]]
    c. 返回?IsArray(target)
4. 返回false
*** 7.2.3 IsCallable(argument)
  抽象操作IsCallable接受参数argument（ECMAScript语言值）。明确argument是一个带有
\[\[Call]]内置方法的可调用函数。被调用时执行下列步骤：
1. 如果Type(argument)不是Object，返回false
2. 如果argument有\[\[Call]]内置方法，返回true
3. 返回false
*** 7.2.4 IsConstrutor(argument)
  抽象操作IsConstructor接受参数argument（ECMAScript语言值）。明确argument是一个
带有\[\[Constructor]]内置方法的函数对象。被调用时执行下列步骤：
1. 如果Type(argument)不是Object，返回false
2. 如果argument有\[\[Constructor]]内置方法，返回true
3. 返回false
*** 7.2.5 IsExtensible(O)
  抽象操作IsExtensible接受参数O（一个Object）,返回Boolean值。明确额外的性质能
否被添加到O上。被调用时执行下列步骤：
1. Assert: Type(O)是Object
2. 返回?O.\[\[IsExtensible]]()
*** 7.2.6 IsIntegralNumber(argument)
  抽象操作IsIntegralNumber接受参数argument。明确argument是否以一个有限的整数
Number值。被调用时执行下列步骤：
1. 如果Type(argument)不是Number，返回false
2. 如果argument是NaN、+∞_F、-∞_F返回false
3. 如果floor(abs(R(argument))) != abs(R(argument))返回false
4. 返回true
*** 7.2.7 IsPropertyKey(argument)
  抽象操作IsPropertyKey接受参数argument（ECMAScript语言值）。明确argument是否可
以作为性质键。被调用时执行下列步骤：
1. 如果Type(argument)是String，返回true
2. 如果Type(argument)是Symbol，返回true
3. 返回false
*** 7.2.8 IsRegExp(argument)
  抽象操作IsRegExp接受参数argument。被调用时执行下列步骤：
1. 如果Type(argument)不是Object，返回false
2. 让matcher是?Get(argument, @@match)
3. 如果matcher不是undefined，返回!ToBoolean(matcher)
4. 如果argument有\[\[RegExpMatcher]]内部占位，返回true
5. 返回false
*** 7.2.9 IsStringPrefix(p,q) 
  抽象操作IsStringPrefix接受参数p（String）和q（String）。明确p是否是q的前缀。
被调用时执行下列步骤：
1. Assert：Type(p)是String
2. Assert：Type(q)是String
3. 如果q是p与其他String r拼接成的String，返回true，否则返回false。
**** 注意 任何String都是自身的前缀，因为r可以是空String
*** 7.2.10 SameValue(x,y)
  抽象操作SameValue接受参数x（ECMAScript语言值）和y（ECMAScript语言值），并返
回Boolean值。被调用时执行下列步骤：
1. 如果Type(x)与Type(y)不同，返回false
2. 如果Type(x)是Number或者BigInt，那么
    a. 返回!Type(x)::sameValue(x, y)
3. 返回!SameValueNonNumeric(x,y)
**** 注意 这个算法与严格相等算法不同，区别在如何处理零与NaN
*** 7.2.11 SameValueZero(x,y)
  抽象操作SameValueZero接受参数x（ECMAScript语言值）和y（ECMAScript语言值），
并返回Boolean值。被调用时执行下列步骤：
1. 如果Type(x)与Type(y)不同，返回false
2. 如果Type(x)是Number或者BigInt，那么
    a. 返回!Type::sameValueZero(x,y)
3. 返回!SameValueNonNumeric(x,y)
**** SameValueZero与SameValue的差异在于处理+0_F和-0_F上
*** 7.2.12 SameValueNonNumeric(x,y)
  抽象操作SameValueNonNumeric接受参数x（ECMAScript语言值）和y（ECMAScript语言值）
，并返回Boolean值。被调用时返回下列步骤：
1. Assert：Type(x)不是Number或BigInt
2. Assert：Type(x)与Type(y)相同
3. 如果Type(x)是Undefined，返回true
4. 如果Type(x)是Null，返回true
5. 如果Type(x)是String，那么
    a. 如果x和y有相同的编码单元（相同长度，相同索引的编码单元相同），返回
       true，否则返回false
6. 如果Type(x)是Boolean，那么
    a. 如果x和y都是true或者都是false，返回true；否则返回false
7. 如果Type(x)是Symbol，那么
    a. 如果x和y都是相同的Symbol值，返回true；否则返回false
8. 如果x和y是相同的Object，返回true；否则返回false
*** 7.2.13 抽象关系比较 <
  值x、y的比较式x < y产生true、false或者undefined（表明至少有个NaN参与了比
较）。除了x、y，这个算法还接受一个Boolean标记LeftFirst作为参数。这个标记用于
控制在操作有潜在副作用的x、y时的评估顺序。这是必要的，因为在ECMAScript明确
规定了从左到右评估表达式。LeftFirst的默认时值true，表明在表达式中的x代表的
表达式发生在y代表的表达式左侧（之前）。如果LeftFirst是false，那就是相反顺
序，y表达式的评估在x之前。比较按照下列步骤执行：
1. 如果LeftFirst是true，那么
    a. 让px是?ToPrimitive(x, number)
    b. 让py是?ToPrimitive(y, number)
2. 否则
    a. 注意: 评估顺序需要反过来，以保证比较按照从左到右的顺序评估
    b. 让py是?ToPrimitive(y, number)
    c. 让px是?ToPrimitive(x, number)
3. 如果Type(px)是String， Type(py)也是String，那么
    a. 如果IsStringPrefix(py, px)是true，返回false
    b. 如果IsStringPrefix(px, py)是true，返回true
    c. 让k是px中与py中对应位置编单元不同的最小非负整数。（必然有这样的k存
       在，即使都不是对方的前缀）
    d. 让m是px在k位的编码单元的数字的整数
    e. 让n是py在k位的编码单元的数字的整数
    f. 如果m<n，返回true。否则返回false
4. 否则
    a. 如果Type(px)是BigInt且Type(py)是String，那么
        i. 让ny是!StringToBigInt(py)
       ii. 如果ny是NaN，返回undefined
      iii. 返回BigInt::lessThan(px,ny)
    b. 如果Type(px)是String且Type(py)是BigInt，那么
        i. 让nx是!StringBoBigInt(px)
       ii. 如果nx是NaN，返回undefined
      iii. 返回BigInt::(nx,py)
    c. 注意因为px和py是基础值，评估顺序不重要
    d. 让nx是!ToNumeric(px)
    e. 让ny是!ToNumeric(py)
    f. 如果Type(nx)与Type(ny)相同，返回Type(nx)::lessThan(nx, ny)
    g. Assert：Type(nx)是BigInt时Type(ny)是Number，或者Type(nx)是Number时Type(ny)是
       BigInt
    h. 如果nx或者ny是NaN，返回undefined
    i. 如果nx是-∞_F或者ny是+∞_F，返回true
    j. 如果nx是+∞_F或者ny是-∞_F，返回false
    k. 如果R(nx) < R(ny)，返回true，否则返回false
**** 注意1 步骤3与+操作（13.15.3）中的步骤2.c是不同的，这里用逻辑与，而在+操作中用的是逻辑或
**** 注意2 字符串比较使用的是简单的按照编码单元的字典序。没有使用更加复杂的语义化的在Unicode标准
     中根据词或则字符串相等和核对的排序。因此符合最基本相等的String值在Unicode标准中也能相等。
     实际上本算法假设两个String都是标准化的形式。此外对于包含补充字符的字符串，使用编码单元的
     字典序与编码点的字典序不同。
*** 7.2.14 抽象相等比较 \=\=
  值x、y的比较式x==y产生true或者false。这个比较式执行时按照下列步骤：
1. 如果Type(x)与Type(y)相同，那么
    a. 返回执行严格相等比较x\=\=\=y的结果
2. 如果x是null，且y是undefined，返回true
3. 如果x是undefined，且y是null，返回true
4. 注意：这一步在B.3.7.2中被替换（
   1.如果Type(x)是Object，且x有\[\[IsHTMLDDA]]内部占位，而y是null或undefined，返回true
   2.如果x是null或undefined，同时Type(y)是Object且y有\[\[IsHTMLDDA]]占位，返回true
）
5. 如果Type(x)是Number而Type(y)是String，返回x==!ToNumber(y)结果
6. 如果Type(x)是String而Type(y)是Number，返回!ToNumer(x)==y结果
7. 如果Type(x)是BigInt而Type(y)是String，那么
    a. 让n是!StringToBigInt(y)
    b. 如果n是NaN，返回false
    c. 返回x==n的结果
8. 如果Type(x)是String而Type(y)是BigInt，返回y==x结果
9. 如果Type(x)是Boolean，返回!ToNumber(x)==y结果
10. 如果Type(y)是Boolean，返回x==!ToNumber(y)结果
11. 如果Type(x)是String、Number、BigInt或者Symbol之一，且Type(y)是Object，返回x==?ToPrimitive(y)结果
12. 如果Type(x)是Object，且Type(y)是String、Number、BigInt或者Symbol之一，返回?ToPrimitive(x)==y结果
13. 如果Type(x)是BigInt且Type(y)是Number，或饿着Type(x)是Number且Type(y)是BigInt，那么
     a. 如果x或y是NaN、-∞_F、+∞_F，返回false
     b. 如果R(x)=R(y)，返回true。否则返回false。
14. 返回false
*** 7.2.15 严格相等比较 \=\=\=
  值x、y的比较式x\=\=\=y产生true或者false。比较式执行时执行下列步骤
1. 如果Type(x)与Type(y)不同，返回false
2. 如果Type(x)是Number或者BigInt那么
    a. 返回!Type(x)::equal(x,y)
3. 返回!SameValueNonNumeric(x, y)
**** 注意 本算法在对待0和NaN时，与SameValue算法不同
** 7.3 Object上的操作
*** 7.3.1 MakeBasicObject(internalSlotsList)
  抽象操作MakeBasicObject接受参数internalSlotsList。这是所有算法创建ECMAScript对象的源，无论基本对象
或奇异对象。提出了所有对象在创建时需要的通用步骤，集中了对象的创建过程。被调用时执行下列步骤：
1. Assert：internalSlotsList是内置占位名称的List
2. 让obj是新创建的对象，且每个在internalSlotsList的名字都创建了相应的内部占位
3. 设置obj的必须内置方法是按照10.1规范定义的基本对象对应的默认值
4. Assert：如果调用方没有同时覆盖obj的\[\[GetPrototypeOf]]和\[\[SetPrototypeOf]]基础内置方法，那么
   internalSlotsList含有\[\[Prototype]]
5. Assert：如果调用方没有同时覆盖obj的\[\[SetPrototypeOf]]、\[\[IsExtensible]]
   和\[\[PreventExtensions]]基础内置方法，那么internalSlotsList含有\[\[Extensible]]
6. 如果internalSlotsList含有\[\[Extensible]]，设置obj.\[\[Extensible]]是true。
7. 返回obj
**** 注意 在本规范中，由例如ArrayCreate、BoundFunctionCreated等抽象操作创建的奇异对象，首先要调用
         MakeBasicObject获得一个基本对象，然后覆盖部分或者全部的内置方法。为了封装奇异对象的创建，对象
	 基础内置方法在这些操作外是不能修改的。
*** 7.3.2 Get(O,P)
  抽象操作Get接受参数O（对象）和P（性质键）。用于检索对象上指定性质的值。被调用时执行下列步骤：
1. Assert：Type(O)是Object
2. Assert：IsPropertyKey(P)是true
3. 返回 ?O.\[\[Get]](P,O)
*** 7.3.3 GetV(V,P)
  抽象操作GetV接受参数V（ECMAScript语言值）和P（性质健）。用于检索ECMAScript值的指定性质的值。如果V不是
对象，会将值封装为合适的对象再在其上执行键查找。被调用时执行下列步骤：
1. Assert：IsPropertyKey(P)是true
2. 让O是?ToObject(V)
3. 返回?O.\[\[Get]](P,V)
*** 7.3.4 Set(O,P,V,Throw)
*** 7.3.5 CreateDataProperty(O,P,V)
*** 7.3.6 CreateMethodProperty(O,P,V)
*** 7.3.7 CreateDataPropertyOrThrow(O,P,V)
*** 7.3.8 DefinePropertyOrThrow(O,P,desc)
*** 7.3.9 DeletePropertyOrThrow(O,P)
*** 7.3.10 GetMethod(V,P)
*** 7.3.11 HasProperty(O,P)
*** 7.3.12 HasOwnProperty(O,P)
*** 7.3.13 Call(F,V[,argumentsList])
*** 7.3.14 Construct(F[,argumentsList[,newTarget]])
*** 7.3.15 SetIntegrityLevel(O,level)
*** 7.3.16 TestIntegrityLevel(O,level)
*** 7.3.17 CreateArrayFromList(elements)
*** 7.3.18 LengthOfArrayLike(obj)
*** 7.3.19 CreateListFromArrayLike(obj[,elementTypes])
*** 7.3.20 Invoke(V,P[,argumentsList])
*** 7.3.21 OrdinaryHasInstance(C,O)
*** 7.3.22 SpeciesConstructor(O,defaultConstructor)
*** 7.3.23 EnumerableOwnPropertyNames(O,kind)
*** 7.3.24 GetFunctionRealm(obj)
*** 7.3.25 CopyDataProperties(target,source,excludedItems)
** 7.4 Iterator Objects上的操作
  参看通用遍历接口（27.1）
** 7.5
** 7.6
** 7.7
** 7.8
* 25
** 25.1


