* 待办
将来会使用LaTex进行处理。
* 约定 
** 若干
表示一个或者多个
** 有限
表示零个、一个或者多个
** 可数
表示零个、一个、多个或者无限个
** 所有英文为原文内容
作为专用词汇表示特定含义，比如类型、参数、概念等。
** 领
表示realm
** 域
表示domain
** 规模
表示某数的模。或者在这里进行约定。数x的模就是x的绝对值|x|
** 性质
表示property
** 属性
表示attribute
** List<some>
表示列表的元素有some特性。
** 相同值
表示两个值是同一个
** 构造范
表示constructor
** 合集
表示collection
** R域
表示R适用的所有值的集合
** 字位
一个二进制位
** 字节
octect 8个连续的二进制位。至于大小端，如果没有明确说明，就不考虑。
** 修圆
指用有限精度数字描述准确数字的处理过程。
** 活 artefact
人工造物
** 圈（juan）
表示scope
** \*\*#N
表示名称为N的值的\*\*，例如绑定#N，表示名称为N的值的绑定。
** Target.property是some
表示Target上有性质property，且其值是some
** 码型
表示production
** TODO instantiate 和 intialize在这里都被翻译成初始化了，这是错误。
   instantiate表示建立变量（实例化）。initialize表示建立变量并赋值，或者给
   未赋值的变量赋值（初始化）。后期需要校订。
** 时标
代表UTC1970年1月1日0时0分0秒000毫秒
** 根据编译原理，大小端由其他编译层处理。
* 前言 
** TODO [44,46] 
* 范围
本标准定义了ECMAScript2021多用途编程语言。
* 一致
一致的ECMAScript实现必须提供和支持本规范的全部类型、值、对象、性质、函数、
程序句法和程序语义。

一致的ECMAScript实现必须将源文本按照最新版本的Unicode标准和ISO/IEC 10646进行
翻译

一致的ECMAScript实现必须按照跟本规范兼容的最新版的ECMA-402提供应用编程接口（
API），支持编写能够适应被不同人类语言使用的不同语言和文化习惯的程序。

一致的ECMAScript实现可以提供本规范之外的类型、值、对象、性质和函数。特别是
一致的ECMAScript实现会提供本规范外的性质和性质的值，用于本规范描述的对象。

一致的ECMAScript实现会支持没有描述在本规范的程序和正则表达式。特别是一致的
ECMAScript实现支持的程序句法使用了在本规范12.6.2中标明的未来保留字。

一致的ECMAScript实现必须不能实现任何在17.1中列出的禁止扩展的扩展内容。

一致的ECMAScript实现必须不能重定义任何不是实现定义、实现近似或者主机定义的
内容。

一致的ECMAScript实现可以选择实现与否可选规范的子条款。任何被实现的可选规范
条款，其包含的所有行为都必须实现。本规范的任何可选规范条款使会用名词
"Normative Optional"标记出来（我用"：：可选规范"标记出来）
** Example Clause Heading ：：可选规范
示例条款内容
* 标准参考
下列引用文档是本文档应用必不可少的。对于标注日期的引用，只有应用提及的
版本。对于未标注日期的，应用最新版本的引用文档（包括其附录）。

ISO/IEC 10646 Information Technology — Universal Multiple-Octet Coded Character
Set (UCS) plus Amendment 1:2005, Amendment 2:2006, Amendment 3:2008, and
Amendment 4:2008, plus additional amendments and corrigenda, or successor

ECMA-402, ECMAScript 2015 Internationalization API Specification.
https://ecma-international.org/publications/standards/Ecma-402.htm
ECMAScript2015 国际化API规范。使数据按照当地习惯进行展示涉及的API的规范。

ECMA-404, The JSON Data Interchange Format.
https://ecma-international.org/publications/standards/Ecma-404.htm
JSON数据交互格式
* 概述
本章节包含了非正式的ECMAScript语言的概述。

ECMAScript是一个面向对象的编程语言，用于在主机环境中计算和操作可计算对
象。这里定义的ECMAScript没有试图是计算机上自立的；实际上，既没有提供输入
外部数据的规范，也没有提供输出计算结果的规范。它期望ECMAScript程序的计算机
环境不仅会提供对象和其他本规范描述的特色，还会提供某些环境标准的对象，
对象的描述与行为都超出本规范期望的用于指明会提供某些可访问的性质和某些
被ECMAScript程序调用的函数的范围。

ECMAScript最初被设计作一个脚本语言，却变成了一个多用途的编程语言。所谓的
脚本语言是指用于操作、定制和自动执行已有系统特色的编程语言。在那些系统
中，有用的功能已经在用户界面了，脚本语言提供程序控制这些功能的机制。就这
种方式，已有系统是提及的用于提供完成脚本语言能力的对象和特色的主机环境。
脚本语言试图被专业或非专业程序员使用。

ECMAScript最初被设计为Web脚本语言，提供生动化浏览器网页和在客户端执行部分
服务端计算的机制。ECMAScript现在被用于在各种主机环境中提供核心脚本能力。
因此这部分各主机环境都有的核心语言（因此也与主机环境无关）被本文档规定。

ECMAScript的用途远超过简单的脚本，被用于广泛的不同系统和规模的编程任务。
因为ECMAScript用途的膨胀，其功能和特色也膨胀了。ECMAScript已经是一个完整多
用途特征的编程语言。
** Web Scripting 网页脚本
*** TODO [48,57]
*** 遗传性质 inherited property
** 本规范的组织方式
本规范的剩余部分如下组织：

条款5定义本规范的记号约定。

条款6到10定义了ECMAScript程序操作的运行时环境。

条款11到17定义了ECMAScript编程语言的实际行为，包括全部语言特色的句法编码
和执行语义。

条款18到28定义ECMAScript标准库。定义了所有ECMAScript程序可用的标准对象。

条款29描述了访问SharedArrayBuffer背景的内存和Atomicsd对象方法的内存一致性
模型
* 记号约定
** 句法与词法
*** 背景无关语法（context-free grammar 可能就是通用的语法描述约定）
"context-free grammar"由若干"productions"组成。每个码型有一个称为nonterminal的
抽象符号作为左支（left-hand side），由可数个nonterminal和terminal符号构成
的序列作为右支（right-hand side)。每个语法，terminal符号都由规定字母表构成。

"chain product"是只有一个"right-hand side nonterminal"和可数个"terminal"
构成的序列组成的码型。

一个语句从开始由仅一个区分出的称为"goal symbol"的"nontermimal"和一个给定
的语法描述（context-free grammar)构成。语句具体指明一个"language"，即一组可数
的"terminal symbol"序列（数学意义上的可数：有限的或无限的）。这个序列可以
通过将语句中所有的"production left-hand side nonterminal"替换为
"production right-hand side"的方式，递归获得。
**** 这里其实蕴含了序的概念。这是按照输入顺序进行语法组织的。
*** 词汇与正则的语法
ECMAScript的"lexical grammar"在12章详解。本语法与它的"terminal symbols"的Unicode
编码一致，符合11.1定义的源码字符规则。定义了若干码型，从"goal symbol"开始有
InputElementDiv, InputElementTemplateTail, InputElementRegExp, 
InputElementRegExpOrTemplateTail，这些码型描述了如何将输入的字符码转换为
输入元素

除了空白符与注释的输入元素组成了ECMAScript的句法语法的"termial symbols"，
称为ECMAScript tokens。这些token是保留词、标识符、文本和ECMAScript语言符号。
同时换行符通常不被认为是token，尽管是输入元素流的一部分，引导进程自动插入
分好。简单的空白符和单行注释是被舍弃的，不会出现在句法语法的输入元素
流中。多行注释（就是/*...*/形式的注释，与占用几行无关）中如果没有换行符，
会被舍弃掉；如果含有一个或多个换行符，将被替换为一个换行符的，然后作为
语句语法输入元素流的一部分

ECMAScript的RegExp语法在22.2.1中给出。该文法还将源字符定义的编码点作为
"terminal symbols"其终结符。从"goal symbol Pattern"开始定义了若干码型描述了
如何将字符码转换为正则表达式。

词汇与正则语法的码型用两个冒号"::"作为分隔符号。词汇与正则语法共享部分
码型。
*** 数字语法
还有一种语法是将字符串转换成数字值。这个语法与词汇语法中处理数字的部分
内容相似。语法的"terminal symbol"是源码。在7.1.4.1中详细描述。

数字语法的码型用三个冒号":::"作为符号来标志。
*** 语句语法
ECMAScript的语句语法在13至16章给出。这语法有被词汇语法定义为
"terminal symbols"的"ECMAScript tokens"。它定义了一套码型，从两个目标符号" 
Script and Module"的某个开始，描述了token序列如何沟组成ECMAScript程序的
语句的正确的独立的组件。

当一个编码流被解析成ECMAScript的"Script"或者"Module"时，它先通过反复运用
词法语法转换成输入元素流，这个输入元素流在被解析成一个单独的语句语法的
运用。如果输入流的全部token不能被解析成一个单独的"goal nontermial Script 或
Module"，这个输入流就在语句语法上错了。

当解析成功后，构造出了一个"parse tree"，他是一个有根的树结构，每个节点
都是"Parse Node"。每个解析节点在语法上是一个"symbol"的实例，他代表一串从
那个"symbol"派生出的源文本。这个解析树的根节点，则代表全部的源文本，是解
析的"goal symbol"的实例。如果某个解析节点是一个"nonterminal"的实例，他同时也
是某个将其"nonterminal"作为"left-hand side"的码型的实例。而且他有可数的子元
素，每个子元素对应码型的"right-hand side"的一个"symbol"，每个子元素是解析
节点，是相应"symbol"的实例。

每次调用解析都是实例出新的解析节点，在每次解析间不重用节点，即使是同样
的源文本。解析节点当且仅当在相同解析调用中，同一个语法"symbol"的实例，代表
相同源文本串的时候才被认为是相同的解析节点。
**** 备注1 多次解析相同字符串导致不同的解析节点。例如：
let str = "1 + 1";
eval(str)
eval(str)
每次调用eval将str的值转换成ECMAScript源码，然后执行具有隔离的解析树的独立的
解析。这些树是截然不同的即使这些解析操作的源文本来自相同的字符值。
**** 备注2 解析树是本规范的方式，实现没有必要一定用相似的数据结构
语句语法的码型使用一个冒号":"作为符号进行区别。

13-16章出现的句法语法不是被"ECMAScript Script or Module"正确接受全部的内容。
某些额外的"token"同样被正确接受，即，那些仅当分号放在特定位置（例如换行符
前）才被语法描述的"token"。此外，某些本语法描述的"token"序列，如果换行符
出现在某些“尴尬”位置后，就不被认为可接受的。

在某些场景内，为了规避歧义，句法语法使用笼统码型，也就是说允许"token"序列
不能组成有效的"ECMAScript Script or Module"。举例来说，这个技术被用在对象字面
量与对象结构模式上。在相应的案例中，提供了一个更严格的补充语法，用于进一
步限制这个可接受的"token"序列。典型的，有个"early error"规则会定义一个错误
条件如果"P不能覆盖N"，P是解析节点（普通的码型实例），而N是从补充来的
"nonterminal"。这样原本被P匹配的"token"序列被用N再次解析作为"goal symbol"。（
如果N用了语法性质的参数，他们就会被设置成相同的值，如果P是起初就解析的）
如果"token"序列不能作为一个N的实例来解析，且没有"token"剩下，会导致错误发
生。

后来，算法会使用"N被P覆盖"语句访问这个解析的结果。既然任何解析失败会
被"early error"规则侦测到，这就总是一个解析节点（一个N实例对应一个给定P）。
*** 语法符号
terminal symbols用等宽加黑（这里我也不知道如何表示）字体表示，无论是在语法
码型还是在文档规范里，只要文字直接表示一个terminal symbol。这会像所写的一样
出现在脚本。以这种方式指明的全部终端符代码符都被认为是恰当的Unicode编码，
包含基本的拉丁字符，而不是那些在Unicode范围内相似外形的编码。终端符不能用
\UnicodeEscapeSequence表示

nonterminal用斜体表示。一个nonterminal（其实就是码型）的定义以跟随若干冒号
的名称开始介绍。冒号的数量表明码型属于那种语法。本码型的若干可替换的
"right-hand sides"跟随在下一行。比如一个语句定义：
WhileStatement:
    while ( Expression ) Statement
声明了WhileStatement nonterminal表示while token、(、一个Exression、)、一个Statement
组成的序列。Expression和Statement上发生他们自己的nonterminal。再举一个语句定义
的例子：
ArgumentList:
    AssignmentExpression
    ArgumentList , AssignmentExpression
声明了ArgumentList可能表示一个单独的AssignmentExpression或者一个由一个
ArgumentList、,、一个AssignmentExpression构成的序列。这个ArgumentList定义是递归
的，因为它的定义需要本身。于是ArgumenList可以包含若干参数，参数用,分隔，
每个参数表达式就是AssignmentExpression。这种nonterminal的递归定义很常见。

下标后缀opt，出现在terminal或nonterminal后，声明一个可选标志。这种包含可选
标志的替换实际是指明两种right-hand sides，一种是缺失可选元素的，一种是包含
可选元素的。如下所示：
VariableDeclaration:
    BindingIdentifier Initializer_opt
是下列定义的简便缩写：
VariableDeclaration:
    BindingIdentifier
    BindingIdentifier Initializer
，更进一步：
ForStatement:
    for ( LexicalDeclaration Expression_opt ; Expression_opt ) Statement
是下列定义的简便缩写：
ForStatement:
    for ( LexicalDeclaration ; Expression_opt ) Statement
    for ( LexicalDeclaration Expression ; Expression_opt ) Statement
是如下的缩写：
ForStatement:
    for ( LexicalDeclaration ; ) Statement
    for ( LexicalDeclaration ; Expression ) Statement
    for ( LexicalDeclaration Expression ; ) Statement
    for ( LexicalDeclaration Expression ; Expression ) Statement
所以，在这个例子里，noterminal ForStatement有四个可替换的right-hand sides

码型可以通过增加"[parameters]"形式的标注的方式参数化，这个标注后缀在一个
码型定义的nonterminal标志上。其中"parameters"可以一个名称或者用都号分隔的
名称列表。一个参数化的码型是一套通过在被参数化的nonterminal symbol后拼接
下划线_和参数名称的方式的所有组合的速记。例如：
StatementList_[Return]:
    ReturnStatement
    ExpressionStatement
是下列定义的简便缩写:
StatementList:
    ReturnStatement
    ExpressionStatement
StatementList_Return:
    ReturnStatement
    ExpressionStatement
，更进一步有：
StatementList_[Return, In]:
    ReturnStatement
    ExpressionStatement
是如下的缩写：
StatementList:
    ReturnStatement
    ExpressionStatement
StatementList_Return:
    ReturnStatement
    ExpressionStatement
StatementList_In:
    ReturnStatement
    ExpressionStatement
StatementList_Return_In:
    ReturnStatement
    ExpressionStatement
多个参数产生的码型组合，不全是完整语法定义需要的。

涉及到码型right-hand side的nonterminal也同样可以使用参数。例如：
StatementList:
    ReturnStatement
    ExpressionStatement_[+In]
等价于：
StatementList:
    ReturnStatement
    ExpressionStatement_In
而
SatementList:
    ReturnStatement
    ExpressionStatement_[~In]
等价于：
SatementList:
    ReturnStatement
    ExpressionStatement

一个nonterminal引用可能同时包含参数列表和"opt"后缀。例如:
VariableDeclaration:
    BindingIdentifier Initializer_[+In]_opt
是下面声明的缩写：
VariableDeclaration:
    BindingIdentifier
    BindingIdentifier Initializer_In

在一个right-hand side nonterminal引用的参数上增加?前缀，表示这个参数是否
出现在依赖于是否出现在当前码型的left-hand side标识上。例如：
VariableDeclaration_[In]:
    BindingIdentifier Initializer_[?In]
是下面声明的缩写：
VariableDeclaration:
    BindingIdentifier Initializer
VariableDeclaration_In:
    BindingIdentifier Initializer_In

如果right-hand分支上含有前缀"[+parameter]"，那么这个分支仅在这个参数名出现
在其码型的nonterminal标识上时可用。与之相反"[~parameter]"，则在其码型的
nonterminal标识上不含有参数名时，参数分支可用。例如：
StatementList_[Return]:
    [+Return]ReturnStatement
    ExpressionStatement
是下面声明的缩写：
StatementList:
    ExpressionStatement
StatementList_Return:
    ReturnStatement
    ExpressionStatement
，再者：
StatementList_[Return]:
    [~Return]ReturnStatement
    ExpressionStatement
是下面声明的缩写：
StatementList:
    ReturnStatement
    ExpressionStatement
StatementList_Return:
    ExpressionStatement

当词汇one of跟随在语法定义的冒号":"后时，表明随后若干行的没给terminal标识
都是一个可选定义。例如，ECMAScript的词法语法包含码型：
NonZeroDigit:: one of
    1 2 3 4 5 6 7 8 9
这仅仅是下面声明的简写：
NonZeroDigit:: one of
    1
    2
    3
    4
    5
    6
    7
    8
    9

如果短语"[empty]"出现在码型的right-hand side中，表明码型的right-hand side没有
任何terminal或者nonterminal

如果短语"[lookahead=seq]"出现在码型的right-hand side，表明这个码型可能仅用在
这个token序列seq是随后的token序列的前置代号，也就是说随后的token序列以seq起始。
类似的"[lookahead∈set]"，其中set是一个有限的非空的token序列的集合，表明这个
码型仅在set中的某些元素是随后token序列的前置代号。为了方便这个集合可以被写
成一个nonterminal，这表示，这个nonterminal展开为这个集合的全部token序列。如果
这个nonterminal可以被展开成无穷的不同token序列，那他被认为是一个编者的错误。
**** 就是写错了。
有些情况需要反向定义。"[lookahead≠seq]"表明码型仅在seq不是随后token序列的
前置代号时才可能被采用，"[lookahead∉set]"表明仅在没有set中的元素是随后的token
序列的前置代号时码型才会被采用。

举例说明，前置定义：
DecimalDigit:: one of
    0 1 2 3 4 5 6 7 8 9
DecimalDigits
    DecimalDigit
    DecimalDigits DecimalDigit
定义：
LookaheadExample::
    n [lookahead ∉ {1, 3, 5, 7, 9}] DecimalDigits
    DecimalDigit [lookahead ∉ DecimalDigit]
会匹配n跟随若干偶数或者仅一位数字形式的源文本。

需要注意这些短语被用在语句语法的时候，可能无法准确的识别跟随的token序列
，因为确定后续的token需要知道哪个词法goal symbol在随后的位置使用。因此，如果
这些短语被用在句法语法时，会被认为是编者的错误，因为如果一个token序列seq
出现在lookahead限制（包括作为一组序列的一部分）里，如果要用的词法goal symbol
是不定的无论seq是否是结果token序列的前置代号。

如果短语"[no LineTerminator here]"出现在语句语法的码型的right-hand side，表明
这个码型是一个被限制的码型，他不可以被用在那些LineTerminator出现在指定位置
的输入流。例如码型：
ThrowStatement:
    throw [no LineTerminator here] Expression;
指明这个码型不能用在LineTerminator出现在throw token与Expression之间的输入流上。

除非LineTerminator是被限制码型明确禁止的，任意个LineTerminator可以在输入元素
流里任何两个连续的token间出现，不影响这个脚本的合理性。

当在词法与数字码型出现在一个多码的token中时，这表示对应的代码序列要构成
一个对应的token。

码型right-hand有可能会用短语"but not"来限制某种展开，表明不包含这种展开。例
如码型：
Identifier::
    IdentifierName but not ReservedWord
意味着nonterminal Identifier可以是被那些提供的编码不能替换为ReservedWord的
IdentifierName替换。
**** 简单来说就是集合IdentifierName - 集合ReseredWord
最后有少些nonterminal被描述短语"sans-serif"描述的标识难以列举所有的选项：
SourceCharacter::
    any Unicode code point
** 算法约定
本规范经常使用若干列表指明算法步骤。这些算法被用于精确指明ECMAScript
语言结构的需要语义。算法不是意图暗示任何实现技术。事实上，鼓励用更有效
的算法实现给定的特性。

算法可能被用一个有序的、逗号分隔的别名序列参数化，这些参数名会被用在
算法步骤里，代表在相应位置传进来的数据。可选的参数被方括号包含（如
[,name]），但是在算法步骤上没有差异。剩余形式的参数需要在参数列表的末端，
以省略号开始（,...name）。剩余形式的参数捕获在必须参数和可选参数后的提供
的所有参数放到一个List中。如果没有这种额外的参数，这个List是空的。

算法步骤可能需要再分为有序的子步骤。子步骤是缩进的，并可能继续拆分到
缩进的子步骤中。第一层用数字标记步骤，第一层的子步骤（第二层）用小写字母
标记，第二层的子步骤（第三层）用小写的罗马数字标记。如果还有更多的层级
需要标记那就从第四层重复这个规则。例如：
1. Top-level step
    a. Substep
    b. Substep
        i. Subsubstep
        ii.Subsubstep
            1. Subsubsubstep
                a. Subsubsubsubstep
                    i. Subsubsubsubsubstep

步骤或者子步骤会使用"if"表明本步骤需要的条件。这时只有条件是true是，这个
步骤才会被采用。如果步骤或者子步骤用"else"开始，这表明当之前同级"if"过程得
到相反结果时，此步骤才会被采用。

步骤会有迭代的子步骤。

以"Assert"/"断言"开始的步骤认定为此算法的恒定条件。这种声明被用于明确的
算法条件，否则就是内含的条件。并没有增加额外的语义要求，因此也无需实现
检查。他们只是让算法清晰。

算法步骤会用"Let x be someValue"的形式定以一些别名。这些别名与"x"和
"someValue"一样是某些根本数据的引用，一个修改了内容，别的也都可见。算法步骤
想避免这种引用行为时，会使用"Let x be a copy of someValue"来浅复制someValue。

一旦声明了别名，后续任意步骤都可以引用此别名，但是之前的步骤不行。别名
可以通过"Set x to someOtherValue"的方式修改别名指向。
*** 抽象操作
为了便利一些算法在本规范的不同部分使用，称这些算法为抽象操作，被命名和
定义为带参数的函数形式，以便于被其他算法用名称的方式引用。抽象操作通常的
引用方式是函数调用，类似OperationName(arg1, arg2)。在一些class-like的规范抽象
的部分抽象操作被当作多态处理的方法。这些方法样子的抽象操作一般引用方式是
someValue.OperationName(arg1, arg2)。
*** 面向句法的操作
面向句法的操作是一个命名的操作，包含若干算法，每个算法联系若干ECMAScript
语法码型。码型还有多个备选定义，但是每个备选有明确的算法。当算法联结到
语法码型后，算法可能会通过参数的方式引用码型备选的终结和非终结符。用这种
方式时，非终结符指向一个从源文本解析出的实际的备选定义。语法码型匹配的源
文本是源码的一部分，这部分源码从参与匹配的第一个终结符开始，结束到参与匹
配的最后一个终结符结束。

当算法联结到码型备选，这个备选一般不会有任何"[]"，这种语法注解。这种注解
应该仅用于句法识别备选，而且不能对联结的备选的语义有任何作用。

在下面的算法中的1、3、4约定的步骤中，带着解析节点和可选的参数，面向句法
的操作会被调用：
1. 让status是SomeNonTerminal的SyntaxDirectedOperation
2. 让someParseNode是某些源码的解析
3. 执行someParseNode的SyntaxDirectedOperation
4. 传递value作为参数，执行someParseNode的SyntaxDirecteOperation

除非显式声明，否则所有的链环码型对于每个操作都有一个隐式定义，这个会被
当作码型的left-hand side的非终止符。如果有上述非终止符，这个隐式的定义就简
单的重复提交相同的操作和相同的参数，给链环码型的right-hand side非终止符，然
后返回这个结果。比如，假设算法有一步骤是：“返回评估Block的结果”，就会有
这样的一个码型：
Block:
    { StatementList }
但是评估操作不会联结算法与码型。这样，评估操作隐式的包含如下形式的联结：
Runtime Semantics: Evaluation
Block: { StatementList }
    1. 返回StatementList的评估结果。
**** 评估是运行语义的行为。
*** 运行语义
描述只在运行时被调用的语义的算法称为运行语义。运行语义被定义为抽象操作
或者面向语句的操作。都会返回一个结束记录。
**** 隐式结束值
本规范的算法通常隐式的返回结束记录，其Type是normal。除非语境中有其
他明显的形式，算法语句才会返回一个不是结束记录的值，例如：
1. Return "Infinity"
意味着同下：
1. Return NormalCompletion("Infinity")

然而，如果return语句的表达式的值是一个结束记录的构造语句，返回结束记录的
结果。如果是抽象操作，返回语句就是简单返回抽象操作产生的结束记录。

抽象操作Completion(completionRecord)用于强调返回之前计算的结束记录。Completion
抽象操作接受一个参数completionRecord，按照下述步骤执行：
1. 断言completionRecord是结束记录
2. 将completionRecord作为这个抽象操作的结束记录返回。

算法步骤中"return"语句没有值，意味着：
1. 返回NormalCompletionRecord(undefined)

如果完结记录不是意外完结，在语境中又没有明确要求是完整的完结记录，那么
任何完结记录的引用的值是指完结记录的Value字段。
**** 投掷异常
算法会投掷异常，例如：
1. Throw a TypeError exception
意味着：
1. Return ThrowCompletion(a newly created TypeError object)
**** 意外就返回
算法步骤有如下或等价描述：
1. ReturnIfAbrupt(argument)
意味着：
1. 如果argument是一个意外完结，返回argument
2. 否则如果argument是一个完结记录，以argument的Value覆盖argument

算法步骤有如下或等价描述：
1. ReturnIfAbrupt(AbstractOperation())
意味着：
1. 让hygienicTemp是AbstractOperation()
2. 如果hygienicTemp是意外完结，返回hygienicTemp
3. 否则如果hygienicTemp是完结记录，以hygienicTemp的Value覆盖hygienicTemp
这里hygienicTemp是短暂的，仅被ReturnIfAbrupt适用的步骤可见。

算法步骤有如下或等价描述：
1. 让result是AbstractOperation(ReturnIfAbrupt(argument))
意味着：
1. 如果argument是意外完结，返回argument
2. 如果argument是完结记录，以argument的Value覆盖argument
3. 让result是AbstractOperation(argument)
**** 意外就返回的简写
调用的抽象操作和面向句法的操作有前缀"?"，表明意外就返回被用在计算完结记
录上。例如步骤：
1. ?OperationName()
等价于：
1. ReturnIfAbrupt(OperationName())
类似的，方法运用形式的步骤：
1. ?someValue.OperationName()
等价于：
1. ReturnIfAbrupt(someValue.OperationName())

类似的，前缀"!"被用于表明后续调用抽象或面向句法的操作绝对不会返回一个意
外完结，而且完结记录的Value备用作操作的返回值。例如步骤：
1. 让val是!OperationName()
等价于如下步骤：
1. 让val是OperationName()
2. 断言val不是意外完结
3. 如果val是完结记录，让val的Value覆盖val

运行语义的面向句法的操作调用使用!和?这种前缀简写：
4. Perform !SyntaxDirectedOperation of NonTerminal
*** 静态语义
上下文无关语法没有足够的能力表达定义在被评估的Script或Module的输入元素流的
所有规则。在这些情况下，需要额外的规则来表达ECMAScript算法约定或者文法要
求。这种规则总是联结到一个语法码型，被称作码型的静态语义。

静态语义规则有名字，通常使用算法定义。命名的静态语义规则联结到语法码型，
码型有多个备选定义，每个备选针对提供的命名的静态语法规则有明确的算法。

一类特殊的静态语法规则是前期错误规则。前期错误规则定义了前期错误条件，联
结到特定的语法码型。大多数的前期错误的评估不是在本规范的的算法内被显示调用
的。一个一致实现必须，在首次评估Script或Module前，校验Script或者Module解析的产
出的所有前期错误规则。任何前期错误规则被违反，这个Script或者Module就是无效的
且不能被评估。
*** 数学操作
本规范给各种数字值相应的引用方式：
1. 数学值 Mathematical values: 任意实数，作为默认数字类型
2. 扩展数学值 Extended mathematical values: 包含+∞和-∞的Mathematical values
3. Numbers: IEEE 754-2019双精度浮点数值
4. BigInts: ECMAScript值准确表示任意有限整数

本规范的语言中，使用下标后缀明确各种不同数字类型的数值。下标F表示浮点
数，下标Z表示BigInt，不带下标则是数学值。

数学操作符如：+、*、=和≥指那些与运算符一致的操作。就是如果被提供了数学
值，这些操作符指的就是那些常用的数学运算。如果提供了Numbers，这些操作符指
的就是IEEE 754-2019内相应的操作。如果被提供了BigInt，这些操作符指将BigInt转
换为数学值后再应用常用的数学运算。

通常，在本规范引用数字值的时候，例如短语"the length of y"或者"the integer 
represented by the four hexadecimal digits ..."，没有任何显式的数字类型声明，这个
短语表示的是数学值。短语需要显示声明使用的是指Numbers或者BigInt，例如，"the
Number value for the number of code points in ..."或者"the BigInt value for ..."。

没有定义含有混合类型运算（比如Numbers与数学值）的数字操作符，应当被认为
是本规范的编辑错误。

本规范中绝大多数数值使用十进制；有时会是Ox跟随0-9或和A-F的形式的16进制
数。

本规范中如果使用integer术语，除非另有声明，指的是整数集上的数学值。如果
是integer Number术语，指的是其数学值在整数集上的Numbers。

本文档里数学值与Numbers或BigInt之间的转换总是显式的。从数学值或者扩展数
值到Numbers的转换被明示为"the Number value for x"或者F(x)，在6.1.6.1有明确定义。
从整数x到BigInt的转换被明示为"the BigInt value for x"或者Z(x)。从Numbers或
者BigInt到数学值的转换被明示为"the mathematical value of x"或者R(x)。+0和-0的数
学值是数学值0。无穷的数学值没有定义。有限值x的扩展数学值x就是x的有限数学
值，+∞和-∞依次是+∞_F和-∞_F的值。NaN没有定义的数学值。

数学函数abs(x)产生x的绝对值，如果x<0，就是-x否则就是x本身。数学函数min(x1,
x2,...,xN)产生x1到xN中数学意义上最小的。数学函数max(x1,x2,...,xN)产生x1到xN中
数学意义上最大的。这些数学函数的定义域是扩展数学值。

"x modulo y"（y是有限的非零的）记法，计算一个与y（或者0）同号的k，满足
abs(k) < abs(y)且x-k = q * y，其中q是整数值。

短语"将x局限在lower和upper间的结果"
短语"the result of clamping x between lower and upper"（x是扩展整数值，lower和
upper是数学值，而且lower≤upper），如果x<lower，产生lower，如果x>upper，产生
upper，其他产生x。

数学函数floor(x)产生不超过x的最大的整数，如果x是+∞，就是最接近+∞的整数。

数学函数min,max,abs,floor没有为Numbers和BigInt定义，任何非数学值应用了这些
方法，都是一个编辑错误。
**** floor(x) = x - (x modulo 1)
*** 值记法
本规范中，ECMAScript语言值用粗体显示。例如null，true或者"hello"。这些区别于
更长的ECMAScrpit代码序列比如：Function.prototype.apply或者let n = 42;

本规范内部的，不能被ECMAScript代码直接察觉的值用sans-serif字体表示。例如，
完结记录的Type字段的值像normal、return、或者throw。
* ECMAScript Date Types and Values
本规范的算法操作的值都有一个联结的类型。可能的值类型在本条款确定。Type
进一步细分为ECMAScript语言的类型和规范的类型。

在本规范，记号"Type(x)"用于简化"the type of x"，其中type指本条款定义的
ECMAScript语言的类型和规范的类型。"empty"术语用于声明一个值时，等于说"no 
value of any type"
** 用于ECMAScript语言的类型
ECMAScript语言的类型与ECMAScript语言编写的ECMAScript程序操作的值一致。ECMAScript
语言的类型有Undefined、Null、Boolean、String、Symbol、Number、BigInt和Object。
ECMAScript语言的值必然是被ECMAScript语言类型描述的。
*** Undefined类型
Undefined类型就一个值，即undefined。任何变量没有被赋值前都有undefined值。
*** Null类型
Null类型就一个值，即null。
*** Boolean类型
表示逻辑实体的Boolean类型有两个值，即true和false。
*** String类型
String类型是所有0到2^53-1个16位二进制无符号数（元素）构成的有序序列的集
合。在运行中的ECMAScript程序中String类型用于表示文本数据，这种情景下每个
String元素被当作UTF-16的编码单元值。在序列中，每个元素被认为占据一个位置。
位置使用非负整数索引。第一个元素（如果有）索引是0，随后元素（如果有）是1，
依次类推。String的长度就是他含有的元素数量。空String长度是0，因此也就没有元
素。

不会翻译String内容的ECMAScript操作不提供任何延伸语义。翻译String值的操作把
每个元素当作UTF-16编码单元。然而ECMAScript不会限制这些编码单元的值或者关系，
所以将String内容作为Unicode编码单元翻译的操作必须考虑从错误格式的自序列。
这些操作需要对每个在[0xD800,0xDBFF]区间的编码单元（在Unicode标准中，作为首
位，或者通用的说法高位编码单元）和每个在[0xDC00,0xDFFF]区间的编码单元（被定
以为尾位，或者通用的说法低位编码单元）依据如下规则提供特殊的处理：
1. 一个编码单元既不是首位也不是尾位，按照原本值翻译。
2. 有两个编码单元的序列，如果第一个编码单元c1是首位，第二个编码单元c2是尾
位，这就是一个编码对，需要按照一个编码点进行翻译，编码点的值是
(c1 - 0xD800)*0x400+(c2-0xDC00)+0x10000
3. 如果编码单元是首位或者尾位，但是按照编码对出现，就按照原本值翻译。
**** 我觉得在组织编码时，这里有个注意事项，就是需要连续独立显示首位和尾位
     时，中间需要增加隔离符号。

函数String.prototype.normalize(见于22.1.3.13)备用显式的规范String值。
String.prototype.localeCompare(见于22.1.3.10)内部规范String值，但是其他操作不会在
操作内容上隐式的规范String值。只有那些显式指明是语言或者地域敏感的操作码型
语言敏感的结果。
**** 这种设计的深层原因是让String的实现尽可能简单和高效。如果ECMAScript源文本
是C规范的，字符串原文被确保是规范的，只要没有包含任意的Unicode。

本规范里，短语"the string-concatenation of A,B,..."（每个参数都是String值、编
码单元、或者编码单元序列），表示按照参数顺序依次拼接参数的编码单元序列形
成的编码单元序列的String值。

短语"the substring of S from inclusiveStart to exclusiveEnd"（S是一个编码单元序列
的String值，inclusiveStart和exclusiveEnd是整数），表示S单元序列上[inclusiveStart,
exclusiveEnd)区间（如果inclusiveStart==exclusiveEnd，会是空集）上的编码单元的
String值。如果缺省了"to"，S的长度作为exclusiveEnd。
**** StringIndexOf(string, searchValue, fromIndex)
抽象操作StringIndexOf使用参数string（String值）,searchValue（String值）和
fromIndex（非负整数）。被调用时按照下列步骤执行：
1. Assert：Type(string)是String
2. Assert：Type(searchValue)是String
3. Assert：formIndex是非负整数
4. 让len是string的长度
5. 如果searchValue是空String，而且fromIndex≤len，返回fromIndex
6. 让searchLen是searchValue的长度
7. 每个从fromIndex开始到的i，且i≤len-searchLen的整数，按照升序依次执行
    a. 让candidate是substring of string from i to i+searchLen
    b. 如果candidate与searchValue有相同的编码序列，返回i
8. 返回 -1
**** 注意。如果searchValue而且fromIndex不大于string的长度时返回fromIndex。这用
空String可以在string的任何位置被找到。
**** 如果fromIndex > string的长度，算法返回-1
*** Symbol类型
Symbol类型是所有可以被用于Object属性的键，且不是Sring值的集合。

每个Symbol值是唯一且无法修改的。

每个Symbol值不可修改的联结到一个被称为Description的值，undefined或者是String
值。
**** 既有Symbols
既有symbol是内置的Symbol值，用于显式引用本规范的算法。他们通常被用于属性
的键，对应的属性值作为本规范的算法的扩展点。除非特殊说明，所有的既有symbol
在全部领下可用。

本规范内，既有symbol使用@@name形式的标注来引用，name是下表的值。
| Specification Name   | Description                     | Value and Purpose                                                                                     |
| @@asyncIterator      | "Symbol.asyncIterator"      | 为对象返回一个默认的AsyncIterator方法。被语句for-await-of语义调用                                     |
| @@hasInstance        | "Symbol.hasInstance"        | constructor对象识别一个对象是否是自身实例的方法。被instanceOf操作符调用                               |
| @@isConcatSpreadable | "Symbol.isConcatSpreadable" | 属性值是Boolean。如果true，表明对象应该被Array.prototype.concat展平为其数组元素                       |
| @@iterator           | "Symbol.iterator"           | 为对象返回默认Iterator的方法。被for-of语句的语义调用。                                                |
| @@match              | "Symbol.match"              | 正则表达式用于匹配字符串的方法。被String.prototype.match方法调用                                      |
| @@matchAll           | "Symbol.matchAll"           | 正则表达式返回一个遍历器的方法，遍历器提供表达式匹配字符串的结果。被String.prototype.matchAll方法调用 |
| @@replace            | "Symbol.replace"            | 正则表达式替换字符串上匹配的子串的方法。被String.prototype.replace方法调用                            |
| @@search             | "Symbol.search"             | 正则表达式返回字符串上匹配的位置索引。被String.prototype.search方法调用                               |
| @@species            | "Symbol.species"            | 其属性值是constructor函数，用于创建衍生对象                                                           |
| @@split              | "Symbol.split"              | 正则表达式用于将字符串在匹配的位置索引上进行拆分的方法。被String.prototype.split方法调用              |
| @@toPrimitive        | "Symbol.toPrimitive"        | 用于将对象转换为基础值的方法。被ToPrimitive抽象操作调用                                               |
| @@toStringTag        | "Symbol.toStringTag"        | 属性值是String值，用于创建对象的默认描述。被内置方法Object.prototype.toString访问                     |
| @@unscopables        | "Symbol.unscopables"        | 属性值是对象，对象自有或继承的属性名称是被联结对象绑定的with环境排除的属性名                          |
*** 数值类型
ECMAScript有两种内置的数值类型：Number和BigInt。本规范任意数值类型T包含乘法
标识记为T::unit。本规范类型也有跟随的抽象操作，就像规范名称op上的给定操作
记为T::op。所有参数是T。"Result"列显示返回的类型，如果调用操作可能会返回意
外完结，"Result"会有标示。
| 调用概要                  | 源文件示例                               | 调用者的评估语义所属                                                     | Result                           |
| T::unaryMinus(x)          | - x                                      | Unary - Operator                                                         | T                                |
| T::bitwiseNOT(x)          | ~ x                                      | 按位非操作符( ~ )                                                        | T                                |
| T::exponentiate(x, y)     | x ** y                                   | 幂运算操作和Math.pow(base, exponent)                                     | T,可能会投掷范围异常             |
| T::multiply(x, y)         | x * y                                    | 乘法算符                                                                 | T                                |
| T::divide(x, y)           | x / y                                    | 乘法算符                                                                 | T,可能会投掷范围异常             |
| T::remiander(x, y)        | x % y                                    | 乘法算符                                                                 | T,可能会投掷范围异常             |
| T::add(x, y)              | x \+\+, \+\+ x, x + y                    | 后自增算符，前自增算符和加法算符                                         | T                                |
| T::subtract(x, y)         | x--, --x, x - y                          | 后自减算符，前自减算符和减法算符                                         | T                                |
| T::leftShift(x, y)        | x << y                                   | 左移算符（<<）                                                           | T                                |
| T::signRightShift(x, y)   | x >> y                                   | 有符号右移算符（>>）                                                     | T                                |
| T::unsignRightShift(x, y) | x >>> y                                  | 无符号右移算符（>>>）                                                    | T，可能会投掷类型错误            |
| T::lessThan(x, y)         | x < y, x > y, x <= y, x >= y             | 关系算符，通过抽象关系比较                                               | Boolean或者undefined（无序输入） |
| T::equal(x, y)            | x \=\= y, x !\= y, x \=\=\= y, x !\=\= y | 相等算符，通过严格相等比较                                               | Boolean                          |
| T::sameValue(x, y)        |                                          | Object内部方法，通过SameValue(x, y)检测相等性                            | Boolean                          |
| T::sameValueZero(x, y)    |                                          | Array、Map和Set方法，通过SameValueZero(x, y)检测相等性，忽略+0与-0的差别 | Boolean                          |
| T::bitwiseAND(x, y)       | x & y                                    | 二进制按位操作符                                                         | T                                |
| T::bitwiseXOR(x, y)       | x ^ y                                    | 二进制按位操作符                                                         | T                                |
| T::bitwiseOR(x, y)        | x \vert y                                | 二进制按位操作符                                                         | T                                |
| T::toString(x)            | String(x)                                | 很多表达式或者内置函数，通过ToString(argument)                           | String                           |

T::unit值和T::op运算不是ECMAScript语言的部分，在这里定义它们，仅仅就是帮助
ECMAScript语言的语义规范。其他抽象操作通过本规范定义。

因为数字类型在转换时通常会丢失精度或者截断，所以ECMAScript语言在这个类型
间不提供隐式的转换。程序员必须显式调用Number和BigInt函数来转换类型，如果调
用的函数需要不同的类型时。
**** 注意 从第一版ECMAScript开始，针对某些操作，已经提供了隐式的会丢失精度
           的数值转换。这些合法的转换被保留在后续的兼容里，但是支持BigInt，
           以便减少程序错误的几率，和在未来版本保留通用值类型的选项。
**** Number类型
Number类型有18,437,736,874,454,810,627（就是2^64 - 2^53 + 3）个值，表示IEEE 
754-2019的双精度64位格式值，在IEEE标准中为二进制浮点数代数而规定的，除了
9,007,199,254,740,990（就是2^53 - 2）个被识别为IEEE标准中的"Not-a-Number"值。
这些"Not-a-Number"值在ECMAScript中被用一个特殊NaN值表示。（注意NaN值是被程序
表达式NaN产生的）。在某些实现中，扩展编码可能侦测到不同Not-a-Number值的差
异，但是这种行为是实现定义的。ECMAScript代码所有的NaN是不区分。
***** 注意 在ArrayBuffer（见于\[\[25.1]]）或者SharedArrayBuffer（见于\[\[25.2]]）
            中，一个Number值被存储到其中后，可能侦测到这种位模式值（能够区
            分的NaN），这种位模式没有必要与ECMAScript实现使用内部表示Number值
            的行为一致。

有两个特殊的值：正无穷与负无穷。为了方便，这些值依次用说明性更好的符号
\+∞_F和\-∞_F表示（这两种Number值用+Infinity或者简单的Infinity和-Infinity产生）。

其他18,437,736,874,454,810,624(就是2^64 - 2^53)值被称为有限值。一半正数，一半
负数。每个有限的正Numbr值都有一个对应的相同规模的负值。

注意这里有一个正0一个负0。为了简便，这些值依次用说明性更好的符号+0_F和
-0_F的方式表示（这两种零Number值被程序表达式+0或0和-0产生）。

这18,437,736,874,454,810,622（就是2^64 - 2^53 - 2）个非零有限值分类两类：
18,428,729,675,200,069,632（2^64 - 2^54 ）是正常化的，具有 s * m * 2^e 的形式
其中s是1或-1，m是在[2^52, 2^53)上的整数，e是[-1074,971]上的整数。剩下的
9,007,199,254,740,990（2^53 - 2）个数是非正常化的，也具有 s * m * ^e 的形式，
其中s是1或-1，m是在(0, 2^52)上的整数，e是-1074.

注意所有Number类型的整数的规模不会超过2^53。整数0有两种Number类型：+0_F和
-0_F。

按照上述形式表达的非零有限值，如果m是奇数，这个数有奇数精度。否则是偶数
精度。

本规范中，短语"x的Number值"，其中x表示一个实数（包括pai这种无理数），意味
Number值按照下列方式选中。（Number值都是有限精度的有理数）。构建一个包含除
-0_F以外的有限值和两个不被有限Number类型表示的特殊值，即2^1024（1*2^53*2^971）
和-2^1024（-1*2^53*2^971），的集合。在其中选择一个数最接近x的元素。如果有两个
与x一样，那么选择是偶数精度，因此2^1024与-2^1024被认为是偶数精度。如果选中
2^1024，替换为\+∞_F；如果是选中-2^1024，替换为-∞_F；如果选中+0，且x<0，替换为
-0；其他选中保持不便。这个结果就是"x的Number值"。（这个码型与IEEE 754-2019的
向偶数近似模式严格一致）。

\+∞的Number值是\+∞_F，\-∞的Number值是\-∞_F。

有些ECMAScript操作只能处理在[-2^31,2^31-1]或者[0,2^16-]上的整数。这些算符接受
全部的Number值，但是算法第一步会转换为期望范围内的整数。数字转换的细节描述
在7.1。

Number::unit的值是1_F
***** Number::unaryMinus(x)
抽象操作Number::unaryMinus接受参数：Number值x，被调用时执行下列两步：
1. 如果x是NaN，返回NaN。
2. 返回相反的x；就是带有相反符号但是相同规模的Number值。
***** Number::bitwiseNOT(x)
抽象操作Number::bitwiseNOT接受参数：Number值x，被调用时执行下列两步：
1. 让oldValue是!ToInt32(x).
2. 返回oldValue的二进制补码。结果的数学值可以准确表示为32位二进制补码的字
   符串。
***** Number::exponentiate(base, exponent)
抽象操作Number::exponentiate接受参数：Number值base与exponent，返回一个基于实现的
近似于base上幂乘exponent的结果（也就是说相同算式在不同实现上结果可能不同）。
被调用时按照如下步骤执行：
1. 如果exponent是NaN，返回NaN。
2. 如果exponent是+0_F或者-0_F，返回1_F。
3. 如果base是NaN，返回NaN。
4. 如果base是+∞_F，那么：
    a. 如果exponent>+0_F，返回+∞，否则返回+0_F。
5. 如果base是-∞_F，那么：
    a. 如果exponent>+0_F，那么：
        i. 如果exponent是奇数Number，返回-∞_F。否这返回+∞_F。
    b. 否则
        i. 如果exponent是奇数Number，返回-0_F。否则返回+0_F。
6. 如果base是+0_F，那么：
    a. 如果exponent > +0_F，返回+0_F。否则返回+∞_F。
7. 如果base是-0_F，那么：
    a. 如果exponent>+0_F，那么：
        i. 如果exponent是奇数Number，返回-0_F，否则返回+0_F。
    b. 否则
        i. 如果exponent是奇数Number，返回-∞_F，否则返回+∞_F。
8. Assert：base是有限的，而且不是+0_F和-0_F。
9. 如果exponent是+∞_F，那么：
    a. 如果abs(R(base))>1，返回+∞_F。
    b. 如果abs(R(base))是1，返回NaN。
    c. 如果abs(R(base))<1，返回+0_F。
10. 如果exponent是-∞_F，那么：（-∞_F在规范中被看作是偶数）
    a. 如果abs(R(base))>1，返回+0_F。
    b. 如果abs(R(base))是1，返回NaN。
    c. 如果abs(R(base))<1，返回+∞_F。
11. Assert： exponent是有限的，而且不是+0_F和-0_F。
12. 如果 base < +0_F，而且exponent不是整数Number，返回NaN。
13. 返回表示R(base)幂乘R(exponent)结果的实现近似值。
****** 注意 base ** exponent的结果在 base 是1_F或者-1_F且exponent是+∞_F或者-∞_F
             ，和base是1_F且exponent是NaN时与IEEE 754-2019不同。在最早ECMAScript
             版本中规定为NaN，而在最新的IEEE 754-2019中规定为1_F。为了兼容，
             历史ECMAScript行为被保留了下来。
***** Number::multiply(x, y)
抽象操作Number::multiply接受Number值参数：x, y。依据IEEE 754-2019中二进制双精
度算术规则执行乘法，产生x和y的乘积。被调用时，执行下列步骤：
1. 如果x或y是NaN，返回NaN。
2. 如果x是+∞_F或者-∞_F，
    a. 如果y是+0_F或者-0_F，返回NaN。
    b. 如果y > +0_F，返回x。
    c. 返回-x。
3. 如果y是+∞_F或者-∞_F，
    a. 如果x是+0_F或者-0_F，返回NaN。
    b. 如果x > +0_F，返回y。
    c. 返回-x。
4. 返回F(R(x)*R(y))
****** 有限精度乘法满足交换律，但是不满足结合律。
***** Number::divide(x,y)
抽象操作Number::divide接受Number值参数：x, y。依据IEEE 754-2019中二进制双精
度算术规则执行乘法，产生x除以y的商。被调用时，执行下列步骤：
1. 如果x是NaN或者y是NaN，返回NaN。
2. 如果x是+∞_F或者-∞_F，那么：
    a. 如果y是+∞_F或者-∞_F，返回NaN。
    b. 如果y是+0_F或者y>+0_F，返回x。
    c. 返回-x。
3. 如果y是+∞_F，那么
    a. 如果x是+0_F或者x>+0_F，返回+0_F。否则返回-0_F。
4. 如果y是-∞_F，那么
    a. 如果x是+0_F或者x>+0_F，返回-0_F。否则返回+0_F。
5. 如果x是+0_F或者-0_F，那么
    a. 如果y是+0_F或者-0_F，返回NaN。
    b. 如果y>+0_F，返回x。
    c. 返回-x。
6. 如果y是+0_F，那么
    a. 如果x>+0_F，返回+∞_F。否则返回-∞_F。
7. 如果y是-0_F，那么
    a. 如果x>+0_F，返回-∞_F。否则返回-∞_F。
8. 返回F(R(x)/R(y))
***** Number::remainder(n,d)
抽象操作Number::remainder接受Number值参数：n, d。从隐含的n除以d计算获得余数。
被调用时，执行下列步骤：
1. 如果n是NaN，或者d是NaN，返回NaN。
2. 如果n是+∞_F或者-∞_F，返回NaN。
3. 如果d是+∞_F或者-∞_F，返回n。
4. 如果d是+0_F或者-0_F，返回NaN。
5. 如果n是+0_F或者-0_F，返回n。
6. Assert：n和d是有限非零的。
7. 让r是R(n)-(R(d)*q)。q是整数，如果n与d不同号，q是负数。q的规模不超过
   R(n)/R(y)的规模的情况下尽可能大。
8. 返回F(r)。
****** 注意1 C与C++在remainder操作中只接受整数，而ECMAScript中也接受浮点数。
****** 注意2 浮点数通过%计算获得的余数与IEEE 754-2019定义的不同。在IEEE 754-2019
中余数采用四舍五入商计算，而不是结算商，所以其行为与常用的整数求余不同。
相较于C库中的函数fmod，ECMAScript语言的%在浮点数上的的计算与Java的整数求余的
行为更相似。
***** Number::add(x, y)
抽象操作Number::add接受Number值参数：x, y。依据IEEE 754-2019中二进制双精
度算术规则执行加法，产生x与y的和。被调用时，执行下列步骤：
1. 如果x是NaN，或者y是NaN，返回NaN。
2. 如果x是+∞_F，且y是-∞_F，返回NaN。
3. 如果x是-∞_F，且y是+∞_F，返回NaN。
4. 如果x是+∞_F或者-∞_F，返回x。
5. 如果y是+∞_F或者-∞_F，返回y。
6. Assert：x和y是都是有限的。
7. 如果x是-0_F，且y是-0_F，返回-0_F。
8. 返回F(R(x)+R(y))。
****** 有限精度加法符合交换律，但是不符合结合律。
***** Number::subtract(x,y)
抽象操作Number::subtract接受Number值参数：x, y。执行减法，产生x减以y的结果。
被调用时，执行下列步骤：
1. 返回 Number::add(x, Number::unaryMinus(y))
****** 注意 x - y的结果总是与 x + (- y) 的结果一致。
***** Number::leftShift(x, y)
抽象操作Number::leftShift接受Number值参数：x，y。被调用时，执行下列步骤：
1. 让lnum是!ToInt32(x)
2. 让rnum是!ToUint32(y)
3. 让shiftCount是R(rnum)对于32的模，R(rnum)%32
4. 返回lnum左移shiftCount位的结果。结果的数学值准确表示这个32位的2禁止字符串。
***** Number::signedRightShift(x,y)
抽象操作Number::signedRightShift接受两个Number值参数：x、y。被调用时，执行
下列步骤：
1. 让lnum是!ToUint32(x)
2. 让rnum是!ToUint32(y)
3. 让shiftCount是R(rnum)在32上的模
4. 返回lnum按符号右移shiftCount位的结果。空位用符号位值填充。结果的数学值准
   确表示结果的32位二进制补码串
***** Number::unsignedRightShift(x,y)
抽象操作Number::unsignedRightShift接受两个Number值参数：x、y。被调用时，执行
下列步骤：
1. 让lnum是!ToUint32(x)
2. 让rnum是!ToUint32(y)
3. 让shiftCount是R(rnum)在32上的模
4. 返回保留符号位lnum右移shiftCount位以0填充的结果。空位用0填充。结果的数学值
   准确表示结果的32位无符号二进制串。
***** Number::lessThan(x,y)
抽象操作Number::lessThan接受两个Number值参数：x、y。被调用时，执行下列步骤：
1. 如果x是NaN，返回undefined
2. 如果y是NaN，返回undefined
3. 如果x、y是相同的Number值，返回false
4. 如果x是+0_F，y是-0_F，返回false
5. 如果x是-0_F，y是+0_F，返回false
6. 如果x是+∞_F，返回false
7. 如果y是+∞_F，返回true
8. 如果y是-∞_F，返回false
9. 如果x是-∞_F，返回true
10. Assert：x和y都是有限的非零Number值
11. 如果R(x)<R(y)，那么返回true。否则返回false。
***** Number::equal(x,y)
抽象操作Number::equal接受两个Number值参数：x、y。被调用时，执行下列步骤：
1. 如果x是NaN，返回false
2. 如果y是NaN，返回false
3. 如果x、y是相同的Number值，返回true
4. 如果x是+0_F，y是-0_F，返回true
5. 如果x是-0_F，y是+0_F，返回true
6. 返回false
***** Number::sameValue(x,y)
抽象操作Number::sameValue接受两个Number值参数：x、y。被调用时，执行下列步骤：
1. 如果x是NaN，而且y也是NaN，返回true
2. 如果x是+0_F，y是-0_F，返回false
3. 如果x是-0_F，y是+0_F，返回false
4. 如果x、y是相同的Number值，返回true
5. 返回false
***** Number::sameValueZero(x,y)
抽象操作Number::sameValueZero接受两个Number值参数：x、y。被调用时，执行下列
步骤：
1. 如果x是NaN，而且y也是NaN，返回true
2. 如果x是+0_F，y是-0_F，返回true
3. 如果x是-0_F，y是+0_F，返回true
4. 如果x、y是相同的Number值，返回true
5. 返回false
***** NumberBitwiseOp(op, x, y)
抽象操作NumberBitwiseOp接受参数：op（Unicode字符串）、Number值x和Number值y。被调
用时执行下列步骤：
1. Assert：op是"&"、"^"或者"|"
2. 让lnum是!ToInt32(x)
3. 让rnum是!ToInt32(y)
4. 让lbits是表示R(lnum)的32位2进制补码字符串
5. 让rbits是表示R(rnum)的32位2进制补码字符串
6. 如果op是&，让result是在lbits和rbits上使用按位与（AND）操作的结果
7. 如果op是^，让result是在lbits和rbits上使用按位异或（XOR）操作的结果
8. 如果op是|，让result是在lbits和rbits上使用按位或（OR）操作的结果
9. 返回result代表的整数的Number值
***** Number::bitwiseAND(x,y)
抽象操作Number::bitwiseAND接受两个Number值参数：x、y。被调用时，执行下列步
骤：
1. 返回NumberBitwiseOp('&', x, y)
***** Number::bitwiseXOR(x,y)
抽象操作Number::bitwiseXOR接受两个Number值参数：x、y。被调用时，执行下列步
骤：
1. 返回NumberBitwiseOp('^', x, y)
***** Number::bitwiseOR(x,y)
抽象操作Number::bitwiseOR接受两个Number值参数：x、y。被调用时，执行下列步
骤：
1. 返回NumberBitwiseOp('|', x, y)
***** Number::toString(x)
抽象操作Number::toString接受一个Number值参数x。转换x为字符串格式。被调用
时，执行下列步骤：
1. 如果x时NaN，返回字符串"NaN"
2. 如果x是+0_F或者-0_F，返回字符串"0"
3. 如果x<+0_F，返回"-"与!Number::toString(-x)的拼接字符串
4. 如果x是+∞_F，返回字符串"Infinity"
5. 让n、k和s是整数，且满足k>=1，10^(k-1)<= s < 10^k, s* 10^(n-k)是R(x)，而且k
   尽可能小。k与s的十进制位数相等，s不能被10整除，s的最低位数字没必要由本
   标准确定
6. 如果k <= n <= 21，返回下列字符串的拼接：
    。十进制s的k位数字（按顺序，非0开始）
    。n-k个0x0030（数字0）
7. 如果0 < n <= 21，返回下列字符串的拼接：
    。十进制s的n个高位部数字
    。0x002E（小数点）
    。十进制s剩余的k-n位数字
8. 如果-6 < n <= 0，返回下列字符串的拼接：
    。0x0030（数字0）
    。0x002E（小数点）
    。-n个0x0030（数字0）。注意n<0，所以取-n。
    。十进制s的k位数字
9. 如果k是1，返回下列字符串的拼接：
    。s的数字
    。0x0065（小写字母e）
    。0x002B（+）或者0x002D（-）与n-1的正负号相同
    。n-1绝对值的十进制数字（非0开始）
10. 返回下列字符串的拼接：
    。十进制s的最高位数字
    。0x002E（小数点）
    。十进制s的低位部k-1个数字
    。0x0065（小写字母e）
    。0x002B（+）或者0x002D（-）与n-1的正负号相同
    。n-1绝对值的十进制数字（非0开始）
****** 注意 如下推论可能对实现有帮助，但不是本标准的规范要求。
             。如果x是Number值，且大于-0_F，那么ToNumber(ToString(x))与x的Number
               值相同
             。本规范的第五步决定了，s的最低位非唯一
****** 注意 如果实现提供了更精确的转换，推荐第5步符合如下指导
             5. 让n、k和s是整数，且满足k>=1，10^(k-1)<= s < 10^k, s* 10^(n-k)是
                R(x)，而且k尽可能小。如果由多个s，选择s*10^(n-k)最接近R(x)的。
                如果由两个可选的s，那么选择偶数。k是十进制s的位数，s不能被
                10整除。
****** 注意 ECMAScript的实现可以在David M. Gay关于二进制浮点数转换的相关论文
             中找到有用的内容和代码。
http://ampl.com/REFS/abstracts.html#rounding 近似展示数字。
http://netlib.sandia.gov/fp/dtoa.c 这是部分代码
http://netlib.sandia.gov/fp/g_fmt.c 这是其他部分代码。
这些内容也可以在netlib镜像找到。
***** BigInt 类型
BigInt类型表示整数值。这个值可以是任何大小，也没有二进制宽度限制（任何
大小好理解。二进制宽度限制估计是表示不限制位16的倍数。但是我估计仍然会是8
的倍数）。如果没有说明，这里的操作都返回准确数学值结果。对于二进制操作，
BigInt被作为二进制补码字符串处理，负数的话认为左侧有无穷位。

BigInt::unit的值是1_Z。
***** BigInt::unaryMinus(x)
抽象操作BigInt::unaryMinus接受一个BigInt参数：x。被调用时执行下列步骤：
1. 如果x是0_Z，返回0_Z
2. 返回表示负的R(x)的BigInt值。
***** BigInt::bitwiseNOT(x)
抽象操作BigInt::bitwiseNOT(x)接受一个BigInt参数。返回x的补码表示的BigInt，也
就是-x-1_Z
***** BigInt::exponentiate(base, exponent)
抽象操作BigInt::exponentiate接受BigInt参数：base、exponent。被调用时执行下
列步骤：
1. 如果exponent < 0_Z。抛出异常。
2. 如果base是0_Z而且exponent是0_Z，返回1_Z。
3. 返回表示R(base)幂乘R(exponent)的结果的BigInt值。
***** BigInt::multiply(x, y)
抽象操作BigInt::multiply接受BigInt参数：x、y。返回x乘以y的结果的BigInt值。
****** 注意 即使结果远超输入规模，准确的数学值结果也应该返回。
***** BigInt::divide(x,y)
抽象操作BigInt::divide接受BigInt参数：x、y。被调用时执行下列步骤：
1. 如果y是0_Z，投掷RangeError异常。
2. 让quotient是R(x)/R(y)
3. 返回quotient向0取整的整数的BigInt值。
***** BigInt::remainder(n, d)
抽象操作BigInt::remainder接受BigInt参数：n、d。被调用时执行下列步骤：
1. 如果d是0_Z，投掷RangeError异常
2. 如果n是0_Z，返回0_Z
3. 让r是被算式r=n-(d*q)决定的BigInt值。q是BigInt，且与n/d同正负号，在不超过n
除以d的商的规模下，尽可能大
4. 返回r
****** r的符号与n的符号一致。
***** BigInt::add(x,y)
抽象操作BigInt::add接受BigInt参数：x、y。返回x与y的和的BigInt值。
***** BigInt::subtract(x,y)
抽象操作BigInt::subtract接受BigInt参数：x、y。返回x减以y的差的BigInt值。
***** BigInt::leftShift(x,y)
抽象操作BigInt::leftShift接受BigInt参数：x、y。被调用时执行下列步骤：
1. 如果y < 0_Z，那么：
    a. 计算R(x)/(2^-y)近似到最接近的整数，包括负数。返回这个整数的BigInt值
2. 返回表示R(x)*(2^y)的BigInt值
****** 语义上等价于按位左移，只是把BigInt值看作是无限长的二进制补码串。
***** BigInt::signedRightShift(x,y)
抽象操作BigInt::signedRightShift接受BigInt参数：x、y。被调用时执行下列步骤：
1. 返回BigInt::leftShift(x,-y)
***** BigInt::unsignedRightShift(x,y)
抽象操作BigInt::unsignedRightShift接受BigInt参数：x、y。被调用时执行下列步骤：
1. 投掷TypeError异常。BigInt值被看作是无限长的二进制补码串，转换没有意义。
***** BigInt::lessThan(x,y)
抽象操作BigInt::lessThan接受BigInt参数：x、y。当R(x)<R(y)时返回true，否则
返回false。
***** BigInt::equal(x,y)
抽象操作BigInt::equal接受BigInt参数：x、y。当R(x)==R(y)时返回true，否则返回
false。
***** BigInt::sameValue(x,y)
抽象操作BigInt::sameValue接受BigInt参数：x、y。被调用时执行下列步骤：
1. 返回BigInt::equal(x,y)
***** BigInt::sameValueZero(x,y)
抽象操作BigInt::sameValueZero接受BigInt参数：x、y。被调用时执行下列步骤：
1. 返回BigInt::equal(x,y)
***** BinaryAnd(x,y)
抽象操作BinaryAnd接受BigInt参数：x、y。被调用时执行下列步骤：
1. Assert：x是0或者1
2. Assert：y是0或者1
3. 如果x是1且y是1，返回1
4. 否则返回0
***** BinaryOr(x,y)
抽象操作BinaryOr接受BigInt参数：x、y。被调用时执行下列步骤：
1. Assert：x是0或者1
2. Assert：y是0或者1
3. 如果x是1或者y是1，返回1
4. 否则返回0
***** BinaryXor(x,y)
抽象操作BinaryXor接受BigInt参数：x、y。被调用时执行下列步骤：
1. Assert：x是0或者1
2. Assert：y是0或者1
3. 如果x是1且y是0，返回1
4. 如果x是0且y是1，返回1
5. 否则返回0
***** BigIntBitwiseOp(op,x,y)
抽象操作BigIntBitwiseOp接受参数op（Unicode字符串）、BigInt值x和BigInt值y。被调
用时执行下列步骤：
1. Assert：op是"&"、"^"或者"|"
2. 置x为R(x)
3. 置y为R(y)
4. 让result是0
5. 让shift是0
6. 重复执行，直到x是0或-1，而且y是0或-1：
    a. 让xDigit是 x modulo 2
    b. 让yDigit是 y modulo 2
    c. 如果op是'&'，置result为 result + (2^shift) * BinaryAnd(xDigit, yDigit)
   d. 如果op是'|'，置result为 result + (2^shift) * BinaryOr(xDigit, yDigit)
   e. 否则
        i. Assert: op 是'^'
        ii. 置result为 result + (2^shift) * BinaryXor(xDigit, yDigit)
   f. 置shift为shift+1
    g. 置x位 (x - xDigit)/2
    h. 置y位 (y - yDigit)/2
7. 如果op是'&'，让tmp是BinaryAnd(x modulo 2, y modulo 2)
8. 如果op是'|'，让tmp是BinaryOr(x modulo 2, y modulo 2)
9. 否则
    a. Assert：op是'|'
    b. 让tmp是BinaryXor(x modulo 2, y modulo 2)
10. 如果tmp!=0，那么
    a. 置result为 result - (2^shift)
    b. 注意：这就保证了符号一致。
11. 返回result的BigInt值
***** BigInt::bitwiseAND(x,y)
抽象操作BigInt::bitwiseAND接受BigInt参数：x、y。被调用时执行下列步骤：
1. 返回BigIntBitwiseOp(&,x,y)
***** BigInt::bitwiseXOR(x,y)
抽象操作BigInt::bitwiseXOR接受BigInt参数：x、y。被调用时执行下列步骤：
1. 返回BigIntBitwiseOp(^,x,y)
***** BigInt::bitwiseOR(x,y)
抽象操作BigInt::bitwiseOR接受BigInt参数：x、y。被调用时执行下列步骤：
1. 返回BigIntBitwiseOp(|,x,y)
***** BitInt::toString(x)
抽象操作BigInt::toString接受BigInt参数：x。转换x到字符串形式。被调用时执行
下列步骤：
1. 如果x < 0_Z，返回"-"与!BigInt::toString(-)的字符串拼接
2. 返回表示x十进制数字的字符串。
**** Object类型
Object逻辑上是若干性质的聚集。性质分为数据性质与访问性质：
. 数据性质指一个键值伴随一个ECMAScript语言值，和描述属性集合
. 访问性质指一个键值伴随一个或者两个访问方法，和描述属性集合
  访问方法用于存储或者取回这个属性联结的ECMAScript语言值。

性质用键值识别。键值类型是ECMAScript的String值或者Symbol值。所有的String或者
Symbol值都是有效的性质键，包括空字符串。性质名称就是性质键的String值。

整数索引是String值的性质键，是最简的数字String，其数字值在[+0_F, 2^53-1]之
间。但是数组的索引在[+0_F,2^32-1)之间。

性质键用于访问性质和其值。有两种访问方式：get与set，对应用于取回值和赋
值。通过get与set访问的性质包括对象直接含有的自有性质和通过原型访问的其他
对象的继承性质。继承性质是继承对象的自有性质或者继承性质。每个对象下的自有
性质的键是相互区别的。

所有对象逻辑上都是若干性质的聚集，但是根据语义访问和操作性质的不同，有多
种对象的形式。请参考6.1.7.2关于定义对象的若干形式。
***** 性质的属性
在本规范中性质用于定义和解释Object性质的状态。数据性质每个键值联结下表
Table3 所示的属性。
| 属性名       | 值域                 | 详细描述                                                                                                    |
| Value        | 任何ECMAScript语言值 | get访问性质获取的值                                                                                         |
| Writable     | Boolean              | 如果false，在ECMAScript代码试图通过set对Value进行赋值时，不会成功                                           |
| Enumerable   | Boolean              | 如果true，性质可以被for-in方式枚举到。否则，这个性质是不可枚举的                                            |
| Configurable | Boolean              | 如果false，那么下列行为会失败：删除性质、修改性质为访问性质、修改属性（除了Value，和Writable由true到false） |

访问性质每个键值联结下表 Table4 所示的属性
| 属性名       | 值域                | 详细描述                                                                                               |
| Get          | Object或者undefined | 如果是Object那么必然是一个函数对象。函数内部call方法在每次取回性质值时被调同，其参数为空               |
| Set          | Object或者undefined | 如果是Object那么必然是一个函数对象。每次对性质值进行赋值时，函数内部call方法被调用，参数仅为要赋予的值 |
| Enumerable   | Boolean             | 如果true，性质可以被for-in方式枚举到。否则，这个性质是不可枚举的                                       |
| Configurable | Boolean             | 如果false，那么下列行为会失败：删除性质、修改性质为数据性质、修改属性。                                |

如果初始化时没有显示的按照本规范声明性质的属性，默认属性设置按照下表
Table5 所示
| 属性名       | 默认值    |
| Value        | undefined |
| Get          | undefined |
| Set          | undefined |
| Writable     | false     |
| Enumerable   | false     |
| Configurabel | false     |
***** Object内部方法与内部占位
在ECMAScript，对象的实际语义是通过被称为内部方法的算法规范的。在ECMAScript
引擎中的每个对象都联结了一套内部方法，这些方法定义了其运行时的行为。这些
内部方法不是ECMAScript语言的内容。他们在本规范中被定义仅仅是为了用于解释。
然而，在ECMAScript实现中的对象表现必须与指定的联结的内部方法表现一致。其实际
完成的方式由实现决定。

内部方法名称是多态的。这个不同对象值在调用一个通用的方法的时候可能会使用
不同的算法。方法调用时的实际背景对象是内部方法的"target"值。如果，运行时，
实现的算法试图使用某个对象不支持的内部方法，会投掷TypeError异常。

内部占位对应联结对象的内部状态，被各ECMAScript实现算法使用。内部占位不是
对象性质，也不能被继承。根据内部占位实现的规范，其状态值可能是任何ECMAScript
语言类型或者ECMAScript规范类型。除非显示指明，内部占位在创建对象的过程就被
联结，而且可能不可以动态的增加。除非显示指明，内部占位的初始值是undefined。
本规范的各种算法创建的对象都有内部占位。然而ECMAScript语言不提供联结到对象
的直接途径。

本规范定义的内部方法和内部占位的名字使用双方括号包裹的形式\[\[]]

Table6 描述了用于本规范创建和修改对象是使用的基础内部方法。每个对象都要有
所有基础内部方法的算法。然而不同对象的内部方法的算法可能不同。

基本对象是满足下列所有标准的对象
. 在Table6中列举的内部方法，对象使用在10.1中的定义
. 如果对象有\[\[Call]]内部方法，使用10.2.1的定义
. 如果对象由\[\[Construct]]内部方法，使用10.2.2的定义。

不是基本对象的对象都是奇异对象。

本规范通过其对象的内部方法识别不同的奇异对象。对象只有奇异对象的部分行为
（比如Array奇异对象或者绑定函数对象），但是没有其指明的全部内部方法，是不被
认为是对应的奇异对象。

Table6 和其他类似表格 的签名列描述了每个内部方法的调用模式。调用模式通常
插入包含描述参数名称的列表。如果参数名与ECMAScript类型名相同，表示这里需要
相同类型的值作为参数。如果内部方法显示返回值，其参数列表后会跟随"->"符号和
返回值的类型名。在签名中使用类型名引用了章节6定义的类型和额外的any。any意味
其值可以是任何ECMAScript语言类型。

除了其参数列表，还有一个内部方法经常访问对象，就是方法调用的对象。

内部方法隐式返回一个完结记录，或者包含调用模式指明的返回类型对应的值的
普通完结，或者投掷完结。
| 内置方法                | 签名                                               | 描述                                                                                                                                                                |
| \[\[GetPrototypeOf]]    | ()->Object \vert Null                              | 明确为当前对象提供继承性质的对象。null表示没有继承性质                                                                                                              |
| \[\[SetPrototypeOf]]    | (Object \vert Null)-> Boolean                      | 为本对象联结其他对象以提供继承性质。传递null表示没有继承性质。返回true表示本操作成功，false表示本操作没有成功。                                                     |
| \[\[IsExtensible]]      | ()-> Boolean                                       | 明确本对象是否允许增加性质。                                                                                                                                        |
| \[\[PreventExtensions]] | ()-> Boolean                                       | 控制本对性能否增加新性质。操作成功返回true，否则返回false。                                                                                                         |
| \[\[GetOwnProperty]]    | (propertyKey)-> Undefined \vert PropertyDescriptor | 返回propertyKey对应的自有性质的PropertyDescriptor。如果不存在这个自有性质，就会返回undefined                                                                        |
| \[\[DefineOwnProperty]] | (propertyKey, PropertyDescriptor)-> Boolean        | 创建或者修改propertyKey对应的自有性质，其状态由PropertyDescriptor描述。如果操作成功返回true，否则返回false。                                                        |
| \[\[HasProperty]]       | (propertyKey) -> Boolean                           | 返回对象的自有性质或者继承性质的键是propertyKey。                                                                                                                   |
| \[\[Get]]               | (propertyKey, Receiver)->any                       | 从本对象返回propertyKey对应性质的值。如果任何ECMAScript代码必然被执行来取回这个性质值，那么在执行代码时Receiver被用作this的值。                                     |
| \[\[Set]]               | (propertyKey, value, Receiver)-> Boolean           | 设置propertyKey性质的值为value。如果任何ECMAScript代码必然被执行来设置这个性质值，那么执行代码时Receiver被用作this的值。如果性质被设置了新值返回true，否则返回false |
| \[\[Delete]]            | (propertyKey) -> Boolean                           | 从本对象中移除propertyKey对应的自有性质。如果没有删除，且性质继续存在返回false。如果删除成功，或者性质不存在，返回true。                                            |
| \[\[OwnPropertyKeys]]   | () -> List<propertyKey>                            | 返回本对象所有自有性质的键的列表                                                                                                                                    |

Table7 描述了对象被作为函数被调用时需要的额外的基本内部方法。函数对象就是
支持\[\[Call]]内部方法的对象。构造范是支持\[\[Constructor]]内部方法的对象。任何
支持\[\[Constructor]]的对象都需要支持\[\[Call]]，因为每个构造范都是函数对象。
因此构造范也被认为是构造函数或者构造函数对象。
| 内置方法          | 签名                         | 描述                                                                                                                                                                                                                                                   |
| \[\[Call]]        | (any, List<any>)->any        | 执行本对象联结的代码。通过函数调用表达式被调用。传递给本内部方法的参数是this值和List<any>。List<any>是调用表达式执行时传递的参数列表。实现了这个内部方法的对象是可调用的。                                                                             |
| \[\[Constructor]] | (List<any>, Object)-> Object | 创建一个对象。通过new操作符或者super调用被调用。第一个参数是表达式调用时传递的值列表。第二个参数是在是使用new操作符是提供的初始值。实现了这个内部方法的对象被称为构造范。函数对象没必要是构造范，所以非构造范的函数对象没有\[\[Constructor]]内部方法。 |

基本对象和标准奇异对象的基础内部方法的语义在第十章具体说明。奇异对象的
内部方法的具体使用没有被实现支持，当尝试调用时应该投掷TypeError异常。
***** 基础内部方法的恒定部分
ECMAScript引擎对象的内部方法必须满足下列的恒定规定。基本ECMAScript对象与本
规范中的所有标准奇异对象维护这些恒定内容。ECMAScript代理对象维护这些恒定内
容是指在调用这个\[\[ProxyHandler]]对象时运行全部的检查。

任何实现提供的任何奇异对象必须维护这些恒定内容。违反这些恒定内容会导致
ECMAScript代码有不可预测的行为和导致安全问题。然而违反这些恒定内容绝对不能
妥协实现的内存安全。

实现不能允许这些恒定内容以任何方式被绕过，比如提供备选接口实现了基础内部
方法的功能但是没有强化恒定内容。

定义：
. 内部方法的目标是这个内部方法在其上被调用的对象。
. 如果目标的\[\[IsExtensible]]返回false，或者\[\[PreventExtensions]]返回true，这个
  目标是不可扩展的。
. 非存在性质是一个不可扩展对象上没有作为自有性质存在的性质。
. 所有SameValue的引用都依赖于SameValue算法的定义。

返回值
内部方法返回的值必然是一个完结记录，携带下列之一：
. \[\[Type]]=normal, \[\[Target]]=empty而且\[\[Value]]为如下列内部方法返回的“正常
  返回值”
. \[\[Type]]=normal, \[\[Target]]=empty而且[\[Value]]为任意ECMAScript语言值。
****** 注意1 内部方法不能返回\[\[Type]]是continue、break或return的完结记录
****** \[\[GetPrototypeOf]]()
. 常规返回的类型是Object或者null
. 如果target是不可扩展的，而且\[\[GetPrototypeOf]]返回了一个值V，随后调用
  \[\[GetPrototypeOf]]都应该返回V的相同值。
****** 注意2 对象的原型链需要是有限长度的（这就是说从任何对象开始，递归的调
用\[\[GetPrototypeOf]]内部方法，最终的结果必须是明确的null）。然而，这个要求并
不强求原型链上某个原型是没有使用标准对象\[\[GetPrototypeOf]]定义的奇异对象的
对象。这种环形原型链可能会在访问对象性质的时候导致无限循环。
****** \[\[SetPrototypeOf]](V)
. 常规返回类型是Boolean
. 如果对象是不可扩展的，而且V与目标上\[\[GetPrototypeOf]]的结果不是SameValue，
  那么\[\[SetPrototypeOf]]必须返回false。
****** \[\[IsExtensible]]()
. 常规返回类型是Boolean
. 如果\[\[IsExtensible]]返回了false，后续目标上所有\[\[IsExtensible]]调用都要返回
  false。
****** \[\[PreventExtensions]]()
. 常规返回类型是Boolean
. 如果\[\[PreventExtensions]]返回true，后续目标上所有\[\[IsExtensible]]调用需要返
  回false，而且目标被认为是不可扩展的。
****** \[\[GetOwnProperty]](P)
. 常规返回类型是PropertyDescriptor或者Undefined
. 如果返回值类型是PropertyDescriptor，那么这个值必须是完整填充的
  PropertyDescriptor
. 如果P描述的是不可设置或者不可写的自有数据性质，后续调用
  \[\[GetOwnProperty]](P)返回PropertyDescriptor的\[\[Value]]必须与P的\[\[Value]]属性
  是相同值
. 如果P除了\[\[Writable]]外的其他属性会在后续的过程中修改，甚至P性质可能会被
  删除，那么此时P的\[\[Configurable]]属性必须是true
. P的\[\[Writable]]属性可能从false修改到true，那么\[\[Configurable]]属性必须是
  true
. 如果target是不可扩展的，而且P是非存在性质，那么后续在这target上调用
  \[\[GetOwnProperty]](P)必须描述P是非存在的（例如必须返回undefined）
****** 注意三
作为第三个不变性的后果，一个数据性质可能在不同时间返回不同值。那么要求其
\[\[Writable]]和\[\[Configurable]]必须都是true，即使没有暴露其他通过基本内部
方法修改这个值的机制。
****** \[\[DefineOwnProperty]](P,Desc)
. 常规返回类型是Boolean
. 如果P在之前已经发现是目标的不可设置的自有性质，那么必须按照下列情况返回
    1. P是可写的数据性质。不可设置的可写数据性质变更成不可设置的不可写数据
       性质。此时返回true。
    2. Desc的所有属性与P的属性全部是相同值。此时返回true。
    3. 其他情况发挥false。
. 如果目标是不可扩展的，P是非存在性质，那么\[\[DefineOwnProperty]](P,Desc)必须
  返回false。其实就是不可扩展的目标对象不能扩展新的性质。
****** \[\[HasProperty]](P)
. 常规返回类型是Boolean
. 如果P在之前已经发现是目标的不可设置的自有的数据或者访问性质，
\[\[HasProperty]]必须返回true
****** \[\[Get]](P,Receiver)
. 常规返回类型是任意ECMAScript语言类型
. 如果P在之前发现是目标的带有值V的不可设置的或不可写的自有数据性质，那么
  \[\[Get]]必须返回V的相同值
****** \[\[Set]](P,V,Receiver)
. 常规返回类型是Boolean
. 如果P在之前已经发现是目标的不可设置的或不可写的自有数据性质，那么
    .如果P的\[\[Value]]属性与V是相同值，返回true
    .否则返回false
. 如果P在之前已经发现是目标的不可设置的自有访问性质，而且P的\[\[Set]]属性是
undefined，那么\[\[Set]](P,V,Receiver)操作必须返回false
****** \[\[Delete]](P)
. 常规返回类型是Boolean
. 如果P在之前已经发现是目标的不可设置的自有的数据或者访问性质，\[\[Delete]]
  操作必须返回false
****** \[\[OwnPropertyKess]]()
. 常规返回类型是List
. 返回的List不允许包含重复的实例
. 返回的List的每个元素类型的要么是String，要么是Symbol
. 返回的List至少要包含之前已经发现的所有不可设置的自有性质的键
. 如果目标是不可扩展的，返回的List必须只能包含目标通过\[\[GetOwnProperty]]发现
  的所有自有性质的键
****** \[\[Call]]()
. 常规返回类型是任意ECMAScript语言类型
****** \[\[Construct]]()
. 常规返回类型是Object
. 目标必须同时有\[\[Call]]内部方法
***** 常用的固有Object
常用的固有是基于本规范算法显示引用的对象进行内建，通常也有领内标识。除非
特殊说明每个固有对象实际上对应一套相似对象，每个领一个。

在本规范里用%name%标识一个固有对象，联结到当前领，对应这个name。类似
%name.a.b%这种用法表示，在评估ECMAScript代码前，已经访问了%name%内部对象的"a"
性质的"b"性质。本领的规定和其固有对象在9.3中描述。常用固有对象列在下表8中。
| 固有对象名称                     | 全局名称             | ECMAScript语言联结                                                 |
| %AggregateError%                 | AggregateError       | AggregateError构造范（20.5.7.1）                                   |
| %Array%                          | Array                | Array构造范（23.1.1）                                              |
| %ArrayBuffer%                    | ArrayBuffer          | ArrayBuffer构造范（25.1.3）                                        |
| %ArrayIteratorPrototype%         |                      | Array遍历器对象的原型（23.1.5）                                    |
| %AsyncFromSyncIteratorPrototype% |                      | 异步-从-同步遍历器对象的原型（27.1.4）这个完全不了解，无法有效翻译 |
| %AsyncFunction%                  |                      | 异步函数对象的构造范（27.7.1）                                     |
| %AsyncGeneratorFunction%         |                      | 异步遍历器对象的构造范（27.4.1）                                   |
| %AsyncIteratorPrototype%         |                      | 所有标准的内置异步构造器都间接的继承自这个对象                     |
| %Atomics%                        | Atomics              | Atomics对象（25.4）                                                |
| %BigInt%                         | BigInt               | BigInt构造范（21.2.1）                                             |
| %BigInt64Array%                  | BigInt64Array        | BigInt64Array构造范（23.2）                                        |
| %BigUint64Array%                 | BigUint64Array       | BigUint64Array构造范（23.2）                                       |
| %Boolean%                        | Boolean              | Boolean构造范（20.3.1）                                            |
| %DataView%                       | DataView             | DataView构造范（25.3.2）                                           |
| %Date%                           | Date                 | Date构造范（21.4.2）                                               |
| %decodeURI%                      | decodeURI            | decodeURI函数（19.2.6.2）                                          |
| %decodeURIComponent%             | decodeURIComponent   | decodeURIComponent函数（19.2.6.3)                                  |
| %encodeURI%                      | encodeURI            | encodeURI函数（19.2.6.4）                                          |
| %encodeURIComponent%             | encodeURIComponent   | encodeURIComponent函数（19.2.6.5）                                 |
| %Error%                          | Error                | Error构造范（20.5.1）                                              |
| %eval%                           | eval                 | eval函数（19.2.1）                                                 |
| %EvalError%                      | EvalError            | EvalError构造范（20.5.5.1）                                        |
| %FinalizationRegistry%           | FinalizationRegistry | FinalizationRegistry构造范（26.2.1）                               |
| %Float32Array%                   | Float32Array         | Float32Array构造范（23.2）                                         |
| %Float64Array%                   | Float64Array         | Float64Array构造范（23.2）                                         |
| %ForInIteratorPrototype%         |                      | For-In遍历器对象的原型（14.7.5.10）                                |
| %Function%                       | Function             | Function构造范（20.2.1）                                           |
| %GeneratorFunction%              |                      | generator对象的构造范（27.3.1）                                    |
| %Int8Array%                      | Int8Array            | Int8Array构造范（23.2）                                            |
| %Int16Array%                     | Int16Array           | Int16Array构造范（23.2）                                           |
| %Int32Array%                     | Int32Array           | Int32Array构造范（23.2）                                           |
| %isFinite%                       | isFinite             | isFinite函数（19.2.2）                                             |
| %isNaN%                          | isNaN                | isNaN函数（19.2.3）                                                |
| %IteratorPrototype%              |                      | 所有标准的内置遍历器对象都间接的继承自这个对象                     |
| %JSON%                           | JSON                 | JSON对象（25.5）                                                   |
| %Map%                            | Map                  | Map构造范（24.1.1）                                                |
| %MapIteratorPrototype%           |                      | Map遍历器对象的原型（24.1.5）                                      |
| %Math%                           | Math                 | Math对象（21.3）                                                   |
| %Number%                         | Number               | Number构造范（21.1.1）                                             |
| %Object%                         | Object               | Object构造范（20.1.1）                                             |
| %parseFloat%                     | parseFloat           | parseFloat函数（19.2.4）                                           |
| %parseInt%                       | parseInt             | parseInt函数（19.2.5）                                             |
| %Promise%                        | Promise              | Promise构造范（27.2.3）                                            |
| %Proxy%                          | Proxy                | Proxy构造范（28.2.1）                                              |
| %RangeError%                     | RangeError           | RangeError构造范（20.5.5.2）                                       |
| %ReferenceError%                 | ReferenceError       | ReferenceRrror构造范（20.5.5.3）                                   |
| %Reflect%                        | Reflect              | Reflect对象（28.1）                                                |
| %RegExp%                         | RegExp               | RegExp构造范（22.2.3）                                             |
| %RegExpStringIteratorPrototype%  |                      | RegExp字符串遍历器对象的原型（22.2.7）                             |
| %Set%                            | Set                  | Set构造范（24.2.1）                                                |
| %SetIteratorPrototype%           |                      | Set遍历器对象的原型（24.2.5）                                      |
| %SharedArrayBuffer%              | SharedArrayBuffer    | SharedArrayBuffer构造范（25.2.2）                                  |
| %String%                         | String               | String构造范（22.1.1）                                             |
| %StringIteratorPrototype%        |                      | String遍历器对象的原型（22.1.5）                                   |
| %Symbol%                         | Symbol               | Symbol构造范（20.4.1）                                             |
| %SyntaxError%                    | SyntaxError          | SyntaxError构造范（20.5.5.4）                                      |
| %ThrowTypeError%                 |                      | 无条件投掷一个新的%TypeError%实例的函数对象                        |
| %TypeArray%                      |                      | 所有类型化数组的构造范的父类（23.2.1）                             |
| %TypeError%                      | TypeError            | TypeError构造范（20.5.5.5）                                        |
| %Uint8Array%                     | Uint8Array           | Uint8Array构造范（23.2）                                           |
| %Uint8ClampedArray%              | Uint8ClampedArray    | Uint8ClampedArray构造范（23.2）                                    |
| %Uint16Array%                    | Uint16Array          | Uint16Array构造范（23.2）                                          |
| %Uint32Array%                    | Uint32Array          | Uint32Array构造范（23.2）                                          |
| %URIError%                       | URIError             | URIError构造范（20.5.5.6）                                         |
| %WeakMap%                        | WeakMap              | WeakMap构造范（24.3.1）                                            |
| %WeakRef%                        | WeakRef              | WeakRef构造范（26.1.1）                                            |
| %WeakSet%                        | WeakSet              | WeakSet构造范（24.4.1）                                            |
****** 注意 额外的实例在表82
** 用于ECMAScript规范类型
规范类型与元值一致，用于描述ECMAScrpt语言构造和ECMAScript语言类型的算法语义
。规范类型包括Reference、List、Completion、PropertyDescriptor、EnvironmentRecord、
AbstrctCloure和DataBlock。规范类型是本规范制作的，不对应任何ECMAScript实现的任
何特定实例。规范类型的值可以被用于描述ECMAScript表达式评估的中间结果，但是
这种值不能存储为对象的性质或者个变量的值。
*** List和Record规范类型
List类型是用于解释在new表达式、在函数调用和其他需要简单的有序的值的算法
的参数列表评估。List类型的多值是简单有序的List元素序列，元素拥有独立的多值
。序列可能是任意长度。List元素会被按照0原点索引随机访问。为了表示的方便用
类似数组的语法访问List元素。比如argument[2]就是argument List的第三个元素的缩
写。

为了表示着方便，一个文法语法被用于表示一个新的List值。比如<<1,2>>定义了
一个List值，它有两个元素，没有按照顺序初始为指定值。一个新的空List被表示
为<< >>。

Record类型用于描述本规范的算法中的数据聚合。一个Record类型值包含一个或者
多个以命名的字段。每个字段的值要么是ECMAScript值要么是表示联结到一个Record
类型的名字的抽象值。字段的名字通常用双方括号包含起来例如\[\[Value]]。

为了表示着方便，类似对象的文法语法被用于表示一个Record值。比如
{ \[\[Field1]]:42, \[\[Field2]:false, \[\[Field3]]:empty } 定义了一个拥有三个字段
的Record值，每个字段被初始化为指定值。字段名字的顺序没有意义。任何没有显式
列出的字段被认为是缺失的。

在规范的文本与算法中，.符号被用于引用Record值的指定字段。例如，如果R表示
之前段落说的Record值，那么R.\[\[Field2]是“R中名称为Field2的字段”的缩写。

常用的Receord字段组合提纲会被命名，这个名字被用作文法Record值的前缀，用于
标识按照描述的指定类型的聚合。例如 PropertyDescriptor { \[\[Value]]:42,
\[\[Writable]]:false, \[\[Configurable]]:true }
*** Set和Relation规范类型
Set类型是用于在内存模型中解释无序的元素合集。Set类型的值就是元素的简单合
集，且没有元素出现一次以上。元素可以在Set中增加与删除。集合间可以进行合
并、取交与差操作。

Relation类型是用于解释Set上的约束。Relation类型的值是值域上的一套有序值对。
比如，事件上的Relation是一组有序的事件对。一个Relation R和R域上的a、b两个值，
a R B是R的成员有序对(a,b)的简写。Relation至少要表示某些条件，当它是满足
这些条件的最小Releation时。

严格偏序是一种Relation值R，满足如下要求：
. R域上的任意值a, b, c
    . 没有a R a, 且
    . 如果a R b 和b R c，那么a R c
**** 上述两个性质分别是非反身性和传递性。
严格全序是满足如下要求的Releation值R
. R域上的任意值a, b, c
    . a 与 b相同, a R b, b R a 三者之一，且
    . 没有 a R a， 且
    . 如果a R b 和b R c，那么a R c
**** 上述三个性质分别是完全性、非反身性和传递性。
**** 注意 上面关系内容其实与抽象代数中关系的描述是一致的，相关的名词以
           数学名词为准。这里就是随意翻译了一下。
*** Completion Record规范类型
Completion类型是一个Record，用于解释运行时值的传播和流程控制，比如语句（
break, continue, return 和 throw）的行为，会产生控制本地外的传递。

Completion类型的值是Record值，其字段在表9中定义。这些值合起来就是Completion
Record
| 字段名称     | 值                                         | 含义                     |
| \[\[Type]]   | 必须normal,break,continue,return,throw之一 | 产生的Completion的类型   |
| \[\[Value]]  | ECMAScript语言值或者空                     | 产生的值                 |
| \[\[Target]] | ECMAScript字符串或者空                     | 直接的控制传输的目标标签 |

术语abrupt completion（意外完结）指\[\[Type]]不是normal的Completion实例。
**** Await
算法步骤
1. 让completion是Await(value)
与下列步骤意味着相同的含意
1. 让asyncContext是运行时执行上下文（running execution context）
2. 让promise是?PromiseResolve(%Promise%, value)
3. 让stepsFulfilled是定义在Await Fulfilled Functions的算法步骤
4. 让lengthFulfilled是定义在Await Fulfilled Functions的函数需要的必要参数的数量
5. 让onFulfilled是!CreateBuiltinFunction(stepsFulfilled, lengthFulfilled,\'''\', <<\[\[AsyncContext\]\]>>)
6. 设置onFulfilled.\[\[AsyncContext]]为asyncContext
7. 让stepsRejected是定义在Await Rejected Functions的算法步骤
8. 让lengthRejected是定义在Await Rejected Functions的函数需要的必要参数的数量
9. 让onRejected是!CreateBuiltinFunction(stepsRejected, lengthRejected, \'''\',<<\[\[AysncContext]]>>)
10. 设置onRejected.\[\[AsyncContext]]为asyncContext
11. 运行!PerformPromiseThen(promise, onFulfilled, onRejected)
12. 从execution context stack中移除asyncContext，将在execution context stack顶部的execution context
    恢复为running execution context
13. 设置asyncContext像那些带着完结completion继续的评估的代码评估状态是completion，这样跟随在Await
    算法之后的步骤就会执行下去
14. 返回
15. 注意：本返回到评估的操作在asyncContext中是最优先继续评估的。

上述步骤中的别名，和预期的completion，都是瞬时的，而且仅在Await的算法步骤中
可见。
***** 注意 Await可以组合?和!前缀，例如： 1. 让result是?Await(value)
      意味着下面行为：
      1. 让result是Await(value)
      2. ReturnIfAbrupt(result)
***** Await Fulfilled Functions
Await fulfilled函数是匿名内建函数，是Await规范的一部分，用于将
promise fulfillment值

作为普通完结派发到调用者。每个Await fulfilled函数有一个内置的
\[\[AsyncContext\]\]当Await fulfilled函数被带着value调用时，下列步骤会被执行
1. 让F是active function object
2. 让asyncContext是F.\[\[AsyncContext]]
3. 让prevContext是running execution context
4. 挂起prevContext
5. 将asyncContext压到execution context stack；asyncContext就是现在的运行时执行背景
6. 继续asyncContext上已经挂起的评估，用NormalCompletion(value)作为这个导致挂起的
   操作的结果。
7. Assert：当到达这步的时候，asyncContext已经从execution context stack中移除，
   而且prevContext是当前的运行时执行背景
8. 返回undefined
    Await fulfilled函数的length性质是1_F
***** Await Rejected Functions
Await rejected函数是匿名内建函数，是Await规范的一部分，用于将promise rejection
原因作为投掷完结派发给调用者。每个Await rejected函数有一个内置的
\[\[AsyncContext]]。当Await rejected函数被带着reason调用时，下列步骤会被执行
1. 让F是active function object
2. 让asyncContext是F.\[\[AsyncContext]]
3. 让prevContext是running execuction context
4. 挂起prevContext
5. 将asyncContext压到execution context stack；asyncContext就是现在的运行时执行背景
6. 继续asyncContext上已经挂起的评估，用ThrowCompletion(reason)作为这个导致挂起
   的操作的结果。
7. Assert：当到达这步的时候，asyncContext已经从execution context stack中移除，
   而且prevContext是当前的运行时执行背景
8. 返回undefined

Await rejected函数的length性质是1_F
**** NormalCompletion
抽象操作NormalCompletion有单一参数argument，比如：
1. 返回 NormalCompetion(argument)
是下列定义的简写：
1. 返回 Completion {\[\[Type]]:normal, \[\[Value]]:argument, \[\[Target]]:empty}
**** ThrowCompletion
抽象操作ThrowCompletion有单一参数argument，比如：
1. 返回 ThrowCompetion(argument)
是下列定义的简写：
1. 返回 Completion {\[\[Type]]:throw, \[\[Value]]:argument, \[\[Target]]:empty}
**** UpdateEmpty(completionRecord, value)
抽象操作UpdateEmpty接受两个参数completionRecord和value。被调用时执行下列步骤：
1. Assert：completionRecord.\[\[Type]]如果是throw或者return，那么
completionRecord.\[\[Value]]必然不空
2. 如果completionRecord.\[\[Type]]不空，返回Completion(completionRecord)
3. 否则返回Completion { \[\[Type]]:completionRecord.\[\[Type]], \[\[Value]]:value,
   \[\[Target]]:completionRecord.\[\[Target]] }
*** ReferenceRecord规范类型
ReferenceRecord类型是用于解释例如delete、typeof、赋值、super关键词和其他语言特
性等操作的行为。举例：赋值语句中的左侧的操作项就被期望产生一个
ReferenceRecord。

ReferenceRecord是一个已解决的名称或性质的绑定，它的字段在表10中定义
| 字段名称             | 值                                                                                  | 含义                                                                                         |
| \[\[Base]]           | 三者之一：除null和undefined的ECMAScript语言的值；Environment Record; unresolvable。 | 占据这个绑定的值或者Environment Record。\[\[Base]]如果是unresolvable表明这个绑定不能被解决。 |
| \[\[ReferencedName]] | String或者Symbol                                                                    | 这个绑定的名称。如果\[\[Base]]值是Evironment Record，那么总是String。                        |
| \[\[Strict]]         | Boolean                                                                             | 如果这个ReferenceRecord来源自严格模式的代码，它就是true，否则就是false                       |
| \[\[ThisValue]]      | 任何ECMAScript语言的值，或者empty                                                   | 如果不空，这个ReferenceRecord表示一个用super关键词表示的性质绑定；它被称为SuperReferenceRecord，而且\[\[Base]]值永不会是EnvironmentRecord。在这种案例里\[\[ThisValue]]是创建ReferenceRecord时的this值。 |

下列抽象操作被用在本规范里以操作上述的Reference。
**** IsPropertyReference(V)
抽象操作IsPropertyReference接受参数V。被调用时执行下列步骤：
1. Assert: V是一个ReferenceRecord
2. 如果V.\[\[Base]]是unresolvable，返回false
3. 如果V.\[\[Base]]是Boolean、String、Symbol、BigInt、Number或者Object返回true，
   否则返回false
**** IsUnresolvableReference(V)
抽象操作IsUnresolvableReference接受参数V。被调用时执行下列步骤：
1. Assert: V是一个ReferenceRecord
2. 如果V.\[\[Base]]是unresolvable，返回true，否则返回false。
**** IsSuperReference(V)
抽象操作IsSuperReference接受参数V。被调用时执行下列步骤：
1. Assert: V是一个ReferenceRecord
2. 如果V.\[\[ThisValue]]非空，返回true，否则返回false。
**** GetValue(V)
抽象操作GetValue接受参数V。被调用时执行下列步骤：
1. ReturnIfAbrupt(V)
2. 如果V不是ReferenceRcord返回V
3. 如果IsUnresolvableReference(V)是true，那么投掷一个ReferenceError异常
4. 如果IsPropertyReference(V)是true，那么
    a. 让baseObj是!ToObject(V.\[\[Base]])
    b. 返回?baseObj.\[\[Get]](V.\[\[ReferenceName]], GetThisValue(V))
5. 否则
    a. 让base是V.\[\[Base]]
    b. Assert：base是一个EnvironmentRecord
    c. 返回 ?base.GetBindingValue(V.\[\[ReferenceName]], V.\[\[String]])（见9.1）
**** PutValue(V, W)    
抽象操作PutValue接受参数V和W。被调用时执行下列步骤：
1. ReturnIfAbrupt(V)
2. ReturnIfAbrupt(W)
3. 如果V不是ReferenceRecord，投掷一个ReferenceError异常
4. 如果IsUnresolvableReference(V)是true，那么
    a. 如果V.\[\[Strict]]是true，投掷一个ReferenceError异常
    b. 让globalObj是GetGlobalObject()
    c. 返回?Set(globalObj, V.\[\[ReferencedName]], W, false)
5. 如果IsPropertyReference(V)是true，那么
    a. 让baseObj是!ToObject(V.\[\[Base]])
    b. 让succeeded是?baseObj.\[\[Set]](V.\[\[ReferencedName]], W, GetThiValue(V))
    c. 如果succeeded是false，而且V.\[\[Strict]]是true，投掷一个类型异常
    d. 返回
6. 否则
    a. 让base是V.\[\[Base]]
    b. Assert：base是EnvironmentRecord
    c. 返回 ?base.SetMutableBinding(V.\[\[ReferencedName]], W, V.\[\[Strict]])（见
9.1）
***** 注意 步骤5.a可能创建一个对象，除了上述抽象操作和基本对象的\[\[Set]]内部
            方法外的其他行为不能访问这个对象。实现可以选择规避实际创建这个
            对象。
**** GetThisValue(V)
抽象操作GetThisValue接受参数V。被调用时执行下列步骤：
1. Assert：IsPropertyReference(V)是true
2. 如果IsSuperReference(V)是true，returV.\[\[ThisValue]]；否则返回V.\[\[Base]]
**** InitializeReferenceBinding(V,W)
抽象操作InitializeReferenceBinding接受参数V和W。被调用时执行下列步骤：
1. ReturnIfAbrupt(V)
2. ReturnIfAbrupt(W)
3. Assert：V是ReferenceRecord
4. Assert：IsUnresolvableReference(V)是false
5. 让base是V.\[\[Base]]
6. Assert：base 是一个EnvironmentRecord
7. 返回base.InitializeBinding(V.\[\[ReferencedName]], W)
*** Property Descriptor规范类型
Property Descriptor类型是用于解释操作和物化Object性质的属性。Property
Descriptor类型的值是Record类型。每个字段的名称就是属性的名称，它的值与
6.1.7.1中确定的属性的值一致。另外，任何字段都可能出现或缺失。在本规范中
为了标记Property Descriptor记录的文法描述，使用PropertyDescriptor作为纲要名称。

依据某些字段的存在或使用情况，Property Descriptor值可以被进一步划分为
数据Property Descriptor和访问Property Descriptor。数据Property Descriptor含有
\[\[Value]]或者\[\[Writable]]字段。访问Property Descriptor含有\[\[Get]]或者
\[\[Set]]字段。Property Descriptor还会含有\[\[Enumerable]]和\[\[Configurable]]。
Property Descriptor不能同时是数据Property Descriptor或者访问Property Descriptor，
然而可以两者都不是，这时就是一个普通的Property Descriptor。一个完整填充的
Property Descriptor必须是两者之一，其属性与对应的表3或者表4一致。

随后的抽象操作被用在本规范来操作Property Descriptor值。
**** IsAccessorDescriptor(Desc)
抽象操作IsAccessorDescriptor接受参数Desc（Property Descriptor值或者undefined）。
被调用时执行下列步骤：
1. 如果Desc是undefined，返回false。
2. 如果Desc.\[\[Get]]和Desc.\[\[Set]]都缺失，返回false。
3. 返回true。
**** IsDataDescriptor(Desc)
抽象操作IsDataDescriptor接受参数Desc（Property Descriptor值或者undefined）。
被调用时执行下列步骤：
1. 如果Desc是undefined，返回false。
2. 如果Desc.\[\[Value]]和Desc.\[\[Writable]]都缺失，返回false。
3. 返回true。
**** IsGenericDescriptor(Desc)
抽象操作IsGenericDescriptor接受参数Desc（Property Descriptor值或者undefined）。
被调用时执行下列步骤：
1. 如果Desc是undefined，返回false。
2. 如果IsAccessorDescriptor(Desc)和IsDataDescriptor(Desc)都是false，返回true。
3. 返回false。
**** FromPropertyDescriptor(Desc)
抽象操作FromPropertyDescriptor接受参数Desc(Property Descriptor值货主undefined)。
被调用时执行下列步骤：
1. 如果Desc是undefined，返回undefined。
2. 让obj是!OrdinaryObjectCreate(%Object.prototype%)
3. Assert: obj是可扩展的不含性质的基本对象
4. 如果Desc有\[\[Value]]字段，那么
    a. 执行!CreateDataPropertyOrThrow(obj, "value", Desc.\[\[Value]])
5. 如果Desc有\[\[Writable]]字段，那么
    a. 执行!CreateDataPropertyOrThrow(obj, "writable", Desc.\[\[Writable]])
6. 如果Desc有\[\[Get]]字段，那么
    a. 执行!CreateDataPropertyOrThrow(obj, "get", Desc.\[\[Get]])
7. 如果Desc有\[\[Set]]字段，那么
    a. 执行!CreateDataPropertyOrThrow(obj, "set", Desc.\[\[Set]])
8. 如果Desc有\[\[Enumerable]]字段，那么
    a. 执行!CreateDataPropertyOrThrow(obj, "enumerable", Desc.\[\[Enumerable]])
9. 如果Desc有\[\[Configurable]]字段，那么
    a. 执行!CreateDataPropertyOrThrow(obj, "configurable", Desc.\[\[Configurable]])
10. 返回obj
**** ToPropertyDescriptor(Obj)
抽象操作ToPropertyDescriptor接受参数Obj，被调用时执行下列步骤：
1. 如果Type(Obj)不是Object，投掷TypeError异常
2. 让desc是新的Property Descriptor且没有初始化任何字段
3. 让hasEnumerable是?HasProperty(Obj, "enumerable")
4. 如果hasEnumerable是true，那么
    a. 让enumerable是!ToBoolean(?Get(Obj, "enumerable"))
    b. 设置desc.\[\[Enumerable]]是enumerable
5. 让hasConfigurable是?HasProperty(Obj, "confirgurable")
6. 如果hasConfigurable是true，那么
    a. 让configurable是!ToBoolean(?Get(Obj, "configurable"))
    b. 设置desc.\[\[Configurable]]是configurable
7. 让hasValue是?HasProperty(Obj, "value")
8. 如果hasValue是true，那么
    a. 让value是?Get(Obj, "value")
    b. 设置desc.\[\[Value]]是value
9. 让hasWritable是?HasProperty(Obj, "writable")
10. 如果hasWritable是true，那么
    a. 让writable是!ToBoolean(?Get(Obj, "writable"))
    b. 设置desc.\[\[Writable]]是writable
11. 让hasGet是?HasProperty(Obj, "get")
12. 如果hasGet是true，那么
    a. 让getter是?Get(Obj, "get")
    b. 如果IsCallable(getter)是false，而且getter不是undefined，投掷TypeError异常
    c. 设置desc.\[\[Get]]是getter
13. 让hasSet是?HasProperty(Obj, "set")
14. 如果hasSet是true，那么
    a. 让setter是?Get(Obj, "set")
    b. 如果IsCallable(setter)是false，而且setter不是undefined，投掷TypeError异常
    c. 设置desc.\[\[Set]]是setter
15. 如果desc.\[\[Get]]存在或者desc.\[\[Set]]存在，那么
    a. 如果desc.\[\[Value]]存在或者desc.\[\[Writable]]存在，投掷TypeError异常
16. 返回desc
**** CompletePropertyDescriptor(Desc)
抽象操作CompletePropertyDescriptor接受参数Desc（一个PropertyDescriptor）。被调用
时执行下列步骤：
1. Assert: Desc是一个PropertyDescriptor
2. 让like是Record {\[\[Value]]:undefined, \[\[Writable]]:undefined, \[\[Get]]:undefined,
\[\[Set]]:undefined, \[\[Enumerable]]:undefined, \[\[Configurable]]:undefined, }
3. 如果IsGenericDescriptor(Desc)是true，或者IsDataDescriptor(Desc)是true，那么
    a. 如果Desc没有\[\[Value]]字段，那么设置Desc.\[\[Value]]是like.\[\[Value]]
    b. 如果Desc没有\[\[Writable]]字段，那么设置Desc.\[\[Writable]]是
like.\[\[Writable]]
4. 否则
    a. 如果Desc没有\[\[Get]]字段，那么设置Desc.\[\[Get]]是like.\[\[Get]]
    b. 如果Desc没有\[\[Set]]字段，那么设置Desc.\[\[Set]]是like.\[\[Set]]
5. 如果Desc没有\[\[Enumerable]]字段，那么设置Desc.\[\[Enumerable]]是
   like.\[\[Enumerable]]
6. 如果Desc没有\[\[Configurable]]字段，那么设置Desc.\[\[Configurable]]是
   like.\[\[Configurable]]
7. 返回Desc
*** Environment Record规范类型
Environment Record类型是用于解释在函数和块中解释名称的行为。这个类型和其上
的操作在9.1中定义。
*** Abstract Closure规范类型
Abstract Closure规范类型用于描述连同值合集的若干算法步骤。Abstract Colsure值
是元值，用函数应用的方式调用，例如closure(arg1, arg2)。和抽象操作类似，调用时
按照Abstract Closure描述的算法步骤执行。

在会创建Abstract Closure的算法步骤中，捕获的值用"capture"后跟随的别名列表
表示。当Abstract Closure被创建了，同时它捕获这些别名联结的值。在Abstract
Closure被调用时执行的指定算法的步骤，捕获的值仍然用捕获时的别名引用。

如果Abstract Closure返回一个完结记录，这个完结记录的\[\[Type]]要么时normal，
要么是throw。

Abstract Closure在行内创建，作为其他算法的组成，例如：
1. 让addend是 41
2. 让closure是新的Abstract Closure，带有parameters(x)捕获addend，并且被调用时
   执行随后的步骤:
    a. 返回 x + addend;
3. 让val时closure(1)
4. Assert: val时42
*** Data Blocks规范类型
Data Block规范类型用于描述确切的可修改的字节数值（8位数值）序列。一个字节
值是一个[0,255]内的整数。每个创建的Data Block值都有固定的字节数，每个字节都
初始化为0。

为了在本规范中表示着方便，适用类似数组的语法访问Data Block中独立的字节。
这种记法将Data Block表示成一个零原点的整数索引的字节序列。例如，如果db是一个
5字节的Data Block值，那么db[2]表示其第三个字节的内容。

一个data blcok驻留在内存里，可以被多个代理访问到的话，被定为Shared Data
Block。Shared Data Block有一个标识（为了检测Shared Data Block值是否相等），这个
标识是无地址的，也就是说它没有绑定到这个块映射在任何进程中的虚拟地址，而
是这个块在内存中的地址集。两个Data Block相等的唯一条件是其包含的地址集相
等，否则他们不相等，而且它们包含的地址集没有交集。最后，Shared Data Block要
能区别于Data Block。

Shared Data Block的语义在内存模型中使用Shared Data Block事件中定义。下面的
抽象操作介绍了Shared Data Block事件，和作为评估语义与内存模型的事件语义间的
界面。事件构成了备选执行，内存模型在备选执行上作为过滤程序。请咨询内存
模型获得完整的语义。

Shared Data Block事件用Record模型，在内存模型中定义。

随后的抽象操作在本规范中用于Data Block值上的操作。
**** CreateByteDataBlock(size)
抽象操作CreateByteDataBlock接受参数size（整数）。被调用时执行下列步骤：
1. Assert：size >= 0
2. 让db是新的Data Block值，包含size个字节。如果无法创建这样的Data Block，
   投掷一个RangeError异常
3. 是指db上所有的字节都是0
4. 返回db
**** CreateSharedByteDataBlock(size)
抽象操作CreateSharedByteDataBlock接受参数size（非负整数）。被调用时执行下列
步骤：
1. Assert：size >= 0
2. 让db是新的Shared Data Block值，包含size个字节。如果无法创建这样的Shared
   Data Block，投掷一个RangeError异常
3. 让execution是环境代理的环境记录的\[\[CandidateExecution]]字段。
4. 让eventList是execution.\[\[EventsRecords]]里满足\[\[AgentSignifier]]是
   AgentSignifier()的元素的\[\[EventList]]字段。
5. 让zero是<<0>>
6. 遍历db的每个索引i，执行
    a. 向eventList中附加WriteShareMemory { \[\[Order]]:Init, \[\[NoTear]]:true,
       \[\[Block]]:db, \[\[ByteIndex]]:i, \[\[ElementSize]]:1, \[\[Payload]]:zero }
7. 返回db
**** CopyDataBlockBytes(toBlock, toIndex, fromBlock, fromIndex, count)
抽象操作CopyDataBlockBytes接受参数toBlock、toIndex(非负整数）、fromBlock、
fromIndex（非负整数）和count（非负整数）。被调用时执行下列步骤：
1. Assert：fromBlock和toBlock是不同的Data Block或者Shared Data Block值。
2. 让fromSize是fromBlock的字节数
3. Assert：fromIndex + count <= fromSize
4. 让toSize是toBlock的字节数
5. Assert：toIndex + count <= toSize
6. 当count > 0时，重复执行
    a. 如果fromBlock是Shared Data Block 那么
        i. 让execution是环境代理的代理记录的\[\[CandidateExecution]]字段
       ii. 让eventList是execution.\[\[EventsRecords]]里满足\[\[AgentSignifier]]是
           AgentSignifier()的元素的\[\[EventList]]字段。
      iii. 让bytes是一个列表，只有一个未确定选定的字节值。
       iv. 注意：在实现中，bytes是底层硬件上的非原子读取指令的结果。这种
           未确定性是内存模型中描述这种弱一致性的监察硬件行为的语义处方。
        v. 让readEvent是 ReadSharedMemory { \[\[Order]]:Unordered, \[\[NoTear]]:true,
           \[\[Block]]:fromBlock, \[\[ByteIndex]]:fromIndex, \[\[ElementSize]]:1}
       vi. 在eventList上追加readEvent
      vii. 在execution.\[\[ChosenValues]]中附加Chosen Value Record {
           \[\[Event]]:readEvent, \[\[ChosenValue]]:bytes }
     viii. 如果toBlock是Shared Data Block，那么
            1. 在eventList上追加 WriteSharedMemory { \[\[Order]]:Unordered,
               \[\[NoTear]]:true, \[\[Block]]:toBlock, \[\[ByteIndex]]:toIndex,
               \[\[ElementSize]]:1, \[\[Payload]]:bytes}
       ix. 否则
            1. 设置toBlock[toIndex]是bytes[0]
    b. 否则
        i. Assert：toBlock不是Shared Data Block
       ii. 设置toBlock[toIndex]是fromBlock[fromIndex]
    c. 设置toIndex是toIndex+1
    d. 设置fromIndex是fromIndex+1
    e. 设置count是count-1.
7. 返回NormalCompletion(empty)
***** 注意 有可能有从data block到shared data block的操作。这里没有禁止有可能
            在别的地方处理了。
* 抽象操作
这些操作不是ECMAScript语言的部分；在这里定义他们，只是帮助ECMAScript语言的
语义规范。而且贯穿本规范还有更多的特定抽象操作被定义了。
** 类型转换    
ECMAScript语言在需要的时候隐式的自动执行类型转换。为了明晰某种结构的语义，
很需要定义一套转换的抽象操作。转换的抽象操作是多态的，他们可以接受任意的
ECMAScript语言类型的值。但是规范类型值不能在这些操作中适用。

在ECMAScript语言中BigInt没有隐式的转换，程序必须调用BigInt来显示的转换到其
他类型。
*** ToPrimitive(input[, preferredType])
抽象操作ToPrimitive接受参数input和可选参数preferredType。将input参数转换为一个
非对象类型。如果一个对象是可以转换为多个原生类型的，它可能需要提示选项
preferredType到想要的类型。被调用时执行下列步骤：
1. Assert：input是ECMAScript语言类型
2. 如果Type(input)是对象，那么
    a. 让exoticToPrim是?GetMethod(input, @@toPrimitive)
    b. 如果exoticToPrim不是undefined，那么
        i. 如果不存在preferredType，让hint是"default"
       ii. 不然如果preferredType是string，让hint是"string"
      iii. 否则
            1. Assert：preferredType是number
            2. 让hint是"number"
       iv. 让result是?Call(exoticToPrim, input, <<hint>>)
        v. 如果Type(result)不是对象，返回result
       vi. 投掷TypeError异常
    c. 如果preferredType不存在，让preferredType是number
    d. 返回?OrdinaryToPrimitive(input, prferredType)
3. 返回input
**** 注意 当ToPrimitive被不带提示的调用时，它的行为跟hint是number时是一样的
           然而，对象可以通过重写@@toPrimitive方法来覆盖这个行为。在本规范中
           只有Date对象（详见21.4.4.45）和Symbol对象（详见20.4.3.5）重写了
           ToPrimitive行为。Date对象对待空hint为string。
**** OrdinaryToPrimitive(O, hint)
抽象操作OrdinaryToPrimitive接受参数O和hint。被调用时执行下列步骤：
1. Assert：Type(O)是对象
2. Assert：hint是number或者string
3. 如果hint是string那么
    a. 让methodNames是<<"toString", "valueOf">>
4. 否则
    a. 让methodNames是<<"valueOf", "toString">>
5. 遍历methodNames的每个元素name，执行
    a. 让method是?Get(O, name)
    b. 如果IsCallable(method)是true，那么
        i. 让result是?Call(method, O)
       ii. 如果Type(result)不是Object，返回resut
6. 投掷TypeError异常
*** ToBoolean(argument)
抽象操作ToBoolean接受参数argument。它根据表11将argument转换成Boolean类型的值
| 参数类型  | 结果                                                                       |
| Undefined | 返回false                                                                  |
| Null      | 返回false                                                                  |
| Boolean   | 返回argument                                                               |
| Number    | 如果argument是+0_F、-0_F或者NaN，返回false。其他返回true                   |
| String    | 如果argument是空字符串（即length是0），返回false。其他返回true             |
| Symbol    | 返回true                                                                   |
| BigInt    | 如果argument是0_Z，返回false。其他返回true。                               |
| Object    | 返回true。注意：一个关联到内置\[\[IsHTMLDDA]]的备选算法在B.3.7.1中强制执行 |
*** ToNumeric(value)
抽象操作ToNumeric接受参数value。它返回value转换成的Number或者BigInt。被调用时
执行下列步骤：
1. 让primValue是?ToPrimitive(value, number)
2. 如果Type(primValue)是BitInt，返回primValue
3. 返回?ToNumber(primValue)
*** ToNumber(argument)
抽象操作ToNumber接受参数argument。它根据表12将argument转换为Number值。
| 参数类型  | 结果                                                                                      |
| Undefined | 返回NaN                                                                                   |
| Null      | 返回+0_F                                                                                  |
| Boolean   | 如果argument是true，返回1_F。如果argument是false，返回+0_F                                |
| Number    | 返回argument（不转换）                                                                    |
| String    | 参看按照下方的语法和转换算法                                                              |
| Symbol    | 投掷TypeError异常                                                                         |
| BigInt    | 投掷TypeError异常                                                                         |
| Object    | 执行下列步骤：1. 让primValue是?ToPrimitive(argument, number)；2. 返回?ToNumber(primValue) |
**** 接受了String类型的ToNumber行为
ToNumber处理String值时将String解释成UTF-16编码点序列后使用后续的语法。如果
这里的语法无法将String值翻译成一个扩展的StringNumberLiteral，那么ToNumber返回的
结果是NaN。
***** 注意1 本语法中终结符都是由BMP（Unicode Basic Multilingual Plane）字符构成。
      所以字符串中包含任何首位和尾位编码单元，无论匹配与否，ToNumber都会返回
      NaN。

Syntax
StringNumericLiteral :::
    StrWhiteSpace_opt
    StrWhiteSpace_opt StrNumericLiteral StrWhiteSpace_opt
StrWhiteSpace :::
    StrWhiteSpaceChar StrWhiteSapce_opt
StrWhiteSpaceChar :::
    WhiteSpace
    LineTerminator
StrNumericLiteral :::
    StrDecimalLiteral
    NonDecimalIntegerLiteral_[~Sep]
StrDecimalLiteral :::
    StrUnsignedDecimalLiteral
    + StrUnsignedDecimalLiteral
    - StrUnsignedDecimalLiteral
StrUnsignedDecimalLiteral :::
    Infinity
    DecimalDigits_[~Sep] . DecimalDigits_[~Sep]_opt ExponentPart_[~Sep]_opt
    . DecimalDigits_[~Sep]_opt ExponentPart_[~Sep]_opt
    DecimalDigits_[~Sep] ExponentPart_[~Sep]_opt

上面用到的没有明确定义的语法符号在字面数字的词法语法（12.8.3）中定义。
***** 注意2 StringNumericLiteral和NumericLiteral语义有些不同，需要注意
             . StringNumericLiteral可以在始末包含有限的空格或者换行符
             . StringNumericLiteral其实位值可以有任意个0
             . StringNumericLiteral可以包含+或-来指明符号
             . StringNumericLiteral可以是空的或者值包含空白符，被转换成+0_F
             . Infinity和-Infinity被时别为StringNumericLiteral，而不是NumericLiteral
             . StringNumericLiteral不能包含BigIntLiteralSuffix
***** 运行语义：MV
String转化为Number值总体上与从字面数字得到Number值的规定相似，但是有些细节
是不同的，所以在这里给出从字符串数字到Number类型值的转换过程。这个值由两步
决定：首先，从字符串数字中派生数学值（MV）；其次，这个数学值按照下方的描述
进行修圆。不是在下方里，而是在其他语法符号中提及的MV，是在12.8.3.1中定义的
MV。
. StringNumericLiteral ::: [empty]的MV是0
. StringNumericLiteral ::: StrWhiteSpace的MV是0
. StringNumericLiteral ::: StrWhiteSpace_opt StrNumericLiteral StrWhiteSpace_opt的MV
  是StrNumericLiter的MV，无论有多少空白或者没有空白
. StringNumericLiteral ::: - StrUnsignedDecimalLiteral的MV是负的
  StrUnsignedDecimalLiteral的MV。（注意如果StrUnsignedDecimalLiteral的MV是0，这个
  MV的负值仍然是0。下方的修圆规则处理这个无符号数值0到合适的+0_F或者-0_F
  浮点数）
. StrUnsignedDecimalLiteral ::: Infinity的MV是10^10000（足够大以致于修圆到+∞_F）
. StrUnsignedDecimalLiteral ::: DecimalDigits . DecimalDigits的MV是第一个
  DecimalDigits的MV加以(第二DecimalDigits的MV与10^-n的积)的和，其中n是第二个
  DecimalDigits的编码点数量
. StrUnsignedDecimalLiteral ::: DecimalDigits . ExponentPart的MV是DecimalDigits的MV
  与10^e的积，其中e是ExponentPart的MV。
. StrUnsignedDecimalLiteral ::: DecimalDigits . DecimalDigits ExponentPart的MV是(第一
  个DecimalDigits的MV加以(第二个DecimalDigits的MV与10^-n的积)的和）与10^e的积，
  其中n是第二个DecimalDigits的编码点数量，而e是ExponentPart的MV。
. StrUnsignedDecimalLiteral ::: . DecimalDigits的MV是DecimalDigits的MV与10^-n的积，
  其中n是DecimalDigits的编码点数量
. StrUnsignedDecimalLiteral ::: . DecimalDigits ExponentPart的MV是DecimalDigits的MV
  与10^(e-n)的积，其中n是DecimalDigits的编码点数量，而e是ExponentPart的MV。
. StrUnsignedDecimalLiteral ::: DecimalDigits ExponentPart的MV是DecimalDigits的MV与
  10^e的积，其中e是ExponentPart的MV。

一旦字符串字面量数字决定了确定的MV，随后被修圆到Number类型的值。如果MV是
0，会被修圆到+0_F，除非字符串字面量的第一个非空白符是"-"，这时会被修圆到
-0_F。其他情况，必须修圆到MV对应的Number值（按照在6.1.6.1中定义的含义），除非
是字面里包含StrUnsignedDecimalLiteral，而且包含了超过20个有意义数字的特殊情
况。在特殊情况里Number值可能是用0替换掉第20位之后的有意义数字的MV的Number
值，或者用0替换掉第20位之后的有意义数字后，再在第20位+1的MV的Number值。

有意义数字是指不在ExponentPart里的，且
. 不是"0"，或者
. 左侧有非0数字，而且右侧有不在ExponentPart里的非0数字的"0"
*** ToIntegerOrInfinity(argument)
抽象操作ToIntegerOrInfinity接受参数argument。它将argument转换成整数、+∞或
-∞。被调用时执行下列步骤：
1. 让number是?ToNumber(argument)
2. 如果number是NaN、+0_F或者-0_F，返回0
3. 如果number是+∞_F，返回+∞
4. 如果number是-∞_F，返回-∞
5. 让integer是floor(abs(R(number)))
6. 如果number<+0_F，设置integer是-integer
7. 返回integer
*** ToInt32(argument)
抽象操作ToInt32接受参数argument。将argument转换为2^32的整数Number，范围在
[F(-2^31),F(2^31-1)]内。被调用时执行下列步骤：
1. 让number是?ToNumber(argument)
2. 如果number是NaN、+0_F、-0_F、+∞_F、-∞_F，返回+0_F
3. 让int是与number相同符号的数学值，规模是floor(abs(R(number)))
4. 让int32bit是int按2^32取模
5. 如果int32bit>=2^31,返回F(int32bit - 2^32)否则返回F(int32bit)
**** 注意 上述定义ToInt32
           . ToInt32抽象操作是向前强效的。如果被提供了一个它产生的结果，
             这个第二次使用需要值不变。
           . ToInt32(ToUnit32(x))与ToInt32(x)是相同值。（这是为了保留后面将+∞_F
             和-∞_F映射到+0_F的性质）
           . ToInt32映射-0_F到+0_F
*** ToUint32(argument)
抽象操作ToUint32接受参数argument。将argument转换为2^32的整数Number，范围在
[+0_F,F(2^32-1)]内。被调用时执行下列步骤：
1. 让number是?ToNumber(argument)
2. 如果number是NaN、+0_F、-0_F、+∞_F、-∞_F，返回+0_F
3. 让int是与number相同符号的数学值，规模是floor(abs(R(number)))
4. 让int32bit是int按2^32取模
5. 返回F(int32bit)
**** 注意 上述定义ToUint32
           . 只有第5步上ToUint32与ToInt32有差异
           . ToUint32抽象操作是向前强效的。如果被提供了一个它产生的结果，这
             个第二次使用需要值不变。
           . ToUnit32(ToInt32(x))与ToUint32(x)是相同值。（这是为了保留后面将+∞_F
             和-∞_F映射到+0_F的性质）
           . ToUint32映射-0_F到+0_F
*** ToInt16(argument)
抽象操作ToInt16接受参数argument。将argument转换为2^16的整数Number，范围在
[F(-2^15), F(2^15-1)]内。被调用时执行下列步骤：
1. 让number是?ToNumber(argument)
2. 如果number是NaN、+0_F、-0_F、+∞_F、-∞_F，返回+0_F
3. 让int是与number相同符号的数学值，规模是floor(abs(R(number)))
4. 让int16bit是int按2^16取模
5. 如果int16bit>=2^15,返回F(int16bi5 - 2^16)否则返回F(int16bit)
*** ToUint16(argument)
抽象操作ToUint16接受参数argument。将argument转换为2^16的整数Number，范围在
[F(+0_F), F(2^16-1)]内。被调用时执行下列步骤：
1. 让number是?ToNumber(argument)
2. 如果number是NaN、+0_F、-0_F、+∞_F、-∞_F，返回+0_F
3. 让int是与number相同符号的数学值，规模是floor(abs(R(number)))
4. 让int16bit是int按2^16取模
5. 返回F(int16bit)
**** 注意 上述定义ToUint16
           . ToUint16与ToUint32的唯一差别是在第4步，用2^16替代了2^32。
           . ToUint16映射-0_F到+0_F
*** ToInt8(argument)
抽象操作ToInt8接受参数argument。将argument转换为2^8的整数Number，范围在
[-128_F, 127_F]内。被调用时执行下列步骤：
1. 让number是?ToNumber(argument)
2. 如果number是NaN、+0_F、-0_F、+∞_F、-∞_F，返回+0_F
3. 让int是与number相同符号的数学值，规模是floor(abs(R(number)))
4. 让int8bit是int按2^8取模
5. 如果int8bit>=2^7,返回F(int8bit - 2^8)否则返回F(int8bit)
*** ToUint8(argument)
抽象操作ToUint8接受参数argument。将argument转换为2^8的整数Number，范围在
[+0_F, 255_F]内。被调用时执行下列步骤：
1. 让number是?ToNumber(argument)
2. 如果number是NaN、+0_F、-0_F、+∞_F、-∞_F，返回+0_F
3. 让int是与number相同符号的数学值，规模是floor(abs(R(number)))
4. 让int8bit是int按2^8取模
5. 返回F(int8bit)
*** ToUint8Clamp(argument)
抽象操作ToUint8Clamp接受参数argument。将argument转化为2^8的整数Number，范围在
[+0_F, 255_F]内。被调用时执行下列步骤：
1. 让number是?ToNumber(argument)
2. 如果number是NaN，返回+0_F
3. 如果R(number)<=0，返回+0_F
4. 如果R(number)>= 255，返回255_F
5. 让f是floor(R(number))
6. 如果f+0.5 < R(number)，返回F(f+1)
7. 如果R(number) < f + 0.5，返回F(f)
8. 如果f是odd，返回F(f+1)
9. 返回F(f)
**** 注意 不像其他ECMAScript的整数转换，ToUint8Clamp的修圆方式不同于截断整数
           也不是转换+∞_F到+0_F。ToUint8Clamp采用中间取偶的方式进行修圆。这也
           不同于Math.round的四舍五入方式。
*** ToBigInt(argument)
抽象操作ToBigInt接受参数argument。将argument转换为BigInt值，或者投掷异常如果
需要隐式的丛Number转换的话。被调用时执行下列步骤：
1. 让prim是?ToPrimitive(argument, number)
2. 按照表13，根据prim值进行返回。
| 参数类型  | 结果                                                                        |
| Undefined | 投掷TypeError异常                                                           |
| Null      | 投掷TypeError异常                                                           |
| Bollean   | 如果prim是true，则返回1n。如果prim是false，则返回0n                         |
| BigInt    | 返回prim                                                                    |
| Number    | 投掷TypeError异常                                                           |
| String    | 1. 让n是!StringToBigInt(prim)；2. 如果n是NaN，投掷SyntaxError异常；3. 返回n |
| Symbol    | 投掷TypeError异常                                                           |
*** StringToBigInt(argument)
应用7.1.4.1的算法，并进行随后的调整
. 替换StrUnsignedDecimalLiteral码型的DecimalDigits中禁止Infinity、小数点和指数部
. 如果NaN，返回NaN。否则返回准确表示MV的BigInt值，不需要修圆。
*** ToBigInt64(argument)
抽象操作ToBigInt64接受参数argument。将argument转换为2^64的BigInt值，范围在
[Z(-2^63),Z(2^63-1)]内。被调用是执行下列步骤：
1. 让n是?ToBigInt(argument)
2. 让int64bit是R(n)按2^64取模
3. 如果int64bit>=2^63，返回Z(int64bit - 2^64)；否则返回Z(int64bit)
*** ToBigUint64(argument)
抽象操作ToBigUint64接受参数argument。将argument转换为2^64的BigInt值，范围在
[0_Z, Z(2^64-1)]内。被调用时执行下列步骤：
1. 让n是?ToBigInt(argument)
2. 让int64bit是R(n)按2^64取模
3. 返回Z(int64bit)
*** ToString(argument)
抽象操作ToString接受参数argument。将argument按照表14转根据其类型转换为String
值。
| 参数类型  | 结果                                                                                       |
| Undefined | 返回"undefined"                                                                            |
| Null      | 返回"null"                                                                                 |
| Boolean   | 如果argument是true，返回"true"。如果argument是false，返回"false"                           |
| Number    | 返回!Number::toString(argument)                                                            |
| String    | 返回argument                                                                               |
| Symbol    | 投掷TypeError异常                                                                          |
| BigInt    | 返回!BigInt::toString(argument)                                                            |
| Object    | 应用随后的步骤：1. 让primValue是?ToPrimitive(argument, string) 2. 返回?ToString(primValue) |
*** ToObject(argument)
抽象操作ToObject接受参数argument。将argument按照表15根据其类型转换为Object
值。
| 参数类型  | 结果                                                                                      |
| Undefined | 投掷TypeError异常                                                                         |
| Null      | 投掷TypeError异常                                                                         |
| Boolean   | 返回一个新的Boolean对象，其内部占位\[\[BooleanData]]是argument。参看20.3Boolean对象的描述 |
| Number    | 返回一个新的Number对象，其内部占位\[\[NumberData]]是argument。参看21.1Number对象的描述    |
| String    | 返回一个新的String对象，其内部占位\[\[StringData]]是argument。参看22.1String对象的描述    |
| Symbol    | 返回一个新的Symbol对象，其内部占位\[\[SymbolData]]是argument。参看20.4Symbol对象的描述    |
| BigInt    | 返回一个新的BigInt对象，其内部占位\[\[BigIntData]]是argument。参看21.2Bigint对象的描述    |
| Object    | 返回argument                                                                              |
*** ToPropertyKey(argument)
抽象操作ToPropertyKey接受参数argument。将argument转换为能作为性质键的值。被调
用时执行下列步骤：
1. 让key是?ToPrimitive(argument,string)
2. 如果Type(key)是Symbol，那么
    a. 返回key
3. 返回!ToString(key)
*** ToLength(argument)
抽象操作ToLenght接受参数argument。将argument转换为适合作为像数组的对象的长度
的整数Number。被调用时执行下列步骤：
1. 让len是?ToIntegerOrInfinity(argument)
2. 如果len <= 0，返回+0_F
3. 返回F(min(len, 2^53-1))
*** CanonicalNumericIndexString(argument)
抽象操作CanonicalNumericIndexString接受参数argument。将argument转换为Number值，
如果是可以Number通过ToString产生的String值或者String"-0"。否则返回undefined。当
被调用时执行下列步骤：
1. Assert：Type(argument)是String
2. 如果argument是"-0"，返回-0_F
3. 让n是!ToNumber(argument)
4. 如果SameValue(!ToString(n), argument)是false，返回undefined
5. 返回n

经典数字字符串是指不会让CanonicalNumericIndexString抽象操作返回undefined的
String值。
*** ToIndex(value)
抽象操作ToIndex接受参数value。将参数value转换为非负整数，如果value是有效的
整数索引值。被调用时执行下列步骤：
1. 如果value是undefined，那么
    a. 返回0
2. 否则
    a. 让integerIndex是F(?ToIntegerOrInfinity(value))
    b. 如果integerIndex < +0_F，投掷RangeError异常
    c. 让index是!ToLength(integerIndex)
    d. 如果!SameValue(integerIndex, index)是false，投掷RangeError异常
    e. 返回R(index)
** 检测和匹配操作
*** RequireObjectCoercible(argument)（coerce强制）
抽象操作RequireObjectCoercible接受参数argument。如果argument不能使用ToObject转换
成Object，会投掷异常。在表16中定义。
| 参数类型  | 结果              |
| Undefined | 投掷TypeError异常 |
| Null      | 投掷TypeError异常 |
| Bollean   | 返回argument      |
| Number    | 返回argument      |
| String    | 返回argument      |
| Symbol    | 返回argument      |
| BigInt    | 返回argument      |
| Oject     | 返回argument      |
*** IsArray(argument)
抽象操作IsArray接受参数argument。被调用时执行下列步骤：
1. 如果Type(Argument)不是Object，返回false
2. 如果argument是Array exotic对象，返回true
3. 如果arugment是Proxy exotic对象，那么
    a. 如果arugment.\[\[ProxyHandler]]是空，投掷TypeError异常
    b. 让target是argument.\[\[ProxyTarget]]
    c. 返回?IsArray(target)
4. 返回false
*** IsCallable(argument)
抽象操作IsCallable接受参数argument（ECMAScript语言值）。明确argument是一个带有
\[\[Call]]内置方法的可调用函数。被调用时执行下列步骤：
1. 如果Type(argument)不是Object，返回false
2. 如果argument有\[\[Call]]内置方法，返回true
3. 返回false
*** IsConstrutor(argument)
抽象操作IsConstructor接受参数argument（ECMAScript语言值）。明确argument是一个
带有\[\[Constructor]]内置方法的函数对象。被调用时执行下列步骤：
1. 如果Type(argument)不是Object，返回false
2. 如果argument有\[\[Constructor]]内置方法，返回true
3. 返回false
*** IsExtensible(O)
抽象操作IsExtensible接受参数O（一个Object）,返回Boolean值。明确额外的性质能
否被添加到O上。被调用时执行下列步骤：
1. Assert: Type(O)是Object
2. 返回?O.\[\[IsExtensible]]()
*** IsIntegralNumber(argument)
抽象操作IsIntegralNumber接受参数argument。明确argument是否以一个有限的整数
Number值。被调用时执行下列步骤：
1. 如果Type(argument)不是Number，返回false
2. 如果argument是NaN、+∞_F、-∞_F返回false
3. 如果floor(abs(R(argument))) != abs(R(argument))返回false
4. 返回true
*** IsPropertyKey(argument)
抽象操作IsPropertyKey接受参数argument（ECMAScript语言值）。明确argument是否可
以作为性质键。被调用时执行下列步骤：
1. 如果Type(argument)是String，返回true
2. 如果Type(argument)是Symbol，返回true
3. 返回false
*** IsRegExp(argument)
抽象操作IsRegExp接受参数argument。被调用时执行下列步骤：
1. 如果Type(argument)不是Object，返回false
2. 让matcher是?Get(argument, @@match)
3. 如果matcher不是undefined，返回!ToBoolean(matcher)
4. 如果argument有\[\[RegExpMatcher]]内部占位，返回true
5. 返回false
*** IsStringPrefix(p,q) 
抽象操作IsStringPrefix接受参数p（String）和q（String）。明确p是否是q的前缀。
被调用时执行下列步骤：
1. Assert：Type(p)是String
2. Assert：Type(q)是String
3. 如果q是p与其他String r拼接成的String，返回true，否则返回false。
**** 注意 任何String都是自身的前缀，因为r可以是空String
*** SameValue(x,y)
抽象操作SameValue接受参数x（ECMAScript语言值）和y（ECMAScript语言值），并返
回Boolean值。被调用时执行下列步骤：
1. 如果Type(x)与Type(y)不同，返回false
2. 如果Type(x)是Number或者BigInt，那么
    a. 返回!Type(x)::sameValue(x, y)
3. 返回!SameValueNonNumeric(x,y)
**** 注意 这个算法与严格相等算法不同，区别在如何处理零与NaN
*** SameValueZero(x,y)
抽象操作SameValueZero接受参数x（ECMAScript语言值）和y（ECMAScript语言值），
并返回Boolean值。被调用时执行下列步骤：
1. 如果Type(x)与Type(y)不同，返回false
2. 如果Type(x)是Number或者BigInt，那么
    a. 返回!Type::sameValueZero(x,y)
3. 返回!SameValueNonNumeric(x,y)
**** SameValueZero与SameValue的差异在于处理+0_F和-0_F上
*** SameValueNonNumeric(x,y)
抽象操作SameValueNonNumeric接受参数x（ECMAScript语言值）和y（ECMAScript语言值）
，并返回Boolean值。被调用时返回下列步骤：
1. Assert：Type(x)不是Number或BigInt
2. Assert：Type(x)与Type(y)相同
3. 如果Type(x)是Undefined，返回true
4. 如果Type(x)是Null，返回true
5. 如果Type(x)是String，那么
    a. 如果x和y有相同的编码单元（相同长度，相同索引的编码单元相同），返回
       true，否则返回false
6. 如果Type(x)是Boolean，那么
    a. 如果x和y都是true或者都是false，返回true；否则返回false
7. 如果Type(x)是Symbol，那么
    a. 如果x和y都是相同的Symbol值，返回true；否则返回false
8. 如果x和y是相同的Object，返回true；否则返回false
*** 抽象关系比较 <
值x、y的比较式x < y产生true、false或者undefined（表明至少有个NaN参与了比
较）。除了x、y，这个算法还接受一个Boolean标记LeftFirst作为参数。这个标记用于
控制在操作有潜在副作用的x、y时的评估顺序。这是必要的，因为在ECMAScript明确
规定了从左到右评估表达式。LeftFirst的默认时值true，表明在表达式中的x代表的
表达式发生在y代表的表达式左侧（之前）。如果LeftFirst是false，那就是相反顺
序，y表达式的评估在x之前。比较按照下列步骤执行：
1. 如果LeftFirst是true，那么
    a. 让px是?ToPrimitive(x, number)
    b. 让py是?ToPrimitive(y, number)
2. 否则
    a. 注意: 评估顺序需要反过来，以保证比较按照从左到右的顺序评估
    b. 让py是?ToPrimitive(y, number)
    c. 让px是?ToPrimitive(x, number)
3. 如果Type(px)是String， Type(py)也是String，那么
    a. 如果IsStringPrefix(py, px)是true，返回false
    b. 如果IsStringPrefix(px, py)是true，返回true
    c. 让k是px中与py中对应位置编单元不同的最小非负整数。（必然有这样的k存
       在，即使都不是对方的前缀）
    d. 让m是px在k位的编码单元的数字的整数
    e. 让n是py在k位的编码单元的数字的整数
    f. 如果m<n，返回true。否则返回false
4. 否则
    a. 如果Type(px)是BigInt且Type(py)是String，那么
        i. 让ny是!StringToBigInt(py)
       ii. 如果ny是NaN，返回undefined
      iii. 返回BigInt::lessThan(px,ny)
    b. 如果Type(px)是String且Type(py)是BigInt，那么
        i. 让nx是!StringBoBigInt(px)
       ii. 如果nx是NaN，返回undefined
      iii. 返回BigInt::(nx,py)
    c. 注意因为px和py是基础值，评估顺序不重要
    d. 让nx是!ToNumeric(px)
    e. 让ny是!ToNumeric(py)
    f. 如果Type(nx)与Type(ny)相同，返回Type(nx)::lessThan(nx, ny)
    g. Assert：Type(nx)是BigInt时Type(ny)是Number，或者Type(nx)是Number时Type(ny)是
       BigInt
    h. 如果nx或者ny是NaN，返回undefined
    i. 如果nx是-∞_F或者ny是+∞_F，返回true
    j. 如果nx是+∞_F或者ny是-∞_F，返回false
    k. 如果R(nx) < R(ny)，返回true，否则返回false
**** 注意1 步骤3与+操作（13.15.3）中的步骤2.c是不同的，这里用逻辑与，而在+操作中用的是逻辑或
**** 注意2 字符串比较使用的是简单的按照编码单元的字典序。没有使用更加复杂的语义化的在Unicode标准
    中根据词或则字符串相等和核对的排序。因此符合最基本相等的String值在Unicode标准中也能相等。
     实际上本算法假设两个String都是标准化的形式。此外对于包含补充字符的字符串，使用编码单元的
     字典序与编码点的字典序不同。
*** 抽象相等比较 \=\=
值x、y的比较式x==y产生true或者false。这个比较式执行时按照下列步骤：
1. 如果Type(x)与Type(y)相同，那么
    a. 返回执行严格相等比较x\=\=\=y的结果
2. 如果x是null，且y是undefined，返回true
3. 如果x是undefined，且y是null，返回true
4. 注意：这一步在B.3.7.2中被替换（
   1.如果Type(x)是Object，且x有\[\[IsHTMLDDA]]内部占位，而y是null或undefined，
     返回true
   2.如果x是null或undefined，同时Type(y)是Object且y有\[\[IsHTMLDDA]]占位，
     返回true
   ）
5. 如果Type(x)是Number而Type(y)是String，返回x==!ToNumber(y)结果
6. 如果Type(x)是String而Type(y)是Number，返回!ToNumer(x)==y结果
7. 如果Type(x)是BigInt而Type(y)是String，那么
    a. 让n是!StringToBigInt(y)
    b. 如果n是NaN，返回false
    c. 返回x==n的结果
8. 如果Type(x)是String而Type(y)是BigInt，返回y==x结果
9. 如果Type(x)是Boolean，返回!ToNumber(x)==y结果
10. 如果Type(y)是Boolean，返回x==!ToNumber(y)结果
11. 如果Type(x)是String、Number、BigInt或者Symbol之一，且Type(y)是Object，
    返回x==?ToPrimitive(y)结果
12. 如果Type(x)是Object，且Type(y)是String、Number、BigInt或者Symbol之一，
    返回?ToPrimitive(x)==y结果
13. 如果Type(x)是BigInt且Type(y)是Number，或饿着Type(x)是Number且Type(y)是BigInt，
    那么
     a. 如果x或y是NaN、-∞_F、+∞_F，返回false
     b. 如果R(x)=R(y)，返回true。否则返回false。
14. 返回false
*** 严格相等比较 \=\=\=
值x、y的比较式x\=\=\=y产生true或者false。比较式执行时执行下列步骤
1. 如果Type(x)与Type(y)不同，返回false
2. 如果Type(x)是Number或者BigInt那么
    a. 返回!Type(x)::equal(x,y)
3. 返回!SameValueNonNumeric(x, y)
**** 注意 本算法在对待0和NaN时，与SameValue算法不同
** Object上的操作
*** MakeBasicObject(internalSlotsList)
抽象操作MakeBasicObject接受参数internalSlotsList。这是所有算法创建ECMAScript
对象的源，无论基本对象或奇异对象。提出了所有对象在创建时需要的通用步骤，
集中了对象的创建过程。被调用时执行下列步骤：
1. Assert：internalSlotsList是内置占位名称的List
2. 让obj是新创建的对象，且每个在internalSlotsList的名字都创建了相应的内部占位
3. 设置obj的必须内置方法是按照10.1规范定义的基本对象对应的默认值
4. Assert：如果调用方没有同时覆盖obj的\[\[GetPrototypeOf]]和\[\[SetPrototypeOf]]
   基础内置方法，那么internalSlotsList含有\[\[Prototype]]
5. Assert：如果调用方没有同时覆盖obj的\[\[SetPrototypeOf]]、\[\[IsExtensible]]
   和\[\[PreventExtensions]]基础内置方法，那么internalSlotsList含有\[\[Extensible]]
6. 如果internalSlotsList含有\[\[Extensible]]，设置obj.\[\[Extensible]]是true。
7. 返回obj
**** 注意 在本规范中，由例如ArrayCreate、BoundFunctionCreated等抽象操作创建的
           奇异对象，首先要调用MakeBasicObject获得一个基本对象，然后覆盖部分
           或者全部的内置方法。为了封装奇异对象的创建，对象基础内置方法在
           这些操作外是不能修改的。
*** Get(O,P)
抽象操作Get接受参数O（对象）和P（性质键）。用于检索对象上指定性质的值。
被调用时执行下列步骤：
1. Assert：Type(O)是Object
2. Assert：IsPropertyKey(P)是true
3. 返回 ?O.\[\[Get]](P,O)
*** GetV(V,P)
抽象操作GetV接受参数V（ECMAScript语言值）和P（性质健）。用于检索ECMAScript
值的指定性质的值。如果V不是对象，会将值封装为合适的对象再在其上执行键
查找。被调用时执行下列步骤：
1. Assert：IsPropertyKey(P)是true
2. 让O是?ToObject(V)
3. 返回?O.\[\[Get]](P,V)
*** Set(O,P,V,Throw)
抽象操作Set接受参数O（Object），P（性质键），V（ECMAScript语言值）和
Throw（Boolean）。用于在object上设置指定性质的值。V是这个性质的新值。被调用时
执行下列步骤：
1. Assert：Type(O)是Object
2. Assert：IsPropertyKey(P)是true
3. Assert：Type(Throw)是Boolean
4. 让success是?O.\[\[Set]](P,V,O)
5. 如果success是false而且Throw是true，投掷TypeError异常
6. 返回success
*** CreateDataProperty(O,P,V)
抽象操作CreateDataProperty接受参数O（Object）、P（性质键）和V（ECMAScript语言
值）。用于在对象上创建一个新的自有性质。被调用时执行下列步骤：
1. Assert：Type(O)是Object
2. Assert：IsPropertyKey(P)是true
3. 让newDesc是PropertyDescriptor { \[\[Value]]:V \[\[Writable]]:true,
   \[\[Enumerable]]:true, \[\[Configurable]]:true }
4. 返回?O.\[\[DefineOwnProperty]](P, newDesc)
**** 注意 本抽象操作创建的性质拥有的属性与ECMAScript语言中赋值语句创建的性质
           的属性相同。通常这个性质不在对象上。如果已经存在且不可设置的，
           或者O是不可扩展的，\[\[DefineOwnProperty]]会返回false
*** CreateMethodProperty(O,P,V)
抽象操作CreateMethodProperty接受参数O（Object）、P（性质键）和V（ECMAScript语言
值）。用于在对象上创建新的自有性质。被调用时执行下列步骤：
1. Assert：Type(O)是Object
2. Assert：IsPropertyKey(P)是true
3. 让newDesc是PropertyDescriptor { \[\[Value:V,\[\[Writable]]:true,
   \[\[Enumerable]]:false, \[\[Configurable]]:true }
4. 返回 ?O.\[\[DefineOwnProperty]](P, newDesc)
**** 注意 本抽象操作创建的性质拥有的属性与使用类声明语法的方法或者内置方法
           的属性相同。通常这个性质不在对象上。如果已经存在且不可设置的，
           或者O是不可扩展的，\[\[DefineOwnProperty]]会返回false
*** CreateDataPropertyOrThrow(O,P,V)
抽象操作CreateDataPropertyOrThrow恶疾首参数O（Object）、P（性质键）和V（
ECMAScript语言值）。在对象上创建新的性质。如果请求的性质修改不能执行，投掷
TypeError异常。被调用时执行下列步骤：
1. Assert：Type(O)是Object
2. Assert：IsPropertyKey(P)是true
3. 让success是?CreateDataProperty(O,P,V)
4. 如果success是false，投掷TypeError异常
5. 返回success
**** 注意 本抽象操作创建的性质拥有的属性与ECMAScript语言中赋值操作创建的性质
           的属性相同。通常这个性质不在对象上。如果已经存在且不可设置，或者
           O是不可扩展的，\[\[DefineOwnProperty]]会返回false，导致本操作投掷
           TypeError异常。
*** DefinePropertyOrThrow(O,P,desc)
抽象操作DefinePropertyOThrow接受参数O（Object）、P（性质键）和desc（
PropertyDescriptor）。被用于以在不能执行修改请求的性质时会投掷TypeError异常的
方式调用对象上\[\[DefineOwnProperty]]内部方法。被调用时执行下列步骤：
1. Assert：Type(O)是Object
2. Assert：IsPropertyKey(P)是true
3. 让success是?O.\[\[DefineOwnProperty]](P,desc)
4. 如果success是false，投掷TypeError异常
5. 返回success
*** DeletePropertyOrThrow(O,P)
抽象操作DeletePropertyOrThrow接受参数O（Object）、P（性质键）。被用于移除对
象上的指定的自有性质。如果性质不可设置，会投掷异常。被调用时执行下列步骤：
1. Assert：Type(O)时Object
2. Assert：IsPropertyKey(P)时true
3. 让success时?O.\[\[Delete]](P)
4. 如果success是false，投掷TypeError异常
5. 返回success
*** GetMethod(V,P)
抽象操作GetMethod接受参数V（ECMAScript语言值）和P（性质键）。被用于当性质的
值被期望是函数时，在ECMAScript语言值上取得指定性质值。被调用时执行下列步骤：
1. Assert：IsPropertyKey(P)是true
2. 让func是?GetV(V,P)
3. 如果func是undefined或null，返回undefined
4. 如果IsCallable(func)是false，投掷TypeError异常
5. 返回func
*** HasProperty(O,P)
抽象操作HasProperty接受参数O（Object）和P（性质键），返回Boolean。用于明确
对象是否有指定性质。性质可以是自有的或者继承的。被调用时执行下列步骤：
1. Assert：Type(O)是Object
2. Assert：IsPropertyKey(P)是true
3. 返回?O.\[\[HasProperty]]
*** HasOwnProperty(O,P)
抽象操作HasOwnProperty接受参数O（Object）和P（性质键），返回Boolean。用于明确
对象是否有指定自有性质。被调用时执行下列步骤：
1. Assert：Type(O)是Object
2. Assert：IsPropertyKey(P)是true
3. 让desc是?O.\[\[GetOwnProperty]](P)
4. 如果des是undefined，返回false
5. 返回true
*** Call(F,V[,argumentsList])
抽象操作Call接受参数F（ECMAScript语言值）、V（ECMAScript语言值）和可选参数
argumentsList（元素是ECMAScript语言值的List）。被用于调用函数对象的\[\[Call]]
内部方法。F是函数对象，V是作为\[\[Call]]的this值的ECMAScript语言值，而
argumentsList是传递给内部方法的相应参数值。如果argumentsList不存在，设置
一个新的空List。被调用时执行下列步骤：
1. 如果argumentsList不存在，设置argumentsList是一个新的空List
2. 如果IsCallable(F)是false，投掷TypeError异常
3. 返回?F.\[\[Call]](V, argumentsList)
*** Construct(F[,argumentsList[,newTarget]])
抽象操作Constructor接受参数F（函数对象）和可选参数arugmentsList和newTarget。
被用于调用函数对象的\[\[Constructor]]内置方法。argumentsList和newTarget是传递给
内部方法的行营参数值。如果argumentsList不存在，设置一个新的空List。如果
newTarget不存在，设置为F。被调用时执行下列步骤：
1. 如果newTarget不存在，设置newTaget为F
2. 如果argumentsList不存在，设置argumentsList是新的空List
3. Assert：IsConstructor(F)是true
4. Assert：IsConstructor(newTarget)是true
5. 返回?F.\[\[Constrcut]](argumentsList, newTarget)
**** 注意 如果newTarget不存在，本操作与new F(...argumentsList)等价
*** SetIntegrityLevel(O,level)
抽象操作SetIntegrityLevel接受参数O和level。用于固定对象的自有性质。被调用时
执行下列步骤：
1. Assert：Type(O)是Object
2. Assert：level是sealed或frozen
3. 让status是?O.\[\[PreventExtensions]]()
4. 如果status是false，返回false
5. 让keys是?O.\[\[OwnPropertyKeys]]()
6. 如果level是sealed，那么
    a. 遍历keys的每个元素key，执行
        i. 执行?DefinePropertyOrThrow(O,k,PropertyDescriptor{\[\[Configurable]]:false})
7. 否则
    a. Assert：level是frozen
    b. 遍历keys的每个元素key，执行
        i. 让currentDesc是?O.\[\[GeOwnProperty]](key)
       ii. 如果currentDec不是undefined，那么
            1. 如果IsAccessorDescriptor(currentDesc)是true，那么
                a. 让desc是PropertyDescriptor{\[\[Configurable]]:false}
            2. 否则
                a. 让desc是PropertyDescriptor{\[\[Configurable]]:false,
                   [\[Writable]]:false}
            3. 执行?DefinePropertyOrThrow(O,k,desc)
8. 返回true
*** TestIntegrityLevel(O,level)
抽象操作TestIntegrityLevel接受参数O和level。用于明确对象的自有性质是否已经固
定。被调用时执行下列步骤：
1. Assert：Type(O)是Object
2. Assert：level是sealed或frozen
3. 让extensible是?IsExtensible(O)
4. 如果extensible是true，返回false
5. 注意：如果对象是extensible，没有性质需要检查
6. 让keys是?O.\[\[OwnPropertyKeys]]()
7. 遍历keys的每个元素key，执行
    a. 让currentDesc是?O.\[\[GetOwnProperty]](key)
    b. 如果currentDesc不是undefined
        i. 如果currentDesc.\[\[Configurable]]是true，返回false
       ii. 如果level是frozen而且IsDataDescriptor(currentDesc)是true,那么
            1. 如果currentDesc.\[\[Writable]]是true，返回false
8. 返回true
*** CreateArrayFromList(elements)
抽象操作CreateArrayFromList接受List参数elements。用于创建元素是elemnts提供的
元素的Array对象。被调用时执行下列步骤
1. Assert：elments是一个List，元素都是ECMAScript语言值
2. 让array是!ArrayCreate(0)
3. 让n是0
4. 遍历elements的每个元素e，执行
    a. 执行!CreateDataPropertyOThrow(array, !ToString(F(n)), e)
    b. 设置n为n+1
5. 返回array
*** LengthOfArrayLike(obj)
抽象操作LengthOfArrayLike接受参数obj。返回貌似数组的对象的length性质（作为
非负整数）。被调用时执行下列步骤：
1. Assert：Type(obj)是Object
2. 返回 R(?ToLength(?Get(obj,"length")))

貌似数组的对象是任何在执行本操作时返回整数而不是意外完结的对象
**** 注意1 通常貌似数组对象还有一些性质的名字是整数，但是不是本定义需要的。
**** 注意2 Array对象和String对象就是貌似数组对象的例子
*** CreateListFromArrayLike(obj[,elementTypes])
抽象操作CreateListFromArrayLike接受参数obj和可选参数elementTypes（有ECMAScript
类型的名称组成的List）。用于创建一个List，其元素是obj的索引键上的性质。
elementTypes包含其名称的ECMAScript语言类型的值可以被List接受。被调用时执行
下列步骤：
1. 如果elementTypes不存在，设置elementTypes是<<Undefined, Null, Boolean, String,
   Symbol, Number, BigInt, Object>>
2. 如果Type(obj)不是Object，投掷TypeError异常
3. 让len是?LengthOfArrayLike(obj)
4. 让list是新的空List
5. 让index是0
6. 当index < len时 重复，
    a. 让indexName时!ToString(F(index))
    b. 让next时?Get(obj, indexName)
    c. 如果Type(next)不是elementTypes的元素，投掷TypeRrror异常
    d. 附加next到list最后一个元素后
    e. 甚至index为index + 1
7. 返回list
*** Invoke(V,P[,argumentsList])
抽象操作Invoke接受参数V（ECMAScript语言值）、P（性质键）和可选参数
argumentList（ECMAScript语言值构成的List）。用于调用ECMAScript语言值上的方法性
质。V作为性质的检索点和调用的this值。argumentsList是传入方法的参数值。如果
argumentsList不存在，一个新的空List作为这个值。被调用时执行下列步骤：
1. Assert：IsPropertyKey(P)是true
2. 如果argumentsList不存在，设置arugmentsList是一个新的空List
3. 让func是?GetV(V,P)
4. 返回?Call(func,V,argumentsList)
*** OrdinaryHasInstance(C,0)
抽象操作OrdinaryHasInstance接受参数C（ECMAScript语言值）和O。实现了检测O继承
自某个继承了C的实例的默认算法。
1. 如果IsCallable(C)是false，返回false
2. 如果C有\[\[BoundTargetFunction]]内置占位那么
    a. 让BC是C.\[\[BoundTargetFunction]]
    b. 返回?InstanceOfOperator(O, BC)
3. 如果Type(O)不是Object，返回false
4. 让P是?Get(C,"prototype")
5. 如果Type(P)不是Object，投掷TypeError异常
6. 重复
    a. 设置O是?O.\[\[GetPrototypeOf]]()
    b. 如果O是null，返回false
    c. 如果SameValue(P,O)是true，返回true
*** SpeciesConstructor(O, defaultConstructor)
抽象操作SpeciesConstructor接受参数O（Object值）和defaultConstrucor（构造范）。
用于在用O派生新的对象时检索需要的构造范。在O中找不到@@species性质指定的构造
范时使用defaultConstructor构造范。被调用时执行下列步骤：
1. Assert：Type(O)时Object
2. 让C是?Get(O,"construcotr")
3. 如果C是undefined，返回defaultConstructor
4. 如果Type(C)不是Object，投掷TypeError异常
5. 让S是?Get(C,@@species)
6. 如果S是undefined或者null，返回defualtConstructor
7. 如果IsConstructor(S)是true，返回S
8. 投掷TypeError异常
*** EnumerableOwnPropertyNames(O, kind)
抽象操EnumerableOwnPropertyNames接受参数O（Object值）和kind（key,value或者
key+value).被调用时执行下列步骤
1. Assert：Type(O)是Object
2. 让ownKesy是?O.\[\[OwnPropertyKeys]]()
3. 让properties是新的空List
4. 遍历ownKeys的每个元素key，执行
    a. 如果Type(key)是String，那么
        i. 让desc是?O.\[\[GetOwnProperty]](key)
       ii. 如果desc不是undefined而且desc.\[\[Enumerable]]是true，那么
            1. 如果kind是key，追加key到properties
            2. 否则
                a. 让value是?Get(O,key)
                b. 如果kind是value，追加value到properties
                c. 否则
                    i. Assert：kind是key+value
                   ii. 让entry是!CreateArrayFromList(<<key,value>>)
                  iii. 追加entry到properties
5. 返回properties
*** GetFunctionRealm(obj)
抽象操作GetFunctionReale接受参数obj.被调用时执行下列步骤
1. Assert：!IsCallable(obj)是true
2. 如果obj有\[\[Realm]]内置占位
    a. 返回obj.\[\[Realm]]
3. 如果obj是绑定的函数对象，那么
    a. 让target是obj.\[\[BoundTargetFunction]]
    b. 返回?GetFunctionRealm(target)
4. 如果obj是Proxy对象，那么
    a. 如果obj.\[\[ProxyHandler]]是null，投掷TypeError异常
    b. 让proxyTarget是obj.\[\[ProxyTarget]]
    c. 然会?GetFunctionRealm(proxyTarget)
5. 返回当前的Realm记录
**** 注意 步骤5仅在对象是一个非标准的没有\[\[Realm]]内置占位的函数对象才会
          触发。
*** CopyDataProperties(target, source, excludedItems)
抽象操作CopyDataProperties接受参数target、source、excludedItems。被调用时执行
下列步骤：
1. Assert：Type(target)是Object
2. Assert：excludedItems是性质键组成的List
3. 如果source是undefined或null，返回target
4. 让from是!ToObject(source)
5. 让keys是?from.\[\[OwnPropertyKeys]]()
6. 遍历keys的每个元素nextKey，执行
    a. 让excluded是false
    b. 遍历excludedItems的每个元素e，执行
        i. 如果SameValue(e, nextKey)和true，那么
            1. 设置excluded是true
    c. 如果excluded是false，那么
        i. 让desc是?from\.\[GetOwnProperty]](nextKey)
       ii. 如果desc不是undefined且desc.\[\[Enumerable]]是true，那么
            1. 让propValue是?Get(from, nextKey)
            2. 执行!CreateDataPropertyOrThrow(target, nextKey, propValue)
7. 返回target
**** 注意 这里的target永远是新创建的对象，且是在投掷异常时无法直接访问的。
** Iterator Objects上的操作
参看通用遍历接口（27.1）
*** GetIterator(obj[,hint[,method]])
抽象操作GetIterator接受参数obj和可选参数hint、method。被调用时执行下列步骤：
1. 如果hint不存在，设置hint是sync
2. Assert: hint是sync或者async
3. 如果method不存在，那么
    a. 如果hint是async，那么
        i. 设置method是?GetMethod(obj, @@asyncIterator)
       ii. 如果method是undefined，那么
            1. 让syncMethod是?GetMethod(obj, @@iterator)
            2. 让syncIteratorRecord是?GetIterator(obj, sync, syncMethod)
            3. 返回!CreateAsyncFromSyncIterator(syncIteratorRecord)
    b. 否则，设置method是?GetMethod(obj, @@iterator)
4. 让iterator是?Call(method, obj)
5. 如果Type(iterator)不是Object，投掷TypeError异常
6. 让nextMethod是?GetV(iterator, "next")
7. 让iteratorRecord是Record {\[\[Iterator]]:iterator, \[\[NextMethod]]:nextMethod,
   \[\[Done]]:false }
8. 返回itratorRecord
*** IteratorNext(iteratorRecord[,value])
抽象操作IteratorNext接受参数iteratorRecord和可选参数value。被调用时执行下列
步骤：
1. 如果value不存在，那么
    a. 让result是?Call(iteratorRecord.\[\[NextMethod]], iteratorRecord.\[\[Iterator]])
2. 否则
    a. 让result是?Call(iteratorRecord.\[\[NextMethod]], iteratorRecord.\[\[Iterator]],
       <<value>>)
3. 如果Type(result)不是Object，投掷TypeError异常
4. 返回result
*** IteratorComplete(iterResult)
抽象操作IteratorComplete接受参数iterResult。被调用时执行下列步骤：
1. Assert：Type(iterResult)是Object
2. 返回!ToBoolean(?Get(iterResult,"done"))
*** IteratorValue(iterResult)
抽象操作IteratorValue接受参数iterResult。被调用时执行下列步骤
1. Assert：Type(iterResult)是Object
2. 返回?Get(iterResult,"value")
*** IteratorStep(iteratorRecord)
抽象操作IteratorStep接受参数iteratorRecord。通过iteratorRecord.\[\[NextMethod]]
请求iteratorRecord.\[\[Iterator]]的下一个值，如果iterator已经结束了，返回false，
否则返回IteratorResult对象。被调用时执行下列步骤：
1. 让result是?IteratorNext(iteratorRecord)
2. 让done是?IteratorComplete(result)
3. 如果done是true，返回false
4. 返回result
*** IteratorClose(iteratorRecord, completion)
抽象操作IteratorClose接受参数iteratorRecord和completion。被用于通知遍历器在到
达完结状态时照常执行任何动作。被调用时执行下列步骤：
1. Assert：Type(iteratorRecord.\[\[Iterator]])是Object
2. Assert：completion是CompletionRecord
3. 让iterator是iteratorRecord.\[\[Iterator]]
4. 让innerResult是GetMethod(iterator, "return")
5. 如果innerResult.\[\[Type]]是nromal，那么
    a. 让return是innerResult.\[\[Value]]
    b. 如果return是undefined，返回Completion(completion)
    c. 设置innerResult是Call(return, iterator)
6. 如果completion.\[\[Type]]是throw，返回Completion(completion)
7. 如果innerResult.\[\[Type]]是throw，返回Completion(innerResult)
8. 如果Type(innerResult.\[\[Value]])不是Object，投掷TypeError异常
9. 返回Completion(completion)
*** AsyncIteratorClose(iteratorRecord, completion)
抽象操作AsyncIteratorClose接受参数iteratorRecord和completion。被用于通知遍历
器在到达完结时照常执行任何动作。被调用时执行下列步骤：
1. Assert：Type(iteratorRecord.\[\[Iterator]])是Object
2. Assert：completion是CompletionRecord值
3. 让iterator是iteratorRecord.\[\[Iterator]]
4. 让innerResult是GetMethod(iterator,"return")
5. 如果innerResult.\[\[Type]]是normal，那么
    a. 让return是innerResult.\[\[Value]]
    b. 如果return是undefined，返回Completion(completion)
    c. 设置innerResult是Call(return, iterator)
    d. 如果innerResult.\[\[Type]]是normal，设置innerResult是
       Await(innerResult.\[\[Value]])
6. 如果completion.\[\[Type]]是throw，返回Completion(completion)
7. 如果innerResult.\[\[Type]]是throw，返回Completion(completion)
8. 如果Type(innerResult.\[\[Value]])不是Object，投掷TypeError异常
9. 返回Compeltion(completion)
*** CreateIterResultObject(value, done)
抽象操作CreateIteResultObject接受参数value和done。创建支持IteratorResult接口的
对象。被调用时执行下列步骤：
1. Assert：Type(donw)是Boolean
2. 让obj是!OrdinaryObjectCreate(%Object.prototype%)
3. 执行!CreateDataPropertyOrThrow(obj, "value", value)
4. 执行!CreateDataPropertyOrThrow(obj,"done",done)
5. 返回obj
*** CreateListIteratorRecord(list)
抽象操作CrateListIteratorRecord接受参数list。创建Iterator(27.1.1.2)对象记录，
其next方法返回list上连续的元素。被调用时执行下列步骤：
1. 让closure是新的没有因素的AbstrctClosure，捕获list，被调用时执行下列步骤：
    a. 遍历list的每个元素E，运行
        i. 执行?Yield(E)
    b. 返回undefined
2. 让iterator是!CreateIteratorFromClosure(closure, empty, %IteratorPrototype%)
3. 返回Record{ \[\[Iterator]]:iterator,
   \[\[NextMethod]]:%GeneratorFunction.prototype.prototype.next%, \[\[Done]]:false }
**** 注意 这里的list不能被ECMAScript代码直接访问到
*** IterableToList(items[,method])
抽象操作IterableToList接受参数items和可选参数method。被调用时执行下列步骤：
1. 如果method存在，那么
    a. 让iteratorRecord是?GetIterator(items, sync, method)
2. 否则
    a. 让iteratorRecord是?GetIterator(items, sync)
3. 让values是一个新的空List
4. 让next是true
5. 当next不是false时，重复运行
    a. 设置next是?IteratorStep(iteratorRecord)
    b. 如果next不是false，那么
        i. 让nextValue是?IteratorValue(next)
       ii. 附加nextValue到values（List）的末端
6. 返回value
* Syntax-Direted Operations 面向句法的操作
除了本节定义的之外，特定的面向句法的操作的定义贯穿本规范。
** Scope Analysis 范围分析（我更倾向于将scope翻译为闭）
*** 静态语义：BoundNames
**** 注意 "*default*"在被规范中被用作人为的名称以表示使用export声明定义的
           可提升的匿名函数。
BindingIdentifier : Identifier
1. 返回一个只有Identifier的String值作元素的List

BindingIdentifier : yield
1. 返回一个只有"yeild"元素的List

BindingIdentifier : await
1. 返回一个只有"await"元素的List

LexicalDeclaration : LetOrConst BindingList ;
1. 返回BindingList的BoundNames

BindingList : BindingList , LexicalBinding
1. 让names是BingdingList的BoundNames
2. 将LexicalBinding的BoundNames的元素附加到names中。
3. 返回names

LexicalBinding : BindingIdentifier Initializer_opt
1. 返回BindingIdentifier的BoundNames

LexicalBinding : BindingPattern Initializer
1. 返回Bindingattern的BoundNames

VariableDeclarationList : VariableDeclarationList , VariableDeclaration
1. 让names是VariableDeclarationList的BoundNames
2. 将VariableDeclaration的BoundNames的元素附加到names中
3. 返回names

VariableDeclaration : BindingIdentifier Initializer_opt
1. 返回BindingIdentifier的BoundNames

VariableDeclaration : BindingPattern Initializer
1. 返回BindingPattern的BoundNames

ObjectBindingPattern : { }
1. 返回新的空List

ObjectBindingPattern : { BindingPropertyList , BindingRestProperty }
1. 让names是BindingPropertyList的BoundNames
2. 将BindingRestProperty的BoundNames的元素附加到names中
3. 返回names

ArrayBindingPattern : [ Elision_opt ]
1. 返回新的空List

ArrayBindingPattern : [ Elision_opt BindingRestElement ]
1. 返回BindingRestElement的BoundNames

ArrayBindingPattern : [ BindingElementList, Elision_opt ]
1. 返回BindingElementList的BoundNames

ArrayBindingPattern : [ BindingElementList , Elision_opt BindingRestElement ]
1. 让names是BindingElementList的BoundNames
2. 将BindingRestElement的BoundNames的元素附加到names中
3. 返回names

BindingPropertyList : BindingPropertyList , BindingProperty
1. 让names是BindingPropertyList的BoundNames
2. 将BindingProperty的BoundNames的元素附加到names中
3. 返回names

BindingElementList : BindingElementList , BindingElisionElement
1. 让names是BindingElementList的BoundNames
2. 将BindingElisionElement的BoundNames的元素附加到names中
3. 返回names

BindingElisionElement : Elision_opt BindingElement
1. 返回BindingElement的BoundNames

BindingProperty : PropertyName : BindingElement
1. 返回BindingElement的BoundNames

SingleNameBinding : BindingIdentifier Initializer_opt
1. 返回BindingIdentifier的BoundNames

BindingElement : BindingPattern Initializer_opt
1. 返回BindingPattern的BoundNames

ForDeclaration : LetOrConst ForBinding
1. 返回ForBinding的BoundNames

FunctionDeclaration : function BindingIdentifier ( FormalParameters ) { FunctionBody }
1. 返回BindingIdentifier的BoundNames

FunctionDeclaration : function （FormalParameters ) { FunctionBody }
1. 返回<<"*default*">>

FormalParameters : [empty]
1. 返回新的空List

FormalParameters : FormalParameterList , FunctionRestParameter
1. 让names是FormalParameterList的BoundNames
2. 将FunctionRestParameter的BoundNames的元素附加到names中
3. 返回names

FormalParameterList : FormalParameterList , FormalParameter
1. 让names是FormalParameterList的BoundNames
2. 将FormalParameter的BoundNames的元素附加到names中
3. 返回names

ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList
1. 让formals是CoverParenthesizedExpressionAndArraowParameterList的
   CoveredFormalsList
2. 返回formals的BoundNames

GeneratorDeclaration : function * BindingIdentifier ( FormalParameters ) { GeneratorBody }
1. 返回BindingIdentifier的BoundNames

GeneratorDeclaration : function * ( FormalParameters ) { GeneratorBody }
1. 返回<<"*default*">>
AsyncGeneratorDeclaration : async function * BindingIdentifier ( FormalParameters ) { AsyncGeneratorBody }
1. 返回BindingIdentier的BoundNames

AsyncGeneratorDeclaration : async function * ( FormalParameters ) { AsyncGeneratorBody }
1. 返回<<"*default*">>
ClassDeclaration : class BindingIdentifier ClassTail
1. 返回BindingIdentifier的BoundNames

ClassDeclaration : class ClassTail
1. 返回<<"*default*">>
AsyncFunctionDeclaration : async function BindingIdentifier ( FormalParameters ) { AsyncFunctionBody }
1. 返回BindingIdentifier的BoundNames

AsyncFunctionDeclaration : async function (FormalParameters ) { AsyncFunctionBody }
1. 返回<<"*default*">>
CoverCallExpressionAndAsyncArrowHead : MemberExpression Arguments
1. 让head是CoverCallExpressionAndAsyncArrowHead的CoveredAsyncArraowHead
2. 返回head的BoundNames

ImportDeclaration : import ImportClause FromClause ;
1. 返回ImportClause的BoundNames

ImportDeclaration : import ModuleSpecifier ;
1. 返回新的空List

ImportClause : ImportedDefaultBinding , NameSpaceImport
1. 让names是ImportedDefaultBinding的BoundNames
2. 将NameSpaceImport的BoundNames的元素附加到names中
3. 返回names

ImportClause : ImportedDefaultBinding , NamedImports
1. 让names是ImportedDefaultBinding的BoundNames
2. 将NamedImports的BoundNames的元素附加到names中
3. 返回names

NamedImports : { }
1. 返回新的空List

ImportsList : ImportsList , ImportSpecifier
1. 让names是ImportsList的BoundNames
2. 将IMportSpecifier的BoundNames的元素附加到names中
3. 返回names

ImportSpecifier : IdentifierNames as ImportedBinding
1. 返回ImportedBinding的BoundNames

ExportDeclaration :
    export ExportFromClause FromClause ;
    export NamedExports ;
1. 返回新的空List

ExportDeclaration : export VariableStatement
1. 返回VariableStatement的BoundNames

ExportDeclaration : export Declaration
1. 返回Declaration的BoundNames

ExportDeclaration : export default HostableDeclaration
1. 让declarationNames是HoistableDeclaration的BoundNames
2. 如果declarationNames没有包含"*default*"，将"*default*"附加到declarationNames
3. 返回declarationNames

ExportDeclaration : export default ClassDeclaration
1. 让declarationNames是ClassDeclaration的BoundNames
2. 如果declarationNames不含有"*default*"，将"*default*"附加到declarationNames
3. 返回declarationNames

ExportDeclaration : export default AssignmentExpression ;
1. 返回<<"*default*">>
*** 静态语义：DeclarationPart 
HoistableDeclaration : FunctionDeclaration
1. 返回 FunctionDeclaration

HoistableDeclaration : GeneratorDeclaration
1. 返回 GeneratorDeclaration

HoistableDeclaration : AsyncFunctionDeclaration
1. 返回 AsyncFunctionDeclaration

HoistableDeclaration : AsyncGeneratorDeclaration
1. 返回 AsyncGeneratorDeclaration

Declaration : ClassDeclaration
1. 返回 ClassDeclaration

Declaration : LexicalDeclaration
1. 返回 LexicalDeclaration
*** 静态语义：IsConstantDeclaration
LexicalDeclaration : LetOrConst BindingList ;
1. 返回LetOrConst的IsConstantDeclaration

LetOrConst : let
1. 返回false

LetOrConst : const
1. 返回 true

FunctionDeclaration :
    function BindingIdentifier ( FormalParameters ) { FunctionBody }
    function ( FormalParameters ) { FunctionBody }
GeneratorDeclaration :
    function * BidningIdentifer ( FormalParameters ) { GeneratorBody }
   function * ( FormalParameters ) { GeneratorBody }
AsyncGeneratorDeclaration : 
    async function * BindingIdentifier ( FormalParameters ) { AsyncGeneratorBody }
   async function * ( FormalParameters ) { AsyncGeneratorBody }
AsyncFunctionDeclaration :
    async function BindingIdentifier ( FormalParameters ) { AsyncFunctionBody }
    async function ( FormalParameters ) { AsyncFunctionBody }
1. 返回false

ClassDeclaration :
    class BindingIdentifier ClassTail
    class ClassTail
1. 返回false

ExportDeclaration :
    export ExportFromClause FromClause ;
    export NamedExports ;
    export default AssignmentExpression ;
1. 返回false
**** 注意 无须将export default AssignmentExpression作为常量声明。因为不存在这样
           的句法对module的default对象的内部名称进行赋值。
*** 静态语义：LexicallyDeclaredNames
Block : { }
1. 返回新的空List

StatementList : StatementList StatementListItem
1. 让names是StatementList的LexicallyDeclaredNames
2. 将StatementListItem的LexicallyDeclaredNames的元素附加到names中
3. 返回names

StatementListItem : Statement
1. 如果Statement是 Statement : LabelledStatement 返回 LabelledStatement的
   LexicallyDeclaredNames
2. 返回新的空List

StatementListItem : Declaration
1. 返回Declaration的BoundNames

CaseBlock : { }
1. 返回新的空List

CaseBlock : { CaseClauses_opt DefaultClause CaseClauses_opt }
1. 如果第一个CaseClauses存在，让names是第一个CaseClauses的LexicallyDeclaredNames
2. 否则names是新的空List
3. 将DefaultClause的LexicallyDeclaredNames的元素附加到names中
4. 如果第二个CaseClauses不存在，返回names
5. 返回将第二个CaseClauses的LexicallyDeclaredNames的元素附加到names后的结果

CaseClauses : CaseClauses CaseClause
1. 让names是CaseClauses的LexicallyDeclaredNames。
2. 将CaseClause的LexicallyDeclaredNames的元素附加到names中
3. 返回names

CaseClause : case Expression : StatementList_opt
1. 如果StatementList存在，返回StatementList的LexicallyDeclaredNames
2. 返回新的空List

DefaultClause : default : StatementList_opt
1. 如果StatementList存在，返回StatementList的LexicallyDeclaredNames
2. 返回新的空List

LabelledStatement : LabelIdentifier : LabelledItem
1. 返回LabelledItem的LexicallyDeclaredNames

LabelledItem : Statement
1. 返回新的空List

LabelledItem : FunctionDeclaration
1. 返回FunctionDeclaration的BoundNames

FunctionStatementList : [ empty ]
1. 返回新的空List

FunctionStatementList : StatementList
1. 返回StatementList的TopLevelLexicallyDeclaredNames

ConciseBody : ExpressionBody
1. 返回新的空List

AsyncConciseBody : ExpressionBody
1. 返回新的空List

ScriptBody : StatementList
1. 返回StatementList的TopLevelLexicallyDeclaredNames
**** 注意1 在Script的顶层，对待函数声明像var声明而不是像词法声明。
**** 注意2 Module的LexicallyDeclaredNames包含其引入的绑定信息。
ModuleItemList : ModuleItemList ModuleItem
1. 让names是ModuleItemList的LexicallyDeclaredNames
2. 将ModuleItem的LexicallyDeclaredNames的元素附加到names中
3. 返回names

ModuleItem : ImportDeclaration
1. 返回ImportDeclaration的BoundNames

ModuleItem : ExportDeclaration
1. 如果ExportDeclaration是export VariableStatement，返回新的空List
2. 返回ExportDeclaration的BoundNames

ModuleItem : StatementListItem
1. 返回StatementListItem的LexicallyDeclaredNames
**** 注意3 在Module的顶层，对待函数声明像词法声明而不是var声明
*** 静态语义：LexciallyScopedDeclarations
StatementList : StatementList StatementListItem
1. 让declarations是StatementList的LexicallyScopedDeclarations
2. 将StatementListItem的LexicallyScopedDeclarations的元素附加到declarations中
3.返回declarations

StatementListItem : Statement
1. 如果Statement是Statement : LabelledStatement，返回LabelledStatement的
   LexicallyScopedDeclarations
2. 返回新的空List

StatementListItem : Declaration
1. 返回仅有Declaration的DeclarationPart的List

CaseBlock : { }
1. 返回新的空List

CaseBlock : { CaseClauses_opt DefaultClasue CaseClauses_opt }
1. 如果第一个CaseClauses存在，让declarations是第一个CaseClauses的
   LexicallyScopedDeclarations
2. 否则让declarations是新的空List
3. 将DefaultClause的LexicallyScopedDeclarations的元素附加到declarations中
4. 如果第二个CaseClauses不存在，返回Declarations
5. 返回将第二个CaseClauses的LexicallyScopedDeclarations的元素附加到
   declarations中的结果

CaseClauses : CaseClauses CaseClause
1. 让declarations是CaseClauses的LexciallyScopedDeclarations
2. 将CaseClause的LexiclallyScopedDeclarations的元素附加到declarations中
3. 返回declarations

CaseClause : case Expression : StatementList_opt
1. 如果StatementList存在，返回StatementList的LexicallyScopedDeclarations
2. 返回新的空List

DefaultClause: default : StatementList_opt
1. 如果StatementList存在，返回StatementList的LexicallyScopedDeclarations
2. 返回新的空List

LabelledStatement : LabelIdentifier : LbelledItem
1. 返回LabelledItem的LexicallyScopedDeclarations

LabelledItem : Statement
1. 返回新的空List

LabelledItem : FunctionDeclaration
1. 返回只有FunctionDeclaration的List

FunctionStatementList : [ empty ]
1. 返回新的空List

FunctionStatementList : StatementList
1. 返回StatementList的TopLevelLexicallyScopedDeclarations

ConciseBody : ExpressionBody
1. 返回新的空List

AsyncConciseBody : ExpressionBody
1. 返回新的空List

ScriptBody : StatementList
1. 返回Statementist的TopLevelLexciallyScopedDeclarations

Module : [ empty ]
1. 返回新的空List

ModuleItemList : ModuleItemList ModuleItem
1. 让declarations是ModuleItemList的LexicallyScopedDeclarations
2. 将ModuleItem的LexicallyScopedDeclarations的元素附加到declarations
3. 返回declarations

ModuleItem : ImportDeclaration
1. 返回新的空List

ExportDeclaration :
    export ExportFromClause FromClause ;
    export NamedExports ;
    export VariableStatement
1. 返回新的空List

ExportDeclaration : export Declaration
1. 返回只有Declaration的DeclarationPart的List

ExportDeclaration : export default HoistableDeclaration
1. 返回只有HoistableDeclaration的DeclarationPart的List

ExportDeclaration : export default ClassDeclaration
1. 返回只有ClassDeclaration的List

ExportDeclaration : export default AssignmentExpression ;
1. 返回只有ExportDeclaration的List
*** 静态语义：VarDeclaredNames
Statement :
    EmptyStatement
    ExpressionStatement
    ContinueStatement
    BreakStatement
    ReturnStatement
    ThrowStatement
    DebuggerStatement
1. 返回新的空List

Block : { }
1. 返回新的空List

StatementList : StatementList StatementListItem
1. 让names是StatementList的VarDeclaredNames
2. 将StatementListItem的VarDeclaredNames的元素附加到names中
3. 返回names

StatementListItem : Declaration
1. 返回新的空List

StatementListItem : var VariableDeclarationList ;
1. 返回VariableDeclarationList的BoundNames

IfStatement : if ( Expression ) Statement else Statement
1. 让names是第一个Statement的VarDeclaredNames
2. 将第二个Statement的VarDeclaredNames的元素附加到names中
3. 返回names

IfStatement : if ( Expression ) Statement
1. 返回Statement的VarDeclaredNames

DoWhileStatement : do Statement while ( Expression ) ;
1. 返回Statement的VarDeclaredNames

WhileStatement : while ( Expression ) Statement
1. 返回Statement的VarDeclaredNames

ForStatement : for ( Expression_opt ; Expression_opt ; Expression_opt ) Statement
1. 返回Statement的VarDeclaredNames

ForInOfStatement
    for ( LeftHandSideExpression in Expression ) Statement
    for ( ForDeclaration in Expression ) Statement
    for ( LeftHandSideExpression of AssignmentExpression ) Statement
    for ( ForDeclaration of AssignmentExpression ) Statement
    for await ( LeftHandSideExpression of AssignmentExpression ) Statement
    for await ( ForDeclaration of AssignmentExpression ) Statement
1. 返回Statement的VarDeclaredNames

ForInOfStatement :
    for ( var ForBinding in Expression ) Statement
    for ( var ForBinding of AssignmentExpression ) Statement
    for await ( var ForBinding of AssignmentExpression ) Statement
1. 让names是ForBinding的BoundNames
2. 将Statement的VarDeclaredNames的元素附加到names中
3. 返回names
**** 注意 本节内容被附件B.3.6扩展了。
WithStatement : with ( Expression ) Statement 
1. 返回Statement的VarDeclaredNames

SwitchStatement : switch ( Expression ) CaseBlock
1. 返回CaseBlock的VarDeclaredNames

CaseBlock : { }
1. 返回新的空List

CaseBlock : { CaseClauses_opt DefaultClause CaseClauses_opt }
1. 如果第一个CaseClauses存在，让names是第一个CaseClauses的VarDeclaredNames
2. 否则names是新的空List
3. 将DefaultClause的VarDeclaredNames的元素附加到names中
4. 如果第二个CaseClauses不存在，返回names
5. 返回将第二个CaseClauses的VarDeclaredNames的元素附加到names后的结果

CaseClauses : CaseClauses CaseClause
1. 让names是CaseClauses的VarDeclaredNames。
2. 将CaseClause的VarDeclaredNames的元素附加到names中
3. 返回names

CaseClause : case Expression : StatementList_opt
1. 如果StatementList存在，返回StatementList的VarDeclaredNames
2. 返回新的空List

DefaultClause : default : StatementList_opt
1. 如果StatementList存在，返回StatementList的VarDeclaredNames
2. 返回新的空List

LabelledStatement : LabelIdentifier : LabelledItem
1. 返回LabelledItem的VarDeclaredNames

LabelledItem : FunctionDeclaration
1. 返回新的空List

TryStatement : try Block Catch
1. 让names是Block的VarDeclaredNames
2. 将Catch的VarDeclaredNames的元素附加到names中
3. 返回names

TryStatement : try Block Finally
1. 让names是Block的VarDeclaredNames
2. 将Finally的VarDeclaredNames的元素附加到names中
3. 返回names

TryStatement : try Block Catch Finally
1. 让names是Block的VarDeclaredNames
2. 将Catch的VarDeclaredNames的元素附加到names中
3. 将Finally的VarDeclaredNames的元素附加到names中
4. 返回names

Catch : catch ( CatchParameter ) Block
1. 返回Block的VarDeclaredNames

FunctionStatementList : [ empty ]
1. 返回新的空List

FunctionStatementList : StatementList
1. 返回StatementList的TopLevelVarDeclaredNames

ConciseBody : ExpressionBody
1. 返回新的空List

AsyncConciseBody : ExpressionBody
1. 返回新的空List

ScriptBody : StatementList
1. 返回StatementList的TopLevelVarDeclaredNames

Module : [empty]
1. 返回新的空List

ModuleItemList : ModuleItemList ModuleItem
1. 让names是ModuleItemList的VarDeclaredNames
2. 将ModuleItem的VarDeclaredNames的元素附加到names中
3. 返回names

ModuleItem : ImportDeclaration
1. 返回新的空List

ModuleItem : ExportDeclaration
1. 如果ExportDeclaration是export VariableStatement，返回ExportDeclaration的
   BoundNames
2. 返回新的空List
*** 静态语义：VarScopedDeclarations
Statement :
    EmptyStatement
    ExpressionStatement
    ContinueStatement
    BreakStatement
    ReturnStatement
    ThrowStatement
    DebuggerStatement
1. 返回新的空List

Block : { }
1. 返回新的空List

StatementList : StatementList StatementListItem
1. 让names是StatementList的VarScopedDeclarations
2. 将StatementListItem的VarScopedDeclarations的元素附加到names中
3. 返回names

StatementListItem : Declaration
1. 返回新的空List

VariableDeclarationList : VariableDeclaration
1. 返回只有VariableDeclaration的List

VariableDeclarationList : VariableDelarationList , VariableDeclaration
1. 让decalrations是VariableDeclarationList的VarScopedDeclarations
2. 将VariableDeclaration附加到declarations
3. 返回declarations

IfStatement : if ( Expression ) Statement else Statement
1. 让declarations是第一个Statement的VarScopedDeclarations
2. 将第二个Statement的VarScopedDeclarations的元素附加到declarations中
3. 返回declarations

IfStatement : if ( Expression ) Statement
1. 返回Statement的VarScopedDeclarations

DoWhileStatement : do Statement while ( Expression ) ;
1. 返回Statement的VarScopedDeclarations

WhileStatement : while ( Expression ) Statement
1. 返回Statement的VarScopedDeclarations

ForStatement : for ( Expression_opt ; Expression_opt ; Expression_opt ) Statement
1. 返回Statement的VarScopedDeclarations

ForStatement : 
    for ( var VariableDeclarationList ; Expression_opt ; Expresion_opt ) Statement
1. 让declarations是VariableDeclarationList的VarScopedDeclarations
2. 将Statement的VarScopedDeclarations的元素附加到declarations中
3. 返回declarations

ForStatement : for ( LexicalDeclaration Expression_opt ; Expression_opt ) Statement
1. 返回Statement的VarScopedDeclarations

ForInOfStatement :
    for ( LeftHandSideExpression in Expression ) Statement
    for ( ForDeclaration in Expression ) Statement
    for ( LeftHandSideExpression of AssignmenetExpression ) Statement
    for ( ForDeclaration of AssignmentExpression ) Statement
    for await ( LeftHandSideExpression of AssigmentExpression ) Statement
    for await ( ForDeclaration of AssignmentExpression ) Statement 
1. 返回Statement的VarScopedDeclarations

ForInOfStatement :
    for ( var ForBinding in Expression ) Statement
    for ( var ForBidning of AssignmentExpression ) Statement
    for await ( var ForBinding of AssignmentExpression ) Statement
1. 让declarations是只有ForBinding的List
2. 将Statement的VarScopedDeclarations的元素附加到declarations
3. 返回declarations
**** 注意 本节内容被附件B.3.6扩展了。
WithStatement : with ( Expression ) Statement 
1. 返回Statement的VarScopedDeclarations

SwitchStatement : switch ( Expression ) CaseBlock
1. 返回CaseBlock的VarScopedDeclarations

CaseBlock : { }
1. 返回新的空List

CaseBlock : { CaseClauses_opt DefaultClause CaseClauses_opt }
1. 如果第一个CaseClauses存在，让declarations是第一个CaseClauses的
   VarScopedDeclarations
2. 否则delcarations是新的空List
3. 将DefaultClause的VarScopedDeclarations的元素附加到declarations中
4. 如果第二个CaseClauses不存在，返回declarations
5. 返回将第二个CaseClauses的VarScopedDeclarations的元素附加到declarations后的结果

CaseClauses : CaseClauses CaseClause
1. 让declarations是CaseClauses的VarScopedDeclarations。
2. 将CaseClause的VarScopedDeclarations的元素附加到declarations中
3. 返回declarations

CaseClause : case Expression : StatementList_opt
1. 如果StatementList存在，返回StatementList的VarScopedDeclarations
2. 返回新的空List

DefaultClause : default : StatementList_opt
1. 如果StatementList存在，返回StatementList的VarScopedDeclarations
2. 返回新的空List

LabelledStatement : LabelIdentifier : LabelledItem
1. 返回LabelledItem的VarScopedDeclarations

LabelledItem : FunctionDeclaration
1. 返回新的空List

TryStatement : try Block Catch
1. 让declarations是Block的VarScopedDeclarations
2. 将Catch的VarScopedDeclarations的元素附加到declarations
3. 返回declarations

TryStatement : try Block Finally
1. 让declarations是Block的VarScopedDeclarations
2. 将Finally的VarScopedDeclarations的元素附加到declarations
3. 返回declarations

TryStatement : try Block Catch Finally
1. 让declarations是Block的VarScopedDeclarations
2. 将Catch的VarScopedDeclarations的元素附加到declarations
3. 将Finally的VarScopedDeclarations的元素附加到declarations
4. 返回declarations

Catch : catch ( CatchParameter ) Block
1. 返回Block的VarScopedDeclarations

FunctionStatementList : [ empty ]
1. 返回新的空List

FunctionStatementList : StatementList
1. 返回StatementList的TopLevelVarScopedDeclarations

ConciseBody : ExpressionBody
1. 返回新的空List

AsyncConciseBody : ExpressionBody
1. 返回新的空List

ScriptBody : StatementList
1. 返回Statementist的TopLevelVarScopedDeclarations

Module : [empty]
1. 返回新的空List

ModuleItemList : ModuleItemList ModuleItem
1. 让declarations是ModuleIemList的VarScopedDeclarations
2. 将ModuleItem的VarScopedDeclarations的元素附加到declarations中
3. 返回declarations

ModuleItem : ExportDeclaration
1. 如果ExportDeclaration是export VariableStatement，返回VariableStatement
   的VArScopedDeclarations
2. 返回新的空List
*** 静态语义：TopLevelLexicallyDeclaredNames
StatementList : StatementList StatementListItem
1. 让names是StatementList的TopLevelLexicallyDeclaredNames
2. 将StatementListItem的TopLevelLexciallyDeclaredNames的元素附加到names中
3. 返回names

StatementListItem : Statement
1. 返回新的空List

StatementListItem : Declaration
1. 如果Declaration是Declaration : HoistableDeclaration, 那么
    a. 返回<<>>
2. 返回Declaration的BoundNames
**** 注意 在function或Scipt的顶层，对待函数声明像var声明而不是词法声明
LabelledStatement : LabelIdentifier : LabelledItem
1. 返回新的空List
*** 静态语义：TopLevelLexicallyScopedDeclarations
Block : { }
1. 返回新的空List

StatementList : StatementList StatementListItem
1. 让declarations是StatementList的TopLevelLexicallyScopedDeclarations
2. 将StatementListItem的TopLevelLexicallyScopedDeclarations的元素附加到declarations
3. 返回declarations

StatementListItem : Statement
1. 返回新的空List

StatementListItem : Declaration
1. 如果Declaration是 Declaration : HoistableDeclaration，那么
    a. 返回<<>>
2. 返回只有Declaration的List

LabelledStatement : LabelIdentifier : LabelledItem
1. 返回新的空List
*** 静态语义：TopLevelVarDeclaredNames
Block : { }
1. 返回新的空List

StatementList : StatementList StatementListItem
1. 让names是StatementList的TopLevelVarDeclaredNames
2. 将StatementListItem的TopLevelVarDeclaredNames的元素附加到names
3. 返回names

StatementListItem : Declaration
1. 如果Declaration是Declaration : HoistableDeclaration，那么
    a. 返回HoistableDeclaration的BoundNames
2. 返回新的空List

StatementListItem : Statement
1. 如果Statement是Statement : LabelledStatement，返回Statement的
   TopLevelVarDeclaredNames
2. 返回Statement的VarDeclaredNames
**** 在function和script的顶层，对待内部函数声明像var声明
LabelledStatement : LabelIdentifier : LabelledItem
1. 返回LabelledItem的TopLevelVarDeclaredNames

LabelledItem : Statement
1. 如果Statemnet是Statement : LabelledStatement，返回Statment的
   TopLevelVarDeclaredNames
2. 返回Statement的VarDeclaredNames

LabelledItem : FunctionDeclaration
1. 返回FunctionDeclaration的BoundNames
*** 静态语义：TopLevelVarScopedDeclarations
Block : { }
1. 返回新的空List

StatementList : StatementList StatementListItem
1. 让declarations是StatementList的TpLevelVarScopedDeclarations
2. 将StatementListItem的TopLevelVarScopedDeclarations的元素附加到declarations中
3. 返回declarations

StatementListItem : Statement
1. 如果Statement是 Statement : LabelledStatement，返回Statement的
   TopLevelVarScopedDeclarations
2. 返回Statement的VarScopedDeclarations

StatementListItem : Declaration
1. 如果Declaration是Declarations : HoistableDeclaration，那么
    a. 让declaration是HoistableDeclaration的DeclarationPart
    b. 返回<<declaration>>
2. 返回新的空List

LabelledStatement : LabelIdentifier : LabelledItem
1. 返回LabelledItem的TopLevelVarScopedDeclarations

LabelledItem : FunctionDeclaration
1. 返回只有FunctionDeclaration的List
** Labels标签
*** 静态语义：ContainsDuplicateLabels
带有参数labelSet
Statement:
    VariableStatement
    EmptyStatement
    ExpressionStatement
    ContinueStatement
    BreakStatement
    ReturnStatement
    ThrowStatement
    DebuggerStatement
Block : { }
StatementListItem : Declaration
1. 返回false

StatementList : StatementList StatementListItem
1. 让hasDuplicates是StatementList带labelSet参数的ContainsDuplicatedLabels
2. 如果hasDuplicates是true，返回true
3. 返回StatementListItem带labelSet参数的ContinsDuplicateLabels

IfStateMent : if ( Expression ) Statement else Statement 
1. 让hasDuplicate是第一个Statement带labelSet参数的ContainsDuplicateLabels
2. 如果hasDuplicates是true，返回true
3. 返回第二个Statement带labelSet参数的ContainsDuplicateLabels

IfStatement : if ( Expression ) Statement
1. 返回Statement带labelSet参数的ContainsDuplicateLabels

DoWhileStatement : do Statement while ( Expression ) ;
1. 返回Statement带labelSet参数的ContainsDuplicateLabels

WhileStatement : while ( Expression ) Statement
1. 返回Statement带labelSet参数的ContainsDuplicateLabels

ForStatement :
    for ( Expression_opt ; Expression_opt ; Expression_opt ) Statement
    for ( var VariableDeclarationList ; Expression_opt ; Expression_opt ) Statement
    for ( LexicalDeclaration Expression_opt ; Expression_opt ) Statement
1. 返回Statement带labelSet参数的ContainsDuplicateLabels

ForInOfStatement :
    for ( LeftHandSideExpression in Expression ) Statement
    for ( var ForBinding in Expression ) Statement
    for ( ForDeclaration in Expression ) Statement
    for ( LeftHandSideExpression of AssignmentExpression ) Statement
    for ( var ForBinding of AssignmentExpression ) Statement
    for ( ForDeclaration of AssignmentExpression ) Statement
    for await ( LeftHandSideExpression of AssignmentExpreesion ) Statement
    for await ( var ForBinding of AssignmentExpreesion ) Statement
    for await ( ForDeclaration of AssignmentExpression ) Statement
1. 返回Statement带labelSet参数的ContainsDupicateLabels
**** 注意 本节被附录B.3.6扩展
WithStatement : with ( Expression ) Statement
1. 返回Statement带labelSet参数的ContainsDuplicateLabels

SwitchStatement : switch ( Expression ) CaseBlock
1. 返回CaseBlock带labelSet参数的ContainsDuplicateLabels

CaseBlock : { }
1. 返回false

CaseBlock : { CaseClauses_opt DefaultCaluse CaseClauses_opt }
1. 如果第一个CaseClauses存在，那么
    a. 让hasDuplicates是CaseClauses带labelSet参数的ContainsDuplicateLabels
    b. 如果hasDuplicates是true，返回true
2. 让hasDuplicates是DefaultClause带labelSet参数的ContainsDuplicateLabels
3. 如果hasDuplicates是true，返回true
4. 如果第二个CaseClauses不存在，返回false
5. 返回第二个CaseClauses带labelSet参数的ContainsDuplicateLabels

CaseClauses : CaseClauses CaseClause
1. 让hasDuplicates是CaseClauses带labelSet参数的ContainsDuplicateLabels
2. 如果hasDuplicates是true，返回true
3. 返回CaseClause带labelSet参数的ContainsDuplicateLabels

CaseClause : case Expression : StatementList_opt
1. 如果StatementList存在，返回StatementList带labelSet参数的ContainsDuplicateLabels
2. 返回false

DefaultClause : default : StatementList_opt
1. 如果StatementList存在，返回StatementList带labelSet参数的ContainsDuplicateLabels
2. 返回false

LabelledStatement : LabelIdentifier : LabelledItem
1. 让label是LabelIdentifier的Sting值
2. 如果label是labelSet的元素，返回true
3. 让newLabelSet是labeSet附加label后的复制
4. 返回LabelledItem带newLabelSet参数的ContainsDuplicateLabel

LabelledItem : FunctionDeclaration
1. 返回false

TryStatement : try Block Catch
1. 让hasDuplicates是Block带labelSet参数的ContainsDuplicateLabels
2. 如果hasDuplicates是true，返回true
3. 返回Catch带labelSet参数的ContainsDuplicateLabels

TryStatement : try Block Finally
1. 让hasDuplicates是Block带labelSet参数的ContainsDuplicateLabels
2. 如果hasDuplicates是true，返回true
3. 返回Finally带labelSet参数的ContainsDuplicateLabels

TryStatement : try Block Catch Finally
1. 让hasDuplicates是Block带labelSet参数的ContainsDuplicateLabels
2. 如果hasDuplicates是true，返回true
3. 让hasDuplicates是Catch带labelSet参数的ContainsDuplicateLabels
4. 如果hasDuplicates是true，返回true
5. 返回Finally带labelSet参数的ContainsDuplicateLabels

Catch : catch ( CatchParameter ) Block
1. 返回Block带labelSet参数的ContainsDuplicateLabels

FunctionStatementList : [empty]
1. 返回false

ModuleItemList : ModuleItemList ModuleItem
1. 让hasDuplicates是ModuleItemList带labelSet参数的ContainsDuplicateLabels
2. 如果hasDuplicates是true，返回true
3. 返回ModuleItem带labelSet参数的ContainsDuplicateLabels

ModuleItem : 
    ImportDeclaration
    ExportDeclaration
1. 返回false
*** 静态语义：ContainsUndefinedBreakTarget
带labelSet参数
Statement :
   VariableStatement
   EmptyStatement
   ExpressionStatement
   ContinueStatement
   ReturnStatement
   ThrowStatement
   DebuggerStatement
Block : { }
StatementListItem : Declaration
1. 返回false

StatementList : StatementList StatementListItem
1. 让hasUndefinedLabels是StatementList带labelSet参数的ContainsUndefinedBreakTarget
2. 如果hasUndefinedLabels是true，返回true
3. 返回StatementListItem带labelSet参数的ContainsUndefinedBreakTarget

IfStatement : if ( Expression ) Statement else Statement
1. 让hasUndefinedLabels是第一个Statement带labelSet参数的ContainsUndefinedBreakTarget
2. 如果hasUndefinedLabels是true，返回true
3. 返回第二个Statement带labelSet参数的ContainsUndefinedBreakTarget

IfStatement : if ( Expression ) Statement
1. 返回Statement带labelSet参数的ContainsUndefinedBreakTarget

DoWhileStatement : do Statement while ( Expression ) ;
1. 返回Statement带labelSet参数的ContainsUndefinedBreakTarget

WhileStatement : while ( Expression ) Statement
1. 返回Statement带labelSet参数的ContainsUndefinedBreakTarget

ForStatement:
    for ( Expression_opt ; Expression_opt ; Expression_opt ) Statement
    for ( var VariableDeclarationList ; Expression_opt ; Expression_opt ) Statement
    for ( LexicalDeclaration Expression_opt ; Expression_opt ) Statement
1. 返回Statement带labelSet参数的ContainsUndefinedBreakTarget

ForInOfStatement :
    for ( LeftHandSideExpression in Expression ) Statement
    for ( var ForBinding in Expression ) Statement
    for ( ForDeclaration in Expression ) Statement
    for ( LeftHandSideExpression of AssignmentExpression ) Statement
    for ( var ForBinding of AssignmentExpression ) Statement
    for ( ForDeclaration of AssignmentExpression ) Statement
    for await ( LeftHandSideExpression of AssignmentExpression ) Statement
    for await ( var ForBinding of AssignmentExpression ) Statement
    for await ( ForDeclaration of AssignmentExpression ) Statement
1. 返回Statement带labelSet参数的ContainsUndefinedBreakTarget
**** 注意  本节在附录B.3.6中被扩展
BreakStatement : break;
1. 返回false

BreakStatement : break LabelIdentifier ;
1. 如果LabelIdentifier的String值不在labelSet中，返回true
2. 返回false

WithStatement : with ( Expression ) Statement
1. 返回Statement带labelSet参数的ContainsUndefinedBreakTarget

SwitchStatement : switch ( Expression ) CaseBlock
1. 返回CaseBlock带labelSet参数的ContainsUndefinedBreakTarget

CaseBlock : { }
1. 返回false

CaseBlock : { CaseClauses_opt DefaultClause CaseClauses_opt }
1. 如果第一个CaseClauses存在，那么
    a. 让hasUndefinedLabels是第一个CaseClauses带labelSet参数的
       ContainsUndefinedBreakTarget
    b. 如果hasUndefinedLabels是true，返回true
2. 让hasUndefinedLabels是DefaultClause带labelSet参数的ContainsUndefinedBreakTarget
3. 如果hasUndefinedLabels是true，返回true
4. 如果第二个CaseClauses不存在，返回false
5. 返回第二个CaseClauses带labelSet参数的ContainsUndefinedBreakTarget

CaseClauses : CaseClauses CaseClause
1. 让hasUndefinedLabels是CaseClauses带labelSet参数ContainsUndefinedBreakTarget
2. 如果hasUndefinedLabels是true，返回true
3. 返回CaseClause带labelSet参数的ContainsUndefinedBreakTarget

CaseClause : case Expression : StatementList_opt
1. 如果StatementList存在，返回StatementList带labelSet参数的
   ContainsUndefinedBreakTarget
2. 返回false

DefaultClause : default : StatementList_opt
1. 如果StatementList存在，返回StatementList带labelSet参数的
   ContainsUndefinedBreakTarget
2. 返回false

LabelledStatement : LabelIdentifier : LabelledItem
1. 让label是LabelIdentifier的String值
2. 让newLabelSet是labelSet的复制，并附加label
3. 返回LabelledItem带newLabelSet参数的ContainsUndefinedBreakTarget

LabelledItem : FunctionDeclaration
1. 返回false

TryStatement : try Block Catch
1. 让hasUndefinedLabels是Block带labelSet参数的ContainsUndefinedBreakTarget
2. 如果hasUndefinedLabels是true，返回true
3. 返回Catch带labelSet参数的ContainsUndefinedBreakTarget

TryStatement : try Block Finally
1. 让hasUndefinedLabels是Block带labelSet参数的ContainsUndefinedBreakTarget
2. 如果hasUndefinedLabels是true，返回true
3. 返回Finally带labelSet参数的ContainsUndefinedBreakTarget

TryStatement : try Block Catch Finally
1. 让hasUndefinedLabels是Block带labelSet参数的ContainsUndefinedBreakTarget
2. 如果hasUndefinedLabels是true，返回true
3. 让hasUndefinedLabels是Catch带labelSet参数的ContainsUndefinedBreakTarget
4. 如果hasUndefinedLabels是true，返回true
5. 返回Catch带labelSet参数的ContainsUndefinedBreakTarget

Catch : catch ( CatchParameter ) Block
1. 返回Block带labelSet参数的ContainsUndefinedBreakTarget

FunctionStatementList : [empty]
1. 返回false

ModuleItemList : ModuleItemList ModuleItem
1. 让hasUndefinedLabels是ModuleItemList带labelSet参数的ContainsUndefinedBreakTarget
2. 如果hasUndefinedLabels是true，返回true
3. 返回ModuleItem带labelSet参数的ContainsUndefinedBreakTarget

ModuleItem :
    ImportDeclaration
    ExportDeclaration
1. 返回false
*** 静态语义：ContainsUndefinedContinueTarget
带iterationSet和labelSet参数
Statement :
   VariableStatement
   EmptyStatement
   ExpressionStatement
   BreakStatement
   ReturnStatement
   ThrowStatement
   DebuggerStatement
Block : { }
StatementListItem : Declaration
1. 返回false

BreakableStatement : IterationStatement
1. 让newIterationSet是iterationSet的复制，附加labelSet的全部元素
2. 返回IterationStatement带newIterationSet和<<>>参数的ContainsUndefinedContinueTarget

StatementList : StatementList StatementListItem
1. 让hasUndefinedLabels是StatementList带iterationSet和<<>>参数的
   ContainsUndefinedBreakTarget
2. 如果hasUndefinedLabels是true，返回true
3. 返回StatementListItem带iterationSet和<<>>参数的ContainsUndefinedBreakTarget

IfStatement : if ( Expression ) Statement else Statement
1. 让hasUndefinedLabels是第一个Statement带iteration和<<>>参数的
   ContainsUndefinedContinueTarget
2. 如果hasUndefinedLabels是true，返回true
3. 返回第二个Statement带iterationSet和<<>>参数的ContainsUndefinedContinueTarget

IfStatement : if ( Expression ) Statement
1. 返回Statement带iterationSet和<<>>参数的ContainsUndefinedContinueTarget

DoWhileStatement : do Statement while ( Expression ) ;
1. 返回Statement带iterationSet和<<>>参数的ContainsUndefinedContinueTarget

WhileStatement : while ( Expression ) Statement
1. 返回Statement带iterationSet和<<>>参数的ContainsUndefinedContinueTarget

ForStatement:
    for ( Expression_opt ; Expression_opt ; Expression_opt ) Statement
    for ( var VariableDeclarationList ; Expression_opt ; Expression_opt ) Statement
    for ( LexicalDeclaration Expression_opt ; Expression_opt ) Statement
1. 返回Statement带iterationSet和<<>>参数的ContainsUndefinedContinueTarget

ForInOfStatement :
    for ( LeftHandSideExpression in Expression ) Statement
    for ( var ForBinding in Expression ) Statement
    for ( ForDeclaration in Expression ) Statement
    for ( LeftHandSideExpression of AssignmentExpression ) Statement
    for ( var ForBinding of AssignmentExpression ) Statement
    for ( ForDeclaration of AssignmentExpression ) Statement
    for await ( LeftHandSideExpression of AssignmentExpression ) Statement
    for await ( var ForBinding of AssignmentExpression ) Statement
    for await ( ForDeclaration of AssignmentExpression ) Statement
1. 返回Statement带iterationSet和<<>>参数的ContainsUndefinedContinueTarget
**** 注意  本节在附录B.3.6中被扩展
ContinueStatement : continue;
1. 返回false

ContinueStatement : continue LabelIdentifier ;
1. 如果LabelIdentifier的String值不在iterationSet中，返回true
2. 返回false

WithStatement : with ( Expression ) Statement
1. 返回Statement带iterationSet和<<>>参数的ContainsUndefinedContinueTarget

SwitchStatement : switch ( Expression ) CaseBlock
1. 返回CaseBlock带iterationSet和<<>>参数的ContainsUndefinedContinueTarget

CaseBlock : { }
1. 返回false

CaseBlock : { CaseClauses_opt DefaultClause CaseClauses_opt }
1. 如果第一个CaseClauses存在，那么
    a. 让hasUndefinedLabels是第一个CaseClauses带iterationSet和<<>>参数的
       ContainsUndefinedContinueTarget
    b. 如果hasUndefinedLabels是true，返回true
2. 让hasUndefinedLabels是DefaultClause带iterationSet和<<>>参数的
   ContainsUndefinedContinueTarget
3. 如果hasUndefinedLabels是true，返回true
4. 如果第二个CaseClauses不存在，返回false
5. 返回第二个CaseClauses带iterationSet和<<>>参数的ContainsUndefinedContinueTarget

CaseClauses : CaseClauses CaseClause
1. 让hasUndefinedLabels是CaseClauses带iterationSet和<<>>参数
   ContainsUndefinedContinueTarget
2. 如果hasUndefinedLabels是true，返回true
3. 返回CaseClause带iterationSet和<<>>参数的ContainsUndefinedContinueTarget

CaseClause : case Expression : StatementList_opt
1. 如果StatementList存在，返回StatementList带iterationSet和<<>>参数的
   ContainsUndefinedContinueTarget
2. 返回false

DefaultClause : default : StatementList_opt
1. 如果StatementList存在，返回StatementList带iterationSet和<<>>参数的
   ContainsUndefinedContinueTarget
2. 返回false

LabelledStatement : LabelIdentifier : LabelledItem
1. 让label是LabelIdentifier的String值
2. 让newLabelSet是lebelSet的复制，并附加label
3. 返回LabelledItem带iterationSet和newLabelSet参数的ContainsUndefinedContinueTarget

LabelledItem : FunctionDeclaration
1. 返回false

TryStatement : try Block Catch
1. 让hasUndefinedLabels是Block带iterationSet和<<>>参数的
   ContainsUndefinedContinueTarget
2. 如果hasUndefinedLabels是true，返回true
3. 返回Catch带iterationSet和<<>>参数的ContainsUndefinedContinueTarget

TryStatement : try Block Finally
1. 让hasUndefinedLabels是Block带iterationSet和<<>>参数的
   ContainsUndefinedContinueTarget
2. 如果hasUndefinedLabels是true，返回true
3. 返回Finally带iterationSet和<<>>参数的ContainsUndefinedContinueTarget

TryStatement : try Block Catch Finally
1. 让hasUndefinedLabels是Block带iterationSet和<<>>参数的
   ContainsUndefinedContinueTarget
2. 如果hasUndefinedLabels是true，返回true
3. 让hasUndefinedLabels是Catch带iterationSet和<<>>参数的
   ContainsUndefinedContinueTarget
4. 如果hasUndefinedLabels是true，返回true
5. 返回Catch带iterationSet和<<>>参数的ContainsUndefinedContinueTarget

Catch : catch ( CatchParameter ) Block
1. 返回Block带iterationSet和<<>>参数的ContainsUndefinedContinueTarget

FunctionStatementList : [empty]
1. 返回false

ModuleItemList : ModuleItemList ModuleItem
1. 让hasUndefinedLabels是ModuleItemList带iterationSet和<<>>参数的
   ContainsUndefinedContinueTarget
2. 如果hasUndefinedLabels是true，返回true
3. 返回ModuleItem带iterationSet和<<>>参数的ContainsUndefinedContinueTarget

ModuleItem :
    ImportDeclaration
    ExportDeclaration
1. 返回false
** 函数名引用
*** 静态语义：HasName
PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList
1. 让expr是CoverParenthesizedExpressionAndArrowParameterList的
   CoveredParenthesizedExpression
2. 如果expr的IsFunctionDefinition是false，返回false
3. 返回expr的HasName

FunctionExpression : 
    function ( FormalParameters ) { FunctionBody }
GeneratorExpression :
    function * ( FormalParameters ) { GeneratorBody }
AsyncFunctionExpression :
    async function * ( FormalParameters ) { AsyncGeneratorBody }
AsyncFunctionExpression :
    Async function ( FormalParameters ) { AsyncFunctionBody }
ArrowFunction : 
    ArrowParameters => ConciseBody
AsyncArrowFunction :
    async AsyncArrowBindingIdentifier => AsyncConciseBody
    CoverCallExpressionAndAsyncArrowHead => AsyncConciseBody
ClassExpression : class ClassTail
1. 返回false
FunctionExpression : 
    function BindingIdentifier ( FormalParameters ) { FunctionBody }
GeneratorExpression :
    function * BindingIdentifier ( FormalParameters ) { GeneratorBody }
AsyncGeneratorExpression : 
    async function * BindingIdentifier ( FormalParameters ) { AsyncGeneratorBody }
AsyncFunctionExpression :
    async function BindingIdentifier ( FormalParameters ) { AsyncFunctionBody }
ClassExpression : class BindingIdentifier ClassTail
1. 返回true
*** 静态语义：IsFunctionDefinition
PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList
1. 让expr是CoverParenthesizedExpressionAndArrowParameterList的
   CoveredParenthesizedExpression
2. 返回expr的IsFunctionDefinition
PrimaryExpression :
    this
    IdentifierReference
    Literal
    ArrayLiteral
    ObjectLiteral
    RegularExpressionLiteral
    TemplateLiteral
MemberExpression :
    MemberExpression [ Expression ]
    MemberExpression . IdentifierName
    MemberExpression TemplateLiteral
    SuperProperty
    MetaProperty
    new MemberExpression Arguments
NewExpression :
    new NewExpression
LeftHandSideExpression : 
    CallExpression
    OptionalExpression
UpdateExpression :
    LeftHandSideExpression \+\+ 
    LeftHandSideExpression \-\-
    \+\+ UnaryExpression
    \-\- UnaryExpression
UnaryExpression :
    delete UnaryExpression
    void UnaryExpression
    typeof UnaryExpression
    \+ UnaryExpression
    \- UnaryExpression
    \~ UnaryExpression
    \! UnaryExpression
    AwaitExpression
ExponentiationExpression :
    UpdateExpression ** ExponentiationExpression
MultiplicativeExpression :
    MultiplicativeExpression MultiplicativeOperator ExponentiationExpression
AdditiveExpression :
    AdditiveExpression + MultiplicativeExpression
    AdditiveExpression - MultiplicativeExpression
ShifExpression :
    ShiftExpression \<\< AdditiveExpression
    ShiftExpression \>\> AdditiveExpression
    ShiftExpression \>\>\> AdditiveExpression
RelationalExression :
    RelationalExpression \< ShiftExpression
    RelationalExpression \> ShiftExpression
    RelationalExpression \<= ShiftExpression
    RelationalExpression \>= ShiftExpression
    RelationalExpression instanceof ShiftExpression
    RelationalExpression in ShiftExpression
EqualityExpression :
    EqualityExpression \=\= RelationalExpression
    EqualityExpression \!\= RelationalExpression
    EqualityExpression \=\=\= RelationalExpression
    EqualityExpression \!\==\= RelationalExpression
BitwiseANDExpression
    BitwiseANDExpression \& EqualityExpression
BitwiseXORExpression :
    BitwiseXORExpression \^ BitwiseANDEExpression
BitWiseORExpression :
    BitWiseORExpression \| BitwiseXORExpression
LogicalANDExpression :
    LogicalANDExpression && BitwiseORExpression
LogicalORExpression :
    LogicalORExpression || LogicalANDExpression
CoalesceExpression :
    CoalesceExpressionHead ?? BitwiseORExpression
ConditionalExpression :
    ShortCircuitExpression ? AssignmentExpression : AssignmentExpression
AssignmentExpression :
    YieldExpression
    LeftHandSideExpression = AssignmentExpression
    LeftHandSideExpression AssignmentOperator AssignmentExpression
    LeftHandSideExpression &&= AssignmentExpression
    LeftHandSideExpression ||= AssignmentExpression
    LeftHandSideExpression ??= AssignmentExpression
Expression :
    Expression , AssignmentExpression
1. 返回false
AssignmentExpression :
    ArrowFunction
    AsyncArrowFunction
FunctionExpression :
    function BindingIdentifier_opt ( FormalParameters ) { FunctionBody }
GeneratorExpression :
    function * BindingIdentifier_opt ( FormalParameters ) { GeneratorBody }
AsyncGeneratorExpression :
    async function * BindingIdentifier_opt ( FormalParameters ) { AsyncGeneratorBody }
AsyncFunctionExpression :
    async function BindingIdentifier_opt ( FormalParameters ) { AsyncFunctionBody }
ClassExpression : class BindingIdentifier_opt ClassTail
1. 返回true
*** 静态语义：IsAnonymousFunctionDefinition(expr)
抽象操作IsAnonymousFunctionDefinition接受参数expr（AssignmentExpression的
ParseNode或者Initialize的ParseNode）。用于明确它的参数是否是一个没有绑定名称的
函数定义。被调用时执行下列步骤：
1. 如果expr的IsFunctionDefinition是false，返回false
2. 让hasName是expr的HasName
3. 如果hasName是true，返回false
4. 返回true
*** 静态语义：IsIdentifierRef
PrimaryExpression : IdentifierReference
1.返回true
PrimaryExpression :
    this
    Literal
    ArrayLiteral
    ObjectLiteral
    FunctionExpression
    ClassExpression
    GeneratorExpression
    AsyncFunctionExpression
    AsyncGeneratorExpression
    RegularExpressionLiteral
    TemplateLiteral
    CoverParenthesizedExpressionAndArrowParameterList
MemberExpression :
    MemberExpression [ Expression ]
    MemberExpression . IdentifierName
    MemberExpression TemplateLiteral
    SuperProperty
    MetaProperty
    new MemberExpression Arguments
NewExpression :
    new NewExpression
LeftHandSideExpression :
    CallExpression
    OptionalExpression
1. 返回 false.
*** 静态语义：NamedEvaluation
带name参数
PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList
1. 让expr是CoverParenthesizedExpressionAndArrowParameterList的
   CoveredParenthesizedExpression
2. 返回expr带name参数的NamedEvaluation

ParenthesizedExpression ( Expression )
1. Assert：IsAnonymousFunctionDefinition(Expression)是true
2. 返回Expression带name参数的NamedEvaluation

FunctionExpression : function ( FormalParameters ) { FunctionBody }
1. 返回FunctionExpression带name参数的InstantiateOrdinaryFunctionExpression

GeneratorExpression : function * ( FormalParameters ) { GeneratorBody }
1. 返回GeneratorExpression带name参数的InstantiateGeneratorFunctionExpression

AsyncGeneratorExpression : async function * ( FormalParameters ) { AsyncGeneratorBody }
1. 返回AsyncGeneratorExpression带name参数的InstantiateAsyncGeneratorFunctionExpression

AsyncFunctionExpression : async function ( FormalParameters ) { AsyncFunctionBody }
1. 返回AsyncFunctionExpression带name参数的InstantiateAsyncFunctionExpression

ArrowFunction : ArrowParameters => ConciseBody
1. 返回ArrowFunction带name参数的InstantiateArrowFunctionExpression

AsyncArrowFunction :
   async AsyncArrowBindingIdentifier => AsyncConciseBody
   CoverCallExpressionAndAsyncArrowedHead => AsyncConciseBody
1. 返回AsyncArrowFunction带name参数的InstantiateAsyncArrowFunctionExpression

ClassExpression : class ClassTail
1. 让value是ClassTail带name参数的ClassDefinitionEvaluation
2. ReturnIfAbrupt(value)
3. 设置value.\[\[SourceText]]是匹配ClassExpression的源文本
4. 返回value
** Contains
*** 静态语义：Contains
带symbol参数

本规范中不是下方列出的的码型备选的Contains隐式的含有如下定义。
1. 遍历这个ParseNode的每个子节点child，执行
    a. 如果child是symbol的实例，返回true
    b. 如果child是非终结符，那么
        i. 让contained是child才symbol参数的Contains
       ii. 如果contained是true，返回true
2. 返回false

FunctionDeclaration : 
    function BindingIdentifier ( FormalParameters ) { FunctionBody }
    function ( FormalParameters ) { FunctionBody }
FunctionExpression : 
    function BindingIdentifier_opt ( FormalParameters ) { FunctionBody }
GeneratorDeclaration :
    function * BindingIdentifier ( FormalParameters ) { GeneratorBody }
   function * ( FormalParameters ) { GeneratorBody }
GeneratorExpression :
    function * BindingIdentifier_opt ( FormalParameters ) { GeneratorBody }
AsyncGeneratorDeclaration :
    async function * BindingIdentifier ( FormalParameters ) { AsyncGeneratorBody }
   async function * ( FormalParameters ) { AsyncGeneratorBody }
AsyncGeneratorExpression :
    async function * BindingIdentifier_opt ( FormalParameters ) { AsyncGeneratorBody }
AsyncFunctionDeclaration :
    async function BindingIdentifier ( FormalParameters ) { AsyncFunctionBody }
    async function ( FormalParameters ) { AsyncFunctionBody }
AsyncFunctionExpression :
   async function BndingIdentifier_opt ( FormalParameters ) { AsyncFunctionBody }
1. 返回false
**** 注意1 依赖于下层建筑的静态语法的规则，一般不查看函数的定义内部。
ClassTail : ClassHeritage_opt { ClassBody }
1. 如果symbol是ClassBody，返回true
2. 如果symbol是ClassHeritage，那么
    a. 如果ClassHeritage存在，返回true，否则返回false
3. 让inHeritage是ClassHeritage带symbol参数的Contains
4. 如果inHeritage是true，返回true
5. 返回ClassBody带symbol参数的ComputedPropertyContains
**** 注意2 依赖于下层建筑的静态语法的规则，除了为了找PropertyName，不查看
            class内容。
ArrowFunciton : ArrowParameters => ConciseBody
1. 如果symbol不是NewTarget、SuperProperty、SuperCall、supper或this，返回false
2. 如果ArrowParameters带symbol参数的Contains是true，返回true
3. 返回ConciseBody带symbol参数的Contains

ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList
1. 让formals是CoverParenthesizedExpressionAndArrowParameterList的CoveredFormalsList
2. 返回formals带symbol参数的Contains

AsyncArrowFunction : async AsyncArrowBindingIdentifier => AsyncConciseBody
1. 如果symbol不是NewTarget、SuperProperty、SuperCall、super或this，返回false
2. 返回AsyncConciseBody带symbol参数的Contains

AsyncArrowFunction : CoverCallExpressionAndAsyncArrowHead => AsyncConciseBody
1. 如果symbol不是NewTarget、SuperProperty、SuperCall、super或this，返回false
2. 让head是CoverCallExpressionAndAsyncArrowHead
3. 如果head带symbol参数的Contains是true，返回true
4. 返回AsyncConciseBody带symbol参数的Contains
**** 注意3 Contains用于在ArrowFunction和AsyncArrowFunction中检查new.target、
            this和super。
PropertyDefinition : MethodDefinition
1. 如果symbol是MethodDefinition，返回true
2. 返回MethodDefinition带symbol参数的ComputedPropertyContains

LiteralPropertyName : IdentifierName
1. 返回false

MemberExpression : MemberExpression . IdentifierName
1. 如果MemberExpression带symbol的Contains是true，返回true
2. 返回false

SuperProperty : super . IdentifierName
1. 如果symbol是保留字super，返回true
2. 返回false

CallExpression : CallExpression . IdentifierName
1. 如果CallExpression带symbol参数的Contains是true，返回true
2. 返回false

OptionalChain : ?. IdentifierName
1. 返回false

OptionalChain : OptionalChain . IdentifierName
1. 如果OptionalChain带symbol参数的Contains是true，返回true
2. 返回false
*** 静态语义：ComputedPropertyContains
带symbol参数
PropertyName : LiteralPropertyName
1. 返回false

PropertyName : ComputedPropertyName
1. 返回ComputedPropertyName带symbol参数的Contains

MethodDefinition : 
    PropertyName ( UniqueFormalParameters ) { FunctionBody }
    get PropertyName ( ) { FunctionBody }
    set PropertyName ( PropertySetParameterList ) { FuncitonBody }
1. 返回PropertyName带symbol参数的ComputedPropertyContains

GeneratorMethod : * PropertyName ( UniqueFormalParameters ) { GeneratorBody }
1. 返回PropertyName带symbol参数的ComputedPropertyContains

AsyncGeneratorMethod :
    async * PropertyName ( UniqueFormalParameters ) { AsyncGeneratorBody }
1. 返回PropertyName带symbol参数的ComputedPropertyContains

ClassElementList : ClassElementList ClassElement
1. 让inList是ClassElementList带symbol参数的ComputedPropertyContains
2. 如果inList是true，返回true
3. 返回ClassElement带symbol参数的ComputedPropertyContains

ClassElement : 
1. 返回false

AsyncMethod : async PropertyName ( UniqueFormalParameters ) { AsyncFunctionBody }
1. 返回PropertyName带symbol参数的ComputedPropertyContains
** Miscellaneous杂七杂八（我觉得可以用其他来翻译）
这些操作用于本规范的多处地方。
*** 运行时语义：InstantiateFunctionObject
带scope参数
FunctionDeclaration :
    function BindingIdentifier ( FormalParameters ) { FunctionBody }
    function ( FormalParameters ) { FunctionBody }
1. 返回FunctionDeclaration带scope参数的?InstantiateOrdinaryFunctionObject

GeneratorDeclaration :
    function BindingIdentifier ( FormalParameters ) { GeneratorBody }
    function ( FormalParameters ) { GeneratorBody }
1. 返回GeneratorDeclaration带scope参数的?InstantiateGeneratorFunctionObject

AsyncGeneratorDeclaration :
    async function *  BindingIdentifier ( FormalParameters ) { AsyncGeneratorBody }
   async function * ( FormalParameters ) { AsyncGeneratorBody }
1. 返回AsyncGeneratorDeclaration带scope参数的?InstantiateAsyncGeneratorFunctionObject

AsyncFunctionDeclaration :
    async function BindingIdentifier ( FormalParameters ) { AsyncFunctionBody }
    async function ( FormalParameters ) { AsyncFunctionBody }
1. 返回AsyncFunctionDeclaration带scope参数的?InstantiateAsyncFunctionObject
*** 运行时语义：BindingInitialization
带value和environment参数
**** 注意 给environment传递undefined表明PutValue操作应该被赋予初始化值。这种情况
           发生在var语句和非严格模式下函数的形式参数中（见于10.2.10）。在这
           些情况中文法绑定被提升了，而且在评估其初始化前就已经提前初始化
           了。
BindingIdentifier : Identifier
1. 让name是Identifier的String值
2. 返回?InitializeBoundName(name, value , environment)

BindingIdentifier : yield
1. 返回?InitializeBoundName("yield", value, environment)

BindingIdentifier : await
1. 返回?InitializeBoundName("await", value, environment)

BindingPattern : ObjectBindingPattern
1. 执行?RequireObjectCoercible(value)
2. 返回ObjectBindingPattern带value和environment参数的BindingInitialization的结果

BindingPattern : ArrayBindingPattern
1. 让iteratorRecord是?GetIterator(value)
2. 让result是ArrayBindingPattern带iteratorRecord和environment参数的
   IteratorBindingInitialization
3. 如果iteratorRecord.\[\[Done]]是false，返回?IteratorClose(iteratorRecord, result)
4. 返回result。

ObjectBindingPattern : { }
1. 返回NormalCompletion(empty)

ObjectBindingPattern : 
    { BindingPropertyList }
    { BindingPropertyList , }
1. 执行BindingPropertyList带value和environment参数的?PropertyBindingInitialization
2. 返回NromalCompletion(empty)

ObjectBindingPattern : { BindingRestProperty }
1. 让excludeNames是新的空List
2. 返回BindingRestProperty带value、environment和excludedNames参数的
   RestBindingInitialization

ObjectBindingPattern : { BindingPropertyList , BindingRestProperty }
1. 让excludedNames是BindingPropertyList带value和environment参数的
   ?PropertyBindingInitialization
2. 返回BindingRestProperty带value、environment和excludedNames参数的
   RestBindingInitialization
**** InitializeBoundName(name, value, environment)
抽象操作InitializeBoundName接受参数name、value和environment。被调用时执行下列步骤：
1. Assert：Type(name)是String
2. 如果environment不是undefined，那么
    a. 执行environment.InitializeBinding(name, value)
    b. 返回NormalCompletion(undefined)
3. 否则
    a. 让lhs是ResolveBinding(name)
    b. 返回?PutValue(lhs, value)
*** 运行时语义：IteratorBindingInitialization
带参数iteratorRecord和environment
**** 注意 给environment传递undefined表明PutValue操作应该被赋予初始化值。这种情况
           发生在非严格模式下函数的形式参数中。在这情况形式参数法绑定被
           提升了，而且在评估其初始化前就已经提前初始化了。
ArrayBindingPattern : [ ]
1. 返回NormalCompletion(empty)

ArrayBindingPattern : [ Elision ]
1. 返回Elsion带iteratorRecord参数的IteratorDestructuringAssignmentEvaluation

ArrayBindingPattern : [ Elision_opt BindingRestElement ]
1. 如果Elision存在，那么
    a. 执行Elision带iteratorRecord参数的?IteratorDestructuringAssignmentEvaluation
2. 返回BindingRestElement带iteratorRecord和Environment参数的
   IteratorBindingInitialization

ArrayBindingPattern : [ bindingElementList , elision ]
1. 执行BindingElementList带iteratorRecord和environment参数的
   ?IteratorBindingInitialization
2. 返回Elision带iteratorRecord参数的IteratorDestructuringAssignmentEvaluation

ArrayBindingPattern : [ BindingElementList , Elision_opt BindingRestElement ]
1. 执行BindingElementList带iteratorrecord和environment的
   ？IteratorBindingInitialization
2. 如果Elision存在，那么
    a. 执行Elision带iteratorRecord参数的?IteratorDestructuringAssignmentEvaluation
3. 返回BindingRestElement带iteratorRecord和environment参数的
   IteratorBindingInitialization

BindingElementList : BindingElementList , BindingElisionElement
1. 执行BindingElementList带iteratorRecord和environment参数的
   ?IteratorBindingInitialization
2. 返回BindingElisionElement带iteratorRecord和environment参数的
   IteratorBindingInitialization

BindingElisionElement : Elision BindingElement
1. 执行Elision带iteratorRecord参数的?IteratorDestructuringAssignmentEvaluation
2. 返回BindingElement带iteratorRecord和environment参数的IteratorBindingInitialization

SingleNameBinding : BindingIdentifier Initializer_opt
1. 让bindingId是BindingIdentifier的String值
2. 让lhs是?ResolveBinding(bindingId, environment)
3. 如果iteratorRecord.\[\[Done]]是false，那么
    a. 让next是IteratorStep(iteratorRecord)
    b. 如果next是意外完结，设置iteratorRecord.\[\[Done]]是true
    c. ReturnIfAbrupt(next)
    d. 如果next是false，设置iteratorRecord.\[\[Done]]是true
    e. 否则
        i. 让v是IteratorValue(next)
       ii. 如果v是意外完结，设置iteratorRecord.\[\[Done]]是true
      iii. ReturnIfAbrupt(v)
4. 如果iteratorRecord.\[\[Done]]是true，让v是undefined
5. 如果Initializer存在，而且v是undefined，那么
    a. 如果IsAnonymousFunctionDefinition(initializer)是true，那么
        i. 设置v是Initializer带bindingId参数的NamedEvaluation
    b. 否则
        i. 让defaultValue是Initializer的评估结果
       ii. 设置v是?GetValue(defaultValue)
6. 如果environment是undefined，返回?PutValue(lhs, v)
7. 返回InitializeReferenceBinding(lhs, v)

BindingElement : BindingPattern Initializer_opt
1. 如果iteratorRecord.\[\[Done]]是false，那么
    a. 让next是IteratorStep(iteratorRecord)
    b. 如果next是意外完结，设置iterator.\[\[Done]]是true
    c. ReturnIfAbrupt(next)
    d  如果next是false，设置iteratorRecord.\[\[Done]]是true
    e. 否则
        i. 让v是IteratorValue(next)
       ii. 如果v是意外完结，设置iteratorRecord.\[\[Done]]是true
      iii. ReturnIfAbrupt(v)
2. 如果iteratorRecord.\[\[Done]]是true，让v是undefined
3. 如果Initializer存在，而且v是undefined，那么
    a. 让defaultValue是评估Initializer的评估
    b. 设置v是?GetValue(defaultValue)
4. 返回BindigPattern带v和environment参数的BindingInitialization

BindingRestElement : ...BindingIdentifier
1. 让lhs是?ResolveBinding(BindingIdentifier的String值，environment)
2. 让A是!ArrayCreate(0)
3. 让n是0
4. Repeat
    a. 如果iteratorRecord.\[\[Done]]是false，那么
        i. 让next是IteratorStep(iteratorRecord)
       ii. 如果next是意外完结，设置iteratorRecord.\[\[Done]]是true
      iii. ReturnIfAbrupt(next)
       iv. 如果next是false，设置iteratorRecord.\[\[Done]]是true
    b. 如果iteratorRecord.\[\[Done]]是true，那么
        i. 如果environment是undefined，返回?PutValue(lhrs, A)
       ii. 返回InitializeReferencedBinding(lhr, A)
    c. 让nextValue是IteratorValue(next)
    d. 如果nextValue是意外完结，设置iteratorRecord.\[\[Done]]是true
    e. ReturnIfAbrupt(nextValue)
    f. 执行!CreateDataPropertyOrThrow(A, !ToString(F(n)), nextValue)
    g. 设置n是n+1

BindingRestElement : ...BindingPattern
1. 让A是!ArrayCreate(0)
2. 让n是0
3. Repeat
    a. 如果iteratorRecord.\[\[Done]]是false，那么
        i. 让next是IteratorStep(iteratorRecord)
       ii. 如果next是意外完结，设置iteratorRecord.\[\[Done]]是true
      iii. ReturnIfAbrupt(next)
       iv. 如果next是false，设置iteratorRecord.\[\[Done]]是true
    b. 如果iteratorRecord.\[\[Done]]是true，那么
        i. 如果environment是undefined，返回?PutValue(lhrs, A)
       ii. 返回InitializeReferencedBinding(lhr, A)
    c. 让nextValue是IteratorValue(next)
    d. 如果nextValue是意外完结，设置iteratorRecord.\[\[Done]]是true
    e. ReturnIfAbrupt(nextValue)
    f. 执行!CreateDataPropertyOrThrow(A, !ToString(F(n)), nextValue)
    g. 设置n是n+1

FromalParameters : [empty]
1. 返回NormalCompletion(empty)

FormalParameters : FormalParameterList , FunctionRestParameter
1. 执行FormalParameterList带iteratorRecord和environment参数的
   ?IteratorBindingInitialization
2. 返回FunctionRestParameter带iteratorRecord和environment参数的
   IteratorBindingInitialization

FormalParameterList : FormalParameterList , FormalParameter
1. 执行FormalParameterList带iteratorRecord和environment参数的
   ?IteratorBindingInitialization
2. 返回FormalParameter带iteratorRecord和environment参数的IteratorBindingInitialization

ArrowParameters : BindingIndetifier
1. Assert：iteratorRecord.\[\[Done]]是false
2. 让next是IteratorStep(iteratorRecord)
3. 如果next是意外完结，设置iteratorRecord.\[\[Done]]是true
4. ReturnIfAbrupt(next)
5. 如果next是false，设置iteratorRecord.\[\[Done]]是true
6. 否则
    a. 让v是IteratorValue(next)
    b. 如果v是意外完结，设置iteratorRecord.\[\[Done]]是true
    c. ReturnIfAbrupt(v)
7. 如果iteratorRecord.\[\[Done]是true，让v是undefined
8. 返回BindingIdentifier带v和environment参数的BindingInitialization

ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList
1. 让formals是CoverParenthesizedExpressionAndArrowParameterList的CoveredFormalsLst
2. 返回formals带iteratorRecord和environment参数的IteratorBindingInitialization

AsyncArrowBindingIdentifier : BindingIdentifier
1. Assert：iteratorRecord.\[\[Done]]是false
2. 让next是IteratorStep(iteratorRecord)
3. 如果next是意外完结，设置iteratorRecord.\[\[Done]]是true
4. ReturnIfAbrupt(next)
5. 如果next是false，设置iteratorRecord.\[\[Done]]是true
6. 否则
    a. 让v是IteratorValue(next)
    b. 如果v是意外完结，设置iteratorRecord.\[\[Done]]是true
    c. ReturnIfAbrupt(v)
7. 如果iteratorRecord.\[\[Done]]是true，让v是undefined
8. 返回BindingIdentifier带v和environment参数的Bindinginitialization
*** 静态语义：AssignmentTargetType
IdentifierReference : identifier
1. 如果IdentifierReference在严格模式里，而且Identifier的String值是"eval"或"arguments"，
   返回invalid
2. 返回 simple

IdentifierReference : 
    yield
    await
CallExpression : 
    CallExpression [ Expression ]
    CallExpression . IdentifierName
MemberExpression :
    MemberExpression [ Expression ]
    MemberExpression . IdentifierName
    SuperProperty
1. Return simple

PrimaryExpression :
    CoverParenthesizedExpressionAndArrowParameterList
1. 让expr是CoverParenthesizedExpressionAndArrowParameterList
2. 返回expr的AssignmentTargetType

PrimaryExpression : 
    this
    Literal
    ArrayLiteral
    ObjectLiteral
    FunctionExpression
    ClassExpression
    GeneratorExpression
    AsyncFunctionExpression
    AsyncGeneratorExpression
    RegularExpressionLiteral
    TempalteLiteral
CallExpression :
    CoverCallExpressionAndAsyncArrowHead
    SuperCall
    ImportCall
    CallExpression Arguments
    CallExpression TempalteLiteral
NewExpression :
    new NewExpression
MemberExpression :
    memberExpression TempalteLiteral
    new MemberExpression Arguments
NewTarget :
    new . target
ImportMeta :
    import . meta
LeftHandSideExpression :
    OptionalExpression
UpdateExpression :
    LeftHandSideExpression ++
    LeftHandSideExpression --
    ++ UnaryExpression
    -- UnaryExpression
UnaryExpression :
    delete UnaryExpression
    void UnaryExpression
    typeof UnaryExpression
    + UnaryExpression
    - UnaryExpression
    ~ UnaryExpression
    ! UnaryExpression
    AwaitExpression
ExponentiationExpression :
    UpdateExpression ** ExponentiationExpression
MultiplicativeExpression :
    MultiplicativeExpression MultiplicativeOperator ExponentiationExpression
AdditiveExpression :
    AdditiveExpression + MultiplicativeExpression
    AdditiveExpression - MultiplicativeExpression
ShiftExpression :
    ShiftExpression \<\< AdditiveExpression
    ShiftExpression \>\> AdditiveExpression
    ShiftExpression \>\>\> AdditiveExpression
RelationalExpression :
    RelationalExpression \< ShiftExpression
    RelationalExpression \> ShiftExpression
    RelationalExpression \<\= ShiftExpression
    RelationalExpression \>\= ShiftExpression
    RelationalExpression instanceof ShiftExpression
    RelationalExpression in ShiftExpression
EqualityExpression : 
    EqualityExpression \=\= RelationalExpression
    EqualityExpression \!\= RelationalExpression
    EqualityExpression \=\=\= RelationalExpression
    EqualityExpression \=\=\= RelationalExpression
BitwiseANDExpression :
    BitwiseANDExpression & EqualityExpression
BitwiseXORExpression :
    BitwiseXORExpression ^ BitwiseANDExpreesion
BitwiseOrExpression :
    BitwiseORExpression | BitwiseXORExpression
LogicalANDExpression :
    LogicalANDExpression && BitwiseORExpression
LogicalORExpression :
    LogicalORExpression || LogicalANDExpression
CoalesceExpression :
    CoalesceExpressionHead ?? BitwiseORExpression
ConditionalExpression :
    ShortCircuitExpression ? AssignmentExpression : AssignmentExpression
AssignmentExpression :
    YieldExpression
    ArrowFunction
    AsyncArrowFunction
    LeftHandSideExpression = AssignmentExpression
    LeftHandSideExpression AssignmentOperator AssignmentExpression
    LefthandSideExpression &&= AssignmentExpression
    LeftHandSizeExpression ||= AssignmentExpression
    LeftHandSideExpression ??= AssignmentExpression
Expression :
    Expression, assignmentExpression
1. 返回invalid
*** 静态语义：PropName
PropertyDefinition : IdnetifierReference
1. 返回IdentifierRefrence的String值。

PropertyDefinition : ... AssignmentExpression
1. 返回empty

PropertyDefinition : Propertyname : AssignmentExpression
1. 返回PropertyName的PropName

LiteralPropertyName : IdentifierName
1. 返回StringLiteral的String值

LiteralPropertyName : NumericLiteral
1. 让nbr是NumericLiteral的numericValue
2. 返回!ToString(nbr)

ComputedPropertyName : [ AssignmentExpression ]
1. 返回empty

MethodDefinition : 
    PropertyName ( UniqueFormalParameters ) { FunctionBody }
    get PropertyName ( ) { FunctionBody }
    set PropertyName ( PropertySetParameterList ) { FunctionBody }
1. 返回PopertyName的PropName

GeneratorMethod : * PropertyName ( UniqueFormalParameters ) { GeneratorBody }
1. 返回PopertyName的PropName

AsyncGenratorMethod : 
    async * PropertyName ( UniqueFormalParameters ) { AsyncGeneratorBody }
1. 返回PopertyName的PropName

ClassElment : ;
1. 返回empty

Asyncmethod : async PropertyNae ( UniqueFormalParameters ) { AsyncFunctionBody }
1. 返回PopertyName的PropName
* 可执行代码与执行背景（执行上下文 Execution Contexts）
** 环境记录 Environment Records
EnvironmentRecord是用在基于ECMAScript代码的词法嵌套结构上定义Identifiers与指定
的变量、函数的联结关系的规范类型。通常EnvironmentRecord被联结到ECMAScript代码
的特定句法结构，比如：FunctionDeclaration、blockStatement或者TryStatement的Catch
语句。这些代码每次被评估时，新的EnvironmentRecord就被创建出来记录被代码创建
处理的identifier的绑定关系。

每个EnvironmentRecord都有一个\[\[OterEnv]]字段，可能是null或者一个指向外层
EnvironmentRecord的引用。（内层）EnvironmentRecord的这个外层引用指向逻辑上包围了
这个内层EnvironmentRecord的EnvironmentRecord，当然，这个外层EnvironmentRecord还有
自己的外层EnvironmentRecord。一个环境记录服务多个内层环境记录。例如，一个
FunctionDeclaration包含了两个嵌套的FunctionDelaration，那么每个嵌套函数的
EnvironmentRecord都由这个外层函数的当前评估的EnvironmentRecord作为自己的外层
EnvironmentRecord。

EnvironmentRecord是纯粹的规范机制，没有必要与ECMAScript实现中的任何活一致。
ECMAScript程序不可以直接访问或者修改环境记录值。
*** 环境记录类型的层次体系
EnvironmentRecord可以被认为是一个简单的面向对象的层级结构，其中
EnvironmentRecord是一个抽象类，有三个实现的子类：declarative EnvironmentRecord, 
object EnvironmentRecord, global EnvironmentRecord。function EnvironmentRecord和 module
EnvironmentRecord是declarative EnvironmentRecord的子类。
. EnvironmentRcord(抽象的）
    。declarative EnvironmentRecord是用于定义ECMAScript语言中例如
      FunctionDeclaration，VariableDeclaration和Catch语句等直接联结标识符与
      ECMAScript语言值的句法元素的效果。
        . function EnvironmentRecord与ECMAScript函数对象的调用一致，且包含这个
          函数内的顶层声明的绑定。可能建立一个新的this绑定。为了支持super
          方法的调用，还会捕获必要的状态。
        . module EnvironmentRecord包含了Module内的顶层声明的绑定。也包含了被
          Module显式引入的绑定。其\[\[OuterEnv]]是global EnvironmentRecord。
    。object EnvironmentRecord用于定义例如WithStatement这种用于联结标识符与某些
      对象性质的ECMAScript元素的效果。
    。global EnvironmentRecord用于Script的全局声明。它没有外层环境，其
      \[\[OuterEnv]]是null。它可以预填充标识符绑定，而且包括一个联结的全局对象
      其性质提供了这个全局环境的某些标识符绑定。当ECMAScript代码被执行了，
      额外的性质有可能被增加到全局对象中，而且其初始性质也会被修改。

EnvironmentRecord抽象类包含了定义在表17中的抽象规范方法。这些抽象方法在每个
具体子类里有确切的具体算法。
| 方法                         | 目的                                                                                                                                                                                                                                                |
| HasBinding(N)                | 明确EnvironmentRecord是否含有String值N的绑定。如果有返回true，否则返回false                                                                                                                                                                         |
| CreateMutableBinding(N, D)   | 在EnvironmentRecord中创建一个新的没有初始化的可修改绑定。String值N是绑定的名称。Boolean参数D是true的话，这个绑定可能会被随后删除。                                                                                                                  |
| CreateImmutableBinding(N, S) | 在EnvironmentRecord中创建一个新的没有初始化的可修改绑定。String值N是绑定的名称。如果S是true的话，那么在其初始化之后试图赋值时会投掷异常，不管这个操作的严格模式设置。                                                                               |
| InitializeBinding(N, V)      | 在EnvironmentRecord中设置一个已经存在但是没有初始化的绑定的值。String值N是绑定的名称。ECMAScript语言类型值V是这个绑定的值。                                                                                                                         |
| SetMutableBinding(N, V, S)   | 在EnvironmentRecord中设置一个已经存在的可修改绑定。String值N是绑定的名称。ECMAScript语言类型值V是这个绑定的值。S是Boolean值标记。如果S是true，这个绑定不会因设置值而投掷TypeError异常                                                               |
| GetBindingValue(N, S)        | 返回EnvironmentRecord中一个已经存在的绑定的值。String值N是绑定的名称。S用于标识引用源于严格模式或这其他要求严格模式的语义。如果S是true，且绑定不存在，会投掷ReferenceError异常。如果绑定存在，但是没有初始化，无论S何值，都会投掷ReferenceError异常 |
| DeleteBinding(N)             | 从EnvironmentRecord中删除一个绑定。String值N是绑定的名称。如果绑定#N存在，能移除这个绑定，就返回true；不能移除就返回false。如果绑定不存在，返回true                                                                                                  |
| HasThisBinding()             | 明确EnvironmentRecord建立了this绑定。如果建立了返回true，否则返回false。                                                                                                                                                                            |
| HasSuperBinding()            | 明确EnvironmentRecord建立了super方法绑定。如果建立了返回true，否则返回false。                                                                                                                                                                       |
| WithBaseObject()             | 如果EnvironmentRecord联结的with语句，返回这个with对象，否则返回undefined。                                                                                                                                                                                              |
**** Declarative Environment Records 
每个DelcarativeEnvironmentRecord联结一个ECMAScript程序圈，包含：variable、
constant、let、class、module、import及function声明。DeclarativeEnvironmentRecord
绑定了这个圈内被声明定义的整套标识符。

DeclarativeEnvironmentRecords的具体规范方法的行为在下方算法中定义。
***** HasBinding(N)
DeclarativeEnvironmentRecord envRec的HasBinding方法接受参数N（String）。明确
参数标识是否已经绑定在记录中。被调用时执行下列步骤：
1. 如果envRec有标识的名字与N一致，返回true。
2. 返回false。
***** CreateMutalbeBinding(N, D)
DeclarativeEnvironmentRecord envRec的CreateMutableBinding方法接受参数N（String）和
D（Boolean）。创建一个可变的名字为N的未初始化绑定。这个EnvironmentRecord必须要
没有名称N的绑定。如果D是true，这个新的绑定标记为可删除的。被调用时执行
下列步骤：
1. Assert：envRec没有绑定#N
2. 在envRec上创建可变绑定#N，并且记为未初始化的。如果D是true，记录这个新建的
   绑定会被随后的DeleteBinding调用删除。
3. 返回NormalCompletion(empty)
***** CreateImmutableBinding(N, s)
DeclarativeEnvironmentRecord envRec的CreateImmutableBinding方法接受参数N（String）
和S（Boolean）。创建一个不变的名字为N的未初始化绑定。这个EnvironmentRecord必须
没有名称N的绑定。如果S是true，这个新的绑定被标记为严格绑定。被调用时执行
下列步骤：
1. Assert：envRec没有绑定#N
2. 在envRec上创建不变绑定#N，并且记为未初始化的。如果S是true，记录这个新建的
   绑定是严格绑定。
3. 返回NormalCompletion(empty)
***** InitializeBinding(N, V)
DeclarativeEnvironmentRecord envRec的InitializeBinding方法接受参数N（String）和
V（ECMAScript语言值）。用于将绑定#N的值替换为V。未初始化的绑定#N必须已经存在。
被调用时执行下列步骤：
1. Assert：envRec必须有未初始化的绑定#N
2. 设置envRec上绑定#N的值为V
2. 记录envRec上绑定#N已经初始化。
3. 返回NormalCompletion(empty)
***** SetMutableBinding(N, V, S)
DeclarativeEnvironmentRecord envRec的SetMutableBinding方法接受参数N（String）、
V（ECMAScript语言值）和S（Boolean）。尝试将绑定#N的当前值替换为参数V的值。
绑定#N通常已经存在，但在罕见的情况下也可能没有。如果绑定#N是不变绑定，且
S是true，会投掷一个TypeError异常。被调用时执行下列步骤：
1. 如果envRec没有绑定#N，那么
    a. 如果S是true，投掷一个ReferenceError异常
    b. 执行envRec.CreateMutableBinding(N, true)
    c. 执行envRec.InitializeBinding(N, V)
    d. 返回 NormalCompletion(empty)
2. 如果envRec的绑定#N是严格绑定，设置S是true。
3. 如果envRec的绑定#N还没有初始化，投掷ReferenceError异常
4. 如果envRec的绑定#N是可变绑定，修改其值为V
5. 否则
    a. Assert：此时试图修改一个不变绑定的值
    b. 如果S是true，投掷TypeError异常
6. 返回NormalCompletion(empty)
****** 注意 会因为缺失绑定触发步骤1的ECMAScript代码：
             function f() { eval("var x; x = (delete x, 0);"); }
***** GetBindingValue(N, S)
DeclarativeEnvironmentRecord envRec的GetBindingValue方法接受参数N（String）和
S（Boolean）。返回envRec上绑定#N的值。如果绑定存在但是没有初始化，会投掷
ReferenceError异常，无论S的值。被调用时执行下列步骤：
1. Assert：envRec有绑定#N
2. 如果envRec的绑定#N没有初始化，投掷ReferenceError异常
3. 返回envRec的绑定#N的值。
***** DeleteBinding(N)
DeclarativeEnvironmentRecord envRec的DeleteBinding方法接受参数N（String）。只能删除
已经明确指定为可删除的绑定。被调用时执行下列步骤：
1. Assert：envRec有绑定#N
2. 如果envRec的绑定#N不可删除，返回false
3. 从envRec上移除绑定#N
4. 返回true
***** HasThisBinding()
DeclarativeEnvironmentRecord envRec的HasThisBinding方法不接受参数。被调用时执行
下列步骤：
1. 返回false。
****** 注意 一个合规的DeclarativeEnvironmentRecord（既不是FuncitonEnvironmentRecord
            也不是ModuleEnvironmentRecord）不会提供this的绑定
***** HasSuperBinding()
DeclarativeEnvironmentRecord envRec的HasSuperBinding方法不接受参数。被调用时执行
下列步骤：
1. 返回false。
****** 注意 一个合规的DeclarativeEnvironmentRecord（既不是FuncitonEnvironmentRecord
            也不是ModuleEnvironmentRecord）不会提供super的绑定
***** WithBaseObject()
DeclarativeEnvironmentRecord envRec的WithBaseObject方法不接受参数。被调用时执行
下列步骤：
1. 返回undefined。
**** Object Environment Records
每个ObjectEnvironmentRecord被联结到对象，这个对象称为绑定对象。一个
ObjectEnvironmentRecord绑定标识名称的集合，名称对应绑定绑定对象的性质名。性质
键不是字符串形式的标识名不包含在绑定标识中。自有的和继承的性质都包含这个
集合中无论其\[\[Enumrable]]属性是否。因为性质可以动态的在对象上添加和删除，
被ObjectEnvironmentRecord绑定的标识集合会潜在的变动，作为性质增加或删除的副
作用。任何因为这种副作用创建的绑定被认为是可修改的绑定，即使其
\[\[Writable]]属性是fasle。不变绑定不存在于ObjectEnvironmentRecord中。

为with语句创建的ObjectEnvironmentRecord在函数调用中提供绑定对象作为隐式的
this值。这个能力受联结在ObjectEnvironmentRecord上的Boolean值withEnvrionment的控
制。其默认值是false。

ObjectEnvironmentRecords的具体规范方法的行为在下方算法中定义。  
***** HasBinding(N)
ObjectEnvironmentRecord envRec的HasBinding方法接受参数N（String）。明确
参数标识是否已经绑定在记录中。被调用时执行下列步骤：
1. 让bindings是envRec的绑定对象
2. 让foundBinding是?HasProperty(bindings,N)
3. 如果foundBinding是false，返回false
4. 如果envRec.withEnvironment是false，返回true
5. 让unscopables是?Get(bindings, @@unscopables)
6. 如果Type(unscopables)是Object，那么
    a. 让blocked是!ToBoolean(?Get(unscopables, N))
    b. 如果blocked是true，返回true
7. 返回true
***** CreateMutalbeBinding(N, D)
ObjectEnvironmentRecord envRec的CreateMutableBinding方法接受参数N（String）和
D（Boolean）。在联结的绑定对象中创建一个名字为N，值为undefined的性质。如果
D是true，这个新性质的\[\[Configurable]]设为true，否则设为false。被调用时执行
下列步骤：
1. 让bindings是envRec的绑定对象
2. 返回?DefinePropertyOrThrow(bindings, N, PropertyDescriptor { \[\[Value]]:undefined,
   \[\[Wriable]]:true, \[\[Enumerable]]:true, \[\[Configurable]]:D }
****** 注意 通常envRec没有N绑定，但是如果有的话，DefinePropertyOrThrow的语义
             会导致已存在的绑定被替换、遮蔽，或者引发返回意外完结
***** CreateImmutableBinding(N, S)
ObjectEnvironmentRecord envRec的CreateImmutableBinding按照本规范不会被使用。
***** InitializeBinding(N, V)
ObjectEnvironmentRecord envRec的InitializeBinding方法接受参数N（String）和
V（ECMAScript语言值）。用于将绑定#N的值替换为V。未初始化的绑定#N必须已经存在。
被调用时执行下列步骤：
1. 返回?envRec.SetMutableBinding(N, V, false)
****** 注意 在本规范中，使用ObjectEnvironmentRecord的CreateMutableBinding时都会
             立即跟随InitializeBinding操作。因此本规范不用显式的追踪
             ObjectEnvironmentRecord上绑定的初始化状态。
***** SetMutableBinding(N, V, S)
ObjectEnvironmentRecord envRec的SetMutableBinding方法接受参数N（String）、
V（ECMAScript语言值）和S（Boolean）。尝试将EnvironmentRecord的绑定对象的性质N
的当前值替换为参数V的值。性质N通常已经存在，但是如果没有或者目前不可写，
由S决定错误如何处理。被调用时执行下列步骤：
1. 让bindings是envRec的绑定对象
2. 让stillExists时?hasProperty(bindings, N)
3. 如果stillExists是false且S是true，投掷ReferenceError异常
4. 返回?Set(bindings, N, V, S)
***** GetBindingValue(N, S)
ObjectEnvironmentRecord envRec的GetBindingValue方法接受参数N（String）和
S（Boolean）。返回绑定对象性质N的值。性质应该已经存在，如果没有，则结果依赖
S。被调用时执行下列步骤：
1. 让bindings是envRec的绑定对象
2. 让value是?HasProperty(bindings, N)
3. 如果value是false，那么
    a. 如果S是false，返回undefined，否则投掷ReferenceError异常
5. 返回?Get(bindings, N)
***** DeleteBinding(N)
ObjectEnvironmentRecord envRec的DeleteBinding方法接受参数N（String）。只能删除
绑定对象的性质N的\[\[Configurable]]是true的绑定。被调用时执行下列步骤：
1. 让bindings是envRec的绑定对象
2. 返回?bindings.\[\[Delete]](N)
***** HasThisBinding()
ObjectEnvironmentRecord envRec的HasThisBinding方法不接受参数。被调用时执行
下列步骤：
1. 返回false。
****** 注意 ObjectEnvironmentRecord不会提供this的绑定
***** HasSuperBinding()
ObjectEnvironmentRecord envRec的HasSuperBinding方法不接受参数。被调用时执行
下列步骤：
1. 返回false。
****** 注意 ObjectEnvironmentRecord不会提供super的绑定
***** WithBaseObject()
ObjectEnvironmentRecord envRec的WithBaseObject方法不接受参数。被调用时执行
下列步骤：
1. 如果envRec的withEnvironment标记是true，返回envRec的绑定对象
2. 否则，返回undefined。
**** FunctionEnvironmentRecord
FunctionEnvironmentRecord是一个DeclarativeEnvironmentRecord，用于标识一个函数的
顶层圈。如果函数不是ArrowFunction，提供一个this绑定。如果不是ArrowFunction，
而且引用了super，其FunctionEnvironmentRecord应该包含能够在函数内执行super方法
调用的状态。

FunctionEnvironmentRecords有表18列出的额外状态字段。
| 字段名                  | 值                                            | 含义                                                       |
| \[\[ThisValue]]         | 任何值                                        | 这是函数调用时的this值                                     |
| \[\[ThisBindingStatus]] | lexical \vert initialized \vert uninitialized | 如果是lexical，这就是一个ArrowFunction，不需要本地的this值 |
| \[\[FunctionObject]]    | Object                                        | 因其调用导致本EnvironmentRecord创建的函数对象              |
| \[\[NewTarget]]         | Object \vert undefined                        | 如果本EnvironmentRecord被\[\[Construct]]内部方法创建的，则\[\[NewTarget]]是\[\[Construct]]的newTarget参数值。否则就是undefined。 |

FunctionEnvironmentRecord支持DeclarativeEnvironmentRecord在表17列出的全部方法。
除了HasThisBinding和HasSuperBinding，其算法也与DeclarativeEnvironmentRecord的一致。
FunctionEnvironmentRecord还额外支持列在表19的方法。
| 方法             | 目的                                                                                                               |
| BindThisValue(V) | 设置\[\[ThisValue]]并记录为已经初始化的                                                                            |
| GetThisBinding() | 返回本EnvironmentRecords的this绑定。如果this绑定没有初始化，投掷ReferenceError异常                                 |
| GetSuperBase()   | 返回本EnvironmentRecord绑定作为super性质访问的基础的这个对象。如果是undefined，表明super性质访问会产生运行时错误。 |

FunctionEnvironmentRecord的具体规范方法的行为定义如下列算法
***** BindThisValue(V)
FunctionEnvironmentRecord envRec的BindThisValue方法接受参数V（ECMAScript语言值）。
被调用时执行下列步骤：
1. Assert：envRec.\[\[ThisBindingStatus]]不是lexical
2. 如果envRec.\[\[ThisBindingStatus]]是initialized，投掷ReferenceError异常
3. 设置envRec.\[\[ThisValue]]为V
4. 设置envRec.\[\[ThisBindingStatus]]为initialized
5. 返回V
***** HasThisBinding()
FunctionEnvironmentRecord envRec的HasThisBinding方法不接受参数。被调用时执行
下列步骤：
1. 如果envRec.\[\[ThisBindingStatus]]是lexical，返回false；否则返回true
***** HasSuperBinding()
FunctionEnvironmentRecord envRec的HasSuperBinding方法不接受参数。被调用时执行
下列步骤：
1. 如果envRec.\[\[ThisBindingStatus]]是lexical，返回false
2. 如果envRec.\[\[FunctionObject]].\[\[HomeObject]]是undefined，返回false；
   否则返回true。
***** GetThisBinding()
FunctionEnvironmentRecord envRec的GetThisBinding方法不接受参数。被调用时执行
下列步骤：
1. Assert：envRec.\[\[ThisBindingStatus]]不是lexical
2. 如果envRec.\[\[ThisBindingStatus]]是uninitialized，投掷ReferenceError异常
3. 返回envRec.\[\[ThisValue]]
***** GetSuperBase()
FunctionEnvironmentRecord envRec的GetSuperBase方法不接受参数。被调用时执行
下列步骤：
1. 让home是envRec.\[\[FunctionObject]].\[\[HomeObject]]
2. 如果home是undefined，返回undefined
3. Assert：Type(home)是Object
4. 返回?home.\[\[GetPrototypeOf]]()
**** Global Environment Record
GlobalEnvironmentRecord用于表示最外层的被运行在普通领的ECMAScript的Script元素
共用的圈。GlobalEnvironmentRecord提供了内建global（条款19）的绑定，全局对象的
性质，和在Script中发生的顶层声明（见于8.1.9、8.1.11）

GlobalEnvironmentRecord是逻辑上的单一记录，但是规定为ObjectEnvironmentRecord和
DeclarativeEnvironmentRecord的组合封装。ObjectEnvironmentRecord将联结的RealmRecord
的全局对象作为其基础的对象。这个全局对象是GlobalEnvironmentRecord的
GetThisBinding方法的返回值。GlobalEnvironmentRecord的ObjectEnvironmentRecord组件包
含所有内建global（条款19）的绑定和全局代码的FunctionDeclaration、
GeneratorDeclaration、AsyncFunctionDeclaration、AsyncGeneratorDeclaration或者
VariableStatement引入的绑定。至于全局代码的其他ECMAScript声明产生的绑定包含在
GlobalEnvironmentRecord的DeclarativeEnvironmentRecord组件里。

可以直接在全局对象上创建性质。因此GlobalEnvironmentRecord的
ObjectEnvironmentRecord组件会包含被FunctionDeclaration、GeneratorDeclaration、
AsyncFunctionDeclaration、AsyncGeneratorDeclaration或者VariableDeclaration声明显式
创建的绑定和全局对象性质隐式创建的绑定。为了区分哪些是声明显式创建的绑
定，GlobalEnvironmentRecord维护了一个由使用CreateGlobalVarBinding和
CreateGlobalFunctionBinding方法绑定的名称构成的List。

GlobalEnvironmentRecord还有列在表20的添加字段和列在表21的添加方法。
| 字段名                  | 值                           | 含义                                                                                                                                                                      |
| \[\[ObjectRecord]]      | ObjectEnvironmentRecord      | 其绑定对象是全局对象。包含联结领上的全局代码的FunctionDeclaration、GeneratorDeclaration、AsyncFunctionDeclaration、AsyncGeneratorDeclaration及VariableDeclaration产生的绑定 |
| \[\[GlobalThisValue]]   | Object                       | 由全局圈的this返回的值。主机可能返回任何ECMAScript对象值。                                                                                                                |
| \[\[DeclarativeRecord]] | DeclarativeEnvironmentRecord | 包含联结领上的全局代码的除FunctionDeclaration、GeneratorDeclaration、AsyncFunctionDeclaration、AsyncGeneratorDeclaration及BariableDeclaration外的声明产生的绑定 |
| \[\[VarNames]]          | List<String>                 | 联结领上的全局代码的FunctionDeclaration、GeneratorDeclaration、AsyncFunctionDeclaration、AsyncGeneratorDeclaration及VariableDeclaration产生的绑定的名称List |

| 方法                                 | 意图                                                                                                                                                                                                                                                                                                     |
| GetThisBinding()                     | 返回本EnvironmentRecord的this绑定                                                                                                                                                                                                                                                                        |
| HasVarDeclaration(N)                 | 明确本EnvironmentRecord的绑定#N是否由VariableDeclaration,FunctionDeclaration,GeneratorDeclaration,AsyncFunctionDeclaration,AsyncGeneratorDeclaration产生的。                                                                                                                                              |
| HasLexicalDeclaration(N)             | 明确本EnvironmentRecord的绑定#N是否由LexicalDeclaration或者ClassDeclaration产生的。                                                                                                                                                                                                                       |
| HasRestrictedGlobalProperty(N)       | 明确全局对象上的性质N能否被全局文法绑定遮蔽                                                                                                                                                                                                                                                              |
| CanDeclareGlobalVar(N)               | 明确相应的CreateGlobalVarBinding带参数N的调用能否成功                                                                                                                                                                                                                                                    |
| CanDeclareGlobalFunction(N)          | 明确相应的CreateGlobalFunctionBinding带参数N的调用能否成功                                                                                                                                                                                                                                               |
| CreteGlobalVarBinding(N, D)          | 用于在GlobalEnvironmentRecord的\[\[ObjectRecord]]组件上创建并初始化为undefined的全局var绑定。这是个可变绑定。相应的全局对象的性质有对var合适的属性。String值N是绑定的名称。如果D是true，这个绑定可以被删除。逻辑上与CreateMutableBinding紧接着SetMutableBinding的效果一样，但是它允许特殊对待var声明。   |
| CreateGlobalFunctionBinding(N, V, D) | 用于在GlobalEnvironmentRecord的\[\[ObjectRecord]]组件上创建并初始化一个全局function。这是个可变绑定。相应的全局对象的性质有对function合适的属性。String值N是绑定的名称。如果D是true，这个绑定可以被删除。逻辑上与CreateMutableBinding紧接着SetMutableBinding的效果一样，但是它允许特殊对待function声明。 |

GlobalEnvironmentRecord的具体规范方法的行为由下列算法定义。
***** HasBinding(N)
GlobalEnvironmentRecord envRec的HasBinding方法接受参数N（String值）。明确本记
录是否有绑定的名称与参数值一致。被调用时执行下列步骤：
1. 让DclRec是envRec.\[\[DeclarativeRecord]]
2. 如果DclRec.HasBinding(N)是true，返回true
3. 让ObjRec是envRec.\[\[ObjectRecord]]
4. 返回?ObjRec.HasBinding(N)
***** CreateMutableBinding(N, D)
GlobalEnvironmentRecord envRec的CreateMutableBinding方法接受参数N（String值）和
D（Boolean）。创建一个新的名字为N的未初始化的可变绑定。创建在联结的
DeclarativeRecord中。执行前绑定#N不应存在于本DeclarativeRecord。如果D是true，
这个新的绑定可以被删除。被调用时执行下列步骤：
1. 让DclRec是envRec.\[\[DeclarativeRecord]]
2. 如果DclRec.HasBinding(N)是true，投掷TypeError异常
3. 返回DclRec.CreateMutableBinding(N, D)
***** CreateImmutableBinding(N, S)
GlobalEnvironmentRecord envRec的CreateImmutableBinding方法接受参数N（String值）和
S（Boolean值）。创建一个新的名字为N的未初始化的不变绑定。绑定#N不能已经存在
于本EnvironmentRecord中。如果S是true，这个新绑定是严格绑定。被调用时执行下列
步骤：
1. 让DclRec是envRec.\[\[DeclarativeRecord]]
2. 如果DclRec.HasBinding(N)是true，投掷TypeError异常
3. 返回DclRec.CreateImmutableBinding(N, S)
***** InitializeBinding(N, V)
GlobalEnvironmentRecord envRec的InitializeBinding方法接受参数N（String值）和V（
ECMAScript语言值）。将绑定#N的当前值为V。未初始化绑定#N必须已经存在。被调用
时执行下列步骤：
1. 让DclRec是envRec.\[\[DeclarativeRecord]]
2. 如果DclRec.HasBinding(N)是true，那么
    a. 返回DclRec.InitializeBinding(N, V)
3. Assert：若绑定#N存在，必在ObjectEnvironmentRecord中。
4. 让ObjRec是envRec.\[\[ObjectRecord]]
5. 返回?ObjRec.InitializeBinding(N, V)
***** SetMutableBinding(N, V, S)
GlobalEnvironmentRecord envRec的SetMutableBinding方法接受参数N（String值）、V（
ECMAScript语言值）和S（Boolean）。试图修改将绑定#N的当前值修改为V。如果是不变
绑定，当S是true时投掷TypeError。一般性质N已经存在，但是如果不存在或者当前不
可写，由S决定错误处理方式。被调用时执行下列步骤：
1. 让DclRec是envRec.\[\[DeclarativeRecord]]
2. 如果DclRec.HasBinding(N)是true，那么
    a. 返回DclRec.SetMutableBinding(N, V, S)
3. 让ObjRec是envRec.\[\[ObjectRecord]]
4. 返回?ObjRec.SetMutableBinding(N, V, S)
***** GeBindingValue(N, S)
GlobalEnvironmentRecord envRec的GetBindingValue方法接受参数N（String值）和S（
Boolean）。返回绑定#N。如果绑定#N没有初始化，投掷ReferenceError异常。一般
性质N已经存在，但是如果不存在或者当前不可写，由S决定错误处理方式。被调用
时执行下列步骤：
1. 让DclRec是envRec.\[\[DeclarativeRecord]]
2. 如果DclRec.HasBinding(N)是true，那么
    a. 返回DclRec.GetBindingValue(N, S)
3. 让ObjRec是envRec.\[\[ObjectRecord]]
4. 返回?ObjRec.GetBindingValue(N, S)
***** DeleteBinding(N)
GlobalEnvironmentRecord envRec的DeleteBinding方法接受参数N（String值）。只能删除
已经明确可删除的的绑定。被调用时执行下列步骤：
1. 让DclRec是envRec.\[\[DeclarativeRecord]]
2. 如果DclRec.HasBinding(N)是true，那么
    a. 返回DclRec.DeleteBinding(N)
3. 让ObjRec是envRec.\[\[ObjectRecord]]
4. 让globalObject是ObjRec的绑定对象
5. 让existingProp是?HasOwnProperty(globalObject, N)
6. 如果existingProp是true，那么
    a. 让status是?ObjRec.DeleteBinding(N)
    b. 如果status是true，那么
        i. 让varNames是envRec.\[\[VarNames]]
       ii. 如果N是varNames的元素，从varNames中移除N
    c. 返回status
7. 返回true
***** HasThisBinding()
GlobalEnvironmentRecord envRec的HasThisBinding方法不接受参数。被调用时执行下
列步骤：
1. 返回true。
****** GlobalEnvironmentRecord总是提供this绑定。
***** HasSuperBinding()
GlobalEnvironmentRecord envRec的HasSuperBinding方法不接受参数。被调用时执行
下列步骤：
1. 返回false。
****** GlobalEnvironmentRecord不提供super绑定。
***** WithBaseObject()
GlobalEnvironmentRecord envRec的WithBaseObject方法不接受参数。被调用时执行
下列步骤：
1. 返回undefined
***** GetThisBinding()
GlobalEnvironmentRecord envRec的GetThisBinding方法不接受参数。被调用时执行下
列步骤：
1. 返回envRec.\[\[GlobalThisValue]]
***** HasVarDeclaration(N)
GlobalEnvironmentRecord envRec的HasVarDeclaration方法接受参数N（String值）。明确
本记录中是否有绑定#N是由VariableStatement或者FunctionDeclaration创建的。被调用
时执行下列步骤：
1. 让varDeclaredNames是envRec.\[\[VarNames]]
2. 如果varDeclaredNames包含N，返回true
3. 返回false
***** HasLexicalDeclaration(N)
GlobalEnvironmentRecord envRec的HasLexicalDeclaration方法接受参数N（String值）。
明确本记录中是否有绑定#N是由类似LexicalDeclaration或者ClassDeclaration等词法
声明创建的。被调用时执行下列步骤：
1. 让DclRec是envRec.\[\[DeclarativeRecord]]
2. 返回DclRec.HasBinding(N)
***** HasRestrictedGlobalProperty(N)
GlobalEnvironmentRecord envRec的HasRestrictedGlobalProperty方法接受参数N（String
值）。明确全局对象的性质N没有被全局词法绑定遮蔽。被调用时执行下列步骤：
1. 让ObjRec是envRec.\[\[ObjectRecord]]
2. 让globalObject是ObjRec的绑定对象。
3. 让existingProp是?globalObject.\[\[GetOwnProperty]](N)
4. 如果existingProp是undefined，返回false
5. 如果existingProp.\[\[Configurable]]是true，返回false
6. 返回true
***** CanDeclareGlobalVar(N)
GlobalEnvironmentRecord envRec的CanDeclareGlobalVar方法接受参数N（String值）。
明确相应的CreateGlobalVarBinding(N)能否成功。多余的var声明和先存在的全局对象
性质的var声明都是允许的。被调用时执行下列步骤：
1. 让ObjRec是envRec.\[\[ObjectRecord]]
2. 让globalObject是ObjRec的绑定对象
3. 让hasProperty是?HasOwnProperty(globalObject, N)
4. 如果hasProperty是true，返回true
5. 返回?IsExtensible(globalObject)
***** CanDeclareGlobalFunction(N)
GlobalEnvironmentRecord envRec的CanDeclareGlobalFunction方法接受参数N（String
值）。明确相应的CreateGlobalFunctionBinding(N)能否成功。被调用时执行下列步骤：
1. 让ObjRec是envRec.\[\[ObjectRecord]]
2. 让globalObject是ObjRec的绑定对象
3. 让existingProp是?globalObject.\[\[GetOwnProperty]](N)
4. 如果existingProp是undefined，返回?IsExtensible(globalObject)
5. 如果existingProp.\[\[Configurable]]是true，返回true
6. 如果IsDataDescriptor(existingProp)是true而且existingProp.\[\[Writable]]是true
   existingProp.\[\[Enumerable]]也是true，返回true
7. 返回false
***** CreateGlobalVarBinding(N, D)
GlobalEnvironmentRecord envRec的CreateGlobalVarBinding方法接受参数N（String值）
和D（Boolean）。在联结的ObjectEnvironmentRecord上创建并初始化一个可变绑定#N，
并且绑定名称记录到联结的\[\[VarNames]] List中。如果已经存在绑定#N，会被复用
并且试图初始化。被调用时执行下列步骤：
1. 让ObjRec是envRec.\[\[ObjectRecord]]
2. 让globalObject是ObjRec的绑定对象
3. 让hasProperty是?HsOwnProperty(globalObject, N)
4. 让extensible是?IsExtensible(globalObject)
5. 如果hasProperty是false而且extensible是true，那么
    a. 执行?ObjRec.CreateMutableBinding(N, D)
    b. 执行?ObjRec.InitializeBinding(N, undefined)
6. 让varDeclaredNames是envRec.\[\[VarNames]]
7. 如果varDeclaredNames不含有N，那么
    a. 附加N到varDeclaredNames
8. 返回NormalCompletion(empty)
***** CreateGlobalFunctionBinding(N, V, D)
GlobalEnvironmentRecord envRec的CreateGlobalFunctionBinding方法接受参数N（String
值）、V（ECMAScript语言值）和D（Boolean值）。在联结的ObjectEnvironmentRecord上
创建并初始化一个可变绑定N，并将绑定名称记录到联结的\[\[VarNames]] List中。
如果绑定已经存在，会被替换。被调用时执行下列步骤：
1. 让ObjRec是envRec.\[\[ObjectRecord]]
2. 让globalObject是ObjRec的绑定对象
3. 让existingProp是?globalObject.\[\[GetOwnProperty]](N)
4. 如果existingProp是undefined或者existingProp.\[\[Configurable]]是true，那么
    a. 让desc是PropertyDescriptor { \[\[Value]]:V, \[\[Writable]]:true,
       \[\[Enumerable]]: true, \[\[Configurable]]:D }
5. 否则
    a. 让desc是PropertyDescriptor { \[\[Value]]:V }
6. 执行?DefinePropertyOrThrow(globalObject, N, desc)
7. 执行?Set(globalObject, N, V, false)
8. 让varDeclaredNames是envRec.\[\[VarNames]]
9. 如果varDeclaredNames不含有N，那么
    a. 附加N到varDeclaredNames
10. 返回NormalCompletion(empty)
****** 注意 全局的函数声明总是表示为全局对象的自有性质。如果可以，已存在
             性质被重设为一套标准属性。步骤7于调用InitializeBinding具体方法
             等价，而且如果globalObject是一个Proxy，会产生Proxy捕获器调用的相
             同序列。
**** Module Environment Record
ModuleEnvironmentRecord是一个DeclarativeEnvironmentRecord，用于描述ECMAScript的
Module值的外层圈。在普通的可变绑定和不变绑定外，ModuleEnvironmentRecord还提供
了不变引入绑定，用于间接访问存在于其他EnvironmentRecord的绑定。

ModuleEnvironmentRecord提供列在表17中的DeclarativeEnvironmentRecord的所有方法，
还共用除了GetBindingValue、DeleteBinding、HasThisBinding和GetThisBinding外的算法。
而且ModuleEnvironmentRecord提供了列在表22中的方法。
| 方法                          | 目的                                                                                                     |
| CreateImportBinding(N, M, N2) | 在ModuleEnvironmentRecord创建不变间接绑定#N。M是一个ModuleRecord，N2是在M的ModuleEnvironmentRecord的绑定 |
| GetThisBinding()              | 返回本EnvironmentRecord的this绑定。                                                                             |

ModuleEnvironmentRecord上额外的具体方法的行为在下方的算法中定义。
***** GetBindingValue(N, S)
ModuleEnvironementRecord envRec的GetBindingValue方法接受参数N（String值）和S（
Boolean值）。返回绑定#N的值。然而如果绑定#N是间接绑定，返回目标绑定的值。
如果绑定#N存在，但是没有初始化，投掷ReferenceError。被调用时执行下列步骤：
1. Assert：S是true
2. Assert：envRec有绑定#N
3. 如果绑定#N是间接绑定，那么
    a. 让M和N2是创建绑定#N时的间接值
    b. 让targetEnv时M.\[\[Environment]]
    c. 如果targetEnv是undefined，投掷ReferenceError异常
    d. 返回?targetEnv.GetBindingValue(N2, true)
4. 如果envRec的绑定#N没有初始化，投掷ReferenceError异常
5. 返回envRec的绑定#N
****** 注意 S总是true，因为Module总是严格模式代码。
***** DeleteBinding(N)
ModuleEnvironementRecord envRec的DeleteBinding方法永不会被用到。
****** 注意 ModuleEnvironmentRecord只用在严格模式，而且早期错误规则阻止了严格
             代码提供给ReferenceRecord会解释到ModuleEnvironmentRecord上某绑定的
             删除操作。
***** HasThisBinding()
ModuleEnvironementRecord envRec的HasThisBinding方法不接受参数。被调用时执行下
列步骤：
1. 返回true
****** 注意 ModuleEnvironmentRcord总是提同this绑定。
***** GetThisBinding()
ModuleEnvironementRecord envRec的GetThisBinding方法不接受参数。被调用时执行下
列步骤：
1. 返回undefined
***** CreateImportBinding(N, M, N2)
ModuleEnvironementRecord envRec的CreateImportBinding方法接受参数N（String值）、
M（ModuleRecord）和N2（String值）。创建一个新的初始化的不变间接绑定#N。绑定#N
不能已经存在于EnvironmentRecord中。N2是M的ModuleEnvironmentRecord的绑定的名称。
访问这个新的绑定会间接访问目标绑定的值。被调用时执行下列步骤：
1. Assert：envRec没有绑定#N
2. Assert：M是ModuleRecord
3. Assert：当M.\[\[Environment]]是已初始化的，它有间接绑定#N2
4. 在envRec创建间接绑定#N，引用M和N2作为其目标绑定，而且记录这个绑定已经
   初始化
5. 返回NormalCompletion(empty)
*** Environment Record操作
下列的抽象操作被用在本规范操作EnvironmentRecord。
**** GetIdentifierReference(env, name, strict)
抽象操作GetIdentifierReference接受参数env（EnvironmentRecord值或null）、name（
String值）和strict（Boolean值）。被调用时执行下列步骤：
1. 如果env是null，那么
    a. 返回ReferenceRecord { \[\[Base]]:unresolvable, \[\[ReferenceName]]:name,
       \[\[Strict]]:strict, \[\[ThisValue]]:empty]] }
2. 让exists是?env.HasBinding(name)
3. 如果exists是true，那么
    a. 返回ReferenceRecord { \[\[Base]]:env, \[\[ReferenceName]]:name,
       \[\[Strict]]:strict, \[\[ThisValue]]:empty]] }
4. 否则
    a. 让outer是env.\[\[OuterEnv]]
    b. 返回?GetIdentifierReference(outer, name, strict)
**** NewDeclarativeEnvironment(E)
抽象操作NewDeclarativeEnvironment接受参数E（EnvironmentRecord值）。被调用时执
行下列步骤：
1. 让env是一个新的不含任何绑定的DeclarativeEnvironmentRecord。
2. 设置env.\[\[OuterEnv]]是E
3. 返回env
**** NewObjectEnvironment(O, E)
抽象操作NewObjectEnvironment接受参数O（Object值）和E（EnvironmentRecord值）。
被调用时执行下列步骤：
1. 让env是一个新的不含任何绑定的ObjectEnvironmentRecord。
2. 设置env.\[\[OuterEnv]]是E
3. 返回env
**** NewFunctionEnvironment(F, newTarget)
抽象操作NewFunctionEnvironment接受参数F和newTarget。被调用时执行下列步骤：
1. Assert：F是一个ECMAScript函数
2. Assert：Type(newTarget)是undefined或者Object
3. 让env是一个新的不含任何绑定的FunctionEnvironmentRecord。
4. 设置env.\[\[FunctionObject]]是F
5. 如果F.\[\[ThisModle]]是lexical，设置env.\[\[ThisBindingStatus]]为lexial
6. 否则设置env.\[\[ThisBindingStatus]]为uninitialized
7. 设置env.\[\[NewTarget]]是newTarget
8. 设置env.\[\[OuterEnv]]是F.\[\[Environment]]
9. 返回env
**** NewGlobalEnvrionment(G, thisValue)
抽象操作NewGlobalEnvironment接受参数G和thisValue。被调用时执行下列步骤：
1. 让objRec是新的含有G作为绑定对象的ObjectEnvironmentRecord
2. 让dclRec是新的不含任何绑定的DeclarativeEnvironmentRecord
3. 让env是新的GlobalEnvironmentRecord
4. 设置env.\[\[ObjectRecord]]是objRec。
5. 设置env.\[\[GlobalThisValue]]是thisValue。
6. 设置env.\[\[DeclarativeRecord]]是dclRec。
7. 设置env.\[\[VarNames]]是新的空List。
8. 设置env.\[\[OuterEnv]]是null。
9. 返回env
**** NewModuleEnvironment(E)
抽象操作NewModuleEnvironment接受参数E（EnvironmentRecord值）。被调用时执行
下列步骤：
1. 让env是新的不含任何绑定ModuleEnvironmentRecord
2. 设置env.\[\[OuterEnv]]是E
3. 返回env
** Realms 领
所有的ECMAScript代码在评估前必须联结到一个领。在概念上，领包含一套内在对
象、ECMAScript全局环境、这个全局环境圈内的加载的所有ECMAScript代码和其他联结
的状态与资源。

领在本规范中表示为RealRecord，其字段列在表23
| 字段名             | 值                                                         | 含义                                                                                                                                                                                                                                                                                                                      |
| \[\[Intrinsics]]   | Record值。其字段名是内在键，字段值是对象                   | 被联结到此领的代码使用的内在值                                                                                                                                                                                                                                                                                            |
| \[\[GlobalObject]] | Object                                                     | 此领的全局对象                                                                                                                                                                                                                                                                                                            |
| \[\[GlobalEnv]]    | GlobalEnvironmentRecord                                    | 此领的全局环境                                                                                                                                                                                                                                                                                                            |
| \[\[TempateMap]]   | List<Record { \[\[Site]]: ParseNode, \[\[Array]]:Object }> | Template对象是对每个领使用其RealRecord的\[\[TempateMap]]进行独立简化的。每个\[\[Site]]是TempalteLiteral的ParseNode。联结的\[\[Array]]值是相应的传递给标记函数的模板对象。注意：如果ParseNode变得不可及，则相应的\[\[Array]]也是不可及的，而且如果某实现将这对内容从\[\[TemplateMap]]上移除，这ParseNode会变成不可观察的。 |
| \[\[HostDefined]]  | 任何值，默认值是undefined                                  | 用于在RealRecord需要联结额外信息的主机的保留字段。                                                                                                                                                                                                                                                                        |
*** CreateRealm()
抽象操作CreateRealm不接受参数。被调用时执行下列步骤：
1. 让realmRec是新的RealmRecord
2. 执行CreateIntrinsics(realmRec)
3. 设置realmRec.\[\[GlobalObject]]是undefined
4. 设置realmRec.\[\[GlobalEnv]]是undefined
5. 设置realmRec.\[\[TemplateMap]]是新的空List
6. 返回realmRec
*** CreateIntrinsics(realmRec)
抽象操作CreateIntrinsics接受参数realmRec。被调用时执行下列步骤：
1. 让intrinsics是一个新的Record
2. 设置realmRec.\[\[Intrinsics]]是intrinsics
3. 按照表8在intrinsics中设置字段，字段名就是第一列中的名字。每个字段的值是
   新的对象，按照本规范条款19到条款28定义的完整的递归的填充性质。每个对象
   性质值都是新的对象值。所有的内置函数对象的值都是通过执行
   CreateBuiltinFunction(steps, length, name, slots, realmRec, prototype)产生的，
   steps是本规范中该函数的定义，name是函数的name性质的初始值，length是函数的
   length性质的初始值，slots是该函数规定的内部占位的名称列表，而prototype是
   该函数的\[\[Prototype]]内部占位的规定值。创建内核和其性质时，必须时有序
   的，以避免依赖未创建的对象。
4. 执行AddRestrictedFunctionProperties(intrinsics.\[\[%Function.prototype%]], realmRec)
5. 返回intrinsics
*** SetRealmGlobalObject(realmRec, globalObj, thisValue)
抽象操作SetRealmGlobalObject接受参数realmRec、globalObj和thisValue。被调用时
执行下列步骤：
1. 如果globalObj是undefined，那么
    a. 让intrinsics是realRec.\[\[Intrinsics]]
    b. 设置globalObj是!OrdinaryObjectCreate(intrinsics.\[\[%Object.prototype%]])
2. Assert：Type(globalObj)是Object
3. 如果thisValue是undefined，设置thisValue是globalObj
4. 设置realmRec.\[\[GlobalObject]]是globalObj
5. 让newGlobalEnv是NewGlobalEnvironment(globalObj, thisValue)
6. 设置realmRec.\[\[GlobalEnv]]是newGlobalEnv
7. 返回realmRec
*** SetDefaultGlobalBindings(realmRec)
抽象操作SetDefaultGlobalBindings接受参数realmRec。被调用时执行下列步骤：
1. 让global是realmRec.\[\[GlobalObject]]
2. 遍历在条款19中规定的GlobalObject的性质，实施
    a. 让name是性质名的String值
    b. 让desc是本性质完整填充的PropertyDescriptor，包含此性质特定的属性。
       列在19.2、19.3和19.4的性质的\[\[Value]]属性是realmRec上的相应内核对象
    c. 执行?DefinePropertyOrThrow(global, name, desc)
3. 返回global
** Execution Contexts执行背景
执行背景是ECMAScript实现用于跟踪代码运行时评估行为的规范设备。任何时刻，
每个评估代码的施动者最多有一个执行背景。这被认为施动者的运行时执行背景。
本规范中指向运行时背景的引用记作SurroundingAgent的RunningExecutionContext（密
接施动者的运行时执行背景）。

ExecutionContextStack用于跟踪执行背景。运行时执行背景总是在栈的顶部。任何
时候，当控制权从联结到当前运行时执行背景的可执行代码传递给没有联结到执行
背景的可执行代码，新的执行背景就会被创建。新的执行背景会被压到栈上，成为
运行时执行背景。

执行背景包含了跟踪其联结代码的执行进程所必需实现规定状态。每个执行背景
至少含有列在表24的状态组件。
| 组件                  | 目的                                                                                                                                       |
| code evaluation state | 用于执行、挂起和复苏联结在本执行背景的代码所需要的状态                                                                                     |
| Function              | 如果本执行背景在评估函数对象的代码，这个组件的值就是函数对象。如果是评估Script或者Module代码，值就是null                                   |
| Realm                 | 用于联结代码访问ECMAScript资源的RealmRecord                                                                                                |
| ScriptOrModule        | 联结代码创立的ModuleRecord或者ScriptRecord。如果没有起源脚本或者模块，比如在InitializeHostDefinedRealm创建的执行背景的起源，这个值就是null |

在本规范中运行时执行背景的代码评估会在各种位置被挂起。一旦这个运行时执行
背景被挂起，一个不同的执行背景会成为运行时执行背景并着手评估自身的代码。
后来一个挂起的执行背景会再次称为运行时背景，并从之前被挂起的位值继续评估
其代码。执行背景中运行时执行背景的状态转变通常按照后入/先出的方式发生。然
而，有些ECMAScript特生需要非LIFO方式转换运行时执行背景。

运行时背景的Realm组件的值也被称为CurrrentRealmRecord（当前领记录）。运行时执
行背景的Function组件也被称为ActiveFunctionObject（活跃函数、活跃函数对象）。

ECMAScript代码的执行背景还有表25列出的额外状态组件。
| 组件               | 目的                                                 |
| LexicalEnvironment | 确认解释本执行背景的代码创建的标识引用需要的EnvrionmentRecord |
| VariablEnvironment | 确认持有本执行背景的代码用VariableStatements创建的绑定的EnvironmentRecord |

执行背景的LexicalEnvironment和VariableEnvironment组件总是EnvironmentRecord。

表示GeneratorObject评估的执行背景还有列在表26的额外组件。
| 组件      | 目的                                |
| Generator | 本执行背景正在评估的GeneratorObject |

绝大多数情况只有运行时执行背景（ExecutionContextStack执行背景栈的顶）是被
本规范的算法直接操作的。因此当无限定的使用术语LexicalEnvironment和
VariableEnvironment时，他们都是指运行时执行环境上的。

执行背景是纯粹的规范机制，无需对应任何ECMAScript实现的任何特定内容。
ECMAScript代码不能直接访问或察觉执行背景。
*** GetActiveScriptOrModule()
抽象操作GetActiveScriptOrModule不接受参数。用于明确基于运行时执行背景的正在
运行的Script或者Module。被调用时执行下列步骤：
1. 如果ExceuctionContextStack是空的，返回null
2. 让ec是ExecutionContextStack上ScriptOrModule组件不是null的最顶部ExecutionContext
3. 如果没有这种ExecutionContext存在，返回null。否则返回ec的ScriptOrModule
*** ResolveBinding(name[, env])
抽象操作ResolveBinding接受参数name（String值）和可选参数env（EnvironmentRecord
值）。用于明确绑定#name。env用于显式提供EnvironmentRecord来搜索绑定。
被调用时执行下列步骤：
1. 如果env不存在，或者env是undefined，那么
    a. 设置env是运行时执行背景的LexicalEnvironment
2. Asset：env是EnvironmentRecord
3. 如果句法码型对应的正在评估的代码被包含在严格模式代码中，让strict是true，
   否则让strict是false
4. 返回?GetIdentifierReference(env, name, strict)
**** 注意 ResolveBinding用于返回ReferenceRecord，其\[\[ReferencedName]]是name
*** GetThisEnvironment()
抽象操作GetThisEnvironment不接受参数。寻找当前提供this绑定的
EnvironmentRecord。被调用时执行下列步骤：
1. 让env是RunningExecutionContext的LexicalEnvironment
2. 重复
    a. 让exists是env.HasThisBinding()
    b. 如果exists是true，返回env
    c. 让outer是env.\[\[OuterEnv]]
    d. Assert：outer不是null
    e. 设置env是outer
**** 注意 循环的步骤2总是会终止，因为环境list会在在全局环境处终止，全局环境
          必然有this绑定。
*** ResolveThisBinding()
抽象操作ResolveThisBinding不接受参数。使用RunningExecutionContext的
LexicalEnvironment明确this绑定。被调用时执行下列步骤：
1. 让envRec是GetThisEnvironment()
2. 返回?envRec.GetThisBinding()
*** GetNewTarget()
抽象操作GetNewTarget不接受参数。使用RunningExecutionContext的LexicalEnvironment
明确NewTarget的值。被调用时执行下列步骤：
1. 让envRec是GetThisEnvironment()
2. Assert：envRec有\[\[NewTarget]]字段
3. 返回envRec.\[\[NewTaraget]]
*** GetGlobalObject()
抽象操作GetGlobalObject不接受参数。返回被当前运行时执行背景使用的全局对
象。被调用时执行下列步骤：
1. 让currentRealm是CurrentRealmRecord
2. 返回currentRealm.\[\[GlobalObject]]
** Jobs and Host Operations to Enqueue Jobs Job和主机对Job队列的操作
Job是一个无参数的AbstractClosure，在当前进程没有其他ECMAScript计算时初始化
一个ECMAScript计算。

Job按ECMAScript主机实现的规划来执行。本规范描述了主机榫（HostHook）
HostEnqueuePromiseJob安排的一类Job，主机可能定义额外的抽象操作来安排job。
那些操作接受JobAbstractClosure作为参数，安排其在未来某时执行。这些实现必须
与下列的要求一致。
. 在未来某时，如果没有运行时执行背景而且ExecutionContextStack是空的，必须
实现：
    1. 执行主机定义的准备步骤
    2. 调用JoAbstractClosure
    3. 执行主机定义的清理步骤。随后ExecutionContextStack必须是空的。
. 任何时刻只能有一个Job被激活经受评估
. 一旦Job的评估开始，在其他Job开始前必须完成运行
. AbstractClosure必须返回一个普通完结，实现自有的错误处理。
*** 注意1 在安排上主机环境不要求统一对待Job。比如网页浏览器与Node.js对待
           PromiseHandling较其他工作有较高优先级；未来特征会引入不那么高优先
           级的Job

在任何指定时间，如果下列条件都成立，scriptOrModule（ScriptRecord、ModuleRecord
或者null）是活跃的Script或者Module:
. GetActiveScriptOrModule()是scriptOrModule
. 如果scriptOrModule是ScriptRecord或者ModuleRecord，让ec是ExecutionContextStack上
其ScriptOrModule是scriptOrModule的最顶部ExecutionContext。ec的Realm组件是
scriptOrModule.\[\[Realm]]

在任何指定时间，如果下列条件都成立，某执行准备评估ECMAScript代码
. ExecutionContextStack不空
. ExecutionContextStack的最顶部ExecutionContext（RunningExecutionContext）的Real组件
是RealmRecord
*** 注意2 主机环境可能通过将执行背景压到ExecutionContextStack上的方式来准备
           执行评估代码。这个特殊步骤是实现自行定义的。
           Realm的指定选择是由主机环境运行的。当Job的回调函数，例如Promise
           句柄，被调用，这个调用推送自己的执行背景和Realm

特定类型的Job有额外的遵循需求。
*** JobCallback Records
JobCallbackRecord是用于存放函数对象的Record值，也是一个主机定义的值。通过
主机排队的Job调用起的函数对象可能还有额外的主机定义的背景。为了传播这个
状态，JobAbstractClosures不能直接捕获和调用函数对象。应该分别使用
HostMakeJobCallback和HostCallJobCallback。
**** 注意 例如：WHATWG HTML规定使用主机定义的值来为Promise回调传播现任的设置
           对象。

JobCallbackRecord有列在表27的字段
| 字段名            | 值                  | 含义                               |
| \[\[Callback]]    | 函数对象            | 当Job被调用时，这个Job会调用的函数 |
| \[\[HostDefined]] | 任何值，默认时empty | 保留给主机的字段                   |
*** HostMakeJobCallback(callback)
主机定义的抽象操作HostMakeJobCallback接受参数callback（函数对象）。

HostMakeJobCallback的实现必须遵循下列要求：
. 必须总是常规完结（不会返回意外完结）
. 必须返回\[\[Callback]]是callback的JobCallbackRecord

默认的HostMakeJobCallback实现被调用时执行下列步骤：
1. Assert： IsCallable(callback)是true
2. 返回JobCallbackRecord { \[\[Callback]]:callback, \[\[HostDefined]]:empty }

不是网页浏览器的ECMAScript主机必须使用HostMakeJobCallback的默认实现。
**** 注意 这会在回调被传到负责最终安排和执行的函数时调用。例如
           promise.then(thenAction)代码，在调用Promise.prototype.then时调用
           MakeJobCallback(thenAction)，而不是在安排到回应Job的时候。
*** HostCallJobCallback(jobCallback, V, argumentsList)
主机定义的抽象操作HostCallJobCallback接受参数jobCallback（JobCallbackRecord）、
V（ECMASCript语言值）和argumentsList（ECMAScript语言值的List）

HostCallJobCallback的实现必须遵循下列要求：
. 必须总是执行并返回Call(jobCallback.\[\[Callback]], V, argumentsList)
**** 注意 这个要求意味着主机不能修改函数对象在本规范中定义的\[\[Call]]行为
HostCallJobCallback的默认实现被调用时执行下列步骤：
1. Assert：IsCallable(jobCallback.\[\[Callback]])是true
2. 返回?Call(jobCallback.\[\[Callback]], V, argumentsList)

不是网页浏览器的ECMAScript主机必须使用HostCallJobCallback的默认实现。
*** HostEnqueuePromiseJob(job, realm)
主机定义的抽象操作HostEnqueuePromiseJob接受参数job（JobAbstractClosure）和
realm（RealmRecord或者null）。安排job在后续被执行。本算法中使用的
AbstractClosures被试图用于联系到Promise的处理，否则被安排到与Promise处理操作
同优先级。

HostEnqueuePromiseJob的实现必须遵循9.4的要求和下列要求：
. 如果realm不是null，每次job被调用时，实现必须执行实现层定义的步骤，那些在

job调用时被准备用于评估ECMAScript代码的执行。
. HostEnqueuePromiseJob被调用时，让scriptOrModule是GetActiveScriptOrModule()。如果

realm不是null，每次job被调用，实现必须执行实现层定义的步骤，那些在job调

用时scriptOrModule时活跃Script或者Module
. Job必须按照安排的HostEnqueuePromiseJob调用顺序执行。
**** 注意 被NewPromiseResolveThenableJob返回的job的realm通常是在then函数对象上调
           用GetFunctionRealm的结果。被NewPromiseReactionJob返回的job的realm通常
           是，在如果句柄不是undefined时，句柄调用GetFunctionRealm的结果。如果
           句柄是null，realm也是null。所有种类的Job，当GetFunctionRealm异常结束
           （在Proxy调用时触发），realm是GetFunctionRealm调用是的Realm。当realm是
           null，不能有用户的ECMAScript代码会被评估，也没有新的ECMAScript对象会
           被创建。例如WHATWG HTML规范使用realm去检查实例概念和运行脚本的能力
           。
** InitializeHostDefinedRealm()
抽象操作InitializeHostDefinedRealm不接受参数。被调用时执行下列步骤：
1. 让realm是CreateRealm()
2. 让newContext是新的执行背景
3. 设置newContext的Function是null
4. 设置newContext的Realm是realm
5. 设置newContext的ScriptOrModule是null
6. 推送newContext到ExecutionContextStack，newContext现在是RunningExecutionContext
7. 如果主机需要使用奇异对象作为realm的全局对象，让global是一个以主机定义的
   方式来创建的对象。否则global是undefined，表明应该创建一个基本对象作为全局
   对象。
8. 如果主机需要在realm的全局范围内this绑定返回其他全局对象，让thisValue是一
   个以主机定义的方式来创建的对象。否则让thisValue是undefined，表明realm的
   全局this绑定应该是全局对象。
9. 执行SetRealmGlobalObject(realm, global, thisValue)
10. 让globalObj是?SetDefaultGlobalBinding(realm)
11. 在globalObj上创建主机定义的全局对象性质
12. 返回NormalCompletion(empty)
** Agents 施动者
施动者是一套ECMAScript执行背景，ExecutionContextStack、RunningExecutionContext、
AgentRecord和ExecutingThread。除了ExecutionThread，其他组成是施动者独占的。

agent的ExecutingThread在agent的独立于其他agent的执行背景上执行一个job，除了
ExecutingThread会被多个agent用作ExecutingThread外，前提是共用这个线程的agent有
一个\[\[CanBlock]]是true的AgentRecord
*** 注意 例如有些网页浏览器在多个无关的浏览窗口中共用一个执行线程
当agent的ExecutingThread执行jobs，这个agent就是job代码的SurroundingAgent。代码
使用SurroundingAgent访问其含有的规范级别的执行对象：RunningExecutionContext、
ExecutionContextStack和其他AgentRecord的字段。
| 字段名                   | 值                       | 含义                                                                                                                                                  |
| \[\[LittleEndian]]       | Boolean                  | 被GetValueFromBuffer和StetValueInBuffer的算法需要的isLitterEndian的参数的值。这是实现定义的，且是实现最有效率的备选。一旦这个值被观察到就不可修改了。 |
| \[\[CanBlock]]           | Boolean                  | 明确施动者是否可以阻塞                                                                                                                                |
| \[\[Signifier]]          | 任何全局唯一值           | 在施动者集群中标识施动者                                                                                                                              |
| \[\[IsLockFree1]]        | Boolean                  | true表示单字节的原子操作是免锁的，其他是false                                                                                                          |
| \[\[IsLockFree2]]        | Boolean                  | true表示两字节的原子操作是免锁的，其他是false                                                                                                          |
| \[\[IsLockFree8]]        | Boolean                  | true表示八字节的原子操作是免锁的，其他是false                                                                                                          |
| \[\[CandidateExecution]] | CandidateExecutionRecord | 见于内存模型                                                                                                                                          |
| \[\[KeptAlive]]          | 对象的List               | 初始化是空List，表示直到当前Job结束前保持活性的对象的列表                                                                                             |

一旦\[\[Signifier]]、\[\[IsLockFree1]]和\[\[isLockFree2]]被本集群中的任何施动者观察到，他们就
不能变动了。
*** 注意2 \[\[IsLockFree1]]和\[\[isLockFree2]]的值不必由硬件决定，但是会反映实现的选择，在不同
         实现或者不同时期发生变动。
         没有\[\[IsLockFree1]]性质，因为四字节的原子操作总是免锁的。
         在实践上，如果一个原子操作被实现为某步带锁的，这个操作不是免锁的。免锁不是免等待，完成一个
         免锁的原子操作需要多少机器步骤是没有上限的。
         原子级访问n的大小是无锁的，不意味任何关于非原子访问n的大小的原子性的意义，尤其是，非原子访问
         可能还会是执行一些离散的内存访问。见于ReadSharedemory和WriteSharedMemory。
*** 注意3 施动者是规范机制，无需对应任何ECMAScript实现的任何活。
*** AgentSignifier()
抽象操作AgentSignifier不接受参数。被调用时执行下列步骤：
1. 让AR是紧围施动者的AgentRecord
2. 返回AR.\[\Signifier]]
*** AgentCanSuspend()
抽象操作AgentCanSuspend不接受参数。被调用时执行下列步骤：
1. 让AR是紧围施动者的AgentRecord
2. 返回AR.\[\[CanBlock]]
**** 注意 在某些环境下可能没有理由让一个施动者挂起。比如在网页浏览器环境下，不让文档的主线程挂起就是
         就是合理的，同时其工作线程就是可以挂起的。
** Agent Clusters
AgentCLuster就是最大的可以通过公用内存进行通讯的agent集合。
*** 注意1 程序在不同的施动者间会通过不在规范内的方式公用内存。至少，
          SharedArrayBuffer对象的备份内存能够被集群中的施动者共用。
          同时施动者可以通过消息通讯那些不能共用内存的内容，而且这些施动者
          从来就没不在同一个集下。

每个施动者都明确从属于一个AgentCluster。
*** 注意2 集群中的施动者完全不必同时存活。如果A创造了B，然后结束A，B创建C，
           如果B可以共享A的某些内存，C可以共享B的某些内存，则A、B、C都在同一
           个集群中。

同一个集群下的施动者的AgentRecord必须有相同的\[\[LittleEndian]]性质
*** 注意3 如果同一集群下施动者有不同的\[\[LittleEndian]]值，多字节数据的共用会
          异常困难。

同一个集群下的施动者的AgentRecord必须有相同的\[\[IsLockFree1]]性质，同样的
\[\[IsLockFree2]]也是如此。

同一个集群下的施动者的AgentRecord必须有不同的\[\[Signifier]]性质

存在嵌入逻辑可以灭活（停止前进进程）或者活化（继续前进进程）施动者而不要
此施动者的声明或配合。如果此嵌入逻辑触发，必须保证如果集群下有施动者被无
限期的灭活，集群下就不能有其他施动者是活化的。
*** 注意4 前面限制的目的是规避一种情况，即某个施动者发生死锁或者饥饿，因为
           其他施动者被灭火。例如在HTML中，共享的worker，在任何窗体中有独立于
           文档的生命周期，被允许分享内存给那些独立文档的专用worker，这个文档
           和其专用worker在其持有锁的时候被灭活（也就是说，文档被推送到窗体
           历史了），这个共享的worker试图获得这个锁，那么这个共享的worker就会
           被锁住直到那个专有worker重新活化。如此同时其他窗体的试图访问这个
           共享worker的其他worker会饥饿（没事干）。
           这个限制的含义是不可以在不属于遵循嵌入逻辑的同时挂起/唤醒的同一
           合集的施动者间共用内存。

嵌入逻辑可以终止一个施动者，无需其所在集群的其他施动者之前的声明或者配
合。如果施动者不是因自己或者集群其他施动者的程序动作，而是因为集群外的强制
行为而终结，嵌入逻辑必须选择一个策略：1、终结掉集群内的全部施动者，2、提供
可靠的API允许集群的施动者配合，这样集群中至少存在一个成员能够侦测到这个终结
命令，通过终结数据包含足够识别施动者会被终结的信息。
*** 注意5 触发这种终结的例子：操作系统或者用户终止了在独立进程中运行的施动
           者；嵌入逻辑根据其他施动者终止了一个正在运行的施动者，当每个施动
           者的资源统计都表明那个施动者失控了。

在集群的任何施动者评估ECMAScript代码之前，集群里的所有施动者的AgentRecord的
\[\[CandidateExecution]]字段被设置为特定初始化的CandidateExecution。这个初始化的
CandidateExecution是空的CandidateExecution，其\[\[EventsRecords]]是AgentEventsRecord的
List，每个AgentEventsRecord的\[\[AgentSignifier]]是其代表的施动者标记，而且
CandidateExecution的\[\[EventList]]和\[\[AgentSynchronizesWith]]字段都是空的List。
*** 注意6 同一集群下的全部施动者在其AgentRecord的\[\[CandidateExecution]]字段共用
           相同的CandidateExecution。CandidateExecution是用于内存模型的规范机制。
*** 注意7 施动者集群是一个规范机制，不对应任何ECMAScript实现的特定活。
** Forward Progress 前进进程
对于施动者引发前进进程是说它根据本规范执行了一步评估。

施动者在其运行时执行背景等待同步的无限期的外部事件时会变成阻塞的。在这种
场景中，只有施动者的AgentRecord的\[\[CanBlock]]性质是true时才可以变成阻塞的。
无障施动者是不能被阻塞的。

实现必须确保：
. 每个无锁施动者最终带着一个专用的执行线程来引发前进进程
. 在共用一个执行线程的施动者集合里，一个施动者最终引发前进进程
. 施动者除非使用提供的显式API来阻塞，否则不能让其他施动者变成阻塞的。
*** 注意 与内存模型的活性保证一起，这确保了所有的SeqCst写入最终都对施动者
          可见。
** Processing Modle of WeakRef and FinalizationRegistry Objects
      终点注册对象和弱引用的进程模型
*** Objectives 目标
本规范没有关于对象被回收的任何保证。失活的对象可能会很久之后，甚至永不，
被释放。因为这个原因，本规范使用术语may来描述触发垃圾收集的行为。

WeakRef与FinalizationReigstry对象的语义是基于发生在特定时间的两个操作的。
. 当WeakRef.prototype.deref被调用，被引（如果没有返回undefined）对象保持活性，

这样随后的同步访问仍然返回这个对象。在同步工作完成时使用ClearKeptObject抽象

操作来重置这个列表。
. 当一个向FinalizationRegistry注册的对象变得不可及时，在同步的ECMAScript执行完成

后，FinalizationRegistry的清理行为的回调的调用可能最终被引发。

FinalizationRegistry清理随着CleanupFinalizationRegistry抽象操作被执行。

ClearKeptObjects或者CleanupFinalizationRegistry行为都不会中断同步的ECMAScript
执行。因为主机会试图延长同步ECMAScript执行的运行，本规范延缓规划
ClearKeptObjects和CleanupFinalizationRegistry到主机环境中。

有些ECMAScript实现包含了后台运行垃圾收集的实现，包含ECMAScript停滞的情况。
让主机环境规划CleanupFinalizationRegistry，为了运行结束工作，允许其继续
ECMAScript执行，会释放持有的值，减少总体内存使用。
*** Liveness 存活
对于对象的某些集合S，就S而言，HypotheicalWeakRef-oblivious（假设弱引用无感知）
执行就是WeakRef的抽象操作WeakRefDeref的执行中获取S引用总是undefined。
**** 注意1 弱引用无感知，与Liveness一起，描述了两个观念。一是WeakRef
            本身不会保持对象存活，二是Liveness里的循环引用不表明对象是活的。
            实现上来说，如果明确对象的活性依赖于其他弱引用的obj2的活性，而
            obj2的活性不能假设obj的活性，因为其可能是循环的。
**** 注意2 弱引用无感知被定义在对象集合上，而不是独立的对象，来明确环。
            如果被定义在独立对象上，那么环里的对象会被认为是获得，即使这个
            对象值仅可以通过环里其他对象的WeakRef来观察到。
**** 注意3 一般如果包含对象的每个集合都是活的，我们说这个独立对象是获得。
在评估的任何点，集合对象S被认为是存活的，如果下列条件满足之一：
. S中的任何元素被包含在施动者的\[\[KeptAlive]]列表里
. 对于S而言，存在有效的未来的HypotheticalWeakRef-oblivious执行能够观察到S中的

任意对象值。
**** 注意4 上面的第二个条件试图描述这样直觉：就是对象如果能不通过WeakRef方式
            就观察的其标识的就是存活的。对象的标识可以被观测到通过观察到两个
            对象的严格相等比较或者观察到其被作为Map的键。
**** 注意5 对象是字段、内部占位或者是性质，不表明对象存活的。例如如果对象是
            请求的参数，再也不会返回到程序中，那么它不能被观察到。
            这处理WeakMap键，WeakSet成员，以及FinalizationRegistry单元记录的
            \[\[WeakRefTarget]]和\[\[UnregisterToken]]字段的。
            上述定义表明WeakMap的键是不存活的，那么其值也无需存活
**** 注意6 Liveness是保证WeakRef引擎不空的下限。这里定义Liveness是出乎意料的。
            事实上引擎使用保守的近似性比如可达性。这里被期望有显著的实现余
            地。
*** Execution 执行
任何时候，如果对象集合S失活，ECMAScript实现可能自动执行下列步骤
1. 遍历集合S的每个元素对象obj，做
    a. 遍历每个WeakRef，记做ref，如果ref.\[\[WeakRefTarget]]是obj，那么做
        i. 设置ref.\[\[WeakRefTarget]]是空
    b. 遍历每个FinalizationRegistry记作fg，如果fg.\[\[Cells]]包含一个Record，
       记作cell，且cell.\[\[WeakRefTarget]]是obj，那么做
        i. 设置cell.\[\[WeakRefTarget]]为空
       ii. 可选项：执行!HostEnqueueFinalizationRegistryCleanupJob(fg)
    c. 遍历每个WeakMap，记作map，如果map.\[\[WeakMapData]]包含一个Record，记作r，
       r.\[\[Key]]是obj，那么做
        i. 设置r.\[\[Key]]为空
       ii. 设置r.\[\[Value]]是空
    d. 遍历每个WeakSet，记作set，如果set.\[\[WeakSetData]]包含obj，那么做
        i. 替换set.\[\[WeakSetData]]上obj所在位置的值为空。
**** 注意1 和Liveness的定义一起，本条款提前描述了实现可能会依据WeakRefs做
            的合法优化。没有观察到对象的标识，也有可能访问到这个对象。所以
            像非转义对象（就是无法观察到标识的对象）上的死亡变量清理和标量
            替换等优化都是允许的。这些优化这样被允许到可观测空WeakRef上，
            WeakRef的点指向那些对象。换句话说，如果对象的标识可以观察到，
            而且对象在WeakRef的内部占位\[\[WeakRefTarget]]，像重新物化这种可
            观测的置空WeakRef的优化是禁止的。因为调用
            HostEnqueueFinalizationRegistryCleanupJob是可选的，在
            FinalizationRegistry注册的对象无需保持FinalizationRegistry存活。实现
            可能会因为任何原因忽略finalizationRegistry的回调，比如
            FinalizationRegistry本身死亡了，或者应用关闭了。
**** 注意2 实现没有义务清空WEakRefs以最大化非存活对象。如果实现选择了一个
            非存活集合S来置空WeakRefs，必须同时为S中的所有对象置空WeakRef。
            也就是说，实现不能置空指向对象obj的WeakRef而不置空其外部的
            WeakRefs，如果外部不空的话，因为外部WeakRef会让执行观察到obj的
            对象值。
*** HostHooks 主机榫
*** HostEnquueFinalizationRegistryCleanupJob(finalizationRegistry)
抽象操作HostEnqueueFinalizationRegistryCleanupJob接受参数finalizationRegistry（
FinalizationRegistry实例）。HostEnqueueFinalizationRegistryCleanupJob是实现定义的
抽象操作，被期望在未来某些点上如果可能的话调用
CleanupFinalizationRegistry(finalizationReigstry)。主机负责保证这个调用不会中断
同步的ECMAScript代码执行。
** ClearKeptObjects()
抽象操作ClearKeptObject不接受参数。ECMAScript实现被期望在一个ECMAScript执行序列
完成后调用ClearKeptObjects。被调用时执行下列步骤：
1. 让agentRecord是外围施动者的AgentRecord
2. 设置agentRecord.\[\[KeptAlive]]是新的空List
** AddToKeptObjects(object)
抽象操作AddTokeptObjects接受参数object（Object值）。被调用时执行下列步骤：
1. 让agentRecord是外围施动者的AgentRecord
2. 将object追加到agentRecord.\[\[KeptAlive]]中
*** 注意 当抽象操作AddTokeptObject被调用于目标饮用上，将目标添加到一个列表
          中，这个列表会强指向这个对象，直到ClearKeptObjects被调用。
** CleanupFinalizationRegistry(finalizationRegistry)
抽象操作CleanupFinalizationRegistry接受参数finalizationRegistry（
FinalizationRegistry）。被调用时执行下列步骤：
1. Assert：finalizationRegistry有\[\[Cells]]和\[\[CleanupCallback]]内部占位
2. 让callback是finalizationRegistry.\[\[CleanupCallback]]
3. 当finalizationRegistry.\[\[Cells]]包含一个Record，记作cell，
   cell.\[\[WeakRefTarget]]是空的，实现可能会执行下列步骤：
    a. 选择cell
    b. 从finalizationRegistry.\[\[Cells]]中移除cell
    c. 执行?Call(callback, undefined, <<cell.\[\[heldValue]]>>)
4. 返回undefined
* Ordinary and Exotic Ojbects Behaviours 基本与奇异对象的行为
** Ordinary Object Internal Methods and Internal Slots
基本对象的内部方法和内部占位

所有的基本对象都有\[\[Prototype]]的内部占位。这个占位的值是null或者一个用
于实现继承的对象。\[\[Prototype]]对象的数据性质被继承（也就是会当作子对象
的性质）于读取许可，但是没有写入许可。访问性质被继承了读取和写入许可。

每个基本对象都有一个布尔值的内部占位\[\[Extensible]]，用于实现规定在6.1.7.3
中的扩展相关的内部方法的不变性。按本意，一旦对象的\[\[Extensible]]的值是
false，这个对象就不再能添加性质，或者修改\[\[Prototype]]内部占位，或者随后
修改\[\[Extensible]]为true。

在随后的算法描述中，预设O是基本对象，P是性质键值，V是ECMAScript语言值，Desc是
PropertyDescriptorRecord

基本对象的每个内部方法都代表了一个相似名称的抽象操作。如果某个抽象操作依赖
于其他内部方法，这个内部方法是以O来唤起的，而不是直接调用那个相似名称的抽
象操作。这些语义确保了奇异对象能够覆盖内在方法的调用，当基本对象的内部方法
被申请给这些奇异对象。
*** \[\[GetPrototypeOf]]()
基本对象O的内部方法\[\[GetPrototypeOf]]不接受参数。被调用时执行下列步骤：
1. 返回!OrdinaryGetPrototypeof(O)
**** OrdinaryGetPrototypeOf(O)
抽象操作OrdianryGetPrototypeOf接受参数O（对象）。被调用时执行下列步骤：
1. 返回O.\[\[Prototype]]
*** \[\[SetPrototypeOf]](V)
基本对象O的内部方法\[\[SetPrototypeOf]]接受参数V（对象值或者null）。被调用时
执行下列步骤：
1. 返回!OrdianrySetPrototypeOf(O, V)
**** OrdinarySetPrototypeOf(O, V)
抽象操作OrdianrySetPrototypeOf接受参数O（对象）和V（ECMAScript语言值）。被调用
时执行下列步骤：
1. Assert：Type(V)是Object或者Type(V)是Null
2. 让current是O.\[\[Prototype]]
3. 如果SameValue(V, current)是true，返回true。
4. 让extensible是O.\[\[Extensible]]
5. 股弱extensible是false，返回false。
6. 让p是V
7. 让done是false
8. 当done是false时，重复
    a. 如果p是null，设置done是true。
    b. 如果SameValue(p, O)是true，返回false
    c. 否则
        i. 如果p.\[\[GetPrototypeOf]]不是定义在10.1.1的内部方法，设置done是true
       ii. 否则，设置p是p.\[\[Prototype]]
9. 设置O.\[\[Prototype]]是V
10. 返回true
***** 注意 步骤8的循环确保了在原型链上不会有循环，而且只含有使用基本对象定
            义的\[\[GetPrototypeOf]]和\[\[SetPrototypeOf]]的对象。
*** \[\[IsExtensible]]()
基本对象O的内部方法\[\[IsExtensible]]不接受参数。被调用时执行下列步骤：
1. 返回!OrdinaryIsExtensible(O)
**** OrdinaryIsExtensible(O)
抽象操作OrdinaryIsExtensible接受参数O（对象值）。被调用时执行下列步骤：
1. 返回O.\[\[Extensible]]
*** \[\[PreventExtensions]]()
基本对象O的内部方法\[\[PreventExtensions]]不接受参数。被调用时执行下列步骤：
1. 返回!OrdinaryPreventExtensions(O)
**** OrdinaryPreventExtensions(O)
抽象操作OrdinaryPreventExtensions接受参数O（对象值）。被调用时执行下列步骤：
1. 设置O.\[\[Extensible]]是false
2. 返回true。
*** \[\[GetOwnProperty]](P)
基本对象O的内部方法\[\[GetOwnProperty]]接受参数P（性质键）。被调用时执行下
列步骤：
1. 返回!OrdinaryGetOwnProperty(O, P)
**** OrdinaryGetOwnProperty(O,P)
抽象操作OrdinaryGetOwnProperty接受参数O（对象值）和P（性质键）。被调用时执
行下列步骤：
1. Assert：IsPropertyKey(P)是true
2. 如果O没有自有性质P，返回undefined
3. 让D是新建的PropertyDescriptor，没有任何字段
4. 让X是O的性质P
5. 如果X是数据性质，那么
    a. 设置D.\[\[Value]]是X.\[\[Value]]的值
    b. 设置D.\[\[Writable]]是X.\[\[Writable]]的值
6. 否则
    a. Assert：X是访问性质
    b. 设置D.\[\[Get]]是X.\[\[Get]]的值
    c. 设置D.\[\[Set]]是X.\[\[Set]]的值
7. 设置D.\[\[Enumerable]]是X.\[\[Enumerable]]的值
8. 设置D.\[\[Configurable]]是X.\[\[Configurable]]的值
9. 返回D
*** \[\[DefineOwnProperty]](P, Desc)
基本对象O的内部方法\[\[DefineOwnProperty]]接受参数P（性质键）和Desc（
PropertyDescriptor）。被调用时执行下列步骤：
1. 返回?OrdinaryDefineOwnProperty(O, P, Desc)
**** OrdinaryDefineOwnProperty(O, P, Desc)
抽象操作OrdinaryDefineOwnProperty接受参数O（对象值）、P（性质键）和Desc（
PropertyDescriptor）。被调用时执行下列步骤：
1. 让current是?O.\[\[GetOwnProperty]](P)
2. 让extensible是?IsExtensible(O)
3. 返回ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current)
**** IsCompatiblePropertyDescriptor(Extensible, Desc, Current)
抽象操作IsCompatiblePropertyDescriptor接受参数Extensible（Boolean）、Desc（
PropertyDescriptor）和Current（PropertyDescriptor）。被调用时执行下列步骤：
1. 返回ValidateAndApplyPropertyDescriptor(

undefined, undefined, Extensible, Desc, Current
)
**** ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current)
抽象操作ValidateAndApplyPropertyDescriptor接受参数O（对象值或者undefined）、P（
性质键）、extensible（Boolean）、Desc（PropertyDescriptor）和current（
PropertyDescriptor）。被调用时执行下列步骤：
***** 注意 如果O是undefined，只执行校验，不修改任何对象。
1. Assert：如果O不是undefined，那么IsPropertyKey(P)必然是true
2. 如果current是undefined，那么
    a. 如果extensible是false，返回false
    b. Assert：extensible是true
    c. 如果IsGenericDescriptor(Desc)是true或者IsDataDescriptor(Desc)是true，那么
        i. 如果O不是undefined，根据Desc的\[\[Value]]、\[\[Writable]]、
           \[\[Enumerable]]和\[\[Configurable]]在对象O上创建自有数据性质P。如果
           Desc上的属性缺失，新性质的属性使用默认值。
    d. 否则
        i. Assert：!IsAccessorDescriptor(Desc)是true
       ii. 如果O不是undefined，根据Desc的\[\[Get]]、\[\[Set]]、\[\[Enumerable]]和
           \[\[Configurable]]在对象O上创建自有访问性质P。如果Desc上的属性缺失，
           新性质的属性使用默认值。
    e. 返回true
3. 如果Desc中需要的属性都缺失，返回true
4. 如果current.\[\[Configurable]]是false，那么
    a. 如果Desc.\[\[Configurable]]是true，返回false
    b. 如果Desc.\[\[Configurable]]存在，且!SameValue(Desc.\[\[Enumerable]],
       current.\[\[Enumerable]])是false，返回false。
5. 如果!IsGenericDescriptor(Desc)是true，那么
    a. 注意：不在需要继续校验了。
6. 否则，如果!SameValue(!IsDataDescriptor(current), !IsDataDescriptor(Desc))是false，
   那么
    a. 如果current.\[\[Configurable]]是false，返回false
    b. 如果IsDataDescriptor(current)是true，那么
        i. 如果O不是undefined，将O的P性质从数据性质转换到访问性质。保留
           \[\[Configurable]]和\[\[Enumerable]]的值，若缺失属性则使用默认值
    c. 否则
        i. 如果O不是undefined，将O的P性质从访问性质转换到数据性质。保留
           \[\[Configurable]]和\[\[Enumerable]]的值，若缺失属性则使用默认值
7. 否则，如果IsDataDescriptor(current)和IsDataDescriptor(Desc)都是true，那么
    a. 如果current.\[\[Configurable]]是false，且current.\[\[Writable]]是false，那么
        i. 如果Desc.\[\[Writable]]是true，返回false
       ii. 如果Desc.\[\[Value]]存在，且SameValue(Desc.\[\[Value]], current.\[\[Value]])
           是false，返回false
      iii. 返回true
8. 否则
    a. Assert：!IsAccessorDescriptor(current)和!IsAccessorDescriptor(Desc)都是true
    b. 如果current.\[\[Configurable]]是false，那么
        i. 如果Desc.\[\[Set]]存在，且SameValue(Desc.\[\[Set]], current.\[\[Set]])是
           false，返回false
       ii. 如果Desc.\[\[Get]]存在，且SameValue(Desc.\[\[Get]], current.\[\[Get]])是
           false，返回false
      iii. 返回true
9. 如果O不是undefined，那么
    a. 遍历Desc中的属性，将O的P性质对应的属性赋予相同的值
10. 返回true
*** \[\[HasProperty]](P)
基本对象O的内部方法\[\[HasProperty]]接受参数P（性质键）。被调用时执行下
列步骤：
1. 返回!OrdinaryHasProperty(O, P)
**** OrdinaryHasProperty(O,P)
抽象操作OrdinaryHasProperty接受参数O（对象值）和P（性质键）。被调用时执
行下列步骤：
1. Assert：IsPropertyKey(P)是true
2. 让hasOwn是?O.\[\[GetOwnProperty]](P)
3. 如果hasOwn不是undefined，返回true
4. 让parent是?O.\[\GetPrototypeOf]]()
5. 如果parent不是null，那么
    a. 返回?parent.\[\[HasProperty]](P)
6. 返回false
*** \[\[Get]](P, Receiver)
基本对象O的内部方法\[\[Get]]接受参数P（性质键）和Receiver（ECMAScript语言
值）。被调用时执行下列步骤：
1. 返回!OrdinaryGet(O, P, Receiver)
**** OrdinaryGet(O,P,Receiver)
抽象操作OrdinaryGet接受参数O（对象值）、P（性质键）和Receiver（ECMAScript语言
值）。被调用时执行下列步骤：
1. Assert：IsPropertyKey(P)是true
2. 让desc是?O.\[\[GetOwnProperty]](P)
3. 如果desc是undefined，那么
    a. 让parent是?O.\[\[GetPrototypeOf]]()
    b. 如果parent是null，返回undefined
    c. 返回?parent.\[\[Get]](P, Receiver)
4. 如果IsDataDescriptor(desc)是true，返回desc.\[\[Value]]
5. Assert：IsAccessorDescriptor(desc)是true
6. 让getter是desc.\[\[Get]]
7. 如果getter是undefined，返回undefined
8. 返回?Call(getter, Receiver)
*** \[\[Set]](P, V, Receiver)
基本对象O的内部方法\[\[Set]]接受参数P（性质键）、V（ECMAScript语言值）和
Receiver（ECMAScript语言值）。被调用时执行下列步骤：
1. 返回?OrdinarySet(O, P)
**** OrdinarySet(O,P,V,Receiver)
抽象操作OrdinarySet接受参数O（对象值）、P（性质键）、V（ECMAScript语言值）和
Receiver（ECMAScript语言值）。被调用时执行下列步骤：
1. Assert：IsPropertyKey(P)是true
2. 让ownDesc是?O.\[\[GetOwnProperty]](P)
3. 返回OrdinarySetWithOwnDescriptor(O,P,V,Reciver,ownDesc)
**** OrdinarySetWithOwnDescriptor(O,P,V,Receiver,ownDesc)
抽象操作OrdinarySet接受参数O（对象值）、P（性质键）、V（ECMAScript语言值）、
Receiver（ECMAScript语言值）和ownDesc（PropertyDescriptor或者undefined）。被调用时
执行下列步骤：
1. Assert：IsPropertyKey(P)是true
2. 如果ownDesc是undefined，那么
    a. 让parent是?O.\[\[GetPrototypeOf]]()
    b. 如果parent不是null，那么
        i. 返回?parent.\[\[Set]](P,V,Receiver)
    c. 否则
       ii. 设置ownDesc是PropertyDescriptor { \[\[Value]]:undefined,
           \[\[Writable]]:true, \[\[Enumerable]]:true, \[\[Configurable]]:true }
3. 如果IsDataDescriptor(ownDesc)是true，那么
    a. 如果ownDesc.\[\[Writable]]是false，返回false
    b. 如果Type(Receiver)不是Object，返回false
    c. 让existingDescriptor是?Receiver.\[\[GetOwnProperty]](P)
    d. 如果existingDescriptor不是undefined，那么
        i. 如果IsAccessorDescriptor(existingDescriptor)是true，返回false
       ii. 如果existingDescriptor.\[\[Writable]]是false，返回false
      iii. 让valueDesc是PropertyDescriptor{\[\[Value]]:V}
       iv. 返回?Receiver.\[\[DefineOwnProperty]](P, valueDesc)
    e. 否则
        i. Assert：Receiver现在没有性质P
       ii. 返回?CreateDataProperty(Receiver, P, V)
4. Assert：IsAccessorDescriptor(ownDesc)是true
5. 让setter是ownDesc.\[\[Set]]
6. 如果setter是undefined，返回false
7. 执行?Call(setter, Receiver, <<V>>)
8. 返回true
*** \[\[Delete]](P)
基本对象O的内部方法\[\[Delete]]接受参数P（性质键）。被调用时执行下列步骤：
1. 返回?OrdinaryDelete(O, P)
**** OrdinaryDelete(O,P)
抽象操作OrdinaryDelete接受参数O（对象值）和P（性质键）。被调用时执行下列
步骤：
1. Assert：IsPropertyKey(P)是true
2. 让desc是?O.\[\[GetOwnProperty]](P)
3. 如果desc是undefined，返回true
4. 如果desc.\[\[Configurable]]是true，那么
    a. 从O上移除性质P
    b. 返回true
5. 返回false
*** \[\[OwnPropertyKeys]]()
基本对象O的内部方法\[\[OwnPropertyKeys]]不接受参数。被调用时执行下列步骤：
1. 返回!OrdinaryOwnPropertyKeys(O)
**** OrdinaryOwnPropertyKeys(O)
抽象操作OrdinaryOwnPropertyKeys接受参数O（对象值）。被调用时执行下列步骤：
1. 让keys是新的空List
2. 遍历O的每个自有性质的键P，如果P是ArrayIndex，按照数字升序，做
    a. 追加P到keys中
3. 遍历O的每个自有性质的键P，如果Type(P)是字符串，且不是ArrayIndex，按照创建
   顺序升序，做
    a. 追加P到keys中
4. 遍历O的每个自有性质的键P，如果Type(P)是Symbol，按照创建顺序升序，做
    a. 追加P到keys中
5. 返回keys
*** OrdinaryObjectCreate(proto[, additionalInternalSlotsList])
抽象操作OrdinaryObjectCreate接受参数proto（对象值或者null）和可选参数
additionalInternalSlotsList（内部占位的名称的List）。用于规定在运行时创建新的
基本对象。additionalInternalSlotsList包含了创建对象时除了\[\[Prototype]]和
\[\[Extensible]]外的必须的内部占位的名字。如果additionalInternalSlotsList没有被
提供，一个新的空List被使用。被调用时执行下列步骤：
1. 让internalSlotsList时<<\[\[Prototype]],\[\[Extensible]]>>
2. 如果additionalInternalSlotsList存在，将其元素附加到internalSlotsList中
3. 让O是!MakeBasicObject(internalSlotsList)
4. 设置O.\[\[Prototype]]是proto
5. 返回O
**** 注意 尽管OrdinaryObjectCreate比调用MakeBasicObject多做了些事情，它表露的
           意图仍然是创建基本对象，而不是奇异对象。因此，在本规范内，它不会
           被任何会修改内部方法从而产生奇异对象的算法调用。产生奇异对象的
           操作直接调用MakeBasicObject。
*** OrdinaryCreateFromConstructor(constructor, intrinsicDefaultProto[,
   interanlSlotsList])

抽象操作OrdinaryCreateFromConstructor接受参数constructor和intrinsicDefaultProto和
可选参数internalSlotsList（内部占位名的List）。创建一个基本对象，其
\[\[Prototype]]是从constructor上检索到的"prototype"性质，如果存在的话。否则的话
使用intrinsicDefaultProto作为\[\[Prototype]]的值。internalSlotList包含了创建对象的
其他内部占位的名称。如果internalSlotList没有提供，使用新的空List。被调用时执
行下列步骤：
1. Assert：intrinsicDefaultProto是内在对象在本规范的名称的String值。对应的对象比
   须是用作对象的\[\[Prototype]]的固有对象。
2. 让proto是?GetPrototypeFromConstructor(constructor, intrinsicDefaultProto)
3. 返回!OrdinaryObjectCreate(proto, internalSlotsList)
*** GetPrototypeFromConstructor(constructor, intrinsicDefaultProto)
抽象操作GetPrototypeFromConstructor接受参数constructor和intrinsicDefaultProto。
明确用于创建对象的\[\[Prototype]]值是由指定的constructor对应的。这个值是从
constructor的"prototype"性质检索到的，如果存在的话。否则使用intrinsicDefaultProto
作为\[\[Prototype]]。被调用时执行下列步骤：
1. Assert：intrinsicDefaultProto是内在对象在本规范的名称的String值。对应的对象比
   须是用作对象的\[\[Prototype]]的固有对象。
2. Assert：IsCallable(constructor)是true
3. 让proto是?Get(constructor, "prototype")
4. 如果Type(proto)不是object，那么
    a. 让realm是?GetFunctionRealm(constructor)
    b. 设置proto是realm的名称为intrinsicDefaultProto的内在对象
5. 返回proto
**** 注意 如果constructor不提供\[\[Prototype]]值，默认值是从constructor函数的
           realm中取得默认值，而不是从运行时执行上下文。
*** RequireInternalSlot(O, internalSlot)
抽象操作RequireInternalSlot接受参数O和internalSlot。如果对象O没有给定的
internalSlot就投掷异常。被调用时执行下列步骤：
1. 如果Type(O)不是对象，投掷TypeError异常
2. 如果O没有internalSlot内部占位，投掷TypeError异常
** ECMAScript Function Objects
ECMAScripFunction对象封装了参数化的ECMAScript代码，闭合了词法环境，支持代码
的动态环境。一个ECMAScriptFunction对象是一个基本对象，有与其他基本对象相同的
内部占位和内部方法。ECMAScriptFunction对象的代码分为严格模式和非严格模式两
种。严格模式代码的ECMAScriptFunction对象称为严格函数。非严格模式代码的则称为
非严格函数。
  \[\[Extensible]]和\[\[Prototype]]之外，ECMAScript对象还有表29所列的内部占位
| 内部占位                 | 类型                              | 描述                                                                                                                                                                                               |
| \[\[Environment]]        | EnvironmentRecord                 | 函数对象闭合的EnvironmentRecord。作为评估函数时的外层环境。                                                                                                                                        |
| \[\[FormalParameters]]   | ParseNode                         | 定义函数形式参数的源文本的解析节点的根节点                                                                                                                                                         |
| \[\[ECMAScriptCode]]     | ParseNode                         | 定义函数体的源文本的解析节点的根节点                                                                                                                                                               |
| \[\[ConstructorKind]]    | base \vert derived                | 函数是否是派生的类构造函数                                                                                                                                                                         |
| \[\[Realm]]              | RealmRecord                       | 创建此函数的领，并为评估此函数时提供需要的固有对象                                                                                                                                                 |
| \[\[ScriptOrModule]]     | ScriptRecord 或者 ModuleRecord    | 函数所在的脚本或者模块                                                                                                                                                                             |
| \[\[ThisMode]]           | lexical \vert strict \vert global | 界定函数的形式参数与函数体的this如何解释。lexical意味着封闭在函数的词法this。strict意味着this就是此函数的调用。global意味着this是undefined或着null时，就解释成全局对象，否则使用ToObject转换后的值 |
| \[\[Strict]]             | Boolean                           | 如果是严格函数就是true，非严格函数是false                                                                                                                                                          |
| \[\[HomeObject]]         | Object                            | 如果函数使用了super，这就是其\[\[GEtPrototypeOf]]提供了查找super性质的开始位值的对象                                                                                                               |
| \[\[SourceText]]         | Unicode编码点序列                 | 定义函数的源文本                                                                                                                                                                                   |
| \[\[IsClassConstructor]] | Boolean                           | 指明此函数是否是一个类构造范。如果true，调用\[\[Call]]，会投掷一个TypeError异常                                                                                                                    |

那找这里的定义，所有的ECMAScript函数对象都有\[\[Call]]内部方法。ECMAScript函
数对象有\[\[Construct]]内部方法时，也是一个构造范。
*** \[\[Call]](thisArgument, argumentsList)
ECMAScript函数对象F上的\[\[Call]]内部函数接受参数thisArgument（ECMAScript语言
值）和argumentsList（List<ECMAScript语言值>）。被调用时执行下列步骤
1. Assert：F是ECMAScript函数对象
2. 让callerContext是运行时执行背景
3. 让calleeContext是PrepareForOrdinaryCall(F, undefined)
4. Assert：calleeContext现在是运行时执行背景
5. 如果F.\[\[IsClassConstructor]]是true，那么
    a. 让error是新创建的TypeError对象
    b. 注意：error是在calleeContext上带着F联结的RealmRecord被创建的
    c. 从ExecutionContextStack上移除calleeContext，并恢复callerContext作为运行时
       执行背景
    d. 返回ThrowCompletion(error)
6. 执行OrdinaryCallBindThis(F, calleeContext, thisArgument)
7. 让result是OrdinaryCallEvaluateBody(F, argumentsList)
8. 从ExecutionContextStack上移除calleeContext，并恢复callerContext作为运行时执行
   背景。
9. 如果result.\[\[Type]]是return，返回NormalCompletion(result.\[\[Value]])
10. ReturnIfAbrupt(result)
11. 返回NormalCompletion(undefined)
**** 注意 当calleeContext在第8步被从ExecutionContextStack上移除后，如果它是被挂
           起并保留的，用于后来被可访问的Generator对象继续使用的话，它不能被
           摧毁。
**** PrepareForOrdinaryCall(F, newTarget)
抽象操作PrepareForOrdianryCall接受参数F（函数对象）和newTarget（ECMAScript语言
值）。被调用时执行下列步骤：
1. Assert：Type(newTarget)是Undefined或Object
2. 让callerContext是运行时执行背景
3. 让calleeContext是一个新的ECMAScript代码的执行背景
4. 设置calleeContext的Function是F
5. 让calleeRealm是F.\[\[Realm]]
6. 设置calleeContext的Realm是calleeRealm
7. 设置calleeContext的ScriptOrModule是F.\[\[ScriptOrModule]]
8. 让localEnv是NewFunctionEnvironment(F, newTarget)
9. 设置calleeContext的LexicalEnvironment是localEnv
10. 设置calleeContext的VariableEnvironment是localEnv
11. 如果callerContext没有挂起，挂起callerContext
12. 推送calleeContext到ExecutionContextStack；calleeContext现在是运行时执行背景
13. 注意：指由所有的异常对象都联结到calleeRealm
14. 返回calleeContext
**** OrdinaryCallBindThis(F, calleeContext, thisArgument)
抽象操作PrepareForOrdianryCall接受参数F（函数对象）、calleeContext（执行背景）
和thisArgument（ECMAScript语言值）。被调用时执行下列步骤：
1. 让thisMode是F.\[\[ThisMode]]
2. 如果thisMode是lexical，返回undefined
3. 让calleeRealm是F.\[\[Realm]]
4. 让localEnv是calleeContext的LexcicalEnvrionment
5. 如果thisMode是strict，让thisValue是thisArgument
6. 否则
    a. 如果thisArgument是undefined或着null，那么
        i. 让globalEnv是calleeRealm.\[\[GlobalEnv]]
       ii. Assert：globalEnv是全局环境记录
      iii. 让thisValue是globalEnv.\[\[GlobalThisValue]]
    b. 否则
        i. 让thisValue是!ToObject(thisArgument)
       ii. 注意：ToObject使用calleeRealm封装对象
7. Assert：localEnv是函数环境记录
8. Assert：下一步不会意外终结，因为localEnv.\[\[ThisBindingStatus]]没有初始化
9. 返回localEnv.BindThisValue(thisValue)
**** Runtime Semantics: EvaluateBody
带参数functionObject和argumentsList（List）
FunctionBody : FunctionStatementList
1. 返回FunctionBody.?EvaluateFunctionBody(functionObject, argumentsList)
ConciseBody : ExpressionBody
1. 返回ConciseBody.?EvaluateConciseBody(functionObject, argumentsList)
GeneratorBody : FunctionBody
1. 返回GeneratorBody.?EvaluateGeneratorBody(functionObject, argumentsList)
AsyncGeneratorBody : FunctionBody
1. 返回AsyncGeneratorBody.?EvaluateAsyncGeneratorBody(functionObject, argumentsList)
AsyncFunctionBody : FunctionBody
1. 返回AsyncFunctionBody.?EvaluateAsyncFunctionBody(functionObject, argumentsList)
AsyncConciseBody : ExpressionBody
1. 返回AsyncConciseBody.?EvaluateAsyncConciseBody(functionObject, argumentsList)
**** OrdianryCallEvaluateBody(F, argumentsList)
抽象操作OrdinaryCallEvaluateBody接受参数F（函数对象）和argumentsList（List）。
被调用时执行下列步骤：
1. 返回带参数F与argumentsList的F.\[\[ECMAScriptCode]]的已解析代码的EvaluateBody
*** \[\[Construct]](argumentsList, newTarget)
ECMAScript函数对象的内部方法\[\[Construct]]接受参数argumentsList（ECMAScript值
的List）和newTarget（构造范）。被调用时执行下列步骤：
1. Assert：F是ECMAScript函数对象
2. Assert：Type(newTarget)是Object
3. 让callerContext是运行时执行背景
4. 让kind是F.\[\[ConstructorKind]]
5. 如果kind是base，那么
    a. 让thisArgument是?OrdinaryCreateFromConstructor(newTarget, "%Object.prototype%")
6. 让calleeContext是PrepareForOrdianryCall(F, newTarget)
7. Assert：calleeContext现在是运行时执行背景
8. 如果kind是base，执行OrdinaryCallBindThis(F, calleeContext, thisArgument)
9. 让constructorEnv是caleeContext的LexicalEnvironment
10. 让result是OrdinaryCallEvaluateBody(F, argumentsList)
11. 从ExecutionContextStack移除calleeContext，恢复callerContext是运行时执行背景
12. 如果result.\[\[Type]]是return，那么
    a. 如果Type(result.\[\[Value]])是对象，返回NormalCompletion(result.\[\[Value]])
    b. 如果kind是base，返回NormalCompletion(thisArgument)
    c. 如果result.\[\[Value]]不是undefined，投掷TypeError异常
13. 否则 ReturnIfAbrupt(result)
14. 返回?constructorEnv.GetThisBinding()
*** OrdinaryFunctionCreate(functionPrototype, sourceText, ParameterList, Body, 
thisMode, Scope)

抽象操作OrdinaryFunctionCreate接受参数functionPrototype（Object），sourceText（
Unicode编码点序列），ParameterList（ParseNode），Body（ParseNode），thisMode（
lexical-this或者non-lexical-this）和Scope（环境记录）。sourceText是将创建的函数
的句法定义的源文件。被调用时执行下列步骤：
1. Assert：Type(functionPrototype)是Object
2. 让internalSlotsList是表29所列的内部占位
3. 让F是!OrdinaryObjectCreate(functionPrototype, internalSlotsList)
4. 设置F.\[\[Call]]是规范10.2.1的定义
5. 设置F.\[\[SourceText]]是sourceText
6. 设置F.\[\[FormalParameters]]是ParameterList
7. 设置F.\[\[ECMAScriptCode]]是Body
8. 如果Body的源文本是严格模式代码，让Strict是true，否则String是false
9. 设置F.\[\[Strict]]是Strict
10. 如果thisMode是lexical-this，设置F.\[\[ThisMode]]是lexical
11. 否则 如果Strict是true，设置F.\[\[ThisMode]]是strict
12. 否则 设置F.\[\[ThisMode]]是global
13. 设置F.\[\[IsCalassConstructor]]是false
14. 设置F.\[\[Environment]]是Scope
15. 设置F.\[\[ScriptOrModule]]是GetActiveScriptOrModule()
16. 设置F.\[\[Realm]]是当前的RealmRecord
17. 设置F.\[\[HomeObject]]是undefined
18. 让len是ParameterList的ExpectedArgumentCount
19. 执行!SetFunctionLength(F, len)
20. 返回F
*** AddRestrictedFunctionProperties(F, realm)
抽象操作AddRestrictedFunctionProperties接受参数F（函数对象）和realm（
RealmRecord）。被调用时执行下列步骤：
1. Assert：realm.\[\[Intrinsics]].\[\[%ThrowTypeError%]]存在且已经初始化。
2. 让thrower是realm.\[\[Intrinsics]].\[\[%ThrowTypeError%]]
3. 执行!DefinePropertyOrThrow(F, "caller", PropertyDescriptor { \[\[Get]]:thrower,
   \[\[Set]]:thrower, \[\[Enumerable]]:false, \[\[Configurable]]:true } )
4. 执行!DefinePropertyOrThrow(F, "arguments", PropertyDescriptor { \[\[Get]]:thrower,
   \[\[Set]]:thrower, \[\[Enumerable]]:false, \[\[Configurable]]:true } )
**** %ThrowTypeError%()
固有%ThrowTypeError%是匿名的内建函数对象，每个领都会定义一次。被调用时执
行下列步骤：
1. 投掷TypeError异常

%ThrowTypeError%的\[\[Extensible]]是false

%ThrowTypeError%的length性质的属性是{\[\[Wriable]]:false, \[\[Enumerable]]:false, 
\[\[Configurable]]:false }

%ThrowTypeError%的name性质的属性是{\[\[Wriable]]:false, \[\[Enumerable]]:false, 
\[\[Configurable]]:false }
*** MakeConstructor(F\[,writablePrototype\[,prototype]])
抽象操作MakeConstructor接受参数F（函数对象）和可选参数writablePrototype（
Boolean）和prototype（对象）。将F转换为构造范。被调用时执行下列步骤：
1. Assert：F是ECMAScript函数对象或者内键函数对象
2. 如果F是ECMAScript函数对象，那么
    a. Assert：IsConstructor(F)是false
    b. Assert：F是可扩展对象，而且没有"prototype"自有性质
    c. 设置F.\[\[Construct]]是10.2.2中规定的定义
3. 设置F.\[\[ConstructorKind]]是base
4. 如果writablePrototype不存在，设置writablePrototype是true
5. 如果prototype不存在，那么
    a. 设置prototype是!OrdinaryObjectCreate(%Object.prototype%)
    b. 执行!DefinePropertyOrThrow(prototype, "constructor", PropertyDescriptor {
       \[\[Value]]:F, \[\[Writable]]:writablePrototype, \[\[Enumerable]]:false,
       \[\[Configurable]]:true })
6. 执行!DefinePropertyOrThrow(F, "prototype", PropertyDescriptor {
   \[\[Value]]:prototype, \[\[Writable]]:writablePrototype, \[\[Enumerable]]:false,
   \[\[Configurable]]:false })
7. 返回NormalCompletion(undefined)
*** MakeClassConstructor(F)
抽象操作MakeClassConstructor接受参数F。被调用时执行下列步骤：
1. Assert：F是ECMAScript函数对象
2. Assert：F.\[\[IsClassConstructor]]是false
3. 设置F.\[\[IsClassConstructor]]是true
4. 返回NormalCompletion(undefined)
*** MakeMethod(F, homeObject)
抽象操作MakeMethod接受参数F和homeObject。设置F为方法。被调用时执行下列步骤：
1. Assert：F是ECMAScript函数对象
2. Assert：Type(homeObject)是Object
3. 设置F.\[\[HomeObject]]是homeObject
4. 返回NormalCompletion(undefined)
*** SetFunctionName(F,name \[,prefix])
抽象操作SetFunctionName接受参数F和name（性质键）和可选参数prefix（String）。
在F上增加name性质。被调用时执行下列步骤：
1. Assert：F是可扩展对象，而且没有name自有性质
2. Assert：Type(name)是String或者Symbol
3. Assert：如果prefix存在，Type(prefix)是String
4. 如果Type(name)是Symbol，那么
    a. 让description是name的\[\[Description]]值
    b. 如果description是undefined，设置name是空字符串
    c. 否则，设置name是"["、description和"]"拼接的字符串
5. 如果F有\[\[InitialName]]的内部占位，那么
    a. 设置F.\[\[InitialName]]是name
6. 如果prefix存在，那么
    a. 设置name是prefix，0x0020和name的字符串拼接
    b. 如果F有\[\[InitialName]]内部占位，那么
        i. 可选的，设置F.\[\[InitialName]]是name
7. 返回!DefinePropertyOrThrow(F, "name", PropertyDescriptor { \[\[Value]]:name,
   \[\[Writable]]:false, \[\[Enumerable]]:false, \[\[Configurable]]:true })
*** SetFunctionLength(F, length)
抽象操作SetFunctionLength接受参数F（函数对象）和length（非负整数或者+∞）。
在F上添加"length"性质。被调用时执行下列步骤：
1. Assert：F是可扩展对象，而且没有length自有性质
2. 返回!DefinePropertyOrThrow(F, "length", PropertyDescriptor {
   \[\[Value]]:Number(length), \[\[Writable]]:false, \[\[Enumerable]]:false,
   \[\[Configurable]]:true })
*** FunctionDeclarationInstantiation(func, argumentsList)
**** 注意1 当为评估ECMAScript函数的执行背景建立后，新的函数环境记录也创建完，
            而且在环境记录中绑定每个形式参数并初始化。在函数体的每个声明也
            初始化。如果函数的形式参数没有包含任何初始化值，那么函数体的声
            明也初始化到相同的环境记录中作为参数。如果参数的默认初始化值存
            在，为函数体声明创建第二个环境记录。形式参数和函数初始化为
            FunctionDeclarationInstantiation的某部分。其他的绑定都在评估函数体的
            时候初始化。

抽象操作FunctionDeclarationInstantiation接受参数func（函数对象）和argumentsList。
func是正在为之建立执行背景的函数对象。被调用时执行下列步骤：
1. 让calleeContext是运行时执行背景
2. 让code是func.\[\[ECMAScriptCode]]
3. 让strict是func.\[\[Strict]
4. 让formals是func.\[\[FormalParameters]]
5. 让parameterNames是formals的BoundName
6. 如果parameterNames有重复实体，让hasDuplicates是true，否则hasDuplicates是false。
7. 让simpleParameterList是formals的IsSimpleParameterList
8. 让hasParameterExpressions是formals的ContainsExpression
9. 让varNames是code的VarDeclaredNames
10. 让varDeclarations是code的VarScopedDeclarations
11. 让lexicalNames是code的LexicallyDeclaredNames
12. 让functionNames是新的空List
13. 让functionsToInitialize是新的空List
14. 按照反序遍历varDeclarations的元素，记为d，做
    a. 如果d不是VariableDeclaration、ForBinding、BindingIdentifier那么
        i. Assert：d必然是FunctionDeclaration、GeneratorDeclaration、
           AsyncFunctionDeclaration或者AsyncGeneratorDeclaration之一
       ii. 让fn是d的BoundNames中的那个唯一元素。
      iii. 如果fn不是functionNames的元素，那么
            1. 将fn作为第一个元素插入到functionNames中。
            2. 注意：如果多个声明为相同名称的函数，最后一个生效
            3. 将d作为第一个元素插入到functionsToInitialize
15. 让argumentsObjectNeeded是true
16. 如果func.\[\[ThisMode]]是lexical，那么
    a. 注意：箭头函数没有arguments对象
    b. 设置argumentsObjectNeeded是false
17. 否则，如果arguments是parameterNames的元素，那么
    a. 设置argumentsObjectNeeded是false
18. 否则，如果hasParameterExpressions是false，那么
    a. 如果arguments是functionNames或者lexicalNames的元素，那么
        i. 设置argumentsObjectNeeded是false
19. 如果strict是true或者hasParameterExpressions是false，那么
    a. 注意：参数和顶层vars只需要一个环境记录
    b. 让env是caleeContext的LexicalEnvironment
20. 否则
    a. 注意：需要一个隔离的环境记录来确保在形式参数中的直接使用eval创建的
              绑定在参数声明的环境之外
    b. 让calleeEnv是calleeContext的LexicalEnvironmnet
    c. 让env是NewDeclarationEnvironment(calleeEnv)
    d. Assert：calleeContext的VariableEnvironment是calleeEnv
    e. 设置calleeContext的LexicalEnvironment是env
21. 遍历parameterNames的字符串，记为paramName，做
    a. 让alreadyDeclared是env.HasBinding(paramName)
    b. 注意：前期错误确保了重复的参数名只会发生在非严格函数里，那么就不会有
              参数默认值或者剩余参数
    c. 如果alreadyDeclared是false，那么
        i. 执行!env.CreateMutableBinding(paramName, false)
       ii. 如果hasDuplicate，那么
            1. 执行!env.InitializeBinding(paramName, undefined)
22. 如果argumentsObjectNeeded是true，那么
    a. 如果strict是true或者如果simpleParameterList是false，那么
        i. 让ao是CreateUnmappedArgumentsObject(argumentsList)
    b. 否则
        i. 注意：映射过的参数对象只提供给非严格函数，非严格函数没有剩余参
                  数、参数默认初始值和解构参数。
       ii. 让ao是CreateMappedArgumentsObject(func, formals, argumentsList, env)
    c. 如果strict是true，那么
        i. 执行!env.CreateImmutableBinding("arguments", false)
    d. 否则
        i. 执行!env.CreateMutableBinding("arguments", false)
    e. 调用env.InitializeBinding("arguments", ao);
    f. 让parameterBindings是List，其元素是parameterNames的元素拼接"arguments"
23. 否则
    a. 让parameterBindings是parameterNames
24. 让iteratorRecord是CreateListIteratorRecord(argumentsList)
25. 如果hasDuplicates是true，那么
    a. 为formals执行带iteratorRecord和undefined参数的?IteratorBindingInitialization
26. 否则
    a. 为formals执行带iteratorRecord和env参数的?IteratorBindingInitialization
27. 如果hasParameterExpressions是false，那么
    a. 注意：只需要一个环境记录就满足参数和顶层vars。
    b. 让instantiatedVarNames是parameterBindings List的复制
    c. 遍历varNames的元素记为n，做
        i. 如果n不是一个instantiatedVarNames的元素，那么
            1. 将n追加到instantiatedVarNames中
            2. 执行!env.CreateMutableBinding(n, false)
            3. 调用env.InitializeBinding(n, undefined)
    d. 让varEnv是env
28. 否则
    a. 注意：需要一个独立的环境记录确保：再形式参数的表达式创建的封闭不能
              访问到函数体内定义的声明。
    b. 让varEnv是NewDeclarativeEnvironment(env)
    c. 设置calleeContext的VariableEnvironment是varEnv
    d. 让instantiatedVarNames是新的空List
    e. 遍历varNames的元素记为n，做
        i. 如果n不是instantiatedVarNames的元素，那么
            1. 将n附加到instantiatedVarNames
            2. 执行!varEnv.CreateMutableBinding(n, false)
            3. 如果n不是parameterBindings的元素，或者n是functionNames的元素，让
               initialValue是undefined
            4. 否则
                a. 让initialValue是!env.GetBindingValue(n, false)
            5. 调用varEnv.InitializeBinding(n, initialValue)
            6. 注意：与形式参数里同名的变量有相同的初始化值
29. 注意：附件B.3.3.1在此处增加了额外的步骤。
30. 如果strict是false，那么
    a. 让lexEnv是NewDeclarativeEnvironment(varEnv)
    b. 注意：非严格函数为顶层词法声明使用独立环境记录，因此一个直接的eval
              能够明确由混淆有预先存在的顶层词法声明的eval代码中引入的任何
              变量声明的适用圈。对于严格函数使用严格的直接eval，总是将所有
              的声明放到新的环境记录里。
31. 否则让lexEnv是varEnv
32. 设置calleeXontext的LexicalEnvironment是lexEnv
33. 让lexDeclarations是code的LexicallyScopedDeclarations
34. 遍历lexDeclarations的元素记为d，做
    a. 注意：词法声明的名称不能与函数/生成器声明、形式参数或者变量的名字
              相同。词法声明的名称只能实例化，不能初始化。
    b. 遍历d的BoundNames的元素，记为dn，做
        i. 如果d的IsConstantDeclaration是true，那么
            1. 执行!lexEnv.CreateImmutableBinding(dn, true)
       ii. 否则
            2. 执行!lexEnv.CreateMutableBinding(dn, false)
35. 遍历functionsToInitialize的解析节点，记作f，做
    a. 让fn是f的BoundNames的独自元素
    b. 让fo是f的带lexEnv参数的InstantiateFunctionObject
    c. 执行!varEnv.SetMutableBinding(fn, fo, false)
36. 返回NormalCompletion(empty)
**** 注意2 B.3.3提供了一个扩展，以便兼容ECMAScript2015之前的ECMAScript的网页
           浏览器实现
**** 注意3 参数初始化可能包含直接eval的表达式。这种eval方式的顶层声明只能
           被本eval代码（11.2）察觉。这种声明产生的环境在8.5.3中描述。
** 内建函数对象Built-in Function Objects
本规范定义的内建函数对象会被实现为ECMAScript函数对象（10.2），其行为使用
ECMAScript代码实现；或者实现为函数奇异对象，其行为以其他方式提供。在各自的
方式中，调用函数的效果必须遵循各自的规范内容。实现可能会提供额外的不是
本规范定义的内建函数对象。

如果一个内建的函数对象被实现为一个奇异对象，必须有10.1中定义的基本对象的
行为。所有的这种函数奇异对象也要有\[\[Prototype]]、\[\[Extensible]]和\[\[Realm]]
内部占位。

除非其他规定，每个内建函数对象都有%Function.prototype%对象，作为其
\[\[Prototype]]内部占位的初始化值。

通过算法步骤或者其他方式对每个内建函数规定的行为是为函数的\[\[Call]]和
\[\[Construct]]调用的函数体时的行为的规范。然而\[\[Construct]]调用不被所有的
内建函数支持。每个内建函数，在由\[\[Call]]调用时，\[\[Call]]的thisArgument提供
this值，\[\[Call]]的argumentList提供命名了的参数，NewTarget值是undefined。当由
\[\[Construct]]调用时，this是未初始化的，\[\[Construct]]的argumentList提供命名了
的参数，newTarget参数提供了NewTarget值。如果内建函数是用ECMAScript函数对象的
方式实现，那么规定的行为必须被函数体的ECMAScript代码实现。ECMAScript函数对象
实现的内建函数必须是严格函数。如果内建的构造范的\[\[Call]]行为有投掷TypeError
异常之外的行为，这个函数的ECMAScript实现必须以不能导致函数的内部占位
\[\[IsClassConstructor]]为true的方式完成。

没有被确定为构造范的内建函数对象不要实现\[\[Construct]]内部函数，除非在
特定的函数里另有规定。当内建的构造范被作为new表达式的一部分被调用时，被调
用的\[\[Construct]]内部方法的argumentsList参数提供了内建构造范的命名了的参数。

不是构造范的内建函数没有prototype性质，除非在特定函数里另有规定。

内建函数有\[\[InitialName]]内部占位。

如果一个内建函数没有使用ECMAScript函数的方式方式来实现，必须提供遵循下列
定义的\[\[Call]]和\[\[Construct]]内部方法。
*** \[\[Call]](thisArgument, argumentsList)
内建函数F的\[\[Call]]内部方法接受参数thisArgument（ECMAScript语言值）和
argumentsList（元素是ECMAScript语言值的List）。被调用时执行下列步骤：
1. 让callerContext是运行时执行背景
2. 如果callerContext没有被挂起，挂起callerContext
3. 让calleeContext是新的执行背景
4. 设置calleeContext的Function是F
5. 让calleeRealm是F.\[\[Realm]]
6. 设置calleeContext的Realm是calleeRealm
7. 设置calleeContext的ScriptOrModule是null
8. 执行calleeContext初始化需要的实现定义
9. 将calleeContext压到ExecutionContextStack；calleeContext目前是运行时执行背景
10. 让result是与规范F一致方式评估F的完结记录。thisArgument是this值，argumentsList
    提供命名了的参数，NewTarget值是undefined。
11. 从ExecutionContextStack移除calleeContext，恢复callerContext作为运行时执行背景
12. 返回result
**** 注意： 当calleeContext被从ExecutionContextStack中移除后，它不能被销毁，如果
             它被一个可访问的生成器对象为了唤醒而挂起和保留的话。
*** \[\[Construct]](arugmentsList, newTarget)
内建方法F的\[\[Construct]]内部方法接受参数argumentsList（元素是ECMAScript
语言值的List）和newTarget（构造范）。执行步骤同\[\[Call]](10.3.1)，除了第10步：
10. 让result是与规范F一致方式评估F的完结记录。this值是未初始化的，
    argumentsList提供命名了的参数，newTarget作为NewTarget的值。
*** CreateBuiltinFunction(steps, length, name, internalSlotsList\[, realm\[,
   prototype\[, prefix]]])

抽象操作CreateBuiltinFunction接受参数steps、length、name和internalSlotsList（内部
占位的名称的List）与可选参数realm、prototype和prefix。internalSlotsList包含了作为
对象必须定义的其他内部占位的名字。操作创建内建的函数对象。被调用时执行下
列步骤：
1. Assert：steps是一套算法的步骤或者本规范提供的关于函数行为的其他定义。
2. 如果realm不存在或者realm是空，设置realm是当前的RealmRecord
3. Assert：realm是ReamlRecord
4. 如果prototype不存在，设置prototype是
   realm.\[\[Intrinsics]].\[\[%Function.prototype%]]
5. 让func是新的内建函数对象，被调用时执行steps描述的动作。新的函数对象有
   列在internalSlotsList的名称的内部占位和\[\[InitialName]]内部占位。
6. 设置func.\[\[Realm]]是realm
7. 设置func.\[\[Prototype]]是prototype
8. 设置func.\[\[Extensible]]是true
9. 设置func.\[\[InitialName]]是null
10. 执行!SetFunctionLength(func, length)
11. 如果prefix不存在，那么
    a. 执行!SetFunctionName(func, name)
12. 否则
    a. 执行!SetFunctionName(func, name, prefix)
13. 返回func

每个本规范定义的内建函数是通过调用CreateBuiltinFunction抽象操作创建的。
** 内建奇异对象内部方法和占位
本规范定义了几个内建的奇异对象。这些对象一般的行为类似基本对象，除了
少量特定情况。下列的奇异对象使用基本对象的内部方法，除了下列显示规定的
例外情况。
*** Bound Function Exotic Objects 绑定了this的函数对象
BoundFunctionExoticObject是包装了其他函数的函数对象。BoundFunctionExoticObject是
可调用的（有\[\[Call]]内部方法，也可能有\[\[Construct]]内部方法）。调用一个
BoundFunctionExoticObject一般导致它包装的函数被调用。

如果对象的\[\[Call]]和\[\[Construct]]（如果有）的内部方法按照随后的实现方式，
其他的基本内部方法使用10.1中定义的方式，那它就是BoundFunctionExoticObject。这些
方法在BoundFunctionCreate中被安进来。

BoundFunctionExoticObject没有列在表29的ECMAScript函数对象的内部占位。表30列出
的内部占位作为他们的替换，除了\[\[Prototype]]和\[\[Extensible]]
| 内部占位                  | 类型           | 描述                                 |
| \[\[BoundTargetFunction]] | 可调用的Object | 被包装的函数对象                     |
| \[\[BoundThis]]           | 任意           | 其值总是作为调用被包装函数时的this值 |
| \[\[BoundArguments]]      | 任意值的List   | 元素作为被包装函数调用时的第一个参数 |
**** \[\[Call]](thisArgument, argumentsList)
BoundFunctionExoticObject F的内部方法\[\[Call]]接受参数thisArgument（ECMAScript语
言值）和argumentsList（ECMAcript语言值的List）。被调用时执行下列步骤：
1. 让target是F.\[\[BoundTargetFunction]]
2. 让boundThis是F.\[\[BoundThis]]
3. 让boundArgs是F.\[\[BoundArguments]]
4. 让args是boundArgs的元素追加上argumentsList的元素的List
5. 返回?Call(target, boundThis, args)
**** \[\[Construct]](argumentsList, newTarget)
BoundFunctionExoticObject F的内部方法\[\[Construct]]接受参数argumentsList（
ECMAScript语言值的List）和newTarget（构造范）。被调用时执行下列步骤：
1. 让target是F.\[\[BoundTargetFunction]]
2. Assert：IsConstructor(target)是true
3. 让boundArgs是F.\[\[BoundArguments]]
4. 让args是boundArgs的元素追加上argumentsList的元素的List
5. 如果SameValue(F, newTarget)是true，设置newTarget为target
6. 返回?Construct(target, args, newTarget)
**** BoundFunctionCreate(targetFunction, boundThis, boundArgs)
抽象操作BoundFunctionCreate接受参数targetFunction、boundThis和boundArgs。用于规范
新的BoundFunctionExoticObject对象的创建行为。被调用时执行下列步骤：
1. Assert：Type(targetFunction)是Object
2. 让proto是?targetFunction.\[\[GetPrototypeOf]]()
3. 让internalSlotsList是表30列出的内部占位，加上\[\[Prototype]]和\[\[Extensible]]的
   List
4. 让obj是!MakeBasicObject(internalSlotsList)
5. 设置obj.\[\[Prototype]]是proto
6. 设置obj.\[\[Call]]是10.4.1.1中定义内容
7. 如果IsConstructor(targetFunction)是true，那么
    a. 设置obj.\[\[Construct]]是10.4.1.2中描述的内容
8. 设置obj.\[\[BoundTargetFunction]]是targetFunction
9. 设置obj.\[\[BoundThis]]是boundThis
10. 设置obj.\[\[BoundArguments]]是boundArguments
11. 返回obj
*** Array Exotic Objects 数组奇异对象
数组对象是一个奇异对象在处理ArrayIndex性质键（6.1.7）时给了特殊对待。性质的
名称是一个ArrayIndex的话，性质也被称作元素。每个数组对象有个一个不可设置的
length性质，它的值总是一个非负整数Number，其数学值小于2^32。length性质的值在
数字上大于所拥有的任何性质名称是ArrayIndex的性质键。无论何时，如果数组对象
创建或修改了自有性质，或者其他性质需要必要的调整以保证这个不变性。尤其是，
当增加一个名称是ArrayIndex的性质，length性质的值发生修改，如果必要，length值
比这个ArrayIndex的值大1；当length性变化的是，每个名称是ArrayIndex且没有小于
length的性质会被删除。这个限制仅提供给数组对象的自有性质，而从其原型上继承
的length和ArrayIndex性质则没有这种影响。
**** 注意 String性质名称P是ArrayIndex，当且仅当ToString(ToUint32(P))等与P，且
           ToUint32(P)b不是F(2^32-1)

对象是ArrayExoticObject（简单的说，数组对象），其\[\[DefineOwnProperty]]内部方
法使用下列的实现，其他基本内部方法使用10.1的定义。这些方法在ArrayCreate中被
安装进来。
**** \[\[DefineOwnProperty]](P, Desc)
ArrayExoticObject A的内部方法\[\[DefineOwnProperty]]接受参数P（性质键）和Desc（
PropertyDescriptor）。被调用时执行下列步骤：
1. Assert：IsPropertyKey(P)是true
2. 如果P是length，那么
    a. 返回?ArraySetLength(A, Desc)
3. 否则，如果P是ArrayIndex，那么
    a. 让oldLenDesc是OrdinaryGetOwnProperty(A, "length")
    b. Assert：!IsDataDescriptor(oldLenDesc)是true
    c. Assert：oldLenDesc.\[\[Configurable]]是false
    d. 让oldLen是oldLenDesc.\[\[Value]]
    e. Assert：oldLen是一个非负整数Number
    f. 让index是!ToUint32(P)
    g. 如果index >= oldLen且oldLenDesc.\[\[Writable]是false，返回false
    h. 让succeeded是!OrdinaryDefineOwnProperty(A, P, Desc)
    i. 如果succeeded是false，返回false
    j. 如果index>=oldLen，那么
        i. 设置oldLenDesc.\[\[Value]]是index+1_F
       ii. 让succeeded是OrdinaryDefineOwnProperty(A "length", oldLenDesc)
      iii. Assert：succeeded是true
    k. 返回true
4. 返回OrdinaryDefineOwnProperty(A, P, Desc)
**** ArrayCreate(length\[, proto])
抽象操作ArrayCreate接受参数length（非负整数）和可选参数proto。用于规范新的
数组奇异对象的创建。被调用时执行下列步骤：
1. 如果length>2^32-1，投掷RangeError异常
2. 如果proto不存在，设置proto是%Array.prototype%
3. 设置A是!MakeBasicObject(<<\[\[Prototype]], \[\[Extensible]]>>)
4. 设置A.\[\[Prototype]]是proto
5. 设置A.\[\[DefineOwnProperty]]符合10.4.2.1中定义
6. 执行!OrdinaryDefineOwnProperty(A, "length", PropertyDescriptor {
   \[\[Value]]:F(length), \[\[Writable]]:true, \[\[Enumerable]]:false,
   \[\[Configurable]]:false })
7. 返回A
**** ArraySpeciesCreate(originalArray, length)
抽象操作ArraySpeciesCreate接受参数originalArray和length（非负整数）。用于规范从
originalArray派生的构造范创建一个新的Array对象的过程。被调用时执行下列步骤：
1. 让isArray是?IsArray(originalArray)
2. 如果isArray是false，返回?ArrayCreate(length)
3. 让C是?Get(originalArray, "constructor")
4. 如果IsConstructor(C)是true，那么
    a. 让thisRealm是当前的RealmRecord
    b. 让realmC是?GetFunctionRealm(C)
    c. 如果thisRealm和reamlC不相同，那么
        i. 如果SameValue(C, realmC.\[\[Intrinsics]].\[\[%Array%]])是true，
           设置C是undefined
5. 如果Type(C)是Object，那么
    a. 设置C是?Get(C,@@species)
    b. 如果C是null，设置C是undefined
6. 如果C是undefined，返回?ArrayCreate(length)
7. 如果IsConstructor(C)是false，投掷TypeError异常
8. 返回?Constructor(C, <<F(length)>>0)
***** 注意 如果originalArray是用标准内建Array构造范为不是运行时执行背景的领而
            创建的，那么新的Array使用运行时执行背景的领进行创建。这维护了网页
            浏览器的兼容性，以往有用Array.prototype方法的行为，而现在用
            ArraySpeciesCreate
**** ArraySetLength(A, Desc)
抽象操作ArraySetLength接受参数A（数组对象）和Desc（PropertyDescriptor）。被调用
时执行步骤：
1. 如果缺少Desc.\[\[Value]]，那么
    a. 返回OrdinaryDefineOwnProperty(A, "length", Desc)
2. 让newLenDesc是Desc的备份
3. 让newLen是?ToUint32(Desc.\[\[Value]])
4. 让numberLen是?ToNumber(Desc.\[\[Value]])
5. 如果newLen与numberLen不相同，投掷RangeError异常
6. 设置newLenDesc.\[\[Value]]是newLen
7. 让oldLenDesc是OrdinaryGetOwnProperty(A, "length")
8. Assert：!IsDataDescriptor(oldLenDesc)是true
9. Assert：oldLenDesc.\[\[Configurable]]是false
10. 让oldLen是oldLenDesc.\[\[Value]]
11. 如果 newLen>= oldLen，那么
    a. 返回OrdinaryDefineOwnProperty(A, "length", newLenDesc)
12. 如果oldLenDesc.\[\[Writable]]是false，返回false
13. 如果缺少newLenDesc.\[\[Writable]]或者其值是true，让newWritable是true
14. 否则
    a. 注意：设置\[\[Writable]]属性是false，暗示了其性质不能被删除。
    b. 让newWritable是false
    c. 设置newLenDesc.\[\[Writable]]是true
15. 让succeeded是!OrdinaryDefineOwnProperty(A, "length", newLenDesc)
16. 如果succeeded是false，返回false
17. 遍历A上是ArrayInde的自有性质，记作P，且其数学值大于或等与newLen（这里
    不能使用不小于，因为有非数字键），按照数字降序，做：
    a. 让deleteSucceeded是!A.\[\[Delete]](P)
    b. 如果deleteSucceeded是false，那么
        i. 设置newLenDesc.\[\[Value]]是!ToUint32(P)+1_F
       ii. 如果newWritable是false，设置newLenDesc.\[\[Writable]]是false
      iii. 执行!OrdinaryDefineOwnProperty(A, "length", newLenDesc)
       iv. 返回false
18. 如果newWritable是false，那么
    a. 让succeeded是!OrdinaryDefineOwnProperty(A, "lenfth", PropertyDescriptor {
       \[\[Writable]]:false } )
    b. Assert：succeeded是true
19. 返回true
***** 注意 步骤3和4，如果Desc.\[\[Value]]是对象，其valueOf会执行两次。这是本
            规范从第二版开始规定的遗留行为。
*** String Exotic Objects
String对象是一个封装了String值的奇异对象，而且暴露了虚拟的整数索引的数据性
质，对应检索String值的编码单元。String奇异对象总是有数据性质length，其值表示
封装的String值的编码单元数量。编码单元数据性质和length性质都是不可修改与
不可设置的。

如果对象的\[\[GetOwnProperty]]、\[\[DefineOwnProerty]]和\[\[OwnPropertyKeys]]的内部
方法使用随后的实现，且其他基本内部方法使用10.1中的定义，对象就是String奇异对
象（简单说String对象）。在StringCreate中安装这些方法。

String奇异对象与基本对象有相同的内部占位。他们都有\[\[StringData]]内部占位。
**** \[\[GetOwnProperty]](P)
StringExoticObject S的\[\[GetOwnProperty]]内部方法接受参数P（性质键）。被调用时
执行下列步骤：
1. Assert：IsPropertyKey(P)是true
2. 让desc是OrdinaryGetOwnProperty(S, P)
3. 如果desc不是undefined，返回desc
4. 返回!StringGetOwnProperty(P, Desc)
**** \[\[DefineOwnProperty]](P, Desc)
StringExoticObject S的\[\[DefineOwnProperty]]内部方法接受参数P（性质键）和Desc（
PropertyDescriptor）。被调用时执行下列步骤：
1. Assert：IsPropertyKey(P)是true
2. 让stringDesc是!StringGetOwnProperty(S, P)
3. 如果stringDesc不是undefined，那么
    a. 让extensible是S.\[\[Extensible]]
    b. 返回!IsCompatiblePropertyDescriptor(extensible, Desc, stringDesc)
4. 返回!OrdinaryDefineOwnProperty(S, P, Desc)
**** \[\[OwnPropertyKeys]]()
StringExoticObject O的\[\[OwnPropertyKeys]]内部方法不接受参数P。被调用时执行
下列步骤：
1. 让keys是新的空List
2. 让str是O.\[\[StringData]]
3. Assert：Type(str)是String
4. 让len是str的长度
5. 从0开始便到len，记作i，i<len，按照升序做：
    a. 追加!ToString(F(i))到keys
6. 遍历O的自有性质，记作P，如果P是ArrayIndex，且!ToIntegerOrInfinity(P)>=len，
   那么按照升序，做
    a. 追加P到keys
7. 遍历O的自有性质，记作P，若Type(P)是String且P不是ArrayIndex，按照创建时间
   升序，做
    a. 追加P到keys
8. 遍历O的自有性质，记作P，若Type(P)是Symbol，按照创建时间升序，做
    a. 追加P到keys
9. 返回keys
**** StringCreate(value, prototype)
抽象操作StringCreate接受参数value（String）和prototype。用于规范
StringExoticObject的创建过程。被调用时执行下列步骤：
1. 让S是!MakeBasicObject(<<\[\[Prototype]], \[\[Extensible]], \[\[StringData]]>>)
2. 设置S.\[\[Prototype]]是prototype
3. 设置S.\[\[StringData]]是value
4. 设置S.\[\[GetOwnProperty]]是10.4.3.1中定义
5. 设置S.\[\[DefineOwnProperty]]是10.4.3.2中定义
6. 设置S.\[\[OwnPropertyKeys]]是10.4.3.3中定义
7. 让length是value的编码单元数量
8. 执行!DefinePropertyOrThrow(S, "length", PropertyDescriptor { \[\[Value]]:F(length),
   \[\[Writable]]:false, \[\[Enumerable]]:false, \[\[Configurable]]:false] })
9. 返回S
**** StringGetOwnProperty(S, P)
抽象操作StringGetOwnProperty接受参数S和P。被调用时执行下列步骤：
1. Assert：S是有\[\[StringData]]内部占位的对象
2. Assert：IsPropertyKey(P)是true
3. 如果Type(P)不是String，返回undefined
4. 让index是!CanonicalNumericIndexString(P)
5. 如果index是undefined，返回undefined
6. 如果IsIntegralNumber(index)是false，返回undefined
7. 如果index是-0_F，返回undefined
8. 让str是S.\[\[StringData]]
9. Assert：Type(str)是String
10. 让len是str的长度
11. 如果R(index)<0或者len<=R(index)返回undefined
12. 让resultStr是一个长度1，包含str上处于R(index)的一个编码单元。
13. 返回PropertyDescriptor { \[\[Value]]:resultStr, \[\[Writable]]:false,
    \[\[Enumerable]]:true, \[\[Configurable]]:false }
*** Arguments Exotic Objects
大多数函数制作一个其函数体代码可见的参数对象。依赖于函数定义的特性，这个
参数对象是基本对象或者参数奇异对象。参数奇异对象是奇异对象，其ArrayIndex性质
映射到调用其联结的ECMAScript函数的形式参数。

如果对象使用下方实现了其内部方法，其他内部方法使用10.1的定义实现，就是
参数奇异对象。CreateMappedArgumentsObject安装这些方法。
**** 注意1 CreateUnmappedArgumentsObject也安装到了本条款，用于创建基本对象，而不
            是参数奇异对象。

参数奇异对象与基本对象有相同的内部占位。还有\[\[ParameterMap]]内部占位。基
本参数对象也有一个\[\[ParameterMap]]内部占位，其值总是undefined。对于基本参数
对象，\[\[ParameterMap]]内部占位仅用于Object.prototype.toString（20.1.3.6）来辨别
他们。
**** 注意2 ArgumentsExoticObject的名称数学值比对应函数对象的形式参数的索引小的
           整数索引的数据性质在初始化共享函数在执行上下文的实际参数的绑定。
           这意味正修改性质会修改实参的值，反过来也一样。这种一致性会在被
           破坏，如果这样的性质被删除后又增加进来，或者修改为访问性质。如果
           参数对象是基本对象，性质的值应该是参数传递进来的简单复制，就不会
           有性质值与形式参数值的动态链接。
**** 注意3 ParameterMap对象和其性质被用于明确说明参数对象与参数绑定一致的设
           备。ParameterMap对象和其性质的值的对象不能被ECMAScript代码直接访问
           到。ECMASCript实现可以不实际创建这个对象来实现规定的语义。
**** 注意4 基本参数对象定义了一个不可设置的访问性质，名称是callee，在访问时
            会投掷异常。这个callee对于ArgumentExotic对象有更多特殊的汉所以，
            仅会为某些非严格函数类来创建。在基本不变性中关于本性质的定义
            用于确保它不会被任何ECMAScript一致实现以任何方式定义。
**** 注意5 ArgumentsExoticObject的ECMAScript实现有一个历史遗留性质caller。2017
            之前的版本，规范在OrdinaryArgumentsObject中包含了一个会投掷异常的
            caller性质。既然实现不在包含本扩展，ECMAScript2017移除了这个投掷
            异常的caller要求
**** \[\[GetOwnProperty]](P)
ArgumentsExoticObject args的内部方法\[\[GetOwnProperty]]接受参数P（性质键）。被
调用时执行下列步骤：
1. 让desc是OrdinaryGetOwnProperty(args, P)
2. 如果desc是undefined，返回desc
3. 让map是args.\[\[ParamterMap]]
4. 让isMapped是!HasOwnProperty(map, P)
5. 如果isMapped是true，那么
    a. 设置desc.\[\[Value]]是Get(map,P)
6. 返回desc
**** \[\[DefineOwnProperty]](P, Desc)
ArgumentsExoticObject args的内部方法\[\[DefineOwnProperty]]接受参数P（性质键）和
Desc（PropertyDescriptor）。被调用时执行下列步骤：
1. 让map是args.\[\[ParamterMap]]
2. 让isMapped是HasOwnProperty(map,P)
3. 让newArgDesc是Desc
4. 如果isMapped是true，而且IsDataDescriptor(Desc)是true，那么
    a. 如果Desc.\[\[Value]]不存在，而且Desc.\[\[Writable]]存在，且值是false，那么
        i. 设置newArgDesc是Desc的备份
       ii. 设置newArgDesc.\[\[Value]]是Get(map, P)
5. 让allowed是?OrdinaryDefineOwnProperty(args, P, newArgDesc)
6. 如果allowed是false，返回false
7. 如果isMapped是true，那么
    a. 如果IsAccessorDescriptor(Desc)是true，那么
        i. 调用map.\[\[Delete]](P)
    b. 否则
        i. 如果Desc.\[\[Value]]存在，那么
            1. 让setStatus是Set(map, P, Desc.\[\[Value]], false)
            2. Assert：setStatus是true。因为参数对象映射的形式参数总是可写的。
       ii. 如果Desc.\[\[Writable]]存在，且是false，那么
            1. 调用map.\[\[Delete]](P)
8. 返回true
**** \[\[Get]](P, Receiver)
ArgumentsExoticObject args的内部方法\[\[GetOwnProperty]]接受参数P（性质键）和
Receiver(ECMAScript语言值）。被调用时执行下列步骤：
1. 让map是args.\[\[ParamterMap]]
2. 让isMapped是!HasOwnProperty(map,P)
3. 如果isMapped是false，那么
    a. 返回?OrdinaryGet(args, P, Receiver)
4. 否则
    a. Assert：map包含形式参数P
    b. 返回Get(map, P)
**** \[\[Set]](P, V, Receiver)
ArgumentsExoticObject args的内部方法\[\[Set]]接受参数P（性质键）、V（ECMAScript
语言值）和Receiver（ECMAScript语言值）。被调用时执行下列步骤：
1. 如果SameValue(args, Receiver)是false，那么
    a. 让isMapped是false
2. 否则
    a. 让map是args.\[\[ParameterMap]]
    b. 让isMapped是!HasOwnProperty(map, P)
3. 如果isMapped是true，那么
    a. 让setStatus是Set(map, P, V, false)
    b. Assert：setStatus是true。因为参数对象映射的形式参数总是可写的
4. 返回?OrdinarySet(args, P, V, Receiver)
**** \[\[Delete]](P)
ArgumentsExoticObject args的内部方法\[\[Delete]]接受参数P（性质键）。被调用时
执行下列步骤：
1. 让map是args.\[\[ParameterMap]]
2. 让isMapped是!HasOwnProperty(map,P)
3. 让result是?OrdinaryDelete(args, P)
4. 如果result是true，而且isMapped是true，那么
    a. 调用map.\[\[Delete]](P)
5. 返回result
**** CreateUnmappedArgumentsObject(argumentsList)
抽象操作CreateUnmappedArgumentsObject接受参数argumentsList。被调用时执行下列步
骤：
1. 让len是argumentsList的元素数量
2. 让obj是!OrdinaryObjectCreate(%ObjectPrototype%, <<\[\[ParameterMap]]>>)
3. 设置obj.\[\[ParameterMap]]是undefined
4. 执行DefinePropertyOrThrow(obj, "length", PropertyDescriptor { \[\[Value]]:F(len),
   \[\[Writable]]:true, \[\[Enumerable]]:false, \[\[Configurable]]:true })
5. 让index是0
6. 当index < len时，重复
    a. 让val是arugmentsList[index]
    b. 执行!CreateDataPropertyOrThrow(obj, !ToString(F(index)), val)
    c. 设置index是index+1
7. 执行!DefinePropertyOrThrow(obj, @@iterator, PropertyDescriptor( {
   \[\[Value]]:%Array.prototype.values%, \[\[Writable]]:true, \[\[Enumerable]]:false,
   \[\[Configurable]]:true } )
8. 执行!DefinePropertyOrThrow(obj, "callee", PropertyDescriptor( {
   \[\[Get]]:%ThrowTypeError%, \[\[Set]]:%ThrowTypeError%, \[\[Enumerable]]:false,
   \[\[Configurable]]:false } )
9. 返回obj
**** CreateMappedArgumentsObject(func, formals, argumentsList, env)
抽象操作CreateMappedArgumentsObject接受参数func（Object）、formals（ParseNode）、
argumentsList（List）和env（EnvironmentRecord）。被调用时执行下列步骤：
1. Assert：formals不包含剩余参数，绑定模式，或者初始化值。有可能包含重复的
   标记。
2. 让len是arugmentsList的元素数量
3. 让obj是!MakeBasicObject(<<\[\[Prototype]],\[\[Extensible]],\[\[ParamterMap]]>>)
4. 设置obj.\[\[GetOwnProperty]]是10.4.4.1中定义
5. 设置obj.\[\[DefineOwnProperty]]是10.4.4.2中定义
6. 设置obj.\[\[Get]]是10.4.4.3中定义
7. 设置obj.\[\[Set]]是10.4.4.4中定义
8. 设置obj.\[\[Delte]]是10.4.4.5中定义
9. 设置obj.\[\[Protptype]]是%Object.prototype%
10. 让map是!OrdinaryObjectCreate(null)
11. 设置obj.\[\[ParameterMap]]是map
12. 让parameterNames是formals的BoundNames
13. 让numberOfParamters是parameterNames的元素数量
14. 让index是0
15. 当index<len时，重复
    a. 让val是argumentsList\[index]
    b. 执行!CreateDataPropertyOrThrow(obj, !ToString(F(index)), val)
    c. 设置index是index+1
16. 执行!DefinePropertyOrThrow(obj, "length", PropertyDescriptor { \[\[Value]]:F(len),
    \[\[Writable]]:true, \[\[Enumerable]]:false, \[\[Configurable]]:true })
17. 让mappedNames是新的空List
18. 让index是numberOfParameters-1
19. 当index>=0是，重复
    a. 让name是parameterNames[index]
    b. 如果name不是mappedNames的元素，那么
        i. 增加name作为mappedNames的元素
       ii. 如果index<len，那么
            1. 让g是MakeArgGetter(name, env)
            2. 让p是MakeArgSetter(name, env)
            3. 执行map.\[\[DefineOwnProperty]](!ToString(F(index)), PropertyDescriptor {
               \[\[Set]]:p, \[\[Get]]:g, \[\[Enumerable]]:false,
               \[\[Configurable]]:true })
    c. 设置index是index-1
20. 执行!DefinePropertyOrThrow(obj, @@iterator, PropertyDescriptor {
    \[\[Value]]:%Array.prototype.values%, \[\[Writable]]:true, \[\[Enumerable]]:false,
    \[\[Configurable]]:true })
21. 执行!DefinePropertyOrThrow(obj, "callee", PropertyDescriptor { \[\[Value]]:func,
    \[\[Writable]]:true, \[\[Enumerable]]:false, \[\[Configurable]]:true })
22. 返回obj
***** MakeArgGetter(name, env)
抽象操作MakeArgGetter接受参数name（String）和env（EnvironmentRecord）。创建一个
内建函数，执行时返回env上name绑定的值。被调用时执行下列步骤：
1. 让steps是随后规定的ArgGetter函数的步骤
2. 让length是随后规定的ArgGetter函数不可选参数的数量
3. 让getter是!CreateBuiltinFunction(steps, length, "",<<\[\[Name]], \[\[Env]]>>)
4. 设置getter.\[\[Name]]是name
5. 设置getter.\[\[Env]]是env
6. 返回getter

ArgGetter函数是一个匿名内建函数，有\[\[Name]]和\[\[Env]]内部占位。当不期望
参数的ArgGetter被调用时，执行下列步骤：
1. 让f是活跃函数对象
2. 让name是f.\[\[Name]]
3. 让env是f.\[\[Env]]
4. 返回env.GetBindingValue(name, false)
****** 注意 ArgGetter永远不会被ECMAScript代码直接访问到。
***** MakeArgSetter(name, env)
抽象操作MakeArgSetter接受参数name（String）和env（EnvironmentRecord）。创建一个
内建函数，执行时设置env上name绑定的值。被调用时执行下列步骤：
1. 让steps是随后规定的ArgSetter函数的步骤
2. 让length是随后规定的ArgSetter函数不可选参数的数量
3. 让setter是!CreateBuiltinFunction(steps, length, "",<<\[\[Name]], \[\[Env]]>>)
4. 设置setter.\[\[Name]]是name
5. 设置setter.\[\[Env]]是env
6. 返回setter。

ArgSetter函数是一个有\[\[Name]]和\[\[Env]]内部占位的匿名内建函数。当ArgSetter被
带value参数调用时，执行下列步骤：
1. 让f是活跃函数对象
2. 让name是f.\[\[Name]]
3. 让env是f.\[\[Env]]
4. 返回env.SetMutableBinding(name, value, false)
****** 注意 ArgSetter永远不会被ECMAScript代码直接访问到。
*** Integer-Indexed Exotic Object 整数索引奇异对象
整数索引奇异对象是值会特殊处理整数索引性质键的奇异对象。

整数索引奇异对象有基本对象的内部占位，还有\[\[ViewedArrayBuffer]]、
\[\[ArrayLength]]、\[\[ByteOffset]]、\[\[ContentType]]和\[\[TypedArrayName]]内部占
位。

如果一个对象\[\[GetOwnProperty]]、\[\[HasProperty]]、\[\[DefineOwnProperty]]、
\[\[Get]]、\[\[Set]]、\[\[Delete]]和\[\[OwnPropertyKey]]内部方法使用本节定义，其
它的基础内部方法使用10.1中定义，这就是整数索引奇异对象。这些方法在
IntegerIndexedObjectCreate中被安装。
**** \[\[GetOwnProperty]](P)
IntegerIndexedExoticObject O的\[\[GetOwnProperty]]内部方法接受参数P（性质键）。
被调用时执行下列步骤：
1. Assert：IsPropertyKey(P)是true
2. Assert：O是IntegerIndexedExoticObject
3. 如果Type(P)是String，那么
    a. 让numericIndex是!CanonicalNumericIndexString(P)
    b.  如果numericIndex不是undefined，那么
        i. 让value是!IntegerIndexedElementGet(O, numericIndex)
       ii. 如果value是undefined，返回undefined
      iii. 返回PropertyDescriptor { \[\[Value]]:value, \[\[Writable]]:true,
           \[\[Enumerable]]:true, \[\[Configurable]]:true }
4. 返回OrdinaryGetOwnProperty(O, P)
**** \[\[HasProperty]](P)
IntegerIndexedExoticObject O的\[\[HasProperty]]内部方法接受参数P（性质键）。
被调用时执行下列步骤：
1. Assert：IsPropertyKey(P)是true
2. Assert：O是IntegerIndexedExoticObject
3. 如果Type(P)是String，那么
    a. 让numericIndex是!CanonicalNumericIndexString(P)
    b. 如果numericIndex不是undefined，返回!IsValidIntegerIndex(O, numericIndex)
4. 返回?OrdinaryHasProperty(O, P)
**** \[\[DefineOwnProperty]](P, Desc)
IntegerIndexedExoticObject O的\[\[DefineOwnProperty]]内部方法接受参数P（性质键）
和Desc（PropertyDescriptor）。被调用时执行下列步骤：
1. Assert：IsPropertyKey(P)是true
2. Assert：O是IntegerIndexedExoticObject
3. 如果Type(P)是String，那么
    a. 让numericIndex是!CanonicalNumericIndexString(P)
    b. 如果numericIndex不是undefined，那么
        i. 如果!IsValidIntegerIndex(O, numericIndex)是false，返回false
       ii. 如果Desc有\[\[Configurable]]字段，且是false，返回false
      iii. 如果Desc有\[\[Enumerable]]字段，且是false，返回false
       iv. 如果!IsAccessorDescriptor(Desc)是true，返回false
        v. 如果Desc有\[\[Writable]]字段，切实false，返回false
       vi. 如果Desc有\[\[Value]]字段，执行?IntegerIndexedElementSet(O, numericIndex,
           Desc.\[\[Value]])
      vii. 返回true
4. 返回?OrdinaryDefineOwnProperty(O, P)
**** \[\[Get]](P, Receiver)
IntegerIndexedExoticObject O的\[\[Get]]内部方法接受参数P（性质键）和Receiver（
ECMAScript语言值）。被调用时执行下列步骤：
1. Assert：IsPropertyKey(P)是true
2. 如果Type(P)是String，那么
    a. 让numericIndex是!CanonicalNumericIndexString(P)
    b. 如果numericIndex不是undefined，那么
        i. 返回!IntegerIndexedElementGet(O, numericIndex)
3. 返回?OrdinaryGet(O, P, Receiver)
**** \[\[Set]](P, V, Receiver)
IntegerIndexedExoticObject O的\[\[Set]]内部方法接受参数P（性质键）、V（ECMAScript
语言值）和Receiver（ECMAScript语言值）。被调用时执行下列步骤：
1. Assert：IsPropertyKey(P)是true
2. 如果Type(P)是String，那么
    a. 让numericIndex是!CanonicalNumericIndexString(P)
    b. 如果numericIndex不是undefined，那么
        i. 执行!IntegerIndexedElementSet(O, numericIndex)
       ii. 返回true
3. 返回?OrdinarySet(O, P, V, Receiver)
**** \[\[Delete]](P)
IntegerIndexedExoticObject O的\[\[Delete]]内部方法接受参数P（性质键）。被调用时
执行下列步骤：
1. Assert：IsPropertyKey(P)是true
2. Assert：O是IntegerIndexedExoticObject
3. 如果Type(P)是String，那么
    a. 让numericIndex是!CanonicalNumericIndexString(P)
    b. 如果numericIndex不是undefined，那么
        i. 如果!IsValidIntegerIndex(O, numericIndex)是false，返回true，否则返回false
4. 返回?OrdinaryDelete(O, P)
**** \[\[OwnPropertyKeys]]
IntegerIndexedExoticObject O的\[\[OwnPropertyKeys]]内部方法不接受参数。被调用时
执行下列步骤：
1. 让keys是新的空List
2. Assert：O是IntegerIndexedExoticObject
3. 如果IsDetachedBuffer(O.\[\[ViewedArrayBuffer]])是false，那么
    a. 按照升序遍历[0, O.\[\[ArrayLength]])上的整数，记作i，做
        i. 在keys上追加!ToString(F(i))
4. 遍历O上自有性质，性质键P，满足Type(P)是String，而且P不是IntegerIndex，按照
   创建时间升序，做：
    a. 在keys上追加P
5. 遍历O上自有性质，性质键P，满足Type(P)是Symbol，按照创建时间升序，做：
    a. 在keys上追加P
6. 返回keys
**** IntegerIndexedObjectCreate(prototype)
抽象操作IntegerIndexedObjectCreate接受参数prototype。用于规定创建新的
IntegerIndexedExoticObject的过程。被调用时执行下列步骤：
1. internalSlotsList是<<\[\[Prototype]], \[\[Extensible]], \[\[ViewedArrayBuffer]], 
   \[\[TypedArrayName]], \[\[ContentType]], \[\[ByteLength]], \[\[ByteOffset]], 
   \[\[ArrayLength]], >>
2. 让A是!MakeBasicObject(internalSlotsList)
3. 设置A.\[\[GetOwnProperty]]是10.4.5.1中定义
4. 设置A.\[\[HasProperty]]是10.4.5.2中定义
5. 设置A.\[\[DefineOwnProperty]]是10.4.5.3中定义
6. 设置A.\[\[Get]]是10.4.5.4中定义
7. 设置A.\[\[Set]]是10.4.5.5中定义
8. 设置A.\[\[Delete]]是10.4.5.6中定义
9. 设置A.\[\[OwnPropertyKeys]]是10.4.5.7中定义
10. 设置A.\[\[Prototype]]是prototype
11. 返回A
**** IsValidIntegerIndex(O, index)
抽象操作IsVaidIntegerIndex接受参数O和index（Number）。被调用时执行下列步骤：
1. Assert：O是IntegerIndexedExoticObject
2. 如果IsDetachedBuffer(O.\[\[ViewedArrayBuffer]])是true，返回false
3. 如果!IsIntegeralNumber(index)是false，返回false
4. 如果index是-0_F，返回false
5. 如果R(index)<0或者R(index)>=O.\[\[ArrayLength]]，返回false
6. 返回true
**** IntegerIndexedElementGet(O, index)
抽象操作IntegerIndexedElementGet接受参数O和index（Number）。被调用时执行下列
步骤：
1. Assert：O是IntegerIndexedExoticObject
2. 如果!IsValidIntegerIndex(O, index)是false，返回undefined
3. 让offset是O.\[\[ByteOffset]]
4. 让arrayTypeName是O.\[\[TypedArrayName]]的String
5. 让elementSize是arrayTypeName按照表60规定的元素大小值
6. 让indexedPosition是(R(index)*elementSize)+offset
7. 让elementType是arrayTypeName在表60规定的元素类型值
8. 返回GetValueFromBuffer(O.\[\[ViewedArrayBuffer]], indexedPosition, elementType, true,
   Unordered)
**** IntegerIndexedElementSet(O, index, value)
抽象操作IntegerIndexedElementSet接受参数O、index（Number）和value。被调用时执
行下列步骤：
1. Assert：O是IntegerIndexedExoticObject
2. 如果O.\[\[ContentType]]是BigInt，让numValue是?ToBigInt(value)
3. 否则让numValue是?ToNumber(value)
4. 如果!IsValidIntegerIndex(O, index)是true，那么
    a. 让offset是O.\[\[ByteOffset]]
    b. 让arrayTypeName是O.\[\[TypedArrayName]]的String值
    c. 让elementSize是arrayTypeName按照表60规定的元素大小的值
    d. 让indexedPosition是(R(index)*elementSize)+offset
   e. 让elementType是arrayTypeName在表60的元素类型值
    f. 执行SetValueBuffer(O.\[\[ViewedArrayBuffer]], indexedPosition, elementType,
       numValue, true, unordered)
5. 返回NormalCompletion(undefined)
***** 注意 这个操作总是成功，但是试图在TypedArray末端写入的时候，或者在某个已
            脱离的ArrayBuffer支持的TypedArray上写入的时候，没有任何效果。
*** Module Namespace Exotic Object 模块命名空间奇异对象
ModuleNamespaceExoticObject是一个暴露从ECMAScript模块（16.2.3）导出的绑定的奇异
对象。Module导出的绑定名称与ModuleNamespaceExoticObject的String键的自有性质是1-1
映射。每个String值的性质键就是对应导出的绑定名称的String值。在
ModuleNamespaceExoticObject只有String键的性质。每个性质都有属性{ 
\[\[Writable]]:true, \[\[Enumerable]]:true, \[\[Configurable]]:false }。
ModuleNamespaceExoticObject都是不可扩展的。

如果对象的\[\[SetPrototypeOf]]、\[\[IsExtensible]]、\[\[PreventExtensions]]、
\[\[GetOwnProperty]]、\[\[DefineOwnProperty]]、\[\[HasProperty]]、\[\[Get]]、
\[\[Set]]、\[\[Delete]]和\[\[OwnPropertyKeys]]内部方法使用本节定义，其他基本内部
方法使用10.1中的定义，这对象就是ModuleNamespaceExoticObject。这些方法在
ModuleNamespaceCreate中安装。

ModuleNamespaceExoticObject有表31中的内部占位。
| 内部占位        | 类型         | 描述                                                                                                                                             |
| \[\[Module]]    | ModuleRecord | 导出这个命名空间的ModuleRecord                                                                                                                   |
| \[\[Exports]]   | List<String> | 作为本对象的性质被导出的名称的String值组成的List。本List被排序时，像String值数组一样用undefined作为comparefn调用%Array.prototype.sort%进行排序。 |
| \[\[Prototype]] | Null         | 本占位总是null（10.4.6.1）                                                                                                                       |

ModuleNamespaceExoticObject在上述内部方法中，除了\[\[GetPrototypeOf]]使用10.1.1中
的定义，其他的特定的备选定义。
**** \[\[SetPrototypeOf]](V)
ModuleNamespaceExoticObject O的\[\[SetPrototypeOf]]内部方法接受参数V（Object或者
null）。被调用时执行下列步骤：
1. 返回?SetImmutablePrototype(O, V)
**** \[\[IsExtensible]]()
ModuleNamespaceExoticObject O的\[\[IsExtensible]]内部方法不接受参数。被调用时执
行下列步骤：
1. 返回false
**** \[\[PreventExtensions]]()
ModuleNamespaceExoticObject O的\[\[PreventExtensions]]内部方法不接受参数。被调用
时执行下列步骤：
1. 返回true
**** \[\[GetOwnProperty]](P)
ModuleNamespaceExoticObject O的\[\[GetOwnProperty]]内部方法接受参数P（性质键）。
被调用时执行下列步骤：
1. 如果Type(P)是Symbol，返回OrdinaryGetOwnProperty(O, P)
2. 让exports是O.\[\[Exports]]
3. 如果P不是exports中元素，返回undefined
4. 让value是?O.\[\[Get]](P, O)
5. 返回PropertyDescriptor { \[\[Value]]:value, \[\[Writable]]:true,
   \[\[Enumerable]]:true, \[\[Configurable]]:false }
**** \[\[DefineOwnProperty]](P, Desc)
ModuleNamespaceExoticObject O的\[\[DefineOwnProperty]]内部方法接受参数P（性质键）
和Desc（PropertyDescriptor）。被调用时执行下列步骤：
1. 如果Type(P)是Symbol，返回OrdinaryDefineOwnProperty(O, P, Desc)
2. 让current是?O.\[\[GetOwnProperty]](P)
3. 如果current是undefined，返回false
4. 如果Desc.\[\[Configurable]]存在且是true，返回false
5. 如果Desc.\[\[Enumerable]]存在且是false，返回false
6. 如果!IsAccessorDescriptor(Desc)是true，返回false
7. 如果Desc.\[\[Writable]]存在且是false，返回false
8. 如果Desc.\[\[Value]]存在，返回SameValue(Desc.\[\[Value]], current.\[\[Value]])
9. 返回true
**** \[\[HasProperty]](P)
ModuleNamespaceExoticObject O的\[\[HasProperty]]内部方法接受参数P（性质键）。被
调用时执行下列步骤：
1. 如果Type(P)是Symbol，返回OrdinaryHasProperty(O, P)
2. 让exports是O.\[\[Exports]]
3. 如果P是exports的元素，返回true
4. 返回false
**** \[\[Get]](P,Receiver)
ModuleNamespaceExoticObject O的\[\[Get]]内部方法接受参数P（性质键）和Receiver
（ECMAScript语言值）。被调用时执行下列步骤：
1. Assert：IsPropertyKey(P)是true
2. 如果Type(P)是Symbol，那么
    a. 返回?OrdinaryGet(O, P, Receiver)
3. 让exports是O.\[\[Exports]]
4. 如果P不是exports元素，返回undefined
5. 让m是O.\[\[Module]]
6. 让binding是!m.ResolveExport(P)
7. Assert：binding是ResolveBindingRecord
8. 让targetModule是binding.\[\[Module]]
9. Assert：targetModule不是undefined
10. 如果binding.\[\[BindingName]]是"*namespace*"，那么
   a. 返回?GetModuleNamespace(targetModule)
11. 让targetEnv四targetModule.\[\[Environment]]
12. 如果targetEnv是undefined，投掷ReferenceError异常
13. 返回?targetEnv.GetBindingValue(binding.\[\[BindingName]], true)
***** 注意 ResolveExport是没有副作用的。每次带着特定exportName和resolveSet参数
            调用本操作，必须返回相同的结果。实现会选择为每个
            ModuleNamespaceExoticObject的\[\[Exports]]预先计算或者缓存ResolveExport
            结果。
**** \[\[Set]](P,V, Receiver)
ModuleNamespaceExoticObject O的\[\[Set]]内部方法接受参数P（性质键）、V（
ECMAScript语言值）和Receiver（ECMAScript语言值）。被调用时执行下列步骤：
1. 返回false
**** \[\[Delete]](P)
ModuleNamespaceExoticObject O的\[\[Delete]]内部方法接受参数P（性质键）。被调用
时执行下列步骤：
1. Assert：IsPropertyKey(P)是true
2. 如果Type(P)是Symbol，那么
    a. 返回?OrdinaryDelete(O, P)
3. 让exports是O.\[\[Exports]]
4. 如果P是exports元素，返回false
5. 返回true
**** \[\[OwnPropertyKeys]]()
ModuleNamespaceExoticObject O的\[\[OwnPropertyKeys]]内部方法不接受参数。被调用时
执行下列步骤：
1. 让exports是O.\[\[Exports]]的副本
2. 让symbolKeys是!OrdinaryOwnPropertyKeys(O)
3. 追加symbolKeys的全部元素到exports中
4. 返回exports
**** ModuleNamespaceCreate(module, exports)
抽象操作ModuleNamespaceCreate接受参数module和exports。用于规范创建
ModuleNamespaceExoticObject的过程。被调用时执行下列步骤：
1. Assert：module是ModuleRecord
2. Assert：module.\[\[Namespace]]是undefined
3. Assert：exports是String的List
4. 让internalSlotsList是表31中列出内部占位列表
5. 让M是!MakeBasicObject(internalSlotsList)
6. 设置M的基本内部方法遵循10.4.6的定义规范
7. 设置M.\[\[Prototype]]是null
8. 设置M.\[\[Module]]是module
9. 让sortedExports是exports元素的list，按照数组使用undefined作为comparefn调用
   %Array.prototype.sort%的方式排序。
10. 设置M.\[\[Exports]]是sortedExports
11. 遵循28.3中定义创建M的自有性质
12. 设置module.\[\[Namespace]]是M
13. 返回M
*** Immutable Prototype Exotic Object
ImmutablePrototypeExoticObject是奇异对象，其\[\[Prototype]]内部占位在初始化后
不能变动。

如果一个对象的\[\[SetPrototypeOf]]内部方法使用随后的实现，这个对象就是
ImmutablePrototypeExoticObject。（其他的基本内部方法可以使用任意实现，依赖于
请求ImmutablePrototypeExoticObject的规定）
**** 注意 不想其他奇异对象，没有指明为创建ImmutablePrototypeExoticObject定义的
           抽象操作。因为他们仅被%Object.prototype%、host环境，在host环境内使
           用，联结的对象潜在的也是奇异对象，所以需要各自指明的创建过程。
**** \[\[SetPrototypeOf]](V)
ImmutablePrototypeExoticObject O的\[\[SetPrototypeOf]]内部方法接受参数V（Object或
null）。被调用时执行下列步骤：
1. 返回?SetImmutablePrototype(O, V)
**** SetImmutablePrototype(O, V)
抽象操作SetImmutablePrototype接受参数O和V。被调用时执行下列步骤：
1. Assert：Type(V)是Object或者Null
2. 让current是?O.\[\[GetPrototypeOf]]()
3. 如果SameValue(V, current)是true，返回true
4. 返回false
** Proxy Object Internal Methods And Internal Slots
ProxyObject是奇异对象，部分基本内部方法使用ECMAScript代码实现。每个
ProxyObject都有\[\[ProxyHandler]]内部占位。\[\[ProxyHandler]]是一个对象，被称为
代理的HandlerObject，也可能是null。HandlerObject的Methods（表32）会被用于扩大
一个或者多个ProxyObject内部方法的实现。每个ProxyObject还有一个内部占位
\[\[ProxyTarget]]，是对象或者null。这个对象称为代理的TargetObject。

如果一个对象的基本内部方法（包括\[\[Call]]和\[\[Construct]]，如果提供了）
使用本节的定义，这个对象就是ProxyExoticObject。使用ProxyCreate安装这些方法。
| 内部方法                | 顾问方法                 |
| \[\[GetPrototypeOf]]    | getPrototypeOf           |
| \[\[SetPrototypeOf]]    | setPrototypeOf           |
| \[\[IsExtensible]]      | isExtensible             |
| \[\[PreventExtensions]] | preventExtensions        |
| \[\[GetOwnProperty]]    | getOwnPropertyDescriptor |
| \[\[DefineOwnProperty]] | defineProperty           |
| \[\[HasProperty]]       | has                      |
| \[\[Get]]               | get                      |
| \[\[Set]]               | set                      |
| \[\[Delete]]            | delete                   |
| \[\[OwnProperty]]       | ownKeys                  |
| \[\[Call]]              | apply                    |
| \[\[Construct]]         | construct                |

顾问方法被调用于以提供代理对象的内部方法时，代理目标对象会作为一个参数
传递给顾问方法。代理顾问对象不需要对应每个基本内部方法。调用代理的内部方
法会导致调用代理目标对象上对应的内部方法，如果顾问对象没有方法对应这种
捕获的话。

代理对象的\[\[ProxyHandler]]和\[\[ProxyTarget]]内部占位总是在对象创建的时候进
行初始化，一般也是不能修改的。有些代理对象以一种允许被随即调用的方式进行
创建。当调用代理的时候，而它的\[\[ProxyHandler]]和\[\[ProxyTarget]]内部占位还被
设置为null，会导致随即调用代理对象的内部方法投掷TypeError一场。

因为代理对象允许使用任意ECMAScript代码实现这些内部方法，可能定义了一个代理
对象的顾问方法违反了6.1.7.3中定义的不变性。6.1.7.3中定义的一些内部方法不变性
是基本的完好不变形。这些不变性被在本节规定的代理对象的内部方法显式的强制
使用。ECMAScript实现必须在任何可能的破坏不变性下保持强壮。

在随后的算法声明中，假设O是ECMAScript对象，P是性质键，V是ECMAScript语言值和
Desc是PropertyDescriptor记录。
*** \[\[GetPrototypeOf]]()
ProxyExoticObject O的\[\[GetPrototypeOf]]内部方法不接受参数。被调用时执行下列
步骤：
1. 让handler是O.\[\[ProxyHandler]]
2. 如果handler是null，投掷TypeError异常
3. Assert：Type(handler)是对象
4. 让target是O.\[\[ProxyTarget]]
5. 让trap是?GetMethod(handler, "getPrototypeOf")
6. 如果trap是undefined，那么
    a. 返回?target.\[\[GetPrototypeOf]]()
7. 让handlerProto是?Call(trap, handler, <<target>>)
8. 如果Type(handlerProto)不是Object或者Null，投掷TypeError异常
9. 让extensibleTarget是?IsExtensible(target)
10. 如果extensibleTarget是true，返回handlerProto
11. 让targetProto是?target.\[\[GetPrototypeOf]]()
12. 如果SameValue(handlerProto,targetProto)是false，投掷TypeError异常
13. 返回handlerProto
**** 注意 代理对象的\[\[GetPrototypeOf]]强制执行下列不变性：
           . \[\[GetPrototypeOf]]的结果必须是Object或者null
           . 如果目标对象不是可扩展的，在代理对象上调用\[\[GetPrototypeOf]]必须
           与在代理目标上调用\[\[GetPrototyOf]]返回相同结果。
*** \[\[SetPrototypeOf]](V)
ProxyExoticObject O的\[\[SetPrototypeOf]]内部方法接受参数V（Object或者null）。
被调用时执行下列步骤：
1. Assert：Type(V)是Object或者Null
2. 让handler是O.\[\[ProxyHandler]]
3. 如果handler是null，投掷TypeError异常
4. Assert：Type(handler)是Object
5. 让target是O.\[\[ProxyTarget]]
6. 让trap是?GetMethod(handler, "setPrototypeOf")
7. 如果trap是undefined，那么
    a. 返回?target.\[\[SetPrototypeOf]](V)
8. 让booleanTrapResult是!ToBoolean(?Call(trap, handler, <<target, V>>))
9. 如果booleanTrapResult是false，返回false
10. 让extensibleTarget是?IsExtensible(target)
11. 如果extensibleTarget是true，返回true
12. 如果targetProto是?target.\[\[GetPrototypeOf]]()
13. 如果SameValue(V,targetProto)是false，投掷TypeError异常
14. 返回true
**** 注意 代理对象的\[\[SetPrototypeOf]]必须强制执行下列不变性：
           . \[\[SetPrototypeOf]]的结果是Boolean值
           . 如果目标对象不是可扩展的，参数值必须与目标对象的\[\[GetPrototype]]
             结果一致。
*** \[\[IsExtensible]]()
ProxyExoticObject O的\[\[IsExtensible]]内部方法不接受参数。被调用时执行下列
步骤：
1. 让handler是O.\[\[ProxyHandler]]
2. 如果handler是null，投掷TypeError异常
3. Assert：Type(handler)是Object
4. 让target是O.\[\[ProxyTarget]]
5. 让trap是?GetMethod(handler, "isExtensible")
6. 如果trap是undefined，那么
    a. 返回?IsExtensible(target)
7. 让booleanTrapResult是!ToBoolean(?Call(trap, handler, <<target>>))
8. 让targetResult是?IsExtensible(target)
9. 如果SameValue(booleanTrapResult, targetResult)是false，投掷TypeError异常
10. 返回booleanTrapResult
**** 注意 代理对象的\[\[IsExtensible]]必须强制执行下列不变性：
           . \[\[IsExtensible]]的结果是Boolean值
           . 提供给代理对象\[\[IsExtensible]]必须与代理目标的\[\[IsExtensible]]
             一致。参数相同，结果相同。
*** \[\[PreventExtensions]]()
ProxyExoticObject O的\[\[PreventExtensions]]内部方法不接受参数。被调用时执行
下列步骤：
1. 让handler是O.\[\[ProxyHandler]]
2. 如果handler是null，投掷TypeError异常
3. Assert：Type(handler)是Object
4. 让target是O.\[\[ProxyTarget]]
5. 让trap是?GetMethod(handler, "preventExtensions")
6. 如果trap是undefined，那么
    a. 返回?target.\[\[PreventExtensions]]()
7. 让booleanTrapResult是!ToBoolean(?Call(trap, handler, <<target>>))
8. 如果booleanTrapResult是true，那么
    a. 让extensibleTarget是?IsExtensible(target)
    b. 如果extensibleTarget是true，投掷TypeError异常
9. 返回booleanTrapResult
**** 注意 代理对象的\[\[PreventExtensions]]必须强制执行下列不变性：
           . \[\[PreventExtensions]]的结果是Boolean值
           . 提供给代理对象\[\[PreventExtensions]]只有在代理目标的
             \[\[IsExtensible]]是false时，返回true。
*** \[\[GetOwnProperty]](P)
ProxyExoticObject O的\[\[GetOwnProperty]]内部方法接受参数P（性质键）。
被调用时执行下列步骤：
1. Assert：IsPropertyKey(P)是true
2. 让handler是O.\[\[ProxyHandler]]
3. 如果handler是null，投掷TypeError异常
4. Assert：Type(handler)是Object
5. 让target是O.\[\[ProxyTarget]]
6. 让trap是?GetMethod(handler, "getOwnPropertyDescriptor")
7. 如果trap是undefined，那么
    a. 返回?target.\[\[GetOwnProperty]]()
8. 让trapResultObj是?Call(trap, handler, <<target, P>>)
9. 如果Type(trapResultObj)不是Object和Undefined，投掷TypeError异常
10. 让targetDesc是?target.\[\[GetOwnProperty]](P)
11. 如果trapResultObj是undefined，那么
    a. 如果targetDesc是undefined，返回undefined
    b. 如果targetDesc.\[\[Configurable]]是false，投掷TypeError异常
    c. extensibleTarget是?IsExtensible(target)
    d. 如果extensibleTarget是false，投掷TypeError异常
    e. 返回undefined
12. 让extensibleTarget是?IsExtensible(target)
13. 让resultDesc是?ToPropertyDescriptor(trapResultObj)
14. 调用CompletePropertyDescriptor(resultDesc)
15. 让valid是IsCompatiblePropertyDescriptor(extensibleTarget, resultDesc, targetDesc)
16. 如果valid是false，投掷TypeError异常
17. 如果resultDesc.\[\[Configurable]]是false，那么
    a. 如果targetDesc是undefined或者targetDesc.\[\[Configurable]]是true，那么
        i. 投掷TypeError异常
    b. 如果resultDesc.\[\[Writable]]是false，那么
        i. 如果target.\[\[Writable]]是true，投掷TypeError异常
18. 返回resultDesc
**** 注意 代理对象的\[\[GetOwnProperty]]必须强制执行下列不变性：
           . \[\[IsExtensible]]的结果是Object或者undefined
           . 如果是目标的不可设置的自有性质，不能被报告为不存在。
           . 如果目标是不可扩展对象，除非目标没有此性质，否则不能报告不存在
           . 如果目标是不可扩展对象，除非目标有此性质，否则不能报告存在
           . 除非目标上的性质是不可设置的，否则不能报告为不可设置的
           . 除非目标上的性质是不可设置且不可写的，否则不能报告为不可设置且
             不可写的
*** \[\[DefineOwnProperty]](P, Desc)
ProxyExoticObject O的\[\[SetPrototypeOf]]内部方法接受参数P（性质键）和Desc（
PropertyDescriptor）。被调用时执行下列步骤：
1. Assert：IsPropertyKey(P)是true
2. 让handler是O.\[\[ProxyHandler]]
3. 如果handler是null，投掷TypeError异常
4. Assert：Type(handler)是Object
5. 让target是O.\[\[ProxyTarget]]
6. 让trap是?GetMethod(handler, "defineProperty")
7. 如果trap是undefined，那么
    a. 返回?target.\[\[DefineOwnProperty]](P, Desc)
8. 让descObj是FromPropertyDescriptor(Desc)
9. 让booleanTrapResult是!ToBoolean(?Call(trap, handler, <<target, P, descObj>>))
10. 如果booleanTrapResult是false，返回false
11. 让targetDesc是?target.\[\[GetOwnProperty]](P)
12. 让extensibleTarget是?IsExtensible(target)
13. 如果Desc.\[\[Configurable]]是false，那么
    a. 让settingConfigFalse是true
14. 否则 让settingConfigFalse是false
15. 如果 targetDesc是undefined，那么
    a. 如果extensibleTargt是false，投掷TypeError异常
    b. 如果settingConfigFalse是true，投掷TypeError异常
16. 否则
    a. 如果IsCompatiblePropertyDescriptor(extensibleTarget, Desc, targetDesc)是false，
       投掷TypeError异常
    b. 如果settingConfigFalse是true，而且targetDesc.\[\[Configurable]]是true，投掷
       TypeError异常
    c. 如果IsDataDescriptor(targetDesc)是true，targetDesc.\[\[Configurable]]是false，
       而且targetDesc.\[\[Writable]]是true，那么
        i. 如果Desc.\[\[Writable]]是false，投掷TypeError异常
17. 返回true
**** 注意 代理对象的\[\[DefineOwnProperty]]必须强制执行下列不变性：
           . \[\[DefineOwnProperty]]的结果是Boolean值
           . 如果目标是不可扩展的，不能增加性质
           . 除非目标对象上的性质是不可设置的，性质不能是不可设置的
           . 除非目标对象上的性质是不可设置的不可写性质，不可设置性质不能
             同时是不可写的。
           . 如果目标上有对应性质，并在目标上通过\[\[DefineOwnProperty]]应用性质
             本身的描述，不会投掷异常
*** \[\[HasProperty]](P)
ProxyExoticObject O的\[\[HasProperty]]内部方法接受参数P（性质键）。被调用时执
行下列步骤：
1. Assert：IsPropertyKey(P)是true
2. 让handler是O.\[\[ProxyHandler]]
3. 如果handler是null，投掷TypeError异常
4. Assert：Type(handler)是Object
5. 让target是O.\[\[ProxyTarget]]
6. 让trap是?GetMethod(handler, "has")
7. 如果trap是undefined，那么
    a. 返回?target.\[\[HasProperty]](P)
8. 让booleanTrapResult是!ToBoolean(?Call(trap, handler, <<trget, P>>))
9. 如果booleanTrapResult是false，那么
    a. 让targetDesc是?target.\[\[GetOwnProperty]](P)
    b. 如果targetDesc不是undefined，那么
        i. 如果targetDesc.\[\[Configurable]]是false，投掷TypeError异常
       ii. 让extensibleTarget是?IsExtensible(target)
      iii. 如果extensibleTarget是false，投掷TypeError异常
10. 返回booleanTrapResult
**** 注意 代理对象的\[\[HasProperty]]必须强制执行下列不变性：
           . \[\[HasProperty]]的结果是Boolean值
           . 如果目标对象上性质是不可设置的，不能报告性质不存在
           . 如果目标对象是不可不扩展的，且有这个性质，不能报告性质不存在
*** \[\[Get]](P, Receiver)
ProxyExoticObject O的\[\[Get]]内部方法接受参数P（性质键）和Receiver（
ECMAScript语言值）。
被调用时执行下列步骤：
1. Assert：IsPropertyKey(P)是true
2. 让handler是O.\[\[ProxyHandler]]
3. 如果handler是null，投掷TypeError异常
4. Assert：Type(handler)是Object
5. 让target是O.\[\[ProxyTarget]]
6. 让trap是?GetMethod(handler, "get")
7. 如果trap是undefined，那么
    a. 返回?target.\[\[Get]](P, Receivere)
8. 让trapResult是?Call(trap, handler, <<target, P, Receiver>>)
9. 让targetDesc是?target.\[\[GetOwnProperty]](P)
10. 如果targetDesc不是undefined，而且targetDesc.\[\[Configurable]]是false，那么
    a. 如果IsDataDescriptor(targetDesc)是true，且targetDesc.\[\[Writable]]是false，
       那么
        i. 如果SameValue(trapResult, targetDesc.\[\[Value]])是false，投掷TypeError
           异常
    b. 如果IsAccessorDescriptor(targetDesc)是true，且targetDesc.\[\[Get]]是
       undefined，那么
        i. 如果trapResult不是undefined，投掷TypeError异常
11. 返回trapResult
**** 注意 代理对象的\[\[Get]]必须强制执行下列不变性：
           . 如果目标对象上对应的性质是不可写的不可设置自有性质，必须报告
             相同的值
           . 如果目标对象上对象的性质是不可设置的访问性质，且没有\[\[Get]]属
             性，必须报告undefined
*** \[\[Set]](P, V, Receiver)
ProxyExoticObject O的\[\[Set]]内部方法接受参数P（性质键）、V（ECMAScript语言
值）和Receiver（ECMAScript语言值）。被调用时执行下列步骤：
1. Assert：IsPropertyKey(P)是true
2. 让handler是O.\[\[ProxyHandler]]
3. 如果handler是null，投掷TypeError异常
4. Assert：Type(handler)是Object
5. 让target是O.\[\[ProxyTarget]]
6. 让trap是?GetMethod(handler, "set")
7. 如果trap是undefined，那么
    a. 返回?target.\[\[Set]](P, V, Receiver)
8. 让booleanTrapResult是!ToBoolean(?Call(trap, handler, <<target, P, V, Receiver>>))
9. 如果booleanTrapResult是false，返回false
10. 让targetDesc是?target.\[\[GetOwnProperty]](P)
11. 如果targetDesc不是undefined，且targetDesc.\[\[Configurable]]是false，那么
    a. 如果IsDataDescriptor(targetDesc)是true，且targetDesc.\[\[Writable]]是false，
       那么
        i. 如果SameValue(V, targetDesc.\[\[Value]])是false，投掷TypeError异常
    b. 如果IsAccessorDescriptor(targetDesc)是true，那么
        i. 如果targetDesc.\[\[Set]]是undefined，投掷TypeError异常
12. 返回true
**** 注意 代理对象的\[\[Set]]必须强制执行下列不变性：
           . \[\[Set]]的结果是Boolean值
           . 如果目标对象上对应的性质是不可写的不可设置数据性质，不能设置
             不同的值
           . 如果目标对象上对应的性质是不可设置的访问性质，且没有\[\[Set]]属
             性，不能设置性质值
*** \[\[Delete]](P)
ProxyExoticObject O的\[\[Delete]]内部方法接受参数P（性质键）。被调用时执行下
列步骤：
1. Assert：IsPropertyKey(P)是true
2. 让handler是O.\[\[ProxyHandler]]
3. 如果handler是null，投掷TypeError异常
4. Assert：Type(handler)是Object
5. 让target是O.\[\[ProxyTarget]]
6. 让trap是?GetMethod(handler, "deleteProperty")
7. 如果trap是undefined，那么
    a. 返回?target.\[\[Delete]](P)
8. 让booleanTrapResult是!ToBoolean(?Call(trap, handler, <<target, P>>))
9. 如果booleanTrapResult是false，返回false
10. 让targetDesc是?target.\[\[GetOwnProperty]](P)
11. 如果targetDesc是undefined，返回true
12. 如果targetDesc.\[\[Configurable]]是false，投掷TypeError异常
13. 让extensibleTarget是?isExtensible(target)
14. 如果extensibleTarget是false，投掷TypeError异常
15. 返回true
**** 注意 代理对象的\[\[Delete]]必须强制执行下列不变性：
           . \[\[Delete]]的结果是Boolean值
           . 如果目标对象对应的性质是不可设置的自有性质，不能报告已删除性质
           . 如果目标对象是不可扩展的，且有对应的自有性质，不能报告已删除性
             质
*** \[\[OwnPropertyKeys]]()
ProxyExoticObject O的\[\[OwnPropertyKeys]]内部方法不接受参数。被调用时执行下列
步骤：
1. 让handler是O.\[\[ProxyHandler]]
2. 如果handler是null，投掷TypeError异常
3. Assert：Type(handler)是Object
4. 让target是O.\[\[ProxyTarget]]
5. 让trap是?GetMethod(handler, "ownKeys")
6. 如果trap是undefined，那么
    a. 返回?target.\[\[OwnPropertyKeys]]()
7. 让trapResultArray是?Call(trap, handler, <<target>>)
8. 让trapResult是?CreateListFromArrayLike(trapResultArray, <<String, Symbol>>)
9. 如果trapResult包含任何重复的实体，投掷TypeError异常
10. 让extensibleTarget是?IsExtensible(target)
11. 让targetKeys是?target.\[\[OwnPropertyKeys]]()
12. Assert：targetKeys是List，其元素是String或Symbol
13. Assert：targetKeys中不包含重复实体
14. 让targetConfigurableKeys是新的空List
15. 让targetNoneconfigurableKeys是新的空List
16. 遍历targetKeys中元素，记作key，做
    a. 让desc是?target.\[\[GetOwnProperty]](key)
    b. 如果desc不是undefined而且desc.\[\[Configurable]]是false，那么
        i. 追加key到targetNonconfigurableKeys中
    c. 否则
        i. 追加key到targetConfigurableKeys
17. 如果extensibleTarget是true，而且targetNonconfigurableKeys是空，那么
    a. 返回trapResult
18. 让uncheckedResultKeys是List，其元素是trapResult的元素
19. 遍历targetNonconfigurableKeys中元素，记作key，做
    a. 如果key不是uncheckedResultKeys的元素，投掷TypeError异常
    b. 从uncheckedResultKeys中移除key
20. 如果extensibleTarget是true，返回trapResult
21. 遍历targetConfigurableKeys中元素，记作key，做
    a. 如果key不是uncheckedResultKeys，投掷TypeError异常
    b. 从uncheckedResultKeys中移除key
22. 如果uncheckedResubltKeys不是空的，投掷TypeError异常
23. 返回trapResult
**** 注意 代理对象的\[\[OwnPropertyKeys]]必须强制执行下列不变性：
           . \[\[OwnPropertyKeys]]的结果是List
           . 返回List不能包含重复实体
           . List元素的类型是String或者Symbol
           . 结果List必须包含目标对象上全部的不可设置的自有性质
           . 如果目标对象是不可扩展的，结果List必须包含且只能包含目标对象的
             全部自有性质
*** \[\[Call]](thisArgument, argumentsList)
ProxyExoticObject O的\[\[Call]]内部方法接受参数thiArgument（ECMAScript语言值）
和argumentsList（ECMAScript语言值的List）。被调用时执行下列步骤：
1. 让handler是O.\[\[ProxyHandler]]
2. 如果handler是null，投掷TypeError异常
3. Assert：Type(handler)是Object
4. 让target是O.\[\[ProxyTarget]]
5. 让trap是?GetMethod(handler, "apply")
6. 如果trap是undefined，那么
    a. 返回?Call(target, thisArgument, argumentsList)
7. 让argArray是!CreateArrayFromList(argumentsList)
8. 返回?Call(trap, handler, <<trget, thisArgument, argArray>>)
**** 注意 只有在代理对象的内部占位\[\[ProxyTarget]]的初始化值是一个有\[\[Call]]
           内部方法的对象时，代理对象才有\[\[Call]]内部方法
*** \[\[Construct]](argumentsList, newTarget)
ProxyExoticObject O的\[\[Constructor]]内部方法接受参数argumentsLis（ECMAScript
语言值）和newTarget（构造范）。被调用时执行下列步骤：
1. 让handler是O.\[\[ProxyHandler]]
2. 如果handler是null，投掷TypeError异常
3. Assert：Type(handler)是Object
4. 让target是O.\[\[ProxyTarget]]
5. Assert：IsConstructor(target)是true
6. 让trap是?GetMethod(handler, "construct")
7. 如果trap是undefined，那么
    a. 返回?Construct(target, argumentsList, newTarget)
8. 让argArray是!CreateArrayFromList(argumentsList)
9. 让newObj是?Call(trap, handler, <<target, argArray, newTarget>>)
10. 如果Type(newObj)不是Object，投掷TypeError异常
11. 返回newObj
**** 注意1 只有在代理对象的内部占位\[\[ProxyTarget]]的初始化值是一个有
            \[\[Construct]]内部方法的对象时，代理对象才有\[\[Construct]]内部方法
**** 注意2 代理对象的\[\[Construct]]必须强制执行下列不变性：
            . \[\[Construct]]的结果是Object
*** ProxyCreate(target, handler)
抽象操作ProxyCreate接受参数target和handler。用于规定ProxyExoticObject的创建。
被调用时执行下列步骤：
1. 如果Type(target)不是Object，投掷TypeError异常
2. 如果Type(handler)不是Object，投掷TypeError异常
3. 让P是!MakeBasicObject(<<\[\[ProxyHandler]], \[\[ProxyTarget]]>>)
4. 除了\[\[Call]]和\[\[Construct]]，按照10.5中规定的定义设置P的基本内部方法
5. 如果IsCallable(target)是true，那么
    a. 设置P.\[\[Call]]是10.5.12规定的定义
    b. 如果IsConstructor(target)是true，那么
        i. 设置P.\[\[Construc]]是10.5.13规定的定义
6. 设置P.\[\[ProxyTarget]]是target
7. 设置P.\[\[ProxyHandler]]是handler
8. 返回P
* ECMAScript Language: Source Code
** Source Text
*** Syntax
SourceCharacter::
    any Unicode code pint
    
ECMAScript代码用Unicode表示。ECMAScript源文本是编码点的序列。全部编码点从
U+0000到U+10FFFF，包含替代用的编码点，只要被语法许可，都可以在源文本中出现。
用于存储与传输ECMAScript源文本的实际的编码与本规范无关。不管扩展的源文本编
码，合用的ECMAScript实现将源文本当作SourceCharacter值等价序列来处理，每个
SourceCharacter是一个Unicode编码点。合用的ECMAScript实现没有被要求常规化源文
本，或者表现的像常规化了源文本。


组合字符序列的组成部件被当作分隔的编码点，尽管用户认为完整的序列是一个
字符。
**** 注意 在字符串字面量，正则表达式字面量，模板字面量和标识，任何Unicode
           编码点可能被用Unicode转义序列表达，也就是显式的用编码点的数字值
           标识。在注释内，作为注释的一部分，这些转义序列被有效的忽略了。
           
           ECMAScript在从Unicode转移序列上的行为与Java编程语言不同。在Java中，
           Unicode转义序列，例如\u000A，出现在单行注释中，被当作是一个行终结
           符（Unicode code pint U+000A就是LINE FEED(LF)），这个之后的编码点就不
           是注释的内容了。类似的如果Unicode转义序列\u000A出现在Java程序的字符
           串字面量里，它会被翻译为行终结符，这是不允许在字符串字面量里的，
           必须使用\n代替\u000A，让LINE FEED(LF)称为字符串字面量的Strng值的一
           部分。在ECMAScript中，一个出现在注释中的Unicode转义序列永远不会被
           翻译，因此也就不会中断注释。类似的，一个出现在ECMAScript程序的字
           符串字面量的Unicode转义序列总是添加到字面量中，且不会被翻译为行
           终结符或者其他会导致字符串字面量终结的编码点。
*** Static Semantic: UTF16EncodeCodePoint(cp)
抽象操作UTF16EncodeCodePoint接受参数cp（Unicode编码点）。被调用时执行下列步
骤：
1. Assert：0 <= cp <= 0x10FFFF
2. 如果 cp <= 0xFFFF, 返回值是cp的编码单元构成的String值
3. 让cu1是值为floor((cp - 0x100000) / 0x400) + 0xD800的编码单元
4. 让cu2是值为((cp - 0x100000) module 0x400) + 0xDC00的编码单元
5. 返回cu1与cu2拼接的String值
*** Static Semantic: CodePointsToString(text)
抽象操作CodePointsToString接受参数text（unicode编码点的序列）。按照6.1.4值中
的描述，转换text为String值。被调用时执行下列步骤：
1. 让result是空String
2. 遍历text中的编码点记作cp，做
    a. 设置result是result与!UTF16EncodeCodePoint(cp)拼接的String值
3. 返回result
*** Static Semantic: UTF16SurrogatePairToCodePoint(lead, trail)
抽象操作UTF16SurrogatePairToCodePoint接受参数lead（编码单元）和trail（编码单
元）。构成了一个UTF-16替代对的两个编码单元被转换为编码点。被调用时执行下列
步骤：
1. Assert：lead是首位，trail是尾位
2. 让cp是(lead - 0xD800) * 0x400 + (trail - 0xDc00) * 0x100000
3. 返回编码点cp
*** Static Semantic: CodePointAt(string, position)
抽象操作CodePointAt接受参数string（String值）和position（非负整数）。按照
6.1.4的描述，将string翻译为UTF-16编码点的序列，然后读取以索引position的编码
单元为开始的编码点。被调用时执行下列步骤：
1. 让size是string的长度
2. Assert：position>=0而且position<size
3. 让first是在string上position位置的编码单元
4. 让cp是数字值与first一致的编码点。
5. 如果first不是首位也不是尾位，那么
    a. 返回记录{ \[\[CodePoint]]:cp, \[\[CodeUnitCount]]:1,
       \[\[IsUnpairedSurrogate]]:false }
6. 如果first是尾位，或者postion+1 = size，那么
    a. 返回记录{ \[\[CodePoint]]:cp, \[\[CodeUnitCount]]:1,
       \[\[IsUnpairedSurrogate]]:true }
7. 让second是string中position+1处的编码单元
8. 如果second不是尾位，那么
    a. 返回记录{ \[\[CodePoint]]:cp, \[\[CodeUnitCount]]:1,
       \[\[IsUnpairedSurrogate]]:true }
9. 设置cp是!UTF16SurrogatePairToCodePoint(first, second)
10. 返回记录{ \[\[CodePoint]]:cp, \[\[CodeUnitCount]]:2,
    \[\[IsUnpairedSurrogate]]:false }
*** Static Semantic: StringToCodePoints(string)
抽象操作StringToCodePoints接受参数string（String值）。按照6.1.4中描述的将string
当作UTF-16编码的文本翻译成Unicode编码点的序列。被调用时执行下列步骤：
1. 让codePoints是新的空List
2. 让size是length的长度
3. 让position是0
4. 当position<size时重复
    a. 让cp时!CodePointAt(string, position)
    b. 追加cp.\[\[CodePoint]]到codePoints
    c. 设置position是position + cp.\[\[CodeUnitCount]]
5. 返回codePoints
*** Static Semantic: ParseText(sourceText, goalSymbol)
抽象操作ParseText接受参数sourceText（Unicode编码点的序列）和goalSymbol（
ECMAScript语法中的非终结符）。被调用时执行下列步骤：
1. 尝试用goalSymbol解析sourceText为GoalSymbol，并分析解析结果是否符合EarlyError
   条件。解析与侦测EarlyError可能以实现定义的方式插入。
2. 如果解释成功，也没有发现EarlyError，返回ParseNode（goalSymbol的实例），其根
   节点是解析的结果
3. 否则含有一个或者多个表示解释错误或者EarlyError的SyntaxError对象的List。如果
   有多个错误出现，List中错误的数量和顺序由实现自行定义，但是至少要有一个。
**** 注意1 考虑到有文本在某个位置有EarlyError，在后面的位置有SyntaxError。有的
            实现先执行Parse段，再执行EarlyError段，可能就只报告SyntaxError，而不
            报告earlyErrors。有的实现是交替两种活动，可能就会报告EarlyError，而
            不报告SyntaxError。还有的实现可能会两者都报告。所有这些行为都是
            允许的
**** 注意2 条款17
** Type of Source Code
有四种类型ECMAScript代码
. 全局代码是作为ECMAScript脚本的源文本。某个脚本的全局代码不包含任何能够解析
成FunctionDeclaration、FunctionExpression、GeneratorDeclaration、
GeneratorExpression、AsyncFunctionDeclaration、AsyncFunctionExpression、
AsyncGeneratorDeclaration、AsyncGeneratorExpression、MethodDefinition、
ArrowFunction、AsyncArrowFunction、ClassDeclaration和ClassExpression的源文本
. 即评代码是提供给内建函数eval的源文本。更精确的说，如果提供给eval函数的参
数是String值，它会被当作ECMAScript脚本。某次eval调用的即评代码是脚本的全局
代码部分。
. 函数代码是解析成ECMAScript函数对象的\[\[ECMAScriptCode]]和\[\[FormalParameters]]
（10.2）内部占位的值的源文本。某个ECMAScript函数的函数代码不包含能解析成内部
的FunctionDeclaration、FunctionExpression、GeneratorDeclaration、GeneratorExpression、
AsyncFunctionDeclaration、AsyncFunctionExpression、AsyncGeneratorDeclaration、
AsyncGeneratorExpression、MethodDefinition、ArrowFunction、AsyncArrowFunction、
ClassDeclaration和ClassExpression的源文本

另外，上述所指的源文本会被解析成：
  。FunctionDeclaration或者FunctionExpression的FormalParameters和FunctionBody
  。GeneratorDeclaration或者GeneratorExpression的FormalParameters和GeneratorBody
  。AsyncFunctionDeclaration或者AsyncFunctionExpression的FormalParameters和
    AsyncFunctionBody 
  。AsyncGeneratorDeclaration或者AsyncGeneratorExpression的FormalParameters和
    AsyncGeneratorBody，
然后匹配到这些声明或者表达式的绑定标识（如果有）的源文本也被包含在函数

对应的函数代码中。
. 模块代码是提供为ModuleBody代码的源文本。当模块初始化时代码直接被评估。某个

模块的模块代码不包含能够解析成内部的FunctionDeclaration、FunctionExpression、
GeneratorDeclaration、GeneratorExpression、AsyncFunctionDeclaration、
AsyncFunctionExpression、AsyncGeneratorDeclaration、AsyncGeneratorExpression、
MethodDefinition、ArrowFunction、AsyncArrowFunction、ClassDeclaration
和ClassExpression的部分的源文本
*** 注意1 函数代码总是被提供做函数定义（15.2）、箭头函数定义（15.3）、方法
           定义（15.4）、生成器定义（15.5）、异步函数定义（15.8）、异步生成器
           定义（15.6）和异步箭头函数（15.9）的函数体。函数代码也被派生自传递
           给函数构造范（20.2.1.1）、生成器构造范（27.3.1.1）和异步函数构造范
           （27.7.1.1）的参数。
*** 注意2 在函数代码中包含绑定标识的实际效果是函数体包含'use strict'指令时
           能够将严格模式的EarlyError应用到作为函数名称的绑定标识，即使周边
           代码不是严格模式
*** Directive Prologues and the Use Strict Directive
指令序章是作为FucntionBody、ScriptBody或者ModuleBody的初始StatementListItems或者
ModuleItems的最长的ExpressionStatements，而且序列的每个ExpressionStatement构成完整
的跟随分号的StringLiteralToken。这个分号可能是显示出现的，也可能是被自动
（12.9）添加的。指令序列也可能是空的序列。

UseStrictDirective是在指令序章中其StringLiteral确切是"use strict"或者'use strict'的
表达式语句。UseStrictDirective不能包含转义序列或者续行符。

指令序章可以包含不止一个UseStrictDirective。然而如果发生了，实现可能会发出
警告。
**** 注意 DirectivePrologue的ExpressionStatements通常在评估其包含的码型时进行评
           估。实现可能会为在DirectivePrologue的不是UseStrictDirective的
           ExpressionStatement定义特殊的实现方式。如果存在恰当的通知机制，如果
           实现遇到在DirectivePrologue里不是UseStrictDirective而且实现也没有定义
           含义的ExpressionStatement，实现应该发出一个警告。
*** Strict Mode Code
ECMAScript句法单元会被适用不限制的或者严格模式的句法和语义（4.3.2）来处理。
在下列情况，代码会被翻译成严格模式代码：
. 以包含UseStrictDirective的指令序章的开始全局代码是严格模式代码
. 模块代码总是严格模式代码
. ClassDeclaration或者ClassExpression的全部部分都是严格模式代码
. 以包含UseStrictDirective的指令序章开始的或者是在严格模式代码内直接调用

eval产生的，即评代码是严格模式代码
. 联结在严格模式内的FunctionDeclaration、FunctionExpression、GeneratorDeclaration、
GeneratorExpression、AsyncFunctionDeclaration、AsyncFunctionExpression、
AsyncGeneratorDeclaration、AsyncGeneratorExpression、MethodDefinition、
ArrowFunction或AsyncArrowFunction的函数代码，或者以包含UseStrictDirective的指令
序章开始的码型函数的\[\[ECMAScriptCode]]内部占位值的代码是严格模式代码。
. 传递给内建Function、Generator、AsyncFunction和AsyncGenerator构造范的函数代码是
严格模式代码，如果最后的参数，在函数处理时作为函数体，是以包含
UseStrictDirective的指令序章开始的String。

不是严格模式代码的ECMAScript代码称作非严格代码。
*** Non-ECMAScript Functions
ECMAScript实现可能会提供函数奇异对象的评估，其评估行为表现为主机定义形式的
可执行代码而不是通过ECMAScript代码。无论函数对象是ECMAScript函数还是非
ECMAScript函数，从一个ECMAScript函数的角度，不能从语义上出来，无论是调用这个
非ECMAScript函数，还是被这个非ECMAScript函数调用。
* ECMAScript Language: Lexical Grammer 词法
ECMAScript中Script或者Module的源文本先转换成输入元素的序列，分别是token、行终
结符、注释和空白。源文本被从左到右，重复的扫描，获取尽可能最长的编码点的
序列，作为下一个输入元素。

某几种情况下词法输入元素的标识敏感于正在消耗此输入元素的句法背景。这需要
此词法有多个目标符号。InputElementRegExpOrTemplateTail目标用在许可TemplateTail、
TemplateMiddle或者RegularExpressionLiteral的句法背景中。InputElementRegExp目标符号
用于许可RegularExpressionLiteral但是不允许TemplateMiddle和TemplateTail的句法背景
中。InputElementTemplateTail目标用于许可TempalteMiddle和或TemplateTail但是不允许
RegularExpressionLiteral的句法背景。在其他背景中，InputElmentDiv被用作词法目标符
号。
** 注意 多重词法目标需要确保不能有会导致自动插入分号的词法模糊。比如没有句
         法允许首位除号或者除号赋值连同首位RegularExpressionLiteral。这不会被引
         发分号插入（12.9）；如下所示：
         a = b
         /hi/g.exec(c).map(d);
         在LineTerminate后第一个非空非注释代码点是U+002F（SOLIDUS），而且句法背
         景允许除号或者除号赋值，且不会在有分号插入在LineTerminator处。然后上
         述例子与下方例子相同的方式被翻译：
         a = b / hi / g.exec(c).map(d);
** Syntax
InputElementDiv ::
    WhiteSpace
    LineTerminator
    Comment
    CommonToken
    DivPunctuator
    RightBracePunctuator

InputElementRegExp ::
    WhiteSpace
    LineTerminator
    Comment
    CommonToken
    RightBracePunctuator
    RegularExpressionLiteral

InputElementRegExpOrTemplateTail ::
    WhiteSpace
    LineTerminator
    Comment
    CommonToken
    RegularExpressionLiteral
    TempalteSubsitutionTail

InputElementTempalteTail ::
    WhiteSpace
    LineTerminator
    Comment
    CommonToken
    DivPunctuator
    TempalteSubsitutionTail
** Unicode Format-Control Characters Unicode格式符
Unicode格式符（比如在Unicode字符集中“Cf”分类中的字符，像LEFT-TO-RIGHT MARK或
者RIGHT-TO-LEFT MARK）是在高级协议（例如标记语言）未涉及此字符时控制一系列文
本的格式的控制编码。

允许格式控制对方便编辑和展示很有帮助。所有的格式控制字符可以用于注释，用于
字符串文法，模板文法和正则表达式文法。

U+200C（ZERO WIDTH NON-JOINER）和U+200D（ZERO WIDTH JOINER）是控制字符，在某些语言
中在格式化词汇或者短语时保持必要的区分性。在ECMAScript源文本中，在第一个字
符后的这些编码可能被用在IdentifierName中。

U+FEFF（ZERO WIDTH NO-BREAK SPACE）是主要用在文本开始位置以标记为Unicode和允许
侦测文本的编码和字节序的控制字符。用于此目的<ZWNBSP>字符有时也出现在文本的
其他位置，比如作为拼接文件的结果。在ECMAScript源文本中<ZWNBSP>编码点被当作空
白字符（12.2）

展示在表33的控制字符在注释、字符串文法和正则表达式文法之外要按照规定对待。

| 编码点 | 名称                      | 缩写     | 用途           |
| U+200C | ZERO WIDTH NON-JOINER     | <ZWNJ>   | IdentifierPart |
| U+200D | ZERO WIDTH JOINER         | <ZWJ>    | IdntifierPart  |
| U+FEFF | ZERO WIDTH NO-BREAK SPACE | <ZWNBSP> | WhiteSpace     |
** White Space 空白符
空白符编码点用改善源文本的可读性和分隔信标（不可分的词法单元），同时是某
种程度上的无足轻重。空白符会出现在两个信标中间，输入的开始或者结尾。空白符
编码点可以出现在StringLiteral、RegularExpressionLiteral、Temlate或者
TemplateSubstitutionTail中，这里他们作为构成文法值的有效编码点。他们也可能出现
在Comment中，但不会在任何信标中出现。

ECMAScript空白符编码点列在表34
| 编码点         | 名称                                   | 缩写     |
| U+0009         | CHARACTER TABULATION                   | <TAB>    |
| U+000B         | LINE TABULATION                        | <VT>     |
| U+000C         | FORM FEED (FF)                         | <FF>     |
| U+0020         | SPACE                                  | <SP>     |
| U+00A0         | NO-BREAK SPACE                         | <NBSP>   |
| U+FEFF         | ZERO WIDTH NO-BREAK SPACE              | <ZWNBSP> |
| 其他类目“Zs” | 其他任何Unicode"Space_Separator"编码点 | <USP>    |

ECMAScript实现必须将列在"Space_Separator"（"Zs"）类目中编码点识别为WhiteSpace编
码点。
*** 注意 表34之外的编码点，ECMAScript WhiteSpace试图排除所有有"White_Space"性质
          但是不在"Space_Separator"类目中的Unicode编码点。
*** Syntax
WhiteSpace ::
    <TAB>
    <VT>
    <FF>
    <SP>
    <NBSP>
    <ZWNBSP>
    <USP>
** Line Terminators 行终结符
像空白符编码点一样，行终结符编码点用于改进源文本的可读性和分隔信标（不可
分的词法单元）。然而不同于空白符编码点，行终结符在句法行为上有一定作用。
通常行终结符出现在两个信标间，但是少量地方是被句法禁止出现行终结符的。行
终结符也会影响自动插入分号（12.9）的过程。行终结符不能在除了StringLiter、
Template或者TemplateSubstitutionTail之外的信标里。<LF>和<CR>行终结符除了作为
LineContinuation的部分外，不能出现在其他StringLiteral信标里。

行终结符不能出现在MultiLineComment中，但是可以出现在SingleLineComment中。

行终结符被包含在\s正则表达式匹配的空白符编码点集中。

ECMAScript行终结符编码点列在表35中:
| 编码点 | Unicode名称          | 缩写 |
| U+000A | LINE FEED (LF)       | <LF> |
| U+000D | CARRIAGE RETURN (CR) | <CR> |
| U+2028 | LINE SEPARATOR       | <LS> |
| U+2029 | PARAGRAPH SEPARATOR  | <PS> |

只有列在表35的Unicode编码点作为行终结符。其他新行或者行中断等Unicode编码点不
被当作行终结符，但是如果符合表34的要求，会被当作空白符。<CR><LF>序列通常被
用于作为行终结符。用于计算行数时，它应当被当作一个单独的源字符。
*** Syntax
LineTerminator ::
    <LF>
    <CR>
    <LS>
    <PS>

LineTerminatorSequence ::
    <LF>
    <CR> [lookahead != <LF>]
    <LS>
    <PS>
    <CR> <LF>
** Comments 注释
注释可以是单行的或着多行的。多行的注释不能是嵌套的。

因为单行注释能含有除了LineTerminator编码点的其他Unicode字符，也因为信标尽可能
长的通用规则，单行注释总是含有从//标记到行末的所有编码点。然而，行末的
LineTerminator不被当作单行注释的一部分；它被词法单独地识别，当作句法输入元素
流的一部分。这点很重要，因为暗示了出现和缺少单行注释不会影响自动分号插入（
12.9）的过程。

注释的行为像空白符，一般被忽略，除了如果一个多行注释包含了行终结符编码点，
此时整个注释被当作一个行终结符。
*** Syntax
Comment ::
    MultiLineComment
    SingleLineComment
MultiLineComment ::
    /* MultiLineCommentChars_opt */
MultiLineCommentChars ::
    MultiLineNotAsteriskChar MultiLineCommentChars_opt
    * PostAsteriskCommentChars_opt
PostAsteriskCommentChars ::
    MultiLineNotForwardSlashOrAsteriskChar MultiLineCommentChars_opt
    * PostAsteriskCommentChars_opt
MultiLineNotAsteriskChar ::
    SourceCharacter but not *
MultiLineNotForwardSlashOrAsteriskChar ::
    SourceCharacter but not one of / or *
SinleLineComment ::
    // SinleLineCommentChars_opt
SinelLineCommentChars ::
    SingleLineCommentChar SingleLineCommentChars_opt
SingleLineCommentChar ::
    SourceCharacter but not LineTerminate
    
本节的许多码型在B.1.3中给出了备选定义。
** Tokens 信标
*** Syntax
CommonToken ::
    IdentifierName
    Punctuator
    NumericLiteral
    StringLiteral
    Template
*** 注意 DivPunctuator、RegularExpressionLiteral、RightBracePunctuator和
          TemplateSubstitutionTail码型派生出额外的信标不被包含在CommonToken码型
          中。
** Names and Keywords 名称与关键词
IdentifierName和ReservedWord是根据Identifier、PatternSyntax和在UnicodeStandardAnnex
#31提供的DefaultIdentifierSyntax，稍加调整，被翻译出的信标。ReservedWord是
IdentifierName的可列子集。句法将Identifier定义为除了ReservedWord的IdentifierName。
Unicode标识语法是基于Unicode标准规定的字符性质。在最新版Unicode标准中规定的
类目中的Unicode编码点，必须被一致的ECMAScript实现对待为对应类目中的编码点。
ECMAScript实现可能识别被后续Unicode标准版本定义的标识编码点。
*** 注意1 本标准规定了特定编码点：U+0024（DOLLAR SIGN）和U+005F（LOW LINE）可以
           出现在IdentifierName的任何位置，编码点：U+200C（ZERO WIDTH NON-JOINER）
           和U+200D（ZERO WIDTH JOINER）可以出现在IdentifierName的第一个编码点后的
           位置。
Unicode转义序列可以出现在IdentifierName中，他们给IdentifierName贡献一个单独的
Unicode编码点。这个编码点是由UnicodeEscapeSequence（12.8.4）的CodePoint翻译的。
UnicodeEscapeSequence中开始的\、u和{}编码单元，如果出现，不给IdentifierName贡献
编码点。如果UnicodeEscapeSequence不合法，不会被用于提供给IdentifierName编码点。
换句话说，如果一个\UnicodeEscapeSequence序列被其提供的SourceCharacter替换，其结
果必须仍然是一个有效的IdentifierName，这个结果与直接使用对应SourceCharacter的
IdentifierName有完全相同的SourceCharacter序列。本规范的IdentifierName的翻译是基于
他们实际编码点的值来贡献具体编码点，无论是否是一个转义序列。

两个IdentifierNames依据Unicode标准来判断相等，在替换了每个UnicodeEscapeSequence
后，除非他们是确切相同的编码点序列，他们是不等的。
*** Syntax
IdentifierName ::
    IdentifierStart
    IdentifierName IdentifierPart
IdentifierStart ::
    UnicodeIDStart
    $
    _
    \UnicodeEscapeSequence
IdentifierPart ::
    UnicodeIDContinue
    $
    \UnicodeEscapeSequence
    <ZWNJ>
    <ZWJ>
UnicodeIDStart ::
    任何带有Unicode性质ID_Start的Unicode编码点
UnicodeIDContinue ::
    任何带有Unicode性质ID_Continue的Unicode编码点
*** 注意2 非终结符IdentifierPart通过UnicodeIDContinue派生_
*** 注意3 带有ID_Start和ID_Continue性质的编码点集依次包含带有Other_ID_Start和
           Other_ID_Continue性质的编码点集。
*** Identifier Names 标识名
**** Static Semantics: Early Errors
IdentifierStart :: \ UnicodeEscapeSequence
. 如果UnicodeEscapeSequence的SV不是$、_或者被UnicodeIDStart词法码型匹配的
  Unicode编码点cp的!UTF16EncodeCodePoint(cp)，那这是一个SyntaxError。
IdentifierPart :: \ UnicodeEscapeSequence
. 如果UnicodeEscapeSequence的SV不是$、_、!UTF16EncodeCodePoint(<ZWNJ>、
  !UTF16EncodeCodePoint(<ZWJ>)或者被UnicodeIDContinue词法码型匹配的
  Unicode编码点cp的!UTF16EncodeCodePoint(cp)，那这是一个SyntaxError。
*** Keywords and Reserved Words 关键词和保留词
关键词是符合IdentifierName的信标，但是还有句法用途；它会在本文中，使用定宽
字体，出现在某些句法码型中。ECMAScript关键词包括if、while、async、await等等。

保留词不能用作为标识的IdentifierName。很多关键词是保留词，但是有些不是，有些
仅在某些背景下是保留词。if和while是保留词。await键在异步函数和异步模块中是
保留词。async不是保留词，可以不被限制的用在变量名或者label语句里。

本归范使用语法码型和EarlyError来规定哪些名称是有效的，哪些是保留词。除了
await和yeild，列在下方的其他保留词的信标是无条件保留的。在13.1中规定了
await和yield的例外行为，使用参数句法码型。最后，有几个EarlyError限制了有效
标识的集合。详见13.1.1、14.3.1.1、14.7.5.1和15.7.1。综述有五类标识名称：
    . Math、window、toString和_，不是关键词，总是可以当作标识
    . 下发列出的ReservedWords除了await和yield，不能作为标识。
    . 某些背景下可以使用await和yield作为标识符。
    . 某些背景下在严格模式中：let、static、implements、interface、package、
      priviate、protected和public不能作为标识
    . as、async、from、get、of、set和target这些可以作为标识符，但是在某些特定
      句法码型中作为关键词，这些地方不允许作为标识。
术语条件关键词或者特定背景关键词（ConditionalKeyword或者ContextualKeyword）是指
在后面三种类目中的有时用作关键词的词汇，因此有些背景可以作为标识，其他背景
下被当作关键词。
**** Syntax
ReservedWord :: one of
    await break case catch class const continue debuffer default do else enum export
    extends false finally for function if import in instanceof new null return super
    switch this throw true try typeof var void while with yield
**** 注意1 参考5.1.5，语法中的关键词匹配规定的SourceCharacter元素字面序列。
            关键词中的编码点不能被表示为\UnicodeEscapeSequence

            标识名可以包含\UnicodeEscapeSequences，但是不可以通过拼写els\u{65}来
            声明一个名为else的变量。在13.1中的EarlyError规则排除与保留词一样
            字符串值的标识。
**** 注意2 enum在本规范中还没有用作一个关键词。这是一个未来的保留词，放在
            这里是用于在将来的语法扩展中作为关键词。

            类似的implements、interface、package、private、protected和public都是在
            严格模式下的未来保留词
**** 注意3 arguments和eval不是关键词，但是在严格模式他们受到一些限制。见于
            13.1.1、8.5.4、15.2.1、15.5.1、15.6.1和15.8.1。
** Punctuators
*** Syntax
Puctuator::
    OptionalChainingPunctuator
    OtherPunctuator

OptionalChainingPunctuator ::
    ?.[lookahead ∉ DecimalDigit]
OtherPunctuator :: one of
    { ( ) [ ] . ... ; , < > <= >= \== != \=== !== + - * % ** ++ -- << >> >>> & | ^ ! ~
   && || ?? ? : = += -= *= %= **= <<= >>= >>>= &= |= ^= &&= ||= ??= =>
DivPunctuator ::
    /
    /=
RightBracePunctuator ::
    }
** Literals
*** Null Literals
**** Syntax
NullLiteral ::
    null
*** Boolean Literals
**** Syntax
BooleanLiteral ::
    true
    false
*** Numeric Literals
**** Syntax
NumericLiteralSepatator ::
    -
NumericLiteral ::
    DecimalLiteral
    DecimalBigIntegerLiteral
    NonDecimalIntegerLiteral_[+Sep]
    NonDecimalIntegerLiteral_[+Sep] BigIntLiteralSuffix

DecimalBigIntegerLiteral ::
    0 BigIntLiteralFuffix
    NonZeroDigit DecimalDigits_[+Sep]_opt BigIntLiteralSuffix
    NonZeroDigit NumericLiteralSeparator DecimalDigits_[+Sep] BigIntLiteralSuffix
NonDecimalIntegerLiteral_[+Sep]
    BinaryIntegerLiteral_[?Sep]
    OctalIntegerLiteral_[?Sep]
    hexIntegerLiteral_[?Sep]
BigIntLitralSuffix ::
    n
DecimalLiteral ::
    DecimalIntegerLiteral . DeicmalDigits_[+Sep]_opt ExponentPart_[+Sep]_opt
    . DeicmalDigits_[+Sep] ExponentPart_[+Sep]_opt
    DecimalIntegerLiteral ExponentPart_[+Sep]_opt
DecimalIntegerLiteral ::
    0
    NonZeroDigit
    NonZeroDigit NumericLiteralSeparator_opt DecimalDigit_[+Sep]
DecimalDigits_[Sep] ::
    DecimalDigit
    DecimalDigits_[?Sep] DecimalDigit
    [+Sep]DecimalDigits_[+Sep] NumericLiteralSeparator DecimalDigit
DeicamlDigit :: one of
    0 1 2 3 4 5 6 7 8 9
NonZeroDigit :: one of
    1 2 3 4 5 6 7 8 9
ExponentPart_[Sep] ::
    ExponentIndicator SignedInteger_[?Sep]
ExponentIndicator :: one of
    e E
SingedInteger_[Sep] ::
    DecimalDigits_[?Sep]
    + DecimalDigits_[?Sep]
    - DecimalDigits_[?Sep]
BinaryIntegerLitral_[Sep] ::
    0b BinaryDigits_[?Sep]
    0B BinaryDigits_[?Sep]
BinaryDigits_[?Sep] ::
    BinaryDigit
    BinaryDigits_[?Sep] BinaryDigit
    [+Sep]BinaryDigits_[+Sep] NumericLiteralSeparator BinaryDigit
BinaryDigit :: one of
    0 1
OctalIntegerLiteral_[Sep] ::
    0o OctalDigits_[?Sep]
    0O OctalDigits_[?Sep]
OctalDigits_[?Sep] ::
    OctalDigit
    OctalDigits_[?Sep] OctalDigit
    [+Sep]OctalDigits_[+Sep] NumericLiteralSeparator OctalDigit
OctalDigit :: one of
    0 1 2 3 4 5 6 7
HexIntegerLiteral_[Sep] ::
    0x HexDigits_[?Sep]
    0X HexDigits_[?Sep]
HexDigits_[?Sep] ::
    HexDigit
    HexDigits_[?Sep] HexDigit
    [+Sep]HexDigits_[+Sep] NumericLiteralSeparator HexDigit
HexDigit :: one of
    0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F

紧随NumericLiteral的源码字符不能是IdentifierStart或者DecimalDigit
**** 注意 例子：3in是错误的，不是两个输入元素3和in
一致实现，在进行严格模式代码时，不能扩展在B.1.1中描述的NumericLiteral句法，来
包含LegacyOctalIntegerLiteral，也不能扩展DecimalIntegerLiteral的句法来包含
NonOctalDecimalIntegerLiteral
**** Static Semantics: MV
代表Number类型或者BigInt类型的值的数字字面量。
    . NumericalLiteral :: DecimalLiteral的MV是DecimalLiteral的MV
    . NonDecimalIntegerLiteral :: BinaryIntegerLiteral的MV是BinaryIntegerLiteral的MV
    . NonDecimalIntegerLiteral :: OctalIntegerLiteral的MV是OctalIntegerLiteral的MV
    . NonDecimalIntegerLiteral :: HexIntegerLiteral的MV是HexIntgerLiteral的MV
    . DecimalLiteral :: DecimalIntegerLiteral . 的MV是DecimalIntegerLiteral的MV
    . DeicmalLiteral :: DecimalIntegerLiteral . DecimalDigits的MV是DecimalIntegerLiteral
      加上（DecimalDigits*10^-n的MV），其中n是DecimalDigits的中排除所有
      NumericLiteralSeparator的数字编码点数量后，后的MV
    . DecimalLiteral :: DecimalIntegerLiteral . ExponentPart的MV是
      DecimalIntegerLiter * 10^e的MV，其中e是ExponentPart的MV
    . DecimalLiteral :: DecimalIntegerLiteral . DeicmalDigits ExponentPart的MV是
      (DeicmalIntegerLiteral的MV加上(DecimalDigits的MV*10^-n))*10^e，其中n是
      DecimalDigits中排除所有NumericLiteralSeparator后的数字编码点数量，e是
      ExponentPart的MV
    . DecimalLiteral :: . DecmalDigits的MV是DecimalDigits的MV*10^-n，其中n是
      DecimalDigits中排除所有NumericLiteralSeparator后的数字编码点数量。
    . DecimalLiteral :: . DeicmalDigits ExponentPart的MV是DecimalDigits的MV*10^(e-n)，
      其中n是DecimalDigits中排除所有NumericLiteralSeparator后的数字编码点数量，
      e是ExponentPart的MV
    . DecimalLiteral :: DecimalIntegerLiteral的MV是DecimalIntegerLiteral的MV
    . DecimalLiteral :: DecimalIntegerLiteral ExponentPart的MV是DecimalIntegerLiteral的
      MV*10^e，其中e是ExponentPart的MV
    . DecimalIntegerLiteral :: 0的MV是0
    . DecimalIntegerLiteral :: NonZeroDigit的MV是NonZeroDigit的MV
    . DecimalLiteral :: DecimalIntegerLiteral . ExponentPart的MV是
    . DecimalIntegerLiteral :: NonZeroDigit NumericLiteralSeparator_opt DecimalDigits的
      MV是(NonZeroDigit的MV*10^n)加上DecimalDigits的MV，其中n是DecimalDigits中排除
      所有NumericLiteralSeparator后的数字编码点数量
    . DecimalDigits :: DecimalDigit的MV是DecimalDigit的MV
    . DecimalDigits :: DecimalDigits DecimalDigit的MV是(DecimalDigits的MV*10)加上
      DecimalDigit的MV
    . DecimalDigits :: DecimalDigits NumericLiteralSeparator DecimalDigit的MV是(
      DecimalDigits的MV*10)加上DecimalDigit的MV
    . ExponentPart :: ExponentIndicator SignedInteger的MV是SignedInteger的MV
    . SignedInteger :: DecimalDigits的MV是DecimalDigits的MV
    . SignedInteger :: + DecimalDigits的MV是DecimalDigits的MV
    . SignedInteger :: - DecimalDigits的MV是DecimalDigits的MV的负数
    . DecimalDigit :: 0或HexDigit :: 0或OctalDigit :: 0或BinaryDigit :: 0的MV是0
    . DecimalDigit :: 1或HexDigit :: 1或OctalDigit :: 1或BinaryDigit :: 1的MV是1
    . DecimalDigit :: 2或HexDigit :: 2或OctalDigit :: 2的MV是2
    . DecimalDigit :: 3或HexDigit :: 3或OctalDigit :: 3的MV是3
    . DecimalDigit :: 4或HexDigit :: 4或OctalDigit :: 4的MV是4
    . DecimalDigit :: 5或HexDigit :: 5或OctalDigit :: 5的MV是5
    . DecimalDigit :: 6或HexDigit :: 6或OctalDigit :: 6的MV是6
    . DecimalDigit :: 7或HexDigit :: 7或OctalDigit :: 7的MV是7
    . DecimalDigit :: 8或HexDigit :: 8的MV是8
    . DecimalDigit :: 9或HexDigit :: 9的MV是9
    . HexDigit :: a或HexDigit :: A的MV是10
    . HexDigit :: b或HexDigit :: B的MV是11
    . HexDigit :: c或HexDigit :: C的MV是12
    . HexDigit :: d或HexDigit :: D的MV是13
    . HexDigit :: e或HexDigit :: E的MV是14
    . HexDigit :: f或HexDigit :: F的MV是15
    . BinaryIntegerLiteral :: Ob BinaryDigits的MV是BinaryDigits的MV
    . BinaryIntegerLiteral :: Ob BinaryDigits的MV是BinaryDigits的MV
    . BinaryDigits :: BinaryDigit的MV是BinaryDigit的MV
    . BinaryDigits :: BinaryDigits BinaryDigit的MV是(BinaryDigits的MV*2)加上
      BinaryDigit的MV
    . BinaryDigits :: BinaryDigits NumericLiteralSeparator BinaryDigit的MV是(
      BinaryDigits的MV*2)加上BinaryDigit的MV
    . OctalIntegerLiteral :: 0o OctalDigits的MV是OctalDigits的MV
    . OctalIntegerLiteral :: 0O OctalDigits的MV是OctalDigits的MV
    . OctalDigits :: OctalDigit的MV是OctalDigit的MV
    . OctalDigits :: OctalDigits OctalDigit的MV是(OctalDigits的MV*8)加上
      OctalDigit的MV
    . OctalDigits :: OctalDigits NumericLiteralSeparator OctalDigit的MV是(
      OctalDigits的MV*8)加上OctalDigit的MV
    . HexIntegerLiteral :: 0x HexDigits的MV是HexDigits的MV
    . HexIntegerLiteral :: 0X HexDigits的MV是HexDigits的MV
    . HexDigits :: HexDigit的MV是HexDigit的MV
    . HexDigits :: HexDigits HexDigit的MV是(HexDigits的MV*16)加上
      HexDigit的MV
    . HexDigits :: HexDigits NumericLiteralSeparator HexDigit的MV是(
      HexDigits的MV*16)加上HexDigit的MV
**** Static Semantics: NumericValue
NumericLiteral :: DecimalLiteral
1. 返回DecimalLiteral的MV按照下面描述的方式修圆后的Number值。
NumericLiteral :: NonDecimalIntegerLiteral
1. 返回NonDecimalLiteral的MV按照下面描述的方式修圆后的Number值。
一旦字面数字的MV确定出来，它就被修圆到一个Number值。如果MV是0，修圆到+0_F，
否则必须（按照6.1.6.1的规范）修圆到一个Number值，除非这是个DecimalLiteral而且
超过20个有效数字，此时会将超过20位的有效位替换为0后的MV的Number值，或者将超
过20位的有效位替换为0并在第20位加1后的MV的Number值。一个数字是有效位，当它
不是ExponentPart一部分，而且
    . 不是0，或者
    . 左侧有非零数字而且右侧有不在ExponentPart的非零数字。
NumericLiteral :: NonDecimalIntegerLiteral BigIntLiteralSuffix
1. 返回代表NonDecimalIntegerLiteral的MV的BigInt值。
DecimalBigIntegerLiteral :: 0 BigIntLiteralSuffix
1. 返回0_Z
DecimalBigIntegerLiteral :: NonZeroDigit BigIntLiteralSuffix
1. 返回代表NonZeroDigit的MV的BigInt值。
DecimalBigIntegerLiteral :: 
        NonZeroDigit DecimalDigits BigIntLiteralSuffix
        NonZeroDigit NumericLiteralSeparator DecimalDigits BigIntLiteralSuffix
1. 让n是DecimalDigits的编码点，排除掉所有的NumericLiteralSeparator
2. 让mv是(NonZeroDigit的MV*10)加上DecimalDigits的MV
3. 返回Z(mv)
*** String Literals
**** 注意1 字符串字面量是用单引号或者双引号围住的0或者多个Unicode编码点。
            Unicode编码点也可能是转义序列。所有的编码点都可能出现在一个
            字符串字面量里，除了关闭引用的编码点：U+005C（REVERSE SOLIDUS）、
            U+000D（CARRIAGE RETURN）和U+000A（LINE FEED）。任何编码点都可以出现
            在转义序列里。字符串字面量评估为ECMAScript String值。在生成这个
            String值时，Unicode编码点是按照11.1.1定义的UTF-16编码。在Basic
            Multilingual Plane（UTF-16规范的术语）编码点被编码成字符串的一个单一
            编码单元元素。其他的编码编码成字符串的两个编码单元元素。
**** Syntax
StringLiteral ::
    " DoubleStringCharacters_opt "
    ' SingleStringCharacters_opt '
DoubleStringCharacters ::
    DoubleStringCharacter DoubleStringCharacters_opt
SingleStringCharacters ::
    SingleStringCharacter SingleStringCharacters_opt
DoubleStringCharacter ::
    SourceCharacter but not one of " or \ or LineTerminator
    <LS>
    <PS>
    \ EscapeSequence
    LineContinuation
SingleStringCharacter ::
    SourceCharacter but not one of ' or \ or LineTerminator
    <LS>
    <PS>
    \ EscapeSequence
    LineContinuation
LineContinuation ::
    \ LineTerminatorSequence
EscapeSequence ::
    CharacterEscapeSequence
    0 [ lookahead ∉ DecimalDigit]
    HexEscapeSequence
    UnicodeEscapeSequence

一致的实现，在进行严格模式代码是，不能扩展EscapeSequence来包含在B.1.2中描述
的LegacyOctalEscapeSequence或者NonOctalDecimalEscapeSequence。
CharacterEscapeSequence ::
    SingleEscapeCharacter
    NonEscapeCharacter
SingleEscapeCharacter :: one of
    ' " \ b f n r t v
NonEscapeCharacter ::
    不是EscapeCharacter或者Lineterminator的SourceCharacter
EscapeCharacter ::
    SingleEscapeCharacter
    DecimalDigit
    x
    u
HexEscapeSequence ::
    x HexDigit HexDigit
UnicodeEscapeSequence ::
    u Hex4Digits
    u{ CodePoint }
Hex4Digits ::
    HexDigit HexDigit HexDigit HexDigit

非终结符HexDigit的定义在12.8.3中给出。SourceCharacter定义在11.1.
**** 注意2 <LF>和<CR>不能出现在字符串字面量里，除非作为LineContinuation的一部分
            来码型空编码点序列。使其包含在String值或者字符串字面量里的恰当方
            式是使用转义序列\n或者\u000A
**** Static Semantics: SV
字符串字面量代表一个String值。字面量的String值（SV）以字符串字面量的不同部分
贡献出的String值的术语进行描述。作为这个过程的一部分，字符串字面量里的某些
Unicdoe编码点按照12.8.3中的描述被翻译成一个数学值（MV）。
    . String :: " "的SV是空字符串
    . String :: ' '的SV是空字符串
    . DoubleStringCharacters :: DoubleStringCharacter DoubleStringCharacters的SV是
      DoubleStringCharacter的SV和DoubleStringCharacters的SV的字符串拼接。
    . SingleStringCharacters :: SingleStringCharacter SingleStringCharacters的SV是
      SingleStringCharacter的SV和SingleStringCharacters的SV的字符串拼接。
    . DoubleStringCharacter :: 不是"或\或者LineTerminator的SourceCharacter 的SV是
      在SourceCharacter的编码点值上使用UTF16EncodeCodePoint的结果。
    . DoubleStringCharacter :: <LS>的S是由编码单元0x2028（LINE SEPARATOR）构成的
      String值
    . DoubleStringCharacter :: <PS>的S是由编码单元0x2029（PARAGRAPH SEPARATOR）构成
      的String值
    . DoubleStringCharacter :: LineContinuation是空String。
    . SingleStringCharacter :: 不是'或\或者LineTerminator的SourceCharacter 的SV是
      在SourceCharacter的编码点值上使用UTF16EncodeCodePoint的结果。
    . SingleStringCharacter :: <LS>的S是由编码单元0x2028（LINE SEPARATOR）构成的
      String值
    . SingleStringCharacter :: <PS>的S是由编码单元0x2029（PARAGRAPH SEPARATOR）构成
      的String值
    . SingleStringCharacter :: LineContinuation是空String。
    . EscapeSequence :: 0是由编码单元0x0000（NULL）构成的String值。
    . CharacterEscapeSequence :: SingleEscapeCharacter的SV是由表36所列的
      SingleEscapeCharactor决定的编码单元构成的String值
| EscapeSequence | 编码单元值 | Unicode字符名称      | 符号 |
| \b             |     0x0008 | BACKSPACE            | <BS> |
| \t             |     0x0009 | CHARACTER TABULATION | <HT> |
| \n             |     0x000A | LINE FEED (LF)       | <LF> |
| \v             |     0x000B | LINE TABULATION      | <VT> |
| \f             |     0x000C | FORM FEED (FF)       | <FF> |
| \r             |     0x000D | CARRIAGE RETURN (CR) | <CR> |
| \"             |     0x0022 | QUOTATION MARK       | "    |
| \'             |     0x0027 | APOSTROPHE           | '    |
| \\             |     0x005c | REVERSE SOLIDUS      | \    |
    . NonEscapeCharacter :: 不是EscapeCharacter或LineTerminator的SourceCharacter 的MV
      是在SourceCharacter的编码点值上使用UTF16EncodeCodePoint的结果。
    . HexEscapeSequence :: x HexDigit HexDigit的SV是由与HexEscapeSequence的MV相同值的
      编码单元构成的String值
    . Hex4Digits :: HexDigit HexDigit HexDigit HexDigit 的SV是由与Hex4Digits的MV相同
      值的编码单元构成的String值
    . UnicodeEscapeSequence :: u{ CodePoint } 的SV是在CodePoint的MV上使用
      UTF16EncodeCodePoint的结果
**** Static Semantics: MV
    . HexEscapeSequence :: x HexDigit HexDigit的MV是(第一个HexDigit的MV*16）加上
     第二个HexDigit的MV。
    . Hex4Digits :: HexDigit HexDigit HexDigit HexDigit的MV是(第一个HexDigit的
      MV*0x1000)加上(第二个HexDigit的MV*0x100)加上(第三个HexDigit的MV*0x10)加上
     第四个HexDigit的MV。
*** Regular Expression Literals
**** 注意1 正则表达式字面量是一个输入元素，每当这个字面量被评估是，转换成
            一个RegExp对象（22.2）。两个正则表达式字面量在程序里评估出的正则
            表达式对象永远不满足===比较，即使两个字面量的内容相同。RegExp对象
            也可以在运行时由new RegExp或者像函数一样调用RegExp的构造（22.2.3）
            来创建。
下方的码型描述了正则表达式字面量的句法，被输入元素扫描器用于找到正则表达式
字面量的结尾。源文本组成的RegularExpressionBody和RegularExpressionFlags被随后的
更加严格的ECMAScript正则表达式语法（22.2.1）解析出来。

实现可以扩展定义在22.2.1的ECMAScript正则表达式语法，但是不能扩展下方定义的
RegularExpressionBody和RegularExpressionFlags码型，或者使用这两个码型的码型。
**** Syntax
RegularExpressionLiteral ::
    / RegularExpressionBody / RegularExpressionFlags
RegularExpressionBody ::
    RegularExpressionFirstChar RegularExpressionChars
RegularExpressionChars ::
    [ empty ]
    RegularExpressionChars RegularExpressionChar
RegularExpressionFirstChar ::
    不是*或\或/或[的 RegularExpressionNonTerminator 
   RegularExpressionBackslashSequence 
    RegularExpressionClass 
RegularExpressionChar ::
    不是\或/或[的 RegularExpressionNonTerminator 
    RegularExpressionBackslashSequence 
    RegularExpressionClass
RegularExpressionBackslashSequence ::
    \ RegularExpressionNonTerminator
RegularExpressionNonTerminator ::
    不是LineTerminator的SourceCharacter
RegularExpressionClass ::
    [ RegularExpressionClassChars ]
RegularExpressionClassChars ::
    [empty]
    RegularExpressionClassChars RegularExpressionClassChar
RegularExpressionClassChar ::
    不是]或\的RegularExpressionNonTerminator
    RegularExpressionBackslashSequence
RegularExpressionFlags ::
    [empty]
    RegularExpressionFlags IdentifierPart
**** 注意2 正则表达式不允许是空的，因为空的正则表达式//是单行注释的编码单元
            序列。一个空正则表达式，使用/(?:)/表示。
**** Static Semantics: Early Error
RegularExpressionFlags :: RegularExpressionFlags IdentifierPart
    . 如果IdentifierPart包含Unicode转义序列，就是一个SyntaxError。
**** Static Semantics: BodyText
RegularExpressionLiteral :: / RegularExpressionBody / RegularExpressionFlags
    . 返回识别为RegularExpressionBody的源文本。
**** Static Semantics: FlagText
RegularExpressionLiteral :: / RegularExpressionBody / RegularExpressionFlags
    . 返回识别为RegularExpressionFlags的源文本。
*** Template Literal Lexical Components
**** Syntax
Template ::
    NoSubstitutionTemplate
    TemplateHead
NoSubstitutionTemplate ::
    ` TemplateCharacters_opt `
TemplateHead ::
    ` TempalteCharacters_opt ${
TemplateSubstitutionTail ::
    TemplateMiddle
    TemplateTail
TemplateMiddle ::
    } TemplateCharacters_opt ${
TemplateTail ::
    } TemplateCharacters_opt `
TemplateCharacters ::
    TemplateCharacter TemplateCharacters_opt
TemplateCharacter
    $ [lookahead != { ]
    \ EscapeSequence
    \ NotEscapeSequence
    LineContinuation
    LineTerminatorSequence
    不是`或\或$或LineTerminator的SourceCharacter
NotSecapeSequence ::
    0 DecimalDigit
    不是0的DecimalDigit
    x [lookahead ∉ HexDigit]
    x HexDigit [lookahead ∉ HexDigit]
    u [lookahead ∉ HexDigit] [lookahead ≠ { ]
    u HexDigit [lookahead ∉ HexDigit]
    u HexDigit HexDigit [lookahead ∉ HexDigit]
    u HexDigit HexDigit HexDigit [lookahead ∉ HexDigit]
    u { [lookahead ∉ HexDigit]
    u { NotCodePoint [lookahead ∉ HexDigit]
    u { CodePoint [lookahead ∉ HexDigit] [lookahead ≠ } ]
NotCodePoint ::
    HexDigits_[~Sep] 但是仅当HexDigits的MV > 0x10FFFF
CopePoint ::
    HexDigits_[~Sep] 但是仅当HexDigits的MV <= 0x10FFFF
一致实现在解析TemplateCharacter时，不能扩展B.1.2中描述的EscapeSequence的定义。
**** 注意 TemplateSubstitutionTail被InputElementTemplateTail的备选词法目标。
**** Static Semantics: TV和TRV
一个模板字面量组件被翻译成Unicode编码点序列。字面量组件的模板值（TV）被描述
为一组由模板字面量组件的不同部分贡献的String值（SV 12.8.4）。作为这个过程的
一部分，有些模板组件里的Unicode编码点按照含有的数学值（MV 12.8.3）来翻译。在
确定TV时，转义序列按照其表示的编码点被替换为相应的UTF-16编码单元组。模板原
始值（TRV）跟模板值很像，区别在于TRV的转义序列按照字面翻译。
    . NoSubstitutionTemplate :: ` `的TV和TRV是空字符串。
    . TemplateHead :: ` ${的TV和TRV是空字符串
    . TemplateMiddle :: } ${的TV和TRV是空字符串
    . TemplateTail :: } `的TV和TRV是空字符串
    . TemplateCharacters :: TemplateCharacter TemplateCharacters的TV是undefined，如果
      TemplateCharacter的TV是undefined或者TemplateCharacters的TV是undefined。否则是
      TemplateCharacter的TV和TempalteCharacters的TV的字符串拼接。
    . TemplateCharacter :: 不是`或\或$或LineTerminater的SourceCharacter 的TV是在
      SourceCharacter的编码点值上使用UTF16EncodeCodePoint的结果。
    . TemplateCharacter :: $的TV是由编码单元0x0024（DOLLAR SIGN）构成的字符串值。
    . TemplateCharacter :: \ EscapeSequence的TV是EscapeSequence的SV
    . TemplateCharacter :: \ NotEscapeSequence的TV是undefined
    . TemplateCharacter :: LineTerminatorSequence的TV是LineTerminatorSequence的TRV
    . LineContinuation :: \ LineTerminatorSequence的TV是空String。
    . TemplateCharacters :: TemplateCharacter TemplateCharacters的TRV是TemplateCharacter
      的TRV和TemplateCharacters的TRV的字符串拼接
    . TemplateCharacters :: 不是`或\或$或LineTerminater的SourceCharacter 的TRV是在
      SourceCharacter的编码点值上使用UTF16EncodeCodePoint的结果。
    . TemplateCharacter :: $的TRV是由编码单元0x0024（DOLLAR SIGN）构成的字符串值。
    . TemplateCharacter :: \ EscapeSequence的TRV是编码单云0x005C（REVERSE SOLIDUS）
      和EscapeSequence的TRV的字符串拼接。
    . TemplateCharacter :: \ NotEscapeSequence的TRV是编码单云0x005C（REVERSE 
      SOLIDUS）和NotEscapeSequence的TRV的字符串拼接。
    . EscapeSequence :: 0的TRV是由编码单元0x0030（DIGIT ZERO）构成的字符串值。
    . NotEscapeSequence :: 0 DecimalDigit的TRV是编码单元0x0030（DIGIT ZERO）和
      DecimalDigit的TRV的字符串拼接
    . NotEscapeSequence :: x [lookahead ∉ HexDigit]的TRV是编码单元0x0078（LATIN 
      SMALL LETTER X）构成的字符串值
    . NotEscapeSequence :: x HexDigit [lookahead ∉ HexDigit]的TRV是编码单元0x0078
      （LATIN SMALL LETTER X）和HexDigit的TRV的字符串拼接。
    . NotEscapeSequence :: u [lookahead ∉ HexDigit] [lookahead ≠ {]的TRV是编码单元
      0x0075（LATIN SMALL LETTER U）构成的字符串值。
    . NotEscapeSequence :: u HexDigit [lookahead ∉ HexDigit]的TRV是编码单元0x0075
      （LATIN SMALL LETTER U）和HexDigit的TRV的字符串拼接。
    . NotEscapeSequence :: u HexDigit HexDigit [lookahead ∉ HexDigit]的TRV是编码单元
      0x0075（LATIN SMALL LETTER U）、第一个HexDigit的TRV和第二个HexDigit的TRV的
      字符串拼接。
    . NotEscapeSequence :: u HexDigit HexDigit HexDigit [lookahead ∉ HexDigit]的TRV是
      编码单元0x0075（LATIN SMALL LETTER U）、第一个HexDigit的TRV、第二个HexDigit
      的TRV和第三HexDigit的TRV的字符串拼接。
    . NotEscapeSequence :: u { [lookahead ∉ HexDigit]的TRV是编码单元0x0075（LATIN
      SMALL LETTER U）和编码单元0x007B（LEFT CURLY BRACKET）的字符串拼接
    . NotEscapeSequence :: u { NotCodePoint [lookahead ∉ HexDigit]的TRV是编码单元
      0x0075（LATIN SMALL LETTER U）、编码单元0x007B（LEFT CURLY BRACKET）和
      NotCodePoint的TRV的字符串拼接。
    . NotEscapeSequence :: u { CodePoint [lookahead ∉ HexDigit] [lookahead ≠ {]的TRV是
      编码单元0x0075（LATIN SMALL LETTER U）、编码单元0x007B（LEFT CURLY BRACKET）
      和CodePoint的TRV的字符串拼接
    . DecimalDigit :: 0 1 2 3 4 5 6 7 8 9之一 的TRV是在码型匹配到的编码点上运行
      UTF16EncodeCodePoint的结果。
    . CharacterEscapeSequence :: NonEscapeCharacter的TRV是NonEscapeCharacter的SV。
    . SingleEscapeCharacter :: ' " \ b f n r t v之一 的TRV是在码型匹配到的编码点
      上运行UTF16EncodeCodePoint的结果。
    . HexEscapeSequence :: x HexDigit HexDigit的TRV是编码单元0x0078（LATIN SMALL
      LETTER U）、第一个HexDigit的TRV和第二个HexDigit的TRV的字符串拼接。
    . UnicodeEscapeSequence :: u Hex4Digits的TRV是编码单元0x0075（LATIN SMALL
      LETTER U）和Hex4Digits的TRV的字符串拼接。
    . UnicodeEscapeSequence :: u{ CodePoint }的TRV是编码单元0x0075（LATIN SMALL
      LETTER U）、编码单元0x007B（LEFT CURLY BRACKET）、CodePoint的TRV和编码单元
      0x007D（RIGHT CURLY BRACKET）的字符串拼接。
    . Hex4Digits :: HexDigit HexDigit HexDigit HexDigit的TRV是第一个HexDigit的TRV、
      第而个HexDigit的TRV、第三个HexDigit的TRV和第四个HexDigit的TRV的字符串拼
      接。
    . HexDigits :: HexDigits HexDigit的TRV是HexDigits的TRV和HexDigit的TRV的字符串
      拼接。
    . HexDigit :: 0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F之一 的TRV是在码型匹配
      到的编码点上运行UTF16EncodeCodePoint的结果。
    . LineContinuation :: \ LineTerminatorSequence 是编码单元0x005C（REVERSE SOLIDUS）
      和LineTerminatorSequence的TRV字符串拼接
    . LineTerminatorSequence :: <LF>的TRV是编码单元0x000A（LINE FEED）构成的字符
      串值。
    . LineTerminatorSequence :: <CR>的TRV是编码单元0x000A（LINE FEED）构成的字符
      串值。
    . LineTerminatorSequence :: <LS>的TRV是编码单元0x2028（LINE SEPARATOR）构成的
      字符串值。
    . LineTerminatorSequence :: <PS>的TRV是编码单元0x2029（PARGRAPH SEPARATOR）构成
      的字符串值。
    . LineTerminatorSequence :: <CR> <LF>的TRV是编码单元0x000A（LINE FEED）构成的
      字符串值。
***** 注意 注意TV不包含LineContinuation的编码单元即使TRV包含他们。在TV和TRV中
           <CR><LF>和<CR> LineTerminatorSequences都被正常化为<LF>。显式的
            EscapeSequence不需要包含<CR>或者<CR><LF>序列。
** Automatic Semicolon Insertion
绝大多数ECMAScript语句和声明必须用分号终结。这种分号通常显式的出现在源文本
里。然而为了方便，这些分号会在某种情况下被从源文本中缺省掉。用在那些会
自动像源文本中插入分号的情况来描述这些情况。
*** Rules of Automatic Semicolon Insertion
在随后的规则里，信标意味着用在条款12中描述的正确的词法目标符确定实际识别的
词法信标。

插入分号由三个基本规则：
1. 在从左到右解析的源文本里，当遇到的信标（称为违法信标）不被任何语法
   码型允许时，如果下方条件至少满足一条，分号会自动插入到违法的信标前。
     。违法信标跟前一个信标被至少隔了一个LineTerminator
     。违法信标是 }
     。前一个信标是)，而且插入的分号会被解析为do-while语句（14.7.2）的
       终结分号。
2. 在从左到右解析的源文本里，当遇到输入的信标流的末端，而且解析器不能
   将这个输入的信标流解析为一个单独的目标非完结符实例，那么分号就会自动
   插入到这个输入流的末端。
3. 在从左到右解析的源文本里，当遇到的信标是被语法某些码型允许，但是这种
   码型是受限码型，而且信标是在这个受限码型里紧随着[no LineTerminator here]
   的终结符或者非终结符的第一个信标（这种信标称为受限信标），且这个受限
   信标跟前一个信标至少隔了一个LineTerminator，那么分号会被插入在这个受限
   信标的前面。

然后，在前面说的规则上覆盖了一个额外的条件：如果自动插入的分号会被解析成
空语句或者成为for语句（14.7.4）头的两个分号之一，这个插入不会执行。
**** 注意 随后的内容是语法中仅有的受限码型
           UpdateExpression_[Yield, Await] :
               LeftHandSideExpression_[?Yield, ?Await] [no LineTerminator here] ++
               LeftHandSideExpression_[?Yield, ?Await] [no LineTerminator here] --
           ContinueStatement_[Yield, Await] :
               continue ;
               continue [no lineTerminator here] LabelIdentifier_[?Yield, ?Await] ;
           BreakStatement_[Yield, Await] :
               break ;
               break [no lineTerminator here] LabelIdentifier_[?Yield, ?Await] ;
           ReturnStatement_[Yield, Await] :
               return ;
               return [no lineTerminator here] Expression_[+In, ?Yield, ?Await] ;
           ThrowStatement_[Yield, Await] :
               throw [no lineTerminator here] Expression_[+In, ?Yield, ?Await] ;
           ArrowFunction_[In, Yield, Await] :
               ArrowParameters_[?Yield, ?Await] [no LineTerminator here] => ConCiseBody_[?In]
           YieldExpression_[In, Await] :
               yield
               yield [no LineTerminator here] AssignmentExpression_[?In, +Yield, ?Await]
               yield [no LineTerminator here] * AssignmentExpression_[?In, +Yield, ?Await]
          这些受限码型的实际效果如下所列：
               . 当遇到++或--信标的时候，解析器会将其作为后缀操作，而且在前一
                 个信标与++或--信标间至少一个LineTerminator，那么分号会自动插入
                 在++或--信标前。
               . 当遇到continue、break、return、throw或者yield信标的时候，下一个
                 信标前遇到LineTerminator，分号会自动插入到continue、break、
                 return、throw或yield信标的后边。
           给ECMAScript程序员的实践建议时：
               . 后缀++或--应当在其作为运算符的同一行
               . 在return或者throw语句中的表达式，或者在yield表达式中的
                 AssignmentExpression应当与return、throw或者yield信标同一行开始。
               . 在break或continue语句中的LabelIdentifier应当与break或者continue信
                 标在同一行
*** Examples of Automatic Semicolon Insertion
本节不是标准内容。

源码
{ 1 2 } 3
不是ECMAScript语法中的有效语句，即使有自动插入分号的机制。相反，源码
{ 1
2 } 3
仍然不是有效的ECMAScript语句，但是会自动插入分号，转换为
{ 1
; 2 ;} 3;
这却是一个有效的ECMAScirpt语句。

源码
for (a; b
)
不是有效的ECMAScript语句，也不会被自动插入分号机制修改，因为这个分号是被for
语句头所需要的。自动插入分号机制不会向for语句头插入分号。

源码
return
a + b
被自动插入分号机制转换成：
return;
a + b;
**** 注意1 表达式a + b不会作为一个值被return语句返回，因为跟信标return之间隔了
            LineTerminator
源码
a = b
++c
被自动插入分号机制转换成：
a = b;
++c;
**** 注意2 信标++不会作为b的后缀操作符，因为b和++之间隔了LineTerminator。
源码
if (a > b)
eles c = d
不是有效的ECMAScript语句，也不会被修改为在else信标前自动插入分号，尽管没有
语法码型用于这里，因为自动插入分号机制会将这里解析为空语句。

源码
a = b + c
(d + e).print()
不会被自动插入分号机制转换，因为第二行开始括号表达式能被翻译为函数调用的
参数：
a = b + c(d + e).print()

在这种赋值语句必须以左括号开始的情况，程序员显式的在前一个语句尾部提供一
个分号，而不是依赖自动插入分号，会是好一些。
*** Interesting Cases of Automatic Semicolon Insertion
本节不是标准内容。

依赖自动插入分号，ECMAScript程序可以极少使用分号的方式书写。如上描述，分号
不必每行插入，自动插入分号可以依靠经过行终结符的多个信标。

当新的句法特征增加到ECMAScript中，会导致其前的行依赖自动插入分号的额外语法
码型会被增加进来以便在解析时变更语法码型。

本节的目的是，如果一个地方没有分号可不可以插入，依赖于其前的源码，这就被
认为是一个有取的自动插入分号案例。本节剩下的部分描述了一些在当前版本
ECMAScript中的自动插入分号案例。
**** Interesting Cases of Automatic Semicolon Insertion in Statement List
在一个StatementList中，许多StatementListItem结尾的分号，使用自动插入分号机制
可以忽略掉。作为上面规则的后果，在以表达式结尾的行末，是需要分好的，如果
随后的行以下方所列的方式开始：
    . ( 。没有分号，这两行合起来被当作CallExpression
    . [ 。没有分号，这两行合起来被当作性质访问，而不是ArrayLiteral或者
      ArrayAssignmentPattern
    . ` 。没有分号，这两行合起来被翻译成标记的模板（13.3.1），前面的表达式
      作为MemberExpression
    . 单位操作符+ 或 -。没有分号，这两行合起来被当作两位操作符。
    . 表达式字面量。没有分号，这两行合起来后，/被当作MultiplicativeOperator，
      例如有旗帜的RegExp
**** Cases of Automatic Semicolon Insertion and "[no LineTerminator here]"
本节不是标准内容。

ECMAScript含有很多包含[no LineTerminator here]的语法码型。这些码型某时意味着
在语法里有可选的操作项。在这些位置引入LineTerminator会改变源文本的语法码型
不使用可选的操作项。

本节剩余内容描述了本版本ECMAScript使用[no LineTerminator here]的码型。
***** List of Grammar Productions with Optional Operands and
                "[no LineTerminator here]"
    . UpdateExpression
    . ContinueStatement
    . BreakStatement
    . ReturnStatement
    . YieldExpression
    . 与Function Definitions（15.2）相关的Async Function Definitions（15.8）
* ECMAScript Language: Expressions 表达式
** Identifiers
*** Syntax
IdentifierReference_[Yield, Await] :
    Identifier
    [~Yield]yield
    [~Await]await
BindingIdentifier_[Yield, Await] :
    Identifier
    yield
    await
LabelIdentifier_[Yield, Await] :
    Identifier
    [~Yield]yield
    [~Await]await
Identifier :
    不是ReservedWord的IdentifierName
**** 注意 yield和await在于法中允许做BindingIdentifier，但是被下方的静态语义禁
           止，以避免自动插入分号机制触发在随后的例子里
           let
           await 0
*** Static Semantics: Early Errors
BindingIdentifier : Identifier
. 如果本码型的代码包含在严格模式代码里，Identifier的String值是arguments或
  eval，那么会是一个SyntaxError

IdentifierReference : yield
BindingIdentifier : yield
LabelIdentifier : yield
. 如果本码型的代码包含在严格模式代码里，那么会是一个SyntaxError

IdentifierReference : await
BindingIdentifier : await
LabelIdentifier : await
. 如果句法的目标符是Module，那么会是一个SyntaxError
    
BindingIdentifier_[Yield, Await] : yield
. 如果码型有一个[Yield]参数，那么会是一个SyntaxError

BindingIdentifier_[Yield, Await] : await
. 如果码型有一个[Await]参数，那么会是一个SyntaxError
    
IdentifierReference_[Yield, Await] : Identifier
BindingIdentifier_[Yield, Await] : Identifier
LabelIdentifier_[Yield, Await] : Identifier
. 如果码型有一个[Yield]参数而且Identifier的String值是yield，那么会是一个
  SyntaxError
. 如果码型有一个[Await]参数而且Identifier的String值是await，那么会是一个
  SyntaxError
      
Identifier : 不是ReservedWord的IdentifierName
. 如果码型在严格模式代码里，而且IdentifierName的String值是implements、
  interface、let、package、private、protected、public、static、yield，那么会是
  一个SyntaxError
. 如果句法的目标符是Module，而且IdentifierName的String值是await，那么会是
  一个SyntaxError
. 如果IdentifierName的String值是除了yield和await的ReservedWord，那么会是一个
  SyntaxError
**** 注意 IdentifierName的String值正常化了在IdentifierName的Unicode转义序列，因此
           能够正常化为ReservedWord的转义序列不能作为Identifier
*** Static Semantics: String Value
IdentifierName ::
    IdentifierStart
    IdentifierName IdentifierPart
1. 让idText是IdentifierName匹配到的源文本
2. 让idTextUnescaped是将出现在idText中的所有\UnicodeEscapeSequence替换为
   UnicodeEscapeSequence表示的编码点
3. 返回!CodePointsToString(idTextUnescaped)
   
IdentifierReference : yield
BindingIdentifier : yield
LabelIdentifier : yield
1. 返回"yield"
   
IdentifierReference : await
BindingIdentifier : await
LabelIdentifier : await
1. 返回"await"

Identifier : 不是ReservedWord的IdentifierName
1. 返回IdentifierName的String值
*** Static Semantics: Evaluation
IdentifierReference : Identifier
1. 返回?ResolveBinding(Identifier的String值)

IdentifierReference : yield
1. 返回?ResolveBinding("yield")

IdentifierReference : await
1. 返回?ResolveBinding("await")
*** 注意1 IdentifierRefrerence的评估结果总是Reference类型的
*** 注意2 在非严格模式代码里，关键词yield可以作为标识。评估这种
           IdentifierReference会将yeild作为标识产生绑定。EarlyError会限制这种评估
           仅发生在非严格模式代码里。
** Primary Expression 基础表达式
*** Syntax
PrimaryExpression_[Yield, Await] :
    this
    IdentifierReference_[?Yield, ?Await]
    Literal
    ArrayLiteral_[?Yield, ?Await]
    ObjectLiteral_[?Yield, ?Await]
    FunctionExpresion
    ClassExpression_[?Yield, ?Await]
    GeneratorExpression
    AsyncFunctionExpression
    AsyncGeneratorExpression
    RegularExpressionLiteral
    TemplateLiteral_[?Yield, ?Await, ~Tagged]
    CoverParenthesizedExpressionAndArrowParameterList_[?Yield, ?Await]
CoverParenthesizedExpressionAndArrowParameterList_[Yield, Await] :
    ( Expression_[+In, ?Yield, ?Await] )
    ( Expression_[+In, ?Yield, ?Await] , )
    ( )
    ( ... BindingIdentifier_[?Yield, ?Await] )
    ( ... BindingPattern_[?Yield, ?Await] )
    ( Expression_[+In, ?Yield, ?Await], ... BindingIdentifier_[?Yield, ?Await] )
    ( Expression_[+In, ?Yield, ?Await], ... BindingPattern_[?Yield, ?Await] )
*** Supplemental Syntax 辅助句法
当处理码型
PrimaryExpression_[Yield, Await] : CoverParenthesizedExpressionAndArrowParameterList_[?Yield, ?Await]
的实例时，CoverParenthesizedExpressionAndArrowParameterList的翻译过程使用随后的
优化语法：
ParenthesizedExpreesion_[Yield, Await] :
    ( Expression_[+In, ?Yield, ?Await] )
*** Semantics 语义
**** Static Semantics: CoveredParenthesizedExpression
CoverParenthesizedExpressionAndArrowParameterList : ( Expression )
1. 返回被CoverParenthesizedExpressionAndArrowParameterList覆盖的
   ParenthesizedExpression
*** The this Keyword 关键词this
**** Runtime Semantics: Evaluation 运行时语义：评估
PrimaryExpression : this
1. 返回?ResolveThisBinding()
*** Identifier Reference
见于13.1的IdentifierReference
*** Literals 字面量
**** Syntax
Literal :
    NullLiteral
    Booleaniteral
    NumericLiteral
    StringLiteral 
**** Runtime Semantics: Evaluation 运行时语义：评估
Literal : NullLiteral
1. 返回 null

Literal : BolleanLiteral
1. 如果BooleanLiteral是false信标，返回false
2. 如果BooleanLiteral是true信标，返回true

Literal : NumericLiteral
1. 返回12.8.3中定义的NumericLiteral的Number值

Literal : StringLiteral
1. 返回12.8.4.1中定义的StringLiteral的SV
*** Array Initializer 数组初始化
**** 注意 数组字面量是一个用方括号包裹的，含有若干作为数组元素的表达式形式
           的list来描述初始化数组对象的表达式。元素不必是字面量，他们在这个
           数组初始化被评估的时候被评估。

数组元素可以在元素list开始、中间或结尾处被省略。当元素list里的逗号没有前置
的AssignmentExpression（比如开始位置或者跟随另一个逗号），缺失的数组元素会贡
先数组的长度，并增加随后元素的索引位置。缺失的数组元素没有定义。如果元素
是在数组尾部被忽略的，这个元素不贡献数组的长度。
**** Syntax
ArrayLiteral_[Yield, Await] :
    [ Elision_opt ]
    [ ElementList_[?Yield, ?Await] ]
    [ ElementList_[?Yield, ?Await], Elision_opt ]

ElementList_[Yield, Await] :
    Elision_opt AssignmentExpression_[+In, ?Yield, ?Await]
    Elision_opt SpreadElement_[?Yield, ?Await]
    ElementList_[?Yield, ?Await] , Elision_opt AssignmentExpression_[+In, ?Yield, ?Await]
    ElementList_[?Yield, ?Await] , Elision_opt SpreadElement_[?Yield, ?Await]
    
Elision :
    ,
    Elision ,
    
SpreadElement_[Yield, Await] :
    ... AssignmentExpression_[+In, ?Yield, ?Await]
**** Runtime Semantics: ArrayAccumulation
带array和nextIndex参数.

Elision : ,
1. 让len是nextIndex + 1
2. 执行?Set(array, "length", F(len), true)
3. 注意：上述步骤如果len超过了2^32-1，回投掷异常
4. 返回 len.

Elision : Elision ,
1. 返回在Elision上执行带array和nextIndex +1参数的ArrayAccumulation的结果

ElementList : Elision_opt AssignmentExpression
1. 如果Elision存在，那么
    a. 设置nextIndex是在Elision上执行带array和nextIndex参数的ArrayAccumulation
       的结果
    b. ReturnIfAbrupt(nextIndex)
2. 让initResult是评估AssignmentExpression的结果
3. 让initValue是?GetValue(initResult)
4. 让created是!CreateDataPropertyOrThrow(array, !ToString(F(nextIndex)), initValue)
5. 返回 nextIndex + 1

ElementList : Elision_opt SpreadElement
1. 如果Elision存在，那么
    a. 设置nextIndex是在Elision上执行带array和nextIndex参数的ArrayAccumulation
       的结果
    b. ReturnIfAbrupt(nextIndex)
2. 返回在SpreadElement上执行带array和nextIndex的结果

ElementList : ElementList , Elision_opt AssignmentExpression
1. 设置nextIndex是在ElementList上执行带array和nextIndex参数的ArrayAccumulation
   的结果
2. ReturnIfAbrupt(nextIndex)
3. 如果Elision存在，那么
    a. 设置nextIndex是在Elision上执行带array和nextIndex参数的ArrayAccumulation
       的结果
    b. ReturnIfAbrupt(nextIndex)
4. 让initResult是评估AssignmentExpression的结果
5. 让initValue是?GetValue(initResult)
6. 让created是!CreateDataPropertyOrThrow(array, !ToString(F(nextIndex)), initValue)
7. 返回 nextIndex + 1

ElementList : ElementList, Elision_opt SpreadElement
1. 设置nextIndex是在ElementList上执行带array和nextIndex参数的ArrayAccumulation
   的结果
2. ReturnIfAbrupt(nextIndex)
3. 如果Elision存在，那么
    a. 设置nextIndex是在Elision上执行带array和nextIndex参数的ArrayAccumulation
       的结果
    b. ReturnIfAbrupt(nextIndex)
4. 返回在SpreadElement上执行带array和nextIndex的结果

SpreadElement : ... AssignmentExpression
1. 让spreadRef是AssignmentExpression的评估结果
2. 让spreadObj是?GetValue(spreadRef)
3. 让iteratorRecord是?GetIterator(spreadObj)
4. 重复
    a. 让next是?IteratorStep(iteratorRecord)
    b. 如果next是false，返回nextIndex
    c. 让nextValue是?IteratorValue(next)
    d. 执行!CreateDataPropertyOrThrow(array, !ToString(F(nextIndex)), nextValue)
    e. 设置nextIndex是nextIndex+1
***** 注意 CreateDataPropertyOrThrow用于确保在array上创建了自有性质，即使内建的
            ArrayPrototypeObject已经修改为阻止使用\[\[Set]]创建新性质的方式。
**** Runtime Semantics: Evaluation 运行时语义：评估
ArrayLiteral : [ Elision_opt ]
1. 让array是!ArrayCreate(0)
2. 如果Elision存在，那么
     a. 设置len是在Elision上执行带array和0参数的ArrayAccumulation的结果
     b. ReturnIfAbrupt(len)
3. 返回array

ArrayLiteral : [ ElementList ]
1. 让array是!ArrayCreate(0)
2. 让len是在ElementList上执行带array和0参数的ArrayAccumulation的结果
3. ReturnIfAbrupt(len)
4. 返回array

ArrayLiteral : [ ElementList, Elision_opt]
1. 让array是!ArrayCreate(0)
2. 设置nextIndex是在ElementList上执行带array和0参数的ArrayAccumulation的结果
3. ReturnIfAbrupt(nextIndex)
4. 如果Elision存在，那么
     a. 设置len是在Elision上执行带array和nextIndex参数的ArrayAccumulation的结果
     b. ReturnIfAbrupt(len)
5. 返回array
*** Object Initializer
**** 注意1 ObjectInitializer是描述初始化Object的表达式，以像字面量的方式书写。
            是在被大括号包裹起来的，由若干个性质键和联结值的对构成的列表。
            其中的值不必是字面量，他们在每次评估ObjectInitializer的时候也被
            评估。
**** Syntax 
ObjectLiteral_[Yield, Await] :
    { }
    { PropertyDefinitionList_[?Yield, ?Await] }
    { PropertyDefinitionList_[?Yield, ?Await] , }

PropertyDefinitionList_[Yield, Await] :
    PropertyDefinition_[?Yield, ?Await]
    PropertyDefinitionList_[Yield, Await] , PropertyDefinition_[?Yield, ?Await]

PropertyDefinition_[Yield, Await] :
    IdentifierReference_[?Yield, ?Await]
    CoverInitializedName_[?Yield, ?Await]
    PropertyName_[?Yield, ?Await] : AssignmentExpression_[+In, ?Yield, ?Await]
    methodDefiniation_[?Yield, ?Await]
    ... AssignmentExpression_[+In, ?Yield, ?Await]
    
PropertyName_[Yield, Await] :
    LiteralPropertyName
    ComputedPropteryName_[?Yield, ?Await]
    
LiteralPropertyName :
    IdentifierName
    StringLiteral
    NumericLiteral

ComputedPropterName_[Yield, Await] :
    [ AssignmentExpression_[+In, ?Yield, ?Await] ]

CoverInitializedName_[Yield, Await] :
    IdentifierReference_[?Yield, ?Await] Initializer_[+In, ?Yield, ?Await]

Initializer_[In, Yield, Await] :
    = AssignmentExpression_[?In, ?Yield, ?Await]
**** 注意2 MethodDefinition定义在15.4
**** 注意3 在某些背景中，ObjectLiteral用于作为更严格的二级语法的覆盖语法。
            CoverInitializedName码型是这些二级语法的必要覆盖。然而在实际上是
            期望ObjectLiteral的普通背景里，使用这些码型会导致早期SyntaxError。
**** Static Semantics: Early Errors 静态语义：早期错误
PropertyDefinition : MethodDefinition
. 如果MethodDefinition的HasDirectSuper是true，这存在SyntaxError。

除了描述实际的对象初始化，ObjectLiteral码型还被用作ObjectAssignmentPattern的覆盖
语法，也可能被识别为CoverParenthesizedExpressionAndArrowParameterList的一部分。当
ObjectLiteral出现在需要ObjectAssignmentPattern的背景中，不要使用随后的早期错误。
此外，在初始解析CoverParenthesizedExpressionAndArrowParameterList或者
CoverCallExpressionAndAsyncArrowHead时也不要使用。

PropertyDefinition : CoverInitializedName
. 如果代码匹配到了此码型，就投掷一个SyntaxError
***** 注意 这种码型存在，所以ObjectLiteral可以作为ObjectAssignmentPattern的覆盖
            语法。不能发生在实际的对象初始化里。
**** Static Semantics: IsComputedPropertyKey
PropertyName : LiteralPropertyName
1. Return false;

PropertyName : ComputedPropertyName
1. Return true;
**** Static Semantics: PropertyNameList
PropertyDefinitionList : PropertyDefinition
1. 如果PropertyDefinition的PropName是空，返回新的空List
2. 返回只有PropertyDefinition的PropName的List

PropertyDefinitionList : PropertyDefinitionList , PropertyDefinition
1. 让list是PropterDefinitionList的PropertyNameList
2. 如果PropertyDefinition的PropName是空，返回list
3. 将PropertyDefinition的PropName追加到list的末端
4. 返回list
**** Runtime Semantics: Evaluation 运行时语义：评估
ObjectLiteral : { }
1. 返回!OrdinaryObjectCreate(%Object.prototype%)

ObjectLiteral :
    { PropertyDefinitionList }
    { PropertyDefinitionList, }
1. 让obj是!OrdinaryObjectCreate(%Object.prototype%)
2. 执行在PropertyDefinitionList上的带obj和true参数的?PropertyDefinitionEvaluation
3. 返回obj

LiteralPropertyName : IdentifierName
1. 返回IdentifierName的字符传值

LiteralPropertyName : StringLiteral
1. 返回StringLiteral的SV

LiteralPropertyName : NumericLiteral
1. 让nbr是NumericLiteral的数字值
2. 返回!ToString(nbr)

ComputedPropertyName : [ AssignmentExpression ]
1. 让exprValue是AssignmentExpression的评估结果
2. 让propName是?GetValue(exprValue)
3. 返回?ToPropertyKey(propName)
**** Runtime Semantics: PropertyDefinitionEvaluation
带参数object和enumerable

PropertyDefinitionList : PropertyDefinitionList , PropertyDefinition
1. 在PropertyDefinitionList上执行带object和enumerable参数的
   ?PropertyDefinitionEvaluation
2. 返回在PropertyDefinition上执行带object和enumerable参数的
   PropertyDefinitionEvaluation的结果

PropertyDefinition : ... AssignmentExpression
1. 让exprValue是评估AssinmentExpression的结果
2. 让fromValue是?GetValue(exprValue)
3. 让excludedNames是新的空List
4. 返回 ?CopyDataProperties(object, fromValue, excluedeNames)

PropertyDefinition : IdentifierReference
1. 让propName是IdentifierReference的字符串值
2. 让exprValue是评估IdentifierReference的结果
3. 让propValue是?GetValue(exprValue)
4. Assert：enumerable是true
5. Assert：object是普通的可扩展对象，没有不可设置性质
6. 返回!CreateDataPropertyOrThrow(object, propName, propValue)

PropertyDefinition : PropertyName : AssignmentExpression
1. 让propKey是PropertyName的评估结果
2. ReturnIfAbrupt(propKey)
3. 如果IsAnonymousFunctionDefinition(AssignmentExpression)是true， 那么
    a. 让propValue是在AssignmentExpression上带propKey参数的?NamedEvaluation
4. 否则
    a. 让exprValueRef是AssignmentExpression的评估结果
    b. 让propValue是?GetValue(exprValueRef)
5. Assert：enumerable是true
6. Assert：object是普通的可扩展对象，没有不可设置性质
7. 返回!CreateDataPropertyOrThrow(object, propName, propValue)
***** 注意 在B.3.1提供了本码型的备选语义。
MethodDefinition:
    PropertyName ( UniqueFormalParameters ) { FunctionBody }
    get PropertyName ( ) { FunctionBody }
    set PropertyName ( PropertySetParameterList ) { FunctionBody }
1. 返回MethodDefinition上带object和enumerable参数的?MethodDefinitionEvaluation

GeneratorMethod : * PropertyName ( UniqueFormalParameters ) { GeneratorBody }
1. 返回GeneratorMethod上带object和enumerable参数的?MethodDefinitionEvaluation

AsyncGeneratorMethod : async * PropertyName ( UniqueFormalParameters ) { AsyncGeneratorBody }
1. 返回AsyncGeneratorMethod上带object和enumerable参数的?MethodDefinitionEvaluation

AsyncMethod : async PropertyName ( UniqueFormalParameters ) { AsyncGeneratorBody }
1. 返回AsyncMethod上带object和enumerable参数的?MethodDefinitionEvaluation
*** Function Defining Expressions
见于15.2的 PrimaryExpression : FunctionExpression .

见于15.5的 PrimaryExpression : GeneratorExpression .

见于15.7的 PrimaryExpression : ClassExpression .

见于15.8的 PrimaryExpression : AsyncFunctionExpression .

见于15.6的 PrimaryExpression : AsyncGeneratorExression .
*** Regular Expression Literals
**** Syntax
见于12.8.5
**** Static Semantics:Early Errors
PrimaryExpression : RegularExpressionLiteral
. 如果IsValidRegularExpressionLiteral(RegularExpressionLiteral)是false，那么有
  SyntaxError。
**** Static Semantics: IsValidRegularExpressionLiteral(literal)
抽象操作IsValidRegularExpressionLiteral接受参数literal。明确其参数是否是一个有效
的正则表达式字面量。被调用时执行下列步骤：
1. Asset：literal是一个RegularExpressionLiteral
2. 如果literal的FlagText包含g,i,m,s,u,y以外的编码点，或者有重复的编码点，
   返回false
3. 让patternText是literal的BodyText
4. 让literal的FlagText包含u，让u是true，否则让u是false
5. 如果u是false，那么
    a. 让stringValue是CodePointsToString(patternText)
    b. 设置patternText是将stringValue每个元素的16位数字按照Unicode BMP翻译成
       编码点的序列。这里不使用UTF-16编码
6. 让parsedResult是ParsePattern(patternText, u)
7. 如果parseResult是ParseNode，返回true，否则返回false
**** Runtime Semantics: Evaluation
PrimaryExpression : RegularExpressionLiteral
1. 让pattern是!CodePointsToString(RegularExpressionLiteral的BodyText)
2. 让flags是!CodePointsToString(RegularExpressionLiteral的FlagText)
3. 返回RegExpCreate(pattern, flags)
*** Template Literals 模板字面量
**** Syntax
TempalteLiteral_[Yield, Await, Tagged] :
    NoSubstitutionTempalte
    SubstitutionTempalte_[?Yield, ?Await, ?Tagged]

SubstitutionTempalte_[Yield, Await, Tagged] :
    TempalteHead Expression_[+In, ?Yield, ?Await] TempateSpans_[?Yield, ?Await, ?Tagged]

TemplateSpans_[Yield, Await, Tagged] :
    TempalteTail
    TempalteMiddleList_[?Yield, ?Await, ?Tagged] TempalteTail

TemplateMiddleList_[Yield, Await, Tagged] :
    TemplateMiddle Expression_[+In, ?Yield, ?Await]
    TemplateMiddleList_[?Yield, ?Await, ?Tagged] TemplateMiddle Expression_[+In, ?Yield, ?Await]
**** Static Semantics: Early Errors
TempalteLiteral_[Yield, Await, Tagged] : NoSubstitutionTempalte
. 如果没有_[Tagged]参数，而且NoSubstitutionTemplate包含NotEscapeSequence，那么
  有语法错误

TempalteLiteral_[Yield, Await, Tagged] : SubstitutionTempalte_[?Yield, ?Await, ?Tagged]
. 如果TemplateLiteral上带false参数的TemplateStrings的结果里有超过2^32-1个
  元素，那么有语法错误

SubstitutionTempalte_[Yield, Await, Tagged] : TempalteHead Expression_[+In, ?Yield, ?Await]
TempateSpans_[?Yield, ?Await, ?Tagged]
. 如果没有_[Tagged]参数，而且TemplateHead包含NotEscapeSequence，那么有语法
  错误

TemplateSpans_[Yield, Await, Tagged] : TempalteTail
. 如果没有_[Tagged]参数，而且TemplateTail包含NotEscapeSequence，那么有语法
  错误

TemplateMiddleList_[Yield, Await, Tagged] :
    TemplateMiddle Expression_[+In, ?Yield, ?Await]
    TemplateMiddleList_[?Yield, ?Await, ?Tagged] TemplateMiddle Expression_[+In, ?Yield, ?Await]
. 如果没有_[Tagged]参数，而且TemplateMiddle包含NotEscapeSequence，那么有语法
  错误
**** Static Semantics: TemplateStrings
带raw参数

TemplateLiteral : NoSubstitutionTemplate
1. 如果raw是false，那么
    a. 让string是NoSubstitutionTemplate的TV
2. 否则
    a. 让string是NoSubstitutionTemplate的TRV
3. 返回只有string作为元素的List

SubstitutionTemplate : TemplateHead Expression TemplateSpans
1. 如果raw是false，那么
    a. 让head是TemplateHead的TV
2. 否则
    a. 让head是TemplateHead的TRV
3. 让tail是TemplateSpans上带raw参数的TemplateStrings
4. 返回head拼接tail的元素的List

TemplateSpans : TemplateTail
1. 如果raw是false，那么
    a. 让tail是TemplateTail的TV
2. 否则
    a. 让tail是TemplateTail的TRV
3. 返回元素是tail的List

TemplateSpans : TemplateMiddleList TemplateTail
1. 让middle是TemplateMiddleList上带raw参数的TemplateStrings
2. 如果raw是false，那么
    a. 让tail是TemplateTail的TV
3. 否则
    a. 让tail是TemplateTail的TRV
4. 返回middle的元素拼接tail后的List

TemplateMiddleList : TemplateMiddle Expression
1. 如果raw是false，那么
    a. 让string是TemplateMiddle的TV
2. 否则
    a. 让string是TemplateMiddle的TRV
3. 返回元素是string的List

TemplateMiddleList : TemplateMiddleList TemplateMiddle Expression
1. 让front是TemplateMiddleList上带raw参数的TemplateStrings
2. 如果raw是false，那么
    a. 让last是TemplateMiddle的TV
3. 否则
    a. 让last是TemplateMiddle的TRV
4. 在front上追加last
5. 返回front
**** GetTemplateObject(templateLiteral)
抽象操作GetTemplateObject接受参数templateLiteral（ParseNode）。被调用时执行下列
步骤：
1. 让realm是当前的RealmRecord
2. 让templateRegistry是realm.\[\[TemplateMap]]
3. 遍历templateRegistry的元素，记作e，做
    a. 如果e.\[\[Site]]与templateLiteral是相同的ParseNode，那么
        i. 返回e.\[\[Array]]
4. 让rawStrings是templateLiteral带true参数的TemplateStrings
5. 让cookedStrings是templateLiteral带false参数的TemplateStrings
6. 让count是cookedStrings这个List的元素数量
7. Assert：count <= 2^32 - 1
8. 让template是!ArrayCreate(count)
9. 让rawObj是!ArrayCreate(count)
10. 让index是0
11. 当index < count时，重复
    a. 让prop是!ToString(F(index))
    b. 让cookedValue是cookedStrings[index]
    c. 执行!DefinePropertyOrThrow( template, prop, PropertyDescriptor {
       \[\[Value]]:cookedValue, \[\[Writable]]:false, \[\[Enumerable]]:true,
       \[\[Configurable]]:false,
       })
    d. 让rawValue是rawStrings[index]的字符串值
    e. 执行!DefinePropertyOrThrow( rawObj, prop, PropertyDescriptor {
       \[\[Value]]:rawValue, \[\[Writable]]:false, \[\[Enumerable]]:true,
       \[\[Configurable]]:false,
       })
    f. 设置index为index+1
12. 执行!SetIntegrityLevel(rawObj, frozen)
13. 执行!DefinePropertyOrThrow( tempalte, "raw", PropertyDescriptor {
    \[\[Value]]:rawObj, \[\[Writable]]:false, \[\[Enumerable]]:false,
    \[\[Configurable]]:false,
    })
14. 执行!SetIntegrityLevel(template, frozen)
15. 将记录{ \[\[Site]]:templateLiteral, \[\[Array]]:template }到templateRegistry
16. 返回template
***** 注意1 创建模板对象的过程不会导致意外完结
***** 注意2 每个领的代码里的TemplateLiteral联结一个唯一的模板对象，其被用
             于评估标记的模板（tagged Templates 13.2.9.5)。模板对象被冻结，
             而且特定的标记模板每次评估时使用相同的模板对象。无论这个
             模板对象是在第一次评估时被懒加载创建的，还是先与第一评估
             创建的，都是实现的选择，并不会被ECMAScript代码感知到。
***** 注意3 未来版本的规范可能在模板对象上定义额外非枚举性质。
**** Runtime Semantics: SubstitutionEvaluation
TemplateSpans : TemplateTail
1. 返回新的空List

TemplateSpans : TemplateMiddleList TemplateTail
1. 返回TempalteMiddleList的SubstitutionEvaluation结果

TemplateMiddleList : TemplateMdille Expression
1. 让subRef是评估Expression的结果
2. 让sub是?GetValue(subRef)
3. 返回只有sub的List

TemplateMiddleList : TemplateMiddleList TemplateMiddle Expression
1. 让preceding是TemplateMdidleList的?SubstitutionEvaluation
2. 让nextRef是评估Expression的结果
3. 让next是?GetValue(nextRef)
4. 将next追加为preceding List最后一个元素
5. 返回preceding
**** Runtime Semantics: Evaluation
TemplateLiteral : NoSubstitutionTemplate
1. 返回按12.8.6中定义的NoSubstitutionTemplate的TV

SubstitutionTemplate : TemplateHead Expression TemplateSpans
1. 让head是按12.8.6中定义的TemplateHead的TV
2. 让subRef是评估Expression的结果
3. 让sub是?GetValue(subRef)
4. 让middle是?ToString(sub)
5. 让tail是评估TempalteSpans的结果
6. ReturnIfAbrupt(tail)
7. 返回head,middle和tail拼接成字符串
***** 注意1 提供给Expression值的字符串转换语义更像String.prototype.concat，
             而不是+操作
TempalteSpans : TemplateTail
1. 返回按12.8.6中定义的TemplateTail的TV

TemplateSpans : TempalteMiddleList TemplateTail
1. 让head是评估TempalteMiddleList的结果
2. ReturnIfAbrupt(head)
3. 让tail是按12.8.6中定义的TemplateTail的TV
4. 返回head和tail拼接成字符串

TempalteMiddelList : TempalteMiddle Expression
1. 让head是是按12.8.6中定义的TempalteMiddle的TV
2. 让subRef是评估Expression的结果
3. 让sub是?GetValue(subRef)
4. 让middle是?ToString(sub)
5. 返回head和middletail拼接成字符串
***** 注意2 提供给Expression值的字符串转换语义更像String.prototype.concat，
             而不是+操作
TemplateMiddleList : TempalteMiddleList TemplateMiddle Expression
1. 让rest是评估TempalteMiddleList的结果
2. ReturnIfAbrupt(head)
3. 让middle是按12.8.6中定义的TemplateMiddle的TV
4. 让subRef是评估Expression的结果
5. 让sub是?GetValue(subRef)
6. 让last是?ToString(sub)
7. 返回rest,middle和last拼接成字符串
***** 注意3 提供给Expression值的字符串转换语义更像String.prototype.concat，
             而不是+操作

*** The Grouping Operator
**** Static Semantics : Early Errors
PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList
. 如果CoverParenthesizedExpressionAndArrowParameterList没有覆盖一个
  ParenthesizedExpression，那么有语法错误。
. ParenthesizeExpression或其派生码型适用早期错误规则，也提供给
  CoverParenthesizedExpressionAndArrowParameterList的
  CoveredParenthesizedExpression
**** Runtime Semantics : Evaluation
PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList
1. 让expr是CoverParenthesizedExpressionAndArrowParameterList的
   CoveredParenthesizedExpression
2. 返回评估expr的结果

ParenthesizedExpression : ( Expression )
1. 返回评估Expression的结果。可能是个引用
***** 注意 本算法不对评估Expression的结果应用GetValue。这个做法的主要目的
            是类似delete或typeof的操作也会应用到括号表达式里。
** Left-Hand-Side Expressions
*** Syntax
MemberExpression_[Yield, Await] :
    PrimaryExpression_[?Yield, ?Await]
    MemberExpression_[?Yield, ?Await] [ Expression_[+In, ?Yield, ?Await] ]
    MemberExpression_[?Yield, ?Await] . IdentifierName
    MemberExpression_[?Yield, ?Await] TemplateLiteral_[?Yield, ?Await, +Tagged]
    SuperProperty_[?Yield, ?Await]
    MetaProperty
    new MemberExpression_[?Yield, ?Await] Arguments_[?Yield, ?Await]

SuperProptery_[Yield, Await] :
    super [ Expression_[+In, ?Yield, ?Await] ]
    super . IdentifierName

MetaProperty : 
    NewTarget
    ImportMeta

NewTarget :
    new . target

ImportMeta :
    import . meta

NewExpression_[Yield, Await] :
    MemberExpression_[?Yield, ?Await]
    new NewExpression_[?Yield, ?Await]

CallExpression_[Yield, Await] :
    CoverCallExpressionAndAsyncArrowHead_[?Yield, ?Await]
    SuperCall_[?Yield, ?Await]
    ImportCall_[?Yield, ?Await]
    CallExpression_[?Yield, ?Await] Arguments_[?Yield, ?Await]
    CallExpression_[?Yield, ?Await] [ Expression_[+In, ?Yield, ?Await] ]
    CallExpression_[?Yield, ?Await] . IdentifierName
    CallExpression_[?Yield, ?Await] TemplateLiteral_[?Yield, ?Await, +Tagged]
    
SuperCall_[Yield, Await] :
    super Arguments_[?Yield, ?Await]

ImportCall_[Yield, Await] : 
    import ( AssignmentExpression_[+In, ?Yield, ?Await] )

Arguments_[Yield, Await] :
    ( )
    ( ArgumentList_[?Yield, ?Await] )
    ( ArgumentList_[?Yield, ?Await] , )

ArgumentList_[Yield, Await] :
    AssignmentExpression_[+In, ?Yield, ?Await]
    ... AssignmentExpression_[+In, ?Yield, ?Await]
    ArgumentList_[?Yield, ?Await] , AssignmentExpression_[+In, ?Yield, ?Await]
    ArgumentList_[?Yield, ?Await] , ... AssignmentExpression_[+In, ?Yield, ?Await]
    
OptionalExpression_[Yield, Await] :
    MemberExpression_[?Yield, ?Await] OptionalChain_[?Yield, ?Await]
    CallExpression_[?Yield, ?Await] OptionalChain_[?Yield, ?Await]
    OptionalExpression_[?Yield, ?Await] OptionalChain_[?Yield, ?Await]

OptionalChain_[Yield, Await] :
    ?. Arguments_[?Yield, ?Await]
    ?. [ Expression_[+In, ?Yield, ?Await] ]
    ?. IdentifierName
    ?. TempalteLiteral_[?Yield, ?Await, +Tagged]
    OptionalChain_[?Yield, ?Await] Arguments_[?Yield, ?Await]
    OptionalChain_[?Yield, ?Await] [ Expression_[+In, ?Yield, ?Await] ]
    OptionalChain_[?Yield, ?Await] IdentifierName
    OptionalChain_[?Yield, ?Await] TempalteLiteral_[?Yield, ?Await, +Tagged]

LeftHandSideExpression_[Yield, Await] :
    NewExpression_[?Yield, ?Await]
    CallExpression_[?Yield, ?Await]
    OptionalExpression_[?Yield, ?Await]
*** Supplemental Syntax
当处理CallExpression : CoverCallExpressionAndAsyncArrowHead码型的实例时，
CoverCallExpressionAndAsyncArrowHead的翻译被精炼为下列语法：
CallMemberExpression_[Yield, Await] :
    MemberExpression_[?Yield, ?Await] Arguments_[?Yield, ?Await]
*** Static Semantics
**** Static Semantics : Early Errors
OptionalChain :
    ?. TempalteLiteral
    OptionalChain TemplateLiteral
. 任何代码匹配这个码型，那么有语法错误
***** 注意 这个码型用于阻止自动分号插入规则（12.9）应用到下列代码：
            a?.b
            `c`
            防止被翻译成两个有效的语句。目的是与没有可选链的代码：
            a.b
            `c`
            保持一致，这里代码是有效语句，而且不会被应用自动分号
            插入规则。
ImportMeta :
    import . meta
. 如果目标符不是Module，那么有语法错误
**** Static Semantics: CoveredCallExpression
CoverCallExpressionAndAsyncArrowHead : MemberExpression Arguments
1. 返回被CoverCallExpressionAndAsyncArrowHead覆盖的CallMemberExpression
*** Property Accessors
**** 注意 性质用名称访问，使用后点记法:
           MemberExpression . IdentifierName
           CallExpression . IdentifierName

           或者方括号记法:
           MemberExpression [ Expression ]
           CallExpression [ Expression ]

           使用如下句法转换：MemberExpression . IdentifierName 的后点记
           法与 MemberExpression [ <identifier-name-string> ] 相同，类似
           的CallExpression . IdentifierName 与
           CallExpression [ <identifier-name-string> ]相同，其中
           <identifier-name-string>是IdentifierName的StringValue的评估结果
**** Runtime Semantics: Evaluation
MemberExpression : MemberExpression [ Expression ]
1. 让baseReference是评估MemberExpression的结果
2. 让baseValue是?GetValue(baseReference)
3. 如果严格模式代码匹配MemberExpression，让strict是true，否则strict是false
4. 返回?EvaluatePropertyAccessWithExpressionKey(baseValue, expression, strict)

MemberExpression : MemberExpression . IdentifierName
1. 让baseReference是评估MemberExpression的结果
2. 让baseValue是?GetValue(baseReference)
3. 如果严格模式代码匹配MemberExpression，让strict是true，否则strict是false
4. 返回?EvaluatePropertyAccessWithIdentifierKey(baseValue, IdentifierName, strict)

CallExpression : CallExpression [ Expression ]
1. 让baseReference是评估CallExpression的结果
2. 让baseValue是?GetValue(baseReference)
3. 如果严格模式代码匹配MemberExpression，让strict是true，否则strict是false
4. 返回?EvaluatePropertyAccessWithExpressionKey(baseValue, Expression, strict)

CallExpression : CallExpression . IdentifierName
1. 让baseReference是评估CallExpression的结果
2. 让baseValue是?GetValue(baseReference)
3. 如果严格模式代码匹配MemberExpression，让strict是true，否则strict是false
4. 返回?EvaluatePropertyAccessWithIdentifierKey(baseValue, IdentifierName, strict)
*** EvaluatePropertyAccessWithExpressionKey(baseValue, expression, strict)
抽象操作EvaluatePropertyAccesWithExpressionKey接受参数baseValue（ECMAScript值），
expression（ParseNode）和strict（Boolean）。被调用时执行下列步骤：
1. 让propertyNameReference是评估expression的结果
2. 让propertyNameValue是?GetValue(propertyNameReference)
3. 让bv是?RequireObjectCoercible(baseValue)
4. 让propertyKey是?ToPropertyKey(propertyNameValue)
5. 返回ReferenceRecord { \[\[Base]]:bv, \[\[ReferencedName]]:propertyKey, 
   \[\[Strict]]:strict, \[\[ThisValue]]:empty, }
*** EvaluatePropertyAccessWithIdentifierKey(baseVAlue, identifierName, strict)
抽象操作EvaluatePropertyAccessWithIdentifierKey接受参数baseValue（ECMAScript值），
identifierName（ParseNode）和strict（Boolean）。被调用时执行下列步骤：
1. Assert：identifierName是一个IdenfiIdentifierName
2. 让bv是?RequireObjectCoercible(baseValue)
3. 让propertyNameString是identifierName的StringValue
4. 返回ReferenceRecord { \[\[Base]]:bv, \[\[ReferencedName]]:propertyNameString, 
   \[\[Strict]]:strict, \[\[ThisValue]]:empty, }
*** The new Operator new操作符
**** 13.3.5.1
NewExpression : new NewExpression
1. 返回?EvaluateNew(NewExpression, empty)

MemberExpression : new MemberExpression Arguments
1. 返回?EvaluateNew(MemberExpression, Argument)
***** EvaluateNew(constructExpr, arguments)
抽象操作EvaluateNew接受参数constructExpr和arguments。被调用时执行下列步骤：
1. Assert：constructExpr是NewExpression或者MemberExpression
2. Assert：argumetns是empty或者Arguments
3. 让ref是评估constructExpr的结果
4. 让constructor是?GetValue(ref)
5. 如果arguments是空，让argList是新的空List
6. 否则，让argList是在arguments上的?ArgumentListEvaluation
7. 如果 IsConstructor(constructor)是false，投掷TypeError异常
8. 返回?Construct(constructor, argList)
*** Function Calls
**** Runtime Semantics: Evaluation
CallExpression : CoverCallExpressionAndAsyncArrowHead
1. 让expr是在CoverCallExressionAndAsyncArrowHead上的CoveredCallExpression
2. 让memberExpr是在expr上的MemberExpression
3. 让arguments是在expr上的Arguments
4. 让ref是memberExpr的评估结果
5. 让func是?GetValue(ref)
6. 如果ref是ReferenceRecord，且IsPropertyReference(ref)是false，而且
   ref.\[\[ReferencedName]]是"eval"，那么
    a. 如果SameValue(func, %eval%)是true，那么
        i. 让argList是在arguments上的?ArgumentListEvaluation
       ii. 如果argList没有元素，返回undefined
      iii. 让evalArg是argList的第一个元素
       iv. 如果这个CallExpression在严格模式代码里，让strictCaller是true，
           否则让strictCaller是false
        v. 让evalRealm是当前的RealmRecord
       vi. 返回?PerformEval(evalArg, evalRealm, strictCaller, true)
7. 让thisCall是这个CallExpression
8. 让tailCall是IsInTailPosition(thisCall)
9. 返回?EvaluateCall(func, ref, arguments, tailCall)

在6.a.vi执行的CallExpression评估是eval的直接调用。

CallExpression : CallExpression Arguments
1. 让ref是CallExpression的评估结果
2. 让func是?GetValue(ref)
3. 让thisCall是这个CallExpression
4. 让tailCall是IsInTailPosition(thisCall)
5. 返回?EvaluateCall(func, ref, Arguments, tailCall)
**** EvaluateCall(func, ref, arguments, tailPosition)
抽象操作EvaluateCall接受参数接受参数func（ECMAScript语言值）、ref（ECMAScript
语言值或者ReferenceRecord）、arguments（ParseNode）和tailPosition（Boolean值）。
被调用时执行下列步骤：
1. 如果ref是ReferenceRecord那么
    a. 如果IsPropertyReference(ref)是true，那么
        i. 让thisValue是GetThisValue(ref)
    b. 否则
        i. 让refEnv是ref.\[\[Base]]
       ii. Assert：refEnv是一个EnvironmentRecord
      iii. 让thisValue是refEnv.WithBaseObject()
2. 让thisValue是undefined
3. 让argList是在arguments上的?ArgumentListEvaluation
4. 如果Type(func)不是Object，投掷TypeError异常
5. 如果IsCallable(func)是false，投掷TypeError异常
6. 如果tailPosition是true，执行PrepareForTailCall()
7. 让resutl是Call(func, thisValue, argList)
8. Assert：如果tailPosition是true，那么上面的调用不在这里返回，但是评估会
   继续，就像随后的return在这里已经发生了一样。
9. Assert：如果result不是意外完结，那么Type(result)必然是一个ECMAScript语言类型
10. 返回result
*** The super Keyword
**** Runtime Semantics：Evaluation
SuperProperty : super [ Expression ]
1. 让env是GetThisEnvironment()
2. 让actualThis是?env.GetThisBinding()
3. 让propertyNameReference是评估Expression的结果
4. 让propertyNameValue是?GetValue(propertyNameReference)
5. 让propertyKey是?ToPropertyKey(PropertyNameValue)
6. 如果本SuperProperty对应的code是严格模式代码，让strict是true，
   否则让strict是false
7. 返回?MakeSuperPropertyReference(actualThis, propertyKey, strict)

SuperProperty : super . IdentifierName
1. 让env是GetThisEnvironment()
2. 让actualThis是?env.GetThisBinding()
3. 让propertyKey是IdentiferName的StringValue
4. 如果本SuperProperty对应的code是严格模式代码，让strict是true，
   否则让strict是false
5. 返回?MakeSuperPropertyReference(actualThis, propertyKey, strict)

SuperCall : super Arguments
1. 让newTarget是GetNewTarget()
2. Assert：Type(newTarget)是Object
3. 让func是!GetSuperConstructor()
4. 让argList是在Arguments上的?ArgumentListEvaluation
5. 如果IsConstructor(func)是false，投掷TypeError异常
6. 让result是?Construct(func, argList, newTarget)
7. 让thisER是GetThisEnvironment()
8. 返回?thisER.BindThisValue(result)
**** GetSuperConstructor()
抽象操作GetSuperConstructor不接受参数。被调用时执行下列步骤：
1. 让evnRec是GetThisEnvironment()
2. Assert：evnRec是FunctionEnvironmentRecord
3. 让activeFunction是envRec.\[\[FunctionObject]]
4. Assert：activeFunction是ECMAScript函数对象
5. 让superConstructor是!activeFunction.\[\[GetPrototypeOf]]()
6. 返回superConstructor
**** MakeSuperPropertyReference( actualThis, propertyKey, strict )
抽象操作MakeSuperPropertyReference接受参数actualThis、propertyKey和strict。被调用
时执行下列步骤：
1. 让env是GetThisEnvironment()
2. Assert：env.HasSuperBinding()是true
3. 让baseValue是?env.GetSuperBase()
4. 让bv是?RequireObjectCoercible(baseValue)
5. 返回ReferenceRecord { \[\[Base]]:bv, \[\[ReferencedName]]:propertyKey, 
   \[\[Strict]]:strict, \[\[ThisValue]]:actualThis, }
6. 注意：返回了SuperReferenceRecord
*** Argument List
**** 注意 评估参数列表产生一个值的List
**** Runtime Semantics: ArgumentListEvaluation
Arguments : ()
1. 返回新的空List

ArgumentList : AssignmentExpression
1. 让ref是评估AssignmentExpression的结果
2. 让arg是?GetValue(ref)
3. 返回只有arg的List

ArgumentList : ... AssignmentExpression
1. 让list是新的空List
2. 让spreadRef是评估AssignmentExpression的结果
3. 让spreadObj是?GetValue(spreadRef)
4. 让iteratorRecord是?GetIterator(spreadObj)
5. 重复
    a. 让next是?IteratorStep(iteratorRecord)
    b. 如果next是false，返回list
    c. 让nextArg是?IteratorValue(next)
    d. 追加nextArg到list的末端

ArgumentList : ArgumentList , AssignmentExpression
1. 让precedingArgs是在ArgumentList上的?ArgumentListEvaluation
2. 让ref是评估AssignmentExpression的结果
3. 让arg是?GetValue(ref)
4. 追加arg到precedingArgs的末端
5. 返回precedingArgs

ArgumentList : ArgumentList , ... AssignmentExpression
1. 让precedingArgs是在ArgumentList上的?ArgumentListEvaluation
2. 让spreadRef是评估AssignmentExpression的结果
3. 让iteratorRecord是?GetIterator(?GetValue(spreadRef))
4. 重复
    a. 让next是?IteratorStep(iteratorRecord)
    b. 如果next是false，返回precedingArgs
    c. 让nextArg是?IteratorValue(next)
    d. 追加nextArg到precedingArgs的末端

TemplateLiteral : NoSubstitutionTemplate
1. 让templateLiteral是本TemplateLiteral
2. 让siteObj是GetTemplateObject(tempalteLiteral)
3. 返回只有siteObj的List

TempalteLiteral : SubstitutionTemplate
1. 让templateLiteral是本TemplateLiteral
2. 让siteObj是GetTemplateObject(tempalteLiteral)
3. 让remaining是在SubstitutionTemplate上的?ArgumentListEvaluation
4. 返回第一个元素siteObj，随后是remaining的元素的List

SubstitutionTemplate : TempalteHead Expression TempalteSpans
1. 让firstRef是评估Expression的结果
2. 让firstSub是?GetValue(firstSubRef)
3. 让restSub是在TemplateSpans上的?SubstitutionEvaluation
4. Assert：restSub是一个List
9. 返回第一个元素firstSub，随后是restSub的元素的List。restSub可能是空List
*** Optional Chains
**** 注意 一个可选链是由一个或多个的性质访问或者函数调用组成的链，第一个
           项以记号?.开始
**** Runtime Semantics : Evaluation
OptionalExpression : MemberExpression OptionalChain
1. 让baseReference是评估MemberExpression的结果
2. 让baseValue是?GetValue(baseReference)
3. 如果baseValue是undefined或者null, 那么
    a. 返回undefined
4. 返回在OptionalChain上执行带baseValue和baseReference参数的ChainEvaluation的结果

OptionalExpression : CallExpression OptionalChain
1. 让baseReference是评估CallExpression的结果
2. 让baseValue是?GetValue(baseReference)
3. 如果baseValue是undefined或者null, 那么
    a. 返回undefined
4. 返回在OptionalChain上执行带baseValue和baseReference参数的ChainEvaluation的结果

OptionalExpression : OptionalExpression OptionalChain
1. 让baseReference是评估OptionaExpression的结果
2. 让baseValue是?GetValue(baseReference)
3. 如果baseValue是undefined或者null, 那么
    a. 返回undefined
4. 返回在OptionalChain上执行带baseValue和baseReference参数的ChainEvaluation的结果
**** Runtime Semantics: ChainEvaluation
带参数baseValue和baseReference

OptionalChain : ?. Arguments
1. 让thisChain是本OptionalChain
2. 让tailCall是IsIntailPosition(thisChain)
3. 返回?EvaluateCall(baseValue, baseReference, Arguments, tailCall)

OptionalChain : ?. [ Expression ]
1. 如果本OptionalChain对应的code是严格模式代码，让strict是true，
   否则让strict是false
2. 返回?EvaluatePropertyAccessWithExpressionKey(baseValue, Expression, strict)

OptionalChain : ?. IdentifierName
1. 如果本OptionalChain对应的code是严格模式代码，让strict是true，
   否则让strict是false
2. 返回?EvaluatePropertyAccessWithIdentiferKey(baseValue, IdentifierName, strict)

OptionalChain : OptionalChain Arguments
1. 让optionalChain是OptionalChain
2. 让newReference是在optionalChain上执行带baseValue和baseReference参数的
   ?ChainEvaluation
3. 让newValue是?GetValue(newReference)
4. 让thisChain是本OptionalChain
5. 让tailCall是IsInTailPosition(thisChain)
6. 返回?EvaluateCall(newValue, newReference, Arguments, tailCall)

OptionalChain : OptionalChain [ Expression ]
1. 让optionalChain是OptionalChain
2. 让newReference是在optionalChain上执行带baseValue和baseReference参数的
   ?ChainEvaluation
3. 让newValue是?GetValue(newReference)
4. 如果本OptionalChain对应的code是严格模式代码，让strict是true，
   否则让strict是false
5. 返回?EvaluatePropertyAccessWithExpressionKey(baseValue, Expression, strict)

OptionalChain : OptionalChain . IdentifierName
1. 让optionalChain是OptionalChain
2. 让newReference是在optionalChain上执行带baseValue和baseReference参数的
   ?ChainEvaluation
3. 让newValue是?GetValue(newReference)
4. 如果本OptionalChain对应的code是严格模式代码，让strict是true，
   否则让strict是false
5. 返回?EvaluatePropertyAccessWithIdentifierKey(baseValue, Expression, strict)
*** Import Calls
**** Runtime Semantics : Evaluation
ImportCall : import ( AssignmentExpression )
1. 让referencingScriptOrModule是!GetActiveScriptOrModule()
2. 让argRef是评估AssignmentExpression的结果
3. 让specifier是?GetValue(argRef)
4. 让promiseCapability是!NewPromiseCapability(%Promise%)
5. 让让specifierString是ToString(specifier)
6. IfAbruptRejectPromise(specifierString, promiseCapability)
7. 执行!HostImportModuleDynamically(referencingScriptOrModule,
   specifierString, promiseCapablity)
8. 返回 promiseCapability.\[\[Promsie]]
*** Tagged Tempaltes
**** 注意 代标签的模板是一个函数调用，这个调用的参数从TemplateLiteral(13.2.9)
           中派生出来。实际参数包含一个模板对象(13.2.9.3)和评估嵌入在
           TemplateLiteral中的表达式产生的各种值。
**** Runtime Semantics : Evaluation
MemberExpression : MemberExpression TemplateLiteral
1. 让tagRef是评估MemberExpression的结果
2. 让tagFunc是?GetValue(tagRef)
3. 让thisCall是本MemberExpression
4. 让tailCall是IsInTailPosition(thisCall)
5. 返回?EvaluateCall(tagFunc, tagRef, TemplateLiteral, tailCall)

CallExpression : CallExpression TemplateLiteral
1. 让tagRef是评估CallExpression的结果
2. 让tagFunc是?GetValue(tagRef)
3. 让thisCall是本CallExpression
4. 让tailCall是IsInTailPosition(thisCall)
5. 返回?EvaluateCall(tagFunc, tagRef, TemplateLiteral, tailCall)
*** Meta Properties
**** Runtime Semantics : Evaluation
NewTarget : new . target
1. 返回GetNewTarget()

ImportMeta : import . meta
1. 让module是!GetActiveScriptOrModule()
2. Assert：module是ModuleRecorde的源文本
3. 让importMeta是module.\[\[ImportMeta]]
4. 如果importMeta是空的，那么
    a. 设置importMeta是!OrdinaryObjectCreate(null)
    b. 让importMetaValues是!HostGetImportMetaProperties
    c. 遍历importMetaValues的Record { \[\[Key]], \[\[Value]] }记作p，
        i. 执行!CreateDataPropertyOrThrow(importMeta, p.\[\[Key]], p.\[\[Value]])
    d. 执行!HostFinalizeImportMeta(importMeta, module)
    e. 设置module.\[\[ImportMeta]]为importMeta
    f. 返回importMeta
5. 否则
    a. Assert：Type(importMeta)是对象
    b. 返回importMeta
***** HostGetImportMetaProperties(moduleRecord)
这是主机定义的抽象操作HostGetImportMetaProperties接受参数moduleRecord
（ModuleRecord）。允许主机向从import.meta返回的对象提供性质键和值。

HostGetImportMetaProperties实现必须遵循下列要求
. 必须返回List，元素都是只有\[\[Key]]和\[\[Value]]的记录
. 每个记录的\[\[Key]]必须是性质键，也就是说对其应用IsPropertyKey必然得到true
. 每个记录的\[\[Value]]必须是一个ECMAScript值
. 必须总是正常完结（也就是说不能返回意外完结）

HostGetImportMetaProperties的默认实现返回新的空List。
***** HostFinalizeImportMeta(importMeta, moduleRecord)
主机定义的抽象操作HostFinalizeImportMeta接受参数importMeta（对象）和
moduleRecored（ModuleRecord）。允许主机执行任何附加操作来准备从import.meta
返回的对象。

大部分主机允许简单定义HostGetImportMetaProperties，但是让HostFinalizeImportMeta
保持默认行为。然而HostFinalizeImportMeta给需要在暴露meta对象给ECMAScript代码前
需要直接调整的主机提供了一个“转义孵化”方式。

HostFinalizeImportMeta实现必须遵循下列要求
. 必须总是正常完结（也就是说不能返回意外完结）

HostFinalizeImportMeta的默认实现返回空的正常完结
** Update Expressions
*** Syntax
UpdateExpression_[Yield, Await] :
    LeftHandSideExpression_[?Yield, ?Await]
    LeftHandSideExpression_[?Yield, ?Await] [no LineTerminator here] ++
    LeftHandSideExpression_[?Yield, ?Await] [no LineTerminator here] --
    ++ UnaryExpression_[?Yield, ?Await]
    -- UnaryExpression_[?Yield, ?Await]
*** Static Semantics : Early Errors
UpdateExpression :
    LeftHandSideExpression ++
    LeftHandSideExpression --
. 如果LeftHandSideExpression的AssignmentTargetType不是simple的，
  那么有语法错误

UpdateExpression :
    ++ UnaryExpression
    -- UnaryExpression
. 如果UnaryExpression的AssignmentTargetType不是simple的，那么有语法错误
*** Postfix Increment Operator
**** Runtime Semantics : Evaluation
UpdateExpression : LeftHandSideExpression ++
1. 让lhs是评估LeftHandSideExpression的评估结果
2. 让oldValue是?ToNumeric(?GetValue(lhs))
3. 让newValue是!Type(oldValue)::add(oldValue, Type(oldVAlue)::unit)
4. 执行?PutValue(lhs, newValue)
5. 返回oldValue
*** Postfix Decrement Operator
**** Runtime Semantic : Evaluation
UpdateExpression : LeftHandSideExpression --
1. 让lhs是评估LeftHandSideExpression的评估结果
2. 让oldValue是?ToNumeric(?GetValue(lhs))
3. 让newValue是!Type(oldValue)::subtract(oldValue, Type(oldVAlue)::unit)
4. 执行?PutValue(lhs, newValue)
5. 返回oldValue
*** Prefix Increment Operator
**** Runtime Semantics : Evaluation
UpdateExpression : ++ UnaryExpression
1. 让expr是评估UnaryExpression的评估结果
2. 让oldValue是?ToNumeric(?GetValue(expr))
3. 让newValue是!Type(oldValue)::add(oldValue, Type(oldVAlue)::unit)
4. 执行?PutValue(expr, newValue)
5. 返回newValue
*** Prefix Decrement
**** Rntime Semantics : Evaluation
UpdateExpression : -- UnaryExpression
1. 让expr是评估UnaryExpression的评估结果
2. 让oldValue是?ToNumeric(?GetValue(expr))
3. 让newValue是!Type(oldValue)::subtract(oldValue, Type(oldVAlue)::unit)
4. 执行?PutValue(lhs, newValue)
5. 返回newValue
** Unary Operators
*** Syntax
UnaryExpression_[Yield, Await] :
    UpdateExpression_[?Yield, ?Await]
    delete UnaryExpression_[?Yield, ?Await]
    void UnaryExpression_[?Yield, ?Await]
    + UnaryExpression_[?Yield, ?Await]
    - UnaryExpression_[?Yield, ?Await]
    ~ UnaryExpression_[?Yield, ?Await]
    ! UnaryExpression_[?Yield, ?Await]
    [+Await]AwaitExpression_[?Yield]
*** The delete Operator
**** Static Semantics : Early Errors
UnaryExpression : delete UnaryExpression
. 如果UnaryExpression在严格代码中，而且是PrimaryExpression : IdentifierReference
  形式，那么有语法错误。
. 如果UnaryExpresion是派生自
  PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList，
  且CoverParenthesizedExpressionAndArrowParameterList最终派生了一个用在
  UniaryExpression的短语，根据这些规则会产生语法错误。本规应则递归使用。
***** 注意 后一条规则意味着例如delete (((foo)))的表达式会产生早期错误，
            因为符合递归应用第一条规则
**** Runtime Semantics : Evaluation
UnaryExpression : delete UnaryExpression
1. 让ref是UnaryExpression的评估结果
2. ReturnIfAbrupt(ref)
3. 如果ref不是ReferenceRecord返回true
4. 如果IsUnresolvableReference(ref)是true，那么
    a. Assert：ref.\[\[Strinct]]是false
    b. 返回true
5. 如果IsPropertyReference(ref)是true，那么
    a. 如果IsSuperReference(ref)是true，投掷ReferenceError异常
    b. 让baseObj是!ToObject(ref.\[\[Base]])
    c. 让deleteStatus是?baseObj.\[\[Delete]](ref.\[\[ReferencedName]])
    d. 如果deleteStatus是false而且ref.\[\[Strict]]是true，投掷TypeError异常
    e. 返回deleteStatus
6. 否则
    a. 让base是ref.\[\[Base]]
    b. Assert：base是EnvironmentRecord
    c. 返回?base.DeleteBinding(ref.\[\[ReferenceName]])
***** 注意1 当delete操作发生在严格模式代码里，如果UnaryExpression直接引用到一个
             变量、函数参数或者函数名，会投掷语法错误。另外，在严格模式代码
             里delete操作在其属性{\[\[Configurable]]:false}的性质上（换言之不能
             被删除），会投掷TypeError异常。
***** 注意2 可能在步骤5.b创建的新对象不能在本抽象操作和基础对象\[\[Delete]]内
             置方法之外访问到。实现可以选择规避实际创建对象。
*** The void Operator
**** Runtime Semantics : Evaluation
UnaryExpression : void UnaryExpression
1. 让expr是评估UnaryExpression的结果
2. 执行?GetValue(expr)
3. 返回undefined
***** 注意 GetValue必须被调用，即使这个值不会被用到，因为它会有可见的
            意外作用。
*** The typeof Operator
**** Runtime Semantics : Evaluation
UnaryExpression : typeof UnaryExpression
1. 让val是评估UnaryExpression的结果
2. 如果val是Reference Record，那么
    a. 如果IsUnresolvableReference(val)是true，返回"undefined"
3. 设置val是?GetValue(al)
4. 根据表37返回String
| Type of val                  | 结果        |
| Undefined                    | "undefined" |
| Null                         | "object"    |
| Boolean                      | "boolean"   |
| Number                       | "number"    |
| String                       | "string"    |
| Symbol                       | "symbol"    |
| BigInt                       | "bigint"    |
| Object（没有实现\[\[Call]]） | "object"    |
| Object（实现\[\[Call]]）     | "function"  |
***** 注意 另外联结了\[\[IsHTMLDDA]]内部占位的实体按B.3.7.3中处理
| Object（有\[\[IsHTMLDDA]]内部占位） | "undefined"|
*** Unary + Operator
**** 注意 一元操作符 + 会将其操作项转换为数值类型
**** Runtime Semantics : Evaluation
UnaryExpression : + UnaryExpression
1. 让expr是评估UnaryExpression的结果
2. 返回?ToNumber(?GetValue(expr))
*** Unary - Operator
**** 注意 一元操作符 - 会将其操作项转换为数值类型，再取负数。+0_F产生-0_F，
           而-0_F产生+0_F
**** Runtime Semantics : Evaluation
UnaryExpression : - UnaryExpression
1. 让expr是评估UnaryExpression的结果
2. 让oldValue是?ToNumber(?GetValue(expr))
3. 让T是Type(oldValue)
4. 返回!T::unaryMinus(oldValue)
*** Bitwise NOT Operate ( ~ )
**** Runtime Semantics : Evaluation
UnaryExpression : ~ UnaryExpression
1. 让expr是评估UnaryExpression的结果
2. 让oldValue是?ToNumeric(?GetValue(expr))
3. 让T是Type(oldValue)
4. 返回!T::bitwiseNOT(oldValue)
*** Logical NOT Operator ( ! )
**** Runtime Semantics : Evaluation
UnaryExpression : ! UnaryExpression
1. 让expr是评估UnaryExpression的结果
2. 让oldValue是?ToBoolean(?GetValue(expr))
3. 如果oldValue是true，返回false
4. 返回true
** Exponentiation Operator
*** Syntax
ExponentiationExpression_[Yield, Await] :
    UnaryExpression_[?Yield, ?Await]
    UpdateExpression_[?Yield, ?Await] ** ExponentiationExpression_[?Yield, ?Await]
*** Runtime Semantics : Evaluation
ExponentiationExpression : UpdateExpression ** ExponentiationExpression
1. 返回?EvaluateStrngOrNumberBinaryExpression(
   UpdateExpression, **, ExponentiationExpression)
** Multiplicative Operators
*** Syntax
MultiplicativeExpression_[Yield, Await] :
    ExponentiationExpression_[?Yield, ?Await]
    MultiplicativeExpression_[?Yield, ?Await] MultiplicativeOperator \
        ExponentiationExpression_[?Yield, ?Await]
MultiplicativeOperator : one of
    * / %
*** 注意 . *操作符执行乘法，产生操作项的积
          . /操作符执行除法，产生操作项的商
          . %操作符从一个隐式的除法返回操作项的余数
*** Runtime Semantics : Evaluation
MultiplicativeExpression : MultiplicativeExpression MultiplicativeOperator \
    ExponentiationExpression
1. 让opText是匹配到MultiplicativeOperator的源文本
2. 返回?EaluateStringOrNumericBinaryExpression(MultiplicativeExpression,
   opText, ExponentiationExpression)
** Additive Operators
*** Syntax
AdditiveExpression_[Yield, Await] :
    MultiplicativeExpression_[?Yield, ?Await]
    AdditiveExpression_[?Yield, ?Await] + MultiplicativeExpression_[?Yield, ?Await]
    AdditiveExpression_[?Yield, ?Await] - MultiplicativeExpression_[?Yield, ?Await]
*** The Addition Operator ( + ) 加法操作符
**** 注意 加法操作符执行字符串拼接或者数字求和
**** Runtime Semantics : Evaluation
AdditiveExpression : AdditiveExpression + MultiplicativeExpression
1. 返回?EvaluateStringOrNumericBinaryExpression(AdditiveExpression, +,
   MultiplicativeExpression)
*** The Addition Operator ( - ) 减法操作符
**** 注意 减法操作符产生操作项的差
**** Runtime Semantics : Evaluation
AdditiveExpression : AdditiveExpression - MultiplicativeExpression
1. 返回?EvaluateStringOrNumericBinaryExpression(AdditiveExpression, -,
   MultiplicativeExpression)
** Bitwise Shift Operators
*** Syntax
ShiftExpression_[Yield, Await] :
    AdditiveExpression_[?Yield, ?Await]
    ShiftExpression_[?Yield, ?Await] << AdditiveExpression_[?Yield, ?Await]
    ShiftExpression_[?Yield, ?Await] >> AdditiveExpression_[?Yield, ?Await]
    ShiftExpression_[?Yield, ?Await] >>> AdditiveExpression_[?Yield, ?Await]
*** The Left Shift Operator ( << ) 左移操作
**** 注意 在操作符左侧的操作项上执行右侧操作项数量的左移操作
**** Runtime Semantics : Evaluation
ShiftExpression : ShiftExpression << AdditiveExpression
1. 返回?EvaluateStringOrNumericBinaryExpression(ShiftExpression, << ,
   AdditiveExpression)
*** The Signed Right Shift Operator ( >> ) 保持符号右移操作
**** 注意 在操作符左侧的操作项上执行右侧操作项数量的右移操作
**** Runtime Semantics : Evaluation
ShiftExpression : ShiftExpression >> AdditiveExpression
1. 返回?EvaluateStringOrNumericBinaryExpression(ShiftExpression, >> ,
   AdditiveExpression)
*** The Unsigned Right Shift Operator ( >>> ) 无符号右移操作
**** 注意 在操作符左侧的操作项上执行右侧操作项数量的0填充右移操作
**** Runtime Semantics : Evaluation
ShiftExpression : ShiftExpression >>> AdditiveExpression
1. 返回?EvaluateStringOrNumericBinaryExpression(ShiftExpression, >>> ,
   AdditiveExpression)
** Relational Operators 关系操作
*** 注意1 评估关系操作符的结果总是Boolean，反映运算符对应的关系是否在两个
           操作项中成立。
*** Syntax
RelationalExpression_[In, Yield, Await] :
    ShiftExpression_[?Yield, ?Await]
    RelationalExpression_[?In, ?Yield, ?Await] < ShiftExpression_[?Yield, ?Await]
    RelationalExpression_[?In, ?Yield, ?Await] > ShiftExpression_[?Yield, ?Await]
    RelationalExpression_[?In, ?Yield, ?Await] <= ShiftExpression_[?Yield, ?Await]
    RelationalExpression_[?In, ?Yield, ?Await] >= ShiftExpression_[?Yield, ?Await]
    RelationalExpression_[?In, ?Yield, ?Await] instanceof \
        ShiftExpression_[?Yield, ?Await]
    [+In]_RelationalExpression_[+In, ?Yield, ?Await] in ShiftExpression_[?Yield, ?Await]
*** 注意2 [In]语法参数被用来避免关系表达式的in操作符与for语句的in操作符的
           混淆
*** Runtime Semantics : Evaluation
RelateionalExpression : RelationalExpression < ShiftExpression
1. 让lref是评估RelationalExpression的结果
2. 让lval是?GetValue(lref)
3. 让rref是评估ShiftExpression的结果
4. 让rval是?GetValue(rref)
5. 让r是执行lval < rval的抽象关系比较（AbstractRelationalComparison）的结果
6. ReturnIfAbrupt(r)
7. 如果r是undefined，返回false，否则返回r。

RelateionalExpression : RelationalExpression > ShiftExpression
1. 让lref是评估RelationalExpression的结果
2. 让lval是?GetValue(lref)
3. 让rref是评估ShiftExpression的结果
4. 让rval是?GetValue(rref)
5. 让r是执行rval < lval带LeftFirst为false参数的抽象关系比较（
   AbstractRelationalComparison）的结果
6. ReturnIfAbrupt(r)
7. 如果r是undefined，返回false，否则返回r。

RelateionalExpression : RelationalExpression <= ShiftExpression
1. 让lref是评估RelationalExpression的结果
2. 让lval是?GetValue(lref)
3. 让rref是评估ShiftExpression的结果
4. 让rval是?GetValue(rref)
5. 让r是执行rval < lval带leftFirst为false参数的抽象关系比较（
   AbstractRelationalComparison）的结果
6. ReturnIfAbrupt(r)
7. 如果r是true或者undefined，返回false，否则返回true。

RelateionalExpression : RelationalExpression >= ShiftExpression
1. 让lref是评估RelationalExpression的结果
2. 让lval是?GetValue(lref)
3. 让rref是评估ShiftExpression的结果
4. 让rval是?GetValue(rref)
5. 让r是执行lval < rval的抽象关系比较（AbstractRelationalComparison）的结果
6. ReturnIfAbrupt(r)
7. 如果r是true或者undefined，返回false，否则返回true。

RelateionalExpression : RelationalExpression instanceof ShiftExpression
1. 让lref是评估RelationalExpression的结果
2. 让lval是?GetValue(lref)
3. 让rref是评估ShiftExpression的结果
4. 让rval是?GetValue(rref)
5. 返回?InstanceofOperator(lval, rval)

RelateionalExpression : RelationalExpression in ShiftExpression
1. 让lref是评估RelationalExpression的结果
2. 让lval是?GetValue(lref)
3. 让rref是评估ShiftExpression的结果
4. 让rval是?GetValue(rref)
5. 如果Type(rval)不是Object，投掷TypeError异常
6. 返回?HasProperty(rval, ?ToPropertyKey(lval))
*** InstanceofOperator(V, target)
抽象操作InstanceOfOperator接受参数V（ECMAScript语言值）和target（ECMAScript语言
值）。实现了泛用算法来明确V是否是target的实例，通过查询target的@@hasInstance
方法，或者（如果没有@@hasInstance）通过明确target的prototype性质是否存在于V的
源性链上。被调用时执行下列步骤：
1. 如果Type(target)不是Object，投掷TypeError异常
2. 让instOfHandler是?GetMethod(target, @@hasInstance)
3. 如果isntOfHandler不是undefined，那么
    a. 返回!ToBoolean(?Call(instOfHandler, target, <<V>>))
4. 如果IsCallable(target)是false，投掷TypeError异常
5. 返回?OrdinaryHasInstance(target, V)
**** 注意 步骤4和5提供了与之前版本的兼容处理，而不是使用@@hasInstance方法定义
           instanceOf操作符的语义。如果没有定义或者继承@@hasInstance方法，使用
           默认的instanceOf语义
** Equality Operators
*** 注意 评估相等操作符的结果总是Boolean类型，反映运算符对应的关系是否在两个
          操作项中成立。
*** Syntax 
EqualityExpression_[In, Yield, Await] :
    RelationalExpression_[?In, ?Yield, ?Await]
    EqualityExpression_[?In, ?Yield, ?Await] \=\= RelationalExpression_[?In, ?Yield, ?Await]
    EqualityExpression_[?In, ?Yield, ?Await] !\= RelationalExpression_[?In, ?Yield, ?Await]
    EqualityExpression_[?In, ?Yield, ?Await] \=\=\= RelationalExpression_[?In, ?Yield, ?Await]
    EqualityExpression_[?In, ?Yield, ?Await] !\=\= RelationalExpression_[?In, ?Yield, ?Await]
*** Runtime Semantics : Evaluation
EqualityExpression : EqualityExpression == RelationalExpression
1. 让lref是评估EqualityExpression的结果
2. 让lval是?GetValue(lref)
3. 让rref是评估RelationalExpresion的结果
4. 让rval是?GetValue(rref)
5. 返回执行rval == lval的抽象操作AbstractEqualityComparison的结果

EqualityExpresion : EqualityExpression != RelationalExpression
1. 让lref是评估EqualityExpression的结果
2. 让lval是?GetValue(lref)
3. 让rref是评估RelationalExpresion的结果
4. 让rval是?GetValue(rref)
5. 让r是执行rval == lval的抽象操作AbstractEqualityComparison的结果
6. ReturnIfAbrupt(r)
7. 如果r是true，返回false。否则返回true

EqualityExpression : EqualityExpression \=\=\= RelationalExpression
1. 让lref是评估EqualityExpression的结果
2. 让lval是?GetValue(lref)
3. 让rref是评估RelationalExpresion的结果
4. 让rval是?GetValue(rref)
5. 返回执行rval \=\=\= lval的抽象操作StrictEqualityComparison的结果

EqualityExpression : EqualityExpression !\=\= RelationalExpression
1. 让lref是评估EqualityExpression的结果
2. 让lval是?GetValue(lref)
3. 让rref是评估RelationalExpresion的结果
4. 让rval是?GetValue(rref)
5. 让r是执行rval \=\=\= lval的抽象操作StrictEqualityComparison的结果
6. Assert：r是一个普通完结
7. 如果r.\[\[Value]]是true，返回false，其他返回true
**** 注意1 上述定义的等价形式：
            . String比较可以强化为：`${a}` == `${b}`
            . Numeric比较可以强化为：+a == +b
            . Boolean比较可以强化为：!a == !b
**** 注意2 相等操作保持下列不变性
            . A != B 等价于 !(A == B)
            . A \=\= B 等价于 B \=\= A，处理A、B的评价顺序变化
**** 注意3 相等操作符的传递性不是总成立。例如两个不同String对象，都表示
            相同的String值，每个String对象都被\=\=操作符认为与String值性相等，
            但是这两个String对象上\=\=却不成立。例如
            . new String("a") \=\= "a"，"a" \=\= new String("a")都是true
            . new String("a") \=\= new String("a")是false
**** 注意4 String的比较使用编码单元值序列进行测试。没有试图使用更多复杂的
            基于Unicode规范定义的面向语义的字符或者字符串的定义判断相等，和
            校对顺序。因此基于Unicode规范相等的String值会被测试为不相等。所以
            这个算法是假定了String值都是已经在规范化的形式。
** Binary Bitwise Operators
*** Syntax
BitwiseANDExpression_[In, Yield, Await] :
    EqualityExpression_[?In, ?Yield, ?Await]
    BitwiseANDExpression_[?In, ?Yield, ?Await] & EqualityExpression_[?In, ?Yield, ?Await]

BitwiseXORExpression_[In, Yield, Await] : 
    BitwiseANDExpression_[?In, ?Yield, ?Await]
    BitwiseXORExpression_[?In, ?Yield, ?Await] ^ BitwiseANDExpression_[?In, ?Yield, ?Await]

BitwiseORExpression_[In, Yield, Await] : 
    BitwiseXORExpression_[?In, ?Yield, ?Await]
    BitwiseORExpression_[?In, ?Yield, ?Await] | BitwiseXORExpression_[?In, ?Yield, ?Await]
*** Runtime Semantics : Evaluation
BitwiseANDExpression : BitwiseANDExpression & EqualityExpreesion
1. 返回?EvaluateStringOrNumericBinaryExpression(BitwiseANDExpression, & , EqualityExpression)

BitwiseXORExpression : BitwiseXORExpression ^ BitwiseANDExpression
1. 返回?EvaluateStringOrNumericBinaryExpression(BitwiseANDExpression, ^ , BitwiseANDExpression)

BitwiseORExpression : BitwiseORExpression | BitwiseXORExpression
1. 返回?EvaluateStringOrNumericBinaryExpression(BitwiseORExpression, | , BitwiseXORExpression)
** Binary Logical Operators
*** Syntax
LogicalANDExpression_[In, Yield, Await] : 
    BitwiseORExpression_[?In, ?Yield, ?Await]
    LogicalANDExpression_[?In, ?Yield, ?Await] && BitwiseORExpression_[?In, ?Yield, ?Await]

LogicalORExpression_[In, Yield, Await] : 
    LogicalANDExpression_[?In, ?Yield, ?Await]
    LogicalORExpression_[?In, ?Yield, ?Await] || LogicalANDExpression_[?In, ?Yield, ?Await]

CoalesceExpression_[In, Yield, Await] : 
    CoalesceExpressionHead_[?In, ?Yield, ?Await] ?? BitwiseORExpression_[?In, ?Yield, ?Await]

CoalesceExpressionHead_[In, Yield, Await] : 
    CoalesceExpression_[?In, ?Yield, ?Await]
    BitwiseORExpression_[?In, ?Yield, ?Await]

ShortCircuitExpression_[In, Yield, Await] : 
    LogicalORExpression_[?In, ?Yield, ?Await]
    CoalesceExpression_[?In, ?Yield, ?Await]
*** 注意 &&或者\|\|操作符产生的值没有必要是Boolean，产生的值通常是操作项的
          值。
*** Runtime Semantics : Evaluation
LogicalANDExpression : LogicalANDExpression && BitwiseORExpression
1. 让lref是评估LogicalANDExpression的结果
2. 让lval是?GetValue(lref)
3. 让lbool是!ToBoolean(lval)
4. 如果lbool是false，返回lval
5. 让rref是评估BitwiseORExpression的结果
6. 返回?GetValue(rref)

LogicalORExpression : LogicalORExpression || LogicalANDExpression
1. 让lref是评估LogicalORExpression的结果
2. 让lval是?GetValue(lref)
3. 让lbool是!ToBoolean(lval)
4. 如果lbool是true，返回lval
5. 让rref是评估LogicalANDExpression的结果
6. 返回?GetValue(rref)

CoalesceExpression : CoalesceExpressionHead ?? BitwiseORExpression
1. 让lref是评估CoalesceExpressionHead的结果
2. 让lval是?GetValue(lref)
3. 如果lval是undefined或者null，那么
    a. rref是评估BitwiseORExpression的结果
    b. 返回?GetValue(rref)
4. 否则返回lval
** Conditional Operator ( ? : )
*** Syntax
ConditionalEpxression_[In, Yield, Await] : 
    ShortCircuitExpression_[?In, ?Yield, ?Await]
    ShortCircuitExpression_[?In, ?Yield, ?Await] ? AssignmentExpression_[?In, ?Yield, ?Await] :
        AssignmentExpression_[?In, ?Yield, ?Await]
*** 注意 在ECMAScript中的ConditionalExpression与C和Java稍有不同，它们允许第二个
          子表达式是表达式，但是限制第三个子表达式还是ConditionalExpression。
          ECMAScript方式的动机是允许赋值表达式由条件的任一臂控制，并消除以
          逗号表达式作为核心表达式产生的混乱且无用的情况。
*** Runtime Semantics : Evaluation
ConditionalExpression : ShortCircuitExpression ? AssignmentExpression : AssignmentExpression
1. 让lref是评估ShortCircuitExpression的结果
2. 让lval是?ToBoolean(?GetValue(lref))
3. 如果lval是true，那么
    a. 让trueRef是评估第一个AssignmentExpression的结果
    b. 返回?GetValue(trueRef)
4. 否则
    a. 让falseRef是评估第二个AssignmentExpression的结果
    b. 返回?GetValue(falseRef)
** Assignment Operators
*** Syntax
AssignmentExpression_[In, Yield, Await] :
    ConditionalExpression_[?In, ?Yield, ?Await]
    [+Yield]_YieldExpression_[?In, ?Await]
    ArrowFunction_[?In, ?Yield, ?Await]
    AsyncArrowFunction_[?In, ?Yield, ?Await]
    LeftHandSideExpression_[?Yield, ?Await] = AssignmentExpression_[?In, ?Yield, ?Await]
    LeftHandSideExpression_[?Yield, ?Await] AssignmentOperator AssignmentExpression_[?In, ?Yield, ?Await]
    LeftHandSideExpression_[?Yield, ?Await] &&= AssignmentExpression_[?In, ?Yield, ?Await]
    LeftHandSideExpression_[?Yield, ?Await] ||= AssignmentExpression_[?In, ?Yield, ?Await]
    LeftHandSideExpression_[?Yield, ?Await] ??= AssignmentExpression_[?In, ?Yield, ?Await]

AssignmentOperator : one of
    *= /= %= += -= <<= >>= >>>= &= ^= |= **=
*** Static Semantics : Early Errors
AssignmentExpression : LeftHandSideExpression = AssignmentExpression
如果LeftHandSideExpression是ObjectLiteral或者ArrayLiteral，应用下列早期错误：
. 如果LeftHandSideExpression没有覆盖AssignmentPatter，那么有SyntaxError
. AssignmentPattern和其派生的码型适用的早期错误规则也应用到被
  LeftHandSideExpression覆盖的AssignmentPattern上。

如果LeftHandSideExpression不是ObjectLiteral也不是ArrayLiteral，应用下列早期错误：
. 如果LeftHandSideExpression的AssignmentTargetType不是简单的，那么有SyntaxError

AssignmentExpression :
    LeftHandSideExpression AssignmentOperator AssignmentExpression
    LeftHandSideExpression &&= AssignmentExpression
    LeftHandSideExpression ||= AssignmentExpression
    LeftHandSideExpression ??= AssignmentExpression
. 如果LeftHandSideExpression的AssignmentTargetType不是简单的，那么有SyntaxError
*** Runtime Semantics : Evaluation
AssignmentExpression : LeftHandSideExpression = AssignmentExpression
1. 如果LeftHandSideExpression不是ObjectLiteral和ArrayLiteral
    a. 让lref是评估LeftHandSideExpression的结果
    b. ReturnIfAbrupt(lref)
    c. 如果IsAnonymousFunctionDefinition(AssignmentExpression)和LeftHandSideExpression
       上的IsIdentifierRef都是true，那么
        i. 让rval是AssignmentExpression上带lref.\[\[ReferenceName]]参数
           NamedEvaluation
    d. 否则
        i. 让rref是评估AssignmentExpression的结果
       ii. 让rval是?GetValue(rref)
    e. 执行?PutValue(lref, rval)
    f. 返回rval
2. 让assignmentPattern是被LeftHandSideExpression覆盖的AssignemtnPattern
3. 让rref是评估AssignmentExpression的结果
4. 让rval是?GetValue(rref)
5. 在assignmentPattern上用rval做参数执行?DestructiongAssignmentEvaluation
6. 返回rval

AssignmentExpression : LeftHandSideExpression AssignmentOperator AssignmentExpression
1. 让lref是评估LeftHandSideExpression的结果
2. 让lval是?GetValue(lref)
3. 让rref是评估AssignmentExpression的结果
4. 让rval是?GetValue(rref)
5. 让assignmentOptText是AssignmentOperator匹配到的源文本
6. 让opText是assignmentOptText按照下表联结的Unicode编码点序列
   | assignmentOptText | opText |
   | **=               | **     |
   | *=                | *      |
   | /=                | /      |
   | %=                | %      |
   | +=                | +      |
   | -=                | -      |
   | <<=               | <<     |
   | >>=               | >>     |
   | >>>=              | >>>    |
   | &=                | &      |
   | ^=                | ^      |
   | \vert=            | \vert  |
7. 让r是ApplyStringOrNumericBinaryOperator(lval, opText, rval)
8. 执行?PutValue(lref, r)
9. 返回r

AssignmentExpression : LeftHandSideExpression &&= AssignmentExpression
1. 让lref是评估LeftHandSideExpression的结果
2. 让lval是?GetValue(lref)
3. 让lbool是!ToBoolean(lval)
4. 如果lbool是false，返回lval
5. 如果IsAnonymousFunctionDefinition(AssignmentExpression)和LeftHandSideExpression上
   的IsIdentifierRef都是true，那么
    a. 让rval是AssignmentExpression上带lref.\[\[ReferenceName]]参数的NamedEvaluation
6. 否则
    a. 让rref是评估AssignmentExpression的结果
    b. 让rval是?GetValue(rref)
7. 执行?PutValue(lref, rval)
8. 返回rval

AssignmentExpression : LeftHandSideExpression ||= AssignmentExpression
1. 让lref是评估LeftHandSideExpression的结果
2. 让lval是?GetValue(lref)
3. 让lbool是!ToBoolean(lval)
4. 如果lbool是true，返回lval
5. 如果IsAnonymousFunctionDefinition(AssignmentExpression)和LeftHandSideExpression上
   的IsIdentifierRef都是true，那么
    a. 让rval是AssignmentExpression上带lref.\[\[ReferenceName]]参数的NamedEvaluation
6. 否则
    a. 让rref是评估AssignmentExpression的结果
    b. 让rval是?GetValue(rref)
7. 执行?PutValue(lref, rval)
8. 返回rval
   
AssignmentExpression : LeftHandSideExpression ??= AssignmentExpression
1. 让lref是评估LeftHandSideExpression的结果
2. 让lval是?GetValue(lref)
3. 让lval不是undefined也不是null，返回lval
4. 如果IsAnonymousFunctionDefinition(AssignmentExpression)和LeftHandSideExpression上
   的IsIdentifierRef都是true，那么
    a. 让rval是AssignmentExpression上带lref.\[\[ReferenceName]]参数的NamedEvaluation
5. 否则
    a. 让rref是评估AssignmentExpression的结果
    b. 让rval是?GetValue(rref)
6. 执行?PutValue(lref, rval)
7. 返回rval
**** 注意 如果这个表达式发生在严格模式，分别在1.e、2、2、2、2步骤的lref都是
           未解决的引用。如果是未解决的，投掷ReferenceError异常。另外，如果在
           8、7、7、6步骤的lref表示\[\[Writable]]属性是false数据性质的引用，或者
           表示\[\[Set]]属性是undefined的访问性质的引用，或者表示不可扩展对象
           上不存在的性质，会有运行时错误，投掷TypeError异常。
*** ApplyStringOrNumericBinaryOperator(lval, opText, rval)
抽象操作ApplyStringOrNumericBinaryOperator接受参数lval（ECMAScript语言值）、
opText（Unicode编码点序列）和rval（ECMAScript语言值）。被调用时执行下列步骤：
1. Assert：opText存在于本算法步骤8的列表中
2. 如果opText是+，那么
    a. 让lprim是?ToPrimitive(lval)
    b. 让rprim是?ToPrimitive(rval)
    c. 如果Type(lprim)是String或者Type(rprim)是String那么
        i. 让lstr是?ToString(lprim)
       ii. 让rstr是?ToString(rprim)
      iii. 返回lstr和rstr的拼接字符串
    d. 置lval是lprim
    e. 置rval是rprim
3. 注意：在此之后，一定是数值运算
4. 让lnum是?ToNumeric(lval)
5. 让rnum是?ToNumeric(rval)
6. 如果Type(lnum)不同于Type(rnum)，投掷TypeError异常
7. 让T是Type(lnum)
8. 让operation是opText在下表中联结的抽象操作
    | opText | operation             |
    | **     | T::exponentiate       |
    | \*     | T::multiply           |
    | \/     | T::divide             |
    | %      | T::remainder          |
    | +      | T::add                |
    | -      | T::subtract           |
    | <<     | T::leftShift          |
    | >>     | T::signedRightShift   |
    | >>>    | T::unsignedRightShift |
    | &      | T::bitwiseAND         |
    | \^     | T::bitwiseXOR         |
    | \vert  | T::bitwiseOR          |
9. 返回?operation(lnum, rnum)
**** 注意1 步骤2.a、2.b中没有为ToPrimitive提供hint参数。除Date外的标准对象会按
            照hint是number处理，Date按照hint是string处理。奇异对象可能使用其他
            缺省方式处理。
**** 注意2 步骤2.c不同于AbstractRelationalComparison的步骤3，这里是逻辑或进行
            判断，而不是逻辑与进行判断。
*** EvaluateStringOrNumericBinaryExpression(leftOperand, opText, rightOperand)
抽象操作EvaluateStringOrNumericBinaryExpression接受参数leftOperand（ParseNode）、
opText（Unicode编码点序列）和rightOperand（ParseNode）。被调用时执行下列步骤：
1. 让lref是评估leftOperand的结果
2. 让lval是?GetValue(lref)
3. 让rref是评估rightOperand的结果
4. 让rval是?GetValue(rref)
5. 返回?ApplyStringOrNumericBinaryOperator(lval, opText, rval)
*** Destructuring Assignment
**** Supplemental Syntax
在某些条件下进行AssignmentExpression : LeftHandSideExpression = AssignmentExpression
码型的实例是，LeftHandSideExpression的翻译可以使用下列方式改善：
AssignmentPattern_[Yield, Await] :
    ObjectAssignmentPattern_[?Yield, ?Await]
    ArrayAssignmentPattern_[?Yield, ?Await]
ObjectAssignmentPattern_[Yield, Await] :
    { }
    { AssignmentRestProperty_[?Yield, ?Await] }
    { AssignmentPropertyList_[?Yield, ?Await] }
    { AssignmentPropertyList_[?Yield, ?Await] , AssignmentRestProperty_[?Yield, ?Await]_opt }
ArrayAssignmentPattern_[Yield, Await] :
    [ Elision_opt AssignmentRestElement_[?Yield, ?Await]_opt ]
    [ AssignmentElementLsit_[?Yield, ?Await] ]
    [ AssignmentElementList_[?Yield, ?Await], Elision_opt AssignmentRestElement_[?Yield, ?Await]_opt ]
AssignmentRestProperty_[Yield, Await] :
    ... DestructuringAssignmentTarget_[?Yield, ?Await]
AssignemtnPropertyList_[Yield, Await] :
    AssignmentProperty_[?Yield, ?Await]
    AssignmentPropertyList_[?Yield, ?Await] , AssignmentProperty_[?Yield, ?Await]
AssignmentElisionElement_[Yield, Await] :
    Elision_opt AssignmentElement_[?Yield, ?Await]
AssignmentProperty_[Yield, Await] :
    IdentifierReference_[?Yield, ?Await] Initializer_[+In, ?Yield, ?Await]_opt
    PropertyName_[?Yield, ?Await] : AssignentElement_[?Yield, ?Await]
AssignmentElement_[Yield, Await] :
    DestructuringAssignmentTarget_[?Yield, ?Await] Initializer_[+In, ?Yield, ?Await]_opt
AssignmentRestElement_[Yield, Await] :
    ... DestructuringAssignmentTarget_[?Yield, ?Await]
DestructuringAssignmentTarget_[Yield, Await] :
    LeftHandSideExpression_[?Yield, ?Await]
**** Static Semantics : Early Errors
AssignmentProperty : IdnetifierReferecne Initializer_opt
. 如果IdentifierReference的AssignmentTargetType不是simple，那么有语法错误

AssignmentRestProperty : ... DestructuringAssignmentTarget
. 如果DestructuringAssignmentTarget是ArrayLiteral和ObjectLiteral，那么有语法错误

DestructuringAssignmentTarget : LeftHandSideExpression
如果LeftHandSideExpression是ObjectLiteral或者ArrayLiteral，应用下列早期错误规则：
. 如果LeftHandSideExpression没有覆盖AssignmentPattern，那么有语法错误
. 适用于AssignmentPattern以及其派生的码型的早期错误规则，也适用被
  LeftHandSideExpression覆盖的AssignmentPattern

如果LeftHandSideExpression不是ObjectLiteral或ArrayLiteral，应用下列早期错误规则：
. 如果LeftHandSideExpression的AssignmentTargetType不是simple，那么有语法错误
**** DestructuringAssignmntEvaluation
带参数value
ObjectAssignmentPattern : { }
1. 执行?RequireObjectCoercible(value)
2. 返回NormalCompletion(empty)

ObjectAssignmentPattern : 
    { AssignmentPropertyList }
    { AssignmentPropertyList , }
1. 执行?RequireObjectCoercible(value)
2. 执行在AssignmentPropertyList上带value参数的
   ?PropertyDestructuringAssignmentEvaluation
3. 返回NormalCompletion(empty)

ArrayAssignmentPattern :  [ ]
1. 让iteratorRecord是?GetIterator(value)
2. 返回?IteratorClose(iteratorRecord, NormalCompletion(empty))

ArrayAssignmentPattern : [ Elision ]
1. 让iteratorRecord是?GetIterator(value)
2. 让result是在Elision上带iteratorRecord的IteratorDestructuringAssignmentEvaluation
3. 如果iteratorRecord.\[\[Done]]是false，返回?IteratorClose(iteratorRecord, result)
4. 返回result

ArrayAssignmentPattern : [ Elision_opt AssignmentRestElement ]
1. 让iteratorRecord是?GetIterator(value)
2. 如果Elision存在，那么
    a. 让status是Elision上带参数iteratorRecord的
       IteratorDestructuringAssignmentEvaluation
    b. 如果status是意外完结，那么
        i. Assert：iteratorRecord.\[\[Done]]是true
       ii. 返回Completion(status)
3. 让result是AssignmentRestElement上带参数iteratorRecord的
   IteratorDestructuringAssignmentEvaluation
4. 如果iteratorRecord.\[\[Done]]是false，返回?IteratorClose(iteratorRecord, result)
5. 返回result

ArrayAssignmentPattern : [ AssignmentElementList ]
1. 让iteratorRecord似乎?GetIterator(value)
2. 让result是AssignmentRestElement上带参数iteratorRecord的
   IteratorDestructuringAssignmentEvaluation
3. 如果iteratorRecord.\[\[Done]]是false，返回?IteratorClose(iteratorRecord, result)
4. 返回result

ArrayAssignmentPattern : [ AssignmentElementList , Elision_opt AssignmentRestElement_opt]
1. 让iteratorRecord似乎?GetIterator(value)
2. 让status是AssignmentRestElement上带参数iteratorRecord的
   IteratorDestructuringAssignmentEvaluation
3. 如果status是意外完结，那么
    a. 如果iteratorRecord.\[\[Done]]是false，
       返回?IteratorClose(iteratorRecord, result)
    b. 返回Completion(status)
4. 如果Elision存在，那么
    a. 置status是Elision上带参数iteratorRecord的
       IteratorDestructuringAssignmentEvaluation
    b. 如果status是意外完结，那么
        i. Assert：iteratorRecord.\[\[Done]]是true
       ii. 返回Completion(status)
5. 如果AssignmentRestElement存在，那么
    a. 置status是AssignmentRestElement上带参数iteratorRecord的
       IteratorDestructuringAssignmentEvaluation
6. 如果iteratorRecord.\[\[Done]]是false，返回?IteratorClose(iteratorRecord, result)
7. 返回Completion(result)

ObjectAssignmentPattern : { AssignmentRestProperty }
1. 执行?RequrieObjectCoercible(value)
2. 让excludedNames是新的空List
3. 返回在AssignmentRestProperty上带value和excludedNames参数的
   RestDestructuringAssignmentEvaluation

ObjectAssignmentPattern : { AssignmentPropertyList , AssignmentRestProperty }
1. 执行?RequrieObjectCoercible(value)
2. 让excludedNames是在AssignmentPropertyList上带value参数的
   ?PropertyDestructuringAssignmentEvaluation
3. 返回在AssignmentRestProperty上带value和excludedNames参数的
   RestDestructuringAssignmentEvaluation
**** Runtime Semantics: PropertyDestructuringAssignmentEvaluation
带参数value
***** 注意 随后的操作收集了所有已解构的性质名
AssignmentPropertyList : AssignmentPropertyList , AssignmentProperty
1. 让propertyNames是在AssignmentPropertyList上带value参数的
   ?PropertyDestructuringAssignmentEvaluation
2. 让nextNames是在AssignmentProperty上带value参数的
   ?PropertyDestructuringAssignmentEvaluation
3. 将nextNames的元素符加到propertyNames里
4. propertyNames

AssignmentProperty : IdentifierReference Initializer_opt
1. 让P是IdentifierReference的String值
2. 让lref是?ResolveBinding(P)
3. 让v是?GetV(Value, P)
4. 如果Initializer_opt存在，而且v是undefined，那么
    a. 如果IsAnonymousFunctionDefinition(Initializer)是true，那么
        i. 置v是Initializer上带参数P的NamedEvaluation
    b. 否则
        i. 让defaultValue是评估Initalizer的结果
       ii. 值v是?GetValue(defaultValue)
5. 执行?PutValue(lref, v)
6. 返回只有P的List
**** Runtime Semantics: RestDestructuringAssignmentEvaluation
带参数value和excludeNames
AssignmentRestProperty : ... DestrcturingAssignmentTarget
1. 让lref是评估DestructuringAssignmentTarget的结果
2. ReturnIfAbrupt(lref)
3. 让restObj是!OridinaryObjectCreate(%Object.prototype%)
4. 执行?CopyDataProperties(restObj, value, excludedName)
5. 返回PutValue(lref, restObj)
**** Runtime Semantics: IteratorDestructuringAssignmentEvaluation
带参数iteratorRecord
AssignmentElementList : AssignmentElisionElement
1. 返回在AssignmentElisionElement上带iteratorRecord参数的
   IteratorDestructuringAssignmentEvaluation

AssignmentElementList : AssignmentElementList , AssignmentElisionElement
1. 执行在AssignmentElementList上带iteratorRecord参数的
   ?IteratorDestructuringAssignmentEvaluation
2. 返回在AssignmentElisionElement上带iteratorRecord参数的
   IteratorDestructuringAssignmentEvaluation的结果

AssignmentElisionElement : AssignmentElement
1. 返回在AssignmentElisionElement上带AssignmentElement参数的
   IteratorDestructuringAssignmentEvaluation

AssignmentElisionElement : Elison AssignmentElement
1. 执行在Elision上带iteratorRecord参数的
   ?IteratorDestructuringAssignmentEvaluation
2. 返回在AssignmentElement上带iteratorRecord参数的
   IteratorDestructuringAssignmentEvaluation的结果

Elison : ,
1. 如果iteratorRecord.\[\[Done]]是false，那么
    a. 让next是IteratorStep(iteratorRecord)
    b. 如果next是意外完结，置iteratorRecord.\[\[Done]]是true
    c. ReturnIfAbrupt(next)
    d. 如果next是false，设置iteratorRecord.\[\[Done]]是true
2. 返回NormalCompletion(empty)

Elison : Elison ,
1. 执行在Elision上带iteratorRecord参数的
   ?IteratorDestructuringAssignmentEvaluation
2. 如果iteratorRecord.\[\[Done]]是false，那么
    a. 让next是IteratorStep(iteratorRecord)
    b. 如果next是意外完结，置iteratorRecord.\[\[Done]]是true
    c. ReturnIfAbrupt(next)
    d. 如果next是false，设置iteratorRecord.\[\[Done]]是true
3. 返回NormalCompletion(empty)

AssignmentElement : DestructuringAssignmentTarget Initializer_opt
1. 如果DestructuringAssignmentTarget不是ObjectLiteral或ArrayLiteral，那么
    a. 让lref是评估DestructuringAssignmentTarget的结果
    b. ReturnIfAbrupt(lref)
2. 如果iteratorRecord.\[\[Done]]是false，那么
    a. 让next是IteratorStep(iteratorRecord)
    b. 如果next是意外完结，置iteratorRecord.\[\[Done]]是true
    c. ReturnIfAbrupt(next)
    d. 如果next是false，设置iteratorRecord.\[\[Done]]是true
    e. 否则
        i. 让value是IteratorValue(next)
       ii. 如果value是意外完结，置iteratorRecord.\[\[Done]]是true
      iii. ReturnIfAbrupt(value)
3. 如果IteratorRecord.\[\[Done]]是true，让value是undefined。
4. 如果Initializer存在，而且value是undefined，那么
    a. 如果IsAnonymousFunctionDefinition(Initializer)是true而且
       DestructuringAssignmentTarget的IsIdentifierRef是true，那么
        i. 让v是在Initializer上带lref.\[\[ReferencedName]]参数的?NamedEvaluation
    b. 否则
        i. 让defaultValue是评估Initializer的结果
       ii. 让v是?GetValue(defaultValue)
5. 否则，让v是value
6. 如果DestructuringAssignmentTarget是ObjectLiteral或者ArrayLiteral，那么
    a. 让nestedAssignmentPattern是被DestructuringAssignmentTarget覆盖的
       AssignmentPattern
    b. 返回在nestedAssignmentPattern上带v参数的DestructuringAssignmentEvaluation
7. 返回?PutValue(lref, v)
***** 注意 从左到右的评估顺序由评估DestructuringAssignmentTarget来维护，
            DestructuringAssignmentTarget在访问迭代器或者评估Initializer之前
            不是解构模式。
AssignmentRestElement : ... DestructuringAssignmentTarget
1. 如果DestructuringAssignmentTarget不是ObjectLiteral或ArrayLiteral，那么
    a. 让lref是评估DestructuringAssignmentTarget的结果
    b. ReturnIfAbrupt(lref)
2. 让A是!ArrayCreate(0)
3. 让n是0
4. 重复，当iteratorRecord.\[\[Done]]是false
    a. 让next是IteratorStep(iteratorRecord)
    b. 如果next是意外完结，置iteratorRecord.\[\[Done]]是true
    c. ReturnIfAbrupt(next)
    d. 如果next是false，设置iteratorRecord.\[\[Done]]是true
    e. 否则
        i. 让nextValue是IteratorValue(next)
       ii. 如果nextValue是意外完结，置iteratorRecord.\[\[Done]]是true
      iii. ReturnIfAbrupt(nextValue)
       iv. 执行!CreateDataPropertyOrThrow(A, !ToString(F(n)), nextValue)
        v. 置n为n+1
5. 如果DestructuringAssignmentTarget不是ObjectLiteral或ArrayLiteral，那么
    a. 返回?PutValue(lref, A)
6. 让nestedAssignmentPattern是被DestructuringAssignmentTarget覆盖的AssignmentPattern
7. 返回在nestedAssignmentPattern上带A参数的DestructuringAssignmentEvaluation
**** Runtime Semantics: KeyedDestructuringAssignmentEvaluation
带参数value和propertyName
AssignmentElement : DestructuringAssignmentTarget Initializer_opt
1. 如果DestructuringAssignmentTarget不是ObjectLiteral或ArrayLiteral，那么
    a. 让lref是评估DestructuringAssignmentTarget的结果
    b. ReturnIfAbrupt(lref)
2. 让v是?GetV(value, propertyName)
3. 如果Initializer存在，而且v是undefined，那么
    a. 如果IsAnonymousFunctionDefinition(Initializer)是true而且
       DestructuringAssignmentTarget的IsIdentifierRef是true，那么
        i. 让rhsValue是在Initializer上带lref.\[\[ReferencedName]]参数的?NamedEvaluation
    b. 否则
        i. 让defaultValue是评估Initializer的结果
       ii. 让rhsValue是?GetValue(defaultValue)
4. 否则，让rhsValue是v
5. 如果DestructuringAssignmentTarget是ObjectLiteral或者ArrayLiteral，那么
    a. 让assignmentPattern是被DestructuringAssignmentTarget覆盖的
       AssignmentPattern
    b. 返回在assignmentPattern上带rhsValue参数的DestructuringAssignmentEvaluation
6. 返回?PutValue(lref, v)
** Comma Operator(,)
*** Syntax
Expression_[In, Yield, Await ] :
    AssignmentExpression_[?In, ?Yield, ?Await ]
    Expression_[?In, ?Yield, ?Await ] , AssignmentExpression_[?In, ?Yield, ?Await ]
*** Runtime Semantics: Evaluation
Expression : Expression , AssignmentExpression
1. 让lref是评估Expression的结果
2. 执行?GetValue(lref)
3. 让rref是评估AssignmentExpression的结果
4. 返回?GetValue(rref)
**** 注意 GetValue必须被调用，即使其结果没有被用到，因为可能有观测副作用。
* ECMAScript Language: Statements and Declarations
** Syntax
Statement_[Yield, Await, Return] :
    BlockStatement_[?Yield, ?Await, ?Return]
    VariableStatement_[?Yield, ?Await]
    EmptyStatement
    ExpressionStatement_[?Yield, ?Await]
    IfStatement_[?Yield, ?Await, ?Return]
    BreakableStatement_[?Yield, ?Await, ?Return]
    ContinueStatement_[?Yield, ?Await]
    BreakStatement_[?Yield, ?Await]
    [+Return]_ReturnStatement_[?Yield, ?Await]
    WithStatement_[?Yield, ?Await, ?Return]
    LabelledStatement_[?Yield, ?Await, ?Return]
    ThrowStatement_[?Yield, ?Await]
    TryStatement_[?Yield, ?Await, ?Return]
    DebuggerStatement

Declaration_[Yield, Await] :
    HoistableDeclaration_[?Yield, ?Await, ~Default]
    ClassDeclaration_[?Yield, ~Default]
    LexicalDeclaration_[+In, ?Yield, ?Await]

HoistableDeclaration_[Yield, Await, Default] :
    FunctionDeclaration_[?Yield, ?Await, ?Default]
    GeneratorDeclaration_[?Yield, ?Await, ?Default]
    AsyncFunctionDeclaration_[?Yield, ?Await, ?Default]
    AsyncGeneratorDeclaration_[?Yield, ?Await, ?Default]

BreakableStatement_[Yield, Await, Return] :
    IteratironStatement_[?Yield, ?Await, ?Return]
    SwitchStatement_[?Yield, ?Await, ?Return]
** Statement Semantics
*** 14.1.1
HoistableDeclaration :
    GeneratorDeclaration
    AsyncFunctionDeclaration
    AsyncGeneratorDeclaration
1. 返回NormalCompletion(empty)

HoistableDeclaration : FunctionDelcaration
1. 返回评估FunctionDeclaration的结果

BreakableStatement :
    IterationStatement
    SwitchStatement
1. 让newLabelSet是新的空List
2. 返回在本BreakableStatement上带newLabelSet参数的LabelledEvaluation
** Block
*** Syntax
BlockStatement_[Yield, Await, Return] :
    Block_[?Yield, ?Await, ?Return]

Block_[Yield, Await, Return] :
    { Statement_[?Yield, ?Await, ?Return]_opt }

StatementList_[Yield, Await, Return] :
    StatementListItem_[?Yield, ?Await, ?Return]
    StatementList_[?Yield, ?Await, ?Return] StatementListIteme_[?Yield, ?Await, ?Return]

StatementListItem_[Yield, Await, Return] :
    Statement_[?Yield, ?Await, ?Return]
    Declaration_[?Yield, ?Await]
*** Static Semantics： Early Errors
Block: { StatementList }
. 如果StatementList上的LexicallyDeclaredNames包含任何重复实体，那么有语法错误
. 如果statementList上的LexicallyDeclaredNames的任何元素也出现在了在StatementList
  上的VarDeclaredNames，那么有语法错误。
*** Runtime Semantics: Evaluation
Block : { }
1. 返回NormalCompletion(empty)

Block : { StatmentList }
1. 让oldEnv是运行时执行背景的LexicalEnvironment
2. 让blockEnv是NewDeclarativeEnvironment(oldEnv)
3. 执行BlockDeclarationInstantiation(StatementList, blockEnv)
4. 置运行时背景的LexicalEnvironment是blockEnv
5. 让blockValue是评估StatementList的结果
6. 置运行时背景的LexicalEnvironment是oldEnv
7. 返回blockValue
**** 注意1 无论如何何种方式离开Block，LexicalEnvironment总存储在它之前的状态里
StatementList : StatementList StatementListItem
1. 让sl是评估StatementList的结果
2. ReturnIfAbrupt(sl)
3. 让s是评估StatementListItem的结果
4. 返回Completion(UpdateEmpty(s, sl))
**** 注意2 StatementList的值是StatementList中最后的码型值的项的值。例如，随后
            的调用eval都产生值1：
            eval("1;;;;;")
            eval("1;{}")
            eval("1;var a;")
*** BlockDeclarationInstantiation(code, env)
**** 注意 当评估Block或者CaseBlock时，新的DeclarativeEnvironmentRecord被创建出，
           并绑定块圈内声明的且在本EnvironmentRecord实例化的变量、常量、函数
           甚至类声明。
抽象操作BlockDeclarationInstantiation接受参数code（ParseNode）和env（Environment
Record）。code是与块的内容一致的ParseNode。env是在其内创建绑定的Environemnt
Record。被调用时执行下列步骤：
1. Assert：env是DeclarativeEnvironmentRecord
2. 让Declarations是code的LexicallyScopedDeclarations
3. 遍历declarations的元素记作d，做
    a. 遍历d的BoundNames的元素记作dn，做
        i. 如果d的IsConstantDeclaration是true，那么
            1. 执行!env.CreateImmutableBinding(dn, true)
       ii. 否则
            1. 执行!env.CreateMutableBinding(dn, false)。注意本步骤在B.3.3.6被取
               代了。
    b. 如果d是FunctionDeclaration、GeneratorDeclaration、AsyncFunctionDeclaration或者
       AsyncGeneratorDeclaration那么
        i. 让fn是d的BoundNames的唯一元素
       ii. 让fo是d上带env参数InstantiateFunctionObject
      iii. 执行env.InitializeBinding(fn, fo)。注意本步骤在B.3.3.6被取代了。
** Declarations and the Variable Statement
*** Let and Const Declarations
**** 注意 let和const声明的变量被圈在运行时执行背景的LexicalEnvironment里。变量
           在它们含有的EnvironmentRecord被初始化时被创建出来，但是不一定被访
           问，直到变量的LexicalBinding被评估了。用带Initializer的LexicalBinding定
           义的变量在LexicalBinding被评估时被赋值为变量的Initializer的
           AssignmentExpression的值
**** Syntax
LexicalDeclaration_[In, Yield, Await] :
    LetOrConst BindingLis[?In, ?Yield, ?Await] ;

LetOrConst :
    let
    const

BindingList_[In, Yield, Await] :
    LexicalBinding[?In, ?Yield, ?Await]
    BindingLis[?In, ?Yield, ?Await] , LexicalBinding[?In, ?Yield, ?Await]

LexicalBinding_[In, Yield, Await] :
    BindingIdentifier[?In, ?Yield, ?Await] Initialzier[?In, ?Yield, ?Await]_opt
    BindingPattern[?In, ?Yield, ?Await] Initializer[?In, ?Yield, ?Await]
**** Static Semantics : Early Errors
LexicalDeclaration : LetOrConst BindingList ;
. 如果BindingList的BoundNames包含let，那么有SyntaxError。
. 如果bindingList的BoundNames包含任何重复实体，那么有SyntaxError。

LexicalBinding : BindingIdentifier Initializer_opt
. 如果Initializer不存在，而且包含此LxicalBinding的LexicalDeclaration的
  IsConstantDeclaration时true，那么有SyntaxError。
**** Runtime Semantics: Evaluation
LexicalDeclaration : LetOrConst BindingList ;
1. 让next是评估BindingList的结果
2. ReturnIfAbrupt(next)
3. 返回NormalCompletion(empty)

BindingList : BindingList , LexicalBinding
1. 让next是评估BindingList的结果
2. ReturnIfAbrupt(next)
3. 返回评估LexicalBinding的结果

LexicalBinding : BindingIdentifer
1. 让lhs是ResolveBinding(BindingIdentifer的String值)
2. 返回InitializeReferencedBinding(lhs undefined)
***** 注意 静态语义规则确保了LexicalBinding的这种形式不会发生在const声明里。
LexicalBinding : BindingIdentifier Initializer
1. 让bindingId是BindingIdentifer的String值
2. 让lhs是ResolveBinding(bindingId)
3. 如果IsAnonymousFunctionDefinition(Initializer)是true，那么
    a. 让value是在Initializer带bindingId参数的NamedEvaluation
4. 否则
    a. 让rhs是评估Initializer的结果
    b. 让value是?GeValue(rhs)
5. 返回InitializeReferencedBinding(lhs, value)

LexicalBinding : BindingPattern Initializer
1. 让rhs是评估Initializer的结果
2. 让value是?GetValue(rhs)
3. 让env是运行执行背景的LexicalEnvironment
4. 返回在BndingPattern上带value和env参数的BindingInitialization的执行结果
*** Variable Statment
**** 注意 var语句声明的变量被圈在运行时执行背景的VariableEnvironemnt。var变量
           在它们包含的EnvironmentRecord被实例化的时候被创建，并被初始化为
           undefined。在任何VariableEnvironment的圈内普通BindingIdentifier会出现在
           一个或多个VariableDeclaration中，但是这些声明会集中定义为一个变量。
           被带Initializer的VariableDeclaration定义的变量在其被执行时赋予
           Initializer的AssignmentExpression的值，而不是变量被创建的时候。
**** Syntax
VariableStatement_[Yield, Await] :
    var VariableDeclarationList_[+In, ?Yield, ?Await];

VariableDeclarationList_[In, Yield, Await] :
    VariableDeclaration_[?In, ?Yield, ?Await]
    VariableDeclarationList_[?In, ?Yield, ?Await] , VariableDeclaration_[?In, ?Yield, ?Await]

VariableDeclaration_[In, Yield, Await] :
    BindingIdentifier_[?Yield, ?Await] Initializer_[?In, ?Yield, ?Await]_opt
    BindingPattern_[?Yield, ?Await] Initializer_[?In, ?Yield, ?Await]
**** Runtime Semantics: Evaluation
VariableStatement : var VariableDeclarationList ;
1. 让next是评估VariableDeclarationList的结果
2. ReturnIfAbrupt(next)
3. 返回NormalCompletion(empty)

VariableDeclarationList : VariableDeclarationList , VariableDeclaration
1. 让next是评估VariableDeclarationList的结果
2. ReturnIfAbrupt(next)
3. 返回评估VariableDeclaration的结果

VariableDeclaration : BindingIdentifier
1. 返回NormalCompletion(empty)

VariableDeclaration : BindingIdentifier Initializer
1. 让bindingId是BindingIdentifer的String值
2. 让lhs是ResolveBinding(bindingId)
3. 如果IsAnonymousFunctionDefinition(Initializer)是true，那么
    a. 让value是在Initializer带bindingId参数的NamedEvaluation
4. 否则
    a. 让rhs是评估Initializer的结果
    b. 让value是?GeValue(rhs)
5. 返回?PutValue(lhs, value)
**** 注意 如果VariableDeclaration是嵌入在with语句里，而且在VariableDeclaration里
           的BindingIdentifier与with语句ObjectEnvironmentRecord的绑定对象的性质名
           相同，那么步骤5会将value赋值给性质，而不是绑定Identifier的
           VariableEnvironemnt.
VariableDeclaration : BindingPattern Initializer
1. 让rhs是评估Initializer的结果
2. 让rval是?GetValue(rhs)
3. 返回在BndingPattern上带rval和undefined参数的BindingInitialization的执行结果
*** Destructuring Binding Patterns
**** Syntax
BindingPattern_[Yield, Await] :
    ObjectBindingPattern_[?Yield, ?Await]
    ArrayBindingPattern_[?Yield, ?Await]

ObjectBindingPattern_[Yield, Await] :
    { }
    { BindingRestProperty_[?Yield, ?Await] }
    { BindingPropertyList_[?Yield, ?Await] }
    { BindingPropertyList_[?Yield, ?Await] , BindignRestProperty_[?Yield, ?Await]_opt }

ArrayBindingPattern_[Yield, Await] :
    [ Elision_opt BindingRestElement_[?Yield, ?Await]_opt ]
    [ BindingElementList_[?Yield, ?Await] ]
    [ BindingElementList_[?Yield, ?Await] , Elision_opt BindingRestElement_[?Yield, ?Await]_opt ]

BindingRestProperty_[Yield, Await] :
    ... BindingIdentifier_[?Yield, ?Await]

BindingPropertyList_[Yield, Await] :
    BindingProperty_[?Yield, ?Await]
    BindingPropertyList_[?Yield, ?Await] , BindingProperty_[?Yield, ?Await]

BindingElementList_[Yield, Await] :
    BindingElisionElement_[?Yield, ?Await]
    BindingElmentList_[?Yield, ?Await] , BindingElisionElement_[?Yield, ?Await]

BindingElisionElement_[Yield, Await] :
    Elision_opt BindingElment_[?Yield, ?Await]

BindingProperty_[Yield, Await] :
    SingleNameBinding_[?Yield, ?Await]
    PropertyName_[?Yield, ?Await] : BindingElement_[?Yield, ?Await]

BindingElement_[Yield, Await] :
    SingleNameBinding_[?Yield, ?Await]
    BindingPattern_[?Yield, ?Await] Initializer_[?Yield, ?Await]_opt

SingleNameBinding_[Yield, Await] :
    BindingIdentifier_[?Yield, ?Await] Initializer_[?Yield, ?Await]

BindingRestElement_[Yield, Await] :
    ... BindingIdentifier_[?Yield, ?Await]
    ... BindingPattern_[?Yield, ?Await]
**** Runtime Semantics : PropertyBindingInitialization
带参数value和environment
***** 注意 这些将所有绑定的性质名收集为List返回，而不是空完结
BindingPropertyList : BindingPropertyList , BindingProperty
1. 让boundNames是在BindingPropertyList上带value和environment参数的
   ?PropertyBindingInitialization
2. 让nextNames是在BindingProperty上带value和environment参数的
   ?PropertyBindingInitialization
3. 追加nextNames的元素到boundNames的末端
4. 返回boundNames

BindingProperty : SingleNameBinding
1. 让name是SingleNameBinding的BoundNames的唯一元素，是字符串值
2. 在SingleNameBinding上带value、environment和name参数执行
   ?KeyedBindingInitialization
3. 返回只有name一个元素的List

BindingProperty : PropertyName : BindingElement
1. 让P是评估PropertyName的结果
2. ReturnIfAbrupt(P)
3. 在BindingElement上带value、environment和P参数执行?KeyedBindingInitialization
4. 返回只有P一个元素的List
**** Runtime Semantics : RestBindingInitialization
带完参数value、environment和excludedNames
BindingRestProperty : ... BindingIdentifier
1. 让lhs是?ResolveBinding(BindingIdentifier的String值, environment)
2. 让restObj是!OrdinaryObjectCreate(%Object.prototype%)
3. 执行?CopyDataProperties(restObj, value, excluedeNames)
4. 如果envriornment是undefinded，返回PutValue(lhs, restObj)
5. 返回InitializeReferencedBinding(lhs, restObj)
**** Runtime Semantics : KeyedBndingInitialization
带完参数value、environment和excludedNames
***** 注意 当environment参数是undefined时，表明应当用PutValue操作赋予初始化值。
            这会出现在非严格模式函数的形式参数里。形式参数绑定被预先初始化
            以便处理多个参数具有相同名称的可能。
BindingElement : BindingPattern Initializer_opt
1. 让v时?GetV(value, propertyName)
2. 如果Initializer存在而且v是undefined，那么
    a. 让defaultValue是评估Initializer的结果
    b. 置v是?GetValue(defaultValue)
3. 返回在BindingPattern上带v和environment参数执行BindingInitialization的结果

SingleNameBinding : BindingIddentifier Initialzier_opt
1. 让bindingId是BindingIdentifer的StringValue
2. 让lhs是?ResolveBinding(bindingId, environment)
3. 让v是?Get(value, propertyName)
4. 如果Initializer存在而且v是undefined，那么
    a. 如果IsAnonymousFunctionDefinition(Initializer)是true，那么
        i. 置v是在Initializer上带bindingId参数执行NamedEvaluation的结果
    b. 否则
        i. 让defaultValue是评估Initializer的结果
       ii. 置v是?GetValue(defaultValue)
5. 如果environment是undefined，返回?PutValue(lhs, v)
6. 返回InitializeReferencedBinding(lhs, v)
** Empty Statement
*** Syntax
EmptyStatement :
    ;
*** Runtime Semantics: Evaluation
EmptyStatement : ;
1. 返回NormalCompletion(empty)
** Expression Statement
*** Syntax
ExpressionStatement_[Yield, Await]
    [lookahead ∉ { \{ , function , async [no LineTerminator here] function , class , let [ \}] 
        Expression [+In, ?Yield, ?Await] ;
*** 注意 ExpressionStatement不能用U+007B（左大括号）开始，因为这会与Block产生
          混淆。ExpressionStatement不能用function和class关键词开始，这会与
          FunctionDeclaration、GeneratorDeclaration或ClassDeclaration产生混淆。
          ExpressionStatement也不能用async function开始，因为这会与
          AsyncFunctionDeclaration或者AsyncGeneratorDeclaration产生混淆。
          ExpressionStatement不能用let [开始，因为这会与第一个LexicalBinding是
          ArrayBindingPattern的let LexicalDeclaration产生混淆。
*** Runtime Semantics : Evaluation
ExpressionStatement : Expression ;
1. 让exprRef是评估Expression的结果
2. 返回?GetValue(exprRef)
** The if Statement
*** Syntax
IfStatement_[Yield, Await, Return] :
    if ( Expression_[+In, ?Yield, ?Await] ) Statement_[+In, ?Yield, ?Await] else
        Statement_[+In, ?Yield, ?Await]
    if ( Expression_[+In, ?Yield, ?Await] ) Statement_[+In, ?Yield, ?Await] [lookahead ≠ else]
*** 注意 前置限制[lookahead ≠ else]解决常见的经典的悬挂else问题。就是选择其
          联结的if的混淆问题，else会联结到最近（最内层）的候选if。
*** Static Semantics: Early Errors
IfStatement :
    if ( Expression ) Statement else Statement
    if ( Expression ) Statement
. 如果IsLabelledFunction(Statement)是true，那么有语法错误。
**** 注意 只在B.3.2中的扩展规定被实现了，才需要应用本规则。
*** Runtime Semantics: Evaluation
IfStatement : if ( Expression ) Statement else Statement
1. 让exprRef是评估Expression的结果
2. 让exprValue是!ToBoolean(?GetValue(exprRef))
3. 如果exprValue是true，那么
    a. 让stmtComletion是评估第一个Statement的结果
4. 否则
    a. 让stmtComletion是评估第二个Statement的结果
5. 返回Completion(UpdateEmpty(stmtCompletion, undefined))

IfStatement : if ( Expression ) Statement
1. 让exprRef是评估Expression的结果
2. 让exprValue是!ToBoolean(?GetValue(exprRef))
3. 如果exprValue是false，那么
    a. 返回NormalCompletion(undefined)
4. 否则
    a. 让stmtComletion是评估Statement的结果
    b. 返回Completion(UpdateEmpty(stmtCompletion, undefined))
** Iteration Statements
*** Syntax
IterationStatement_[Yield, Await, Return] :
    DoWhileStatement_[?Yield, ?Await, ?Return]
    WhileStatement_[?Yield, ?Await, ?Return]
    ForStatement_[?Yield, ?Await, ?Return]
    ForInOfStatement_[?Yield, ?Await, ?Return]
*** Semantics
**** LoopContinues(completion, labelSet)
抽象操作LoopContinues接受参数completion和labelSet。被调用时执行下列步骤：
1. 如果completion.\[\[Type]]是normal，返回true
2. 如果completion.\[\[Type]]不是continue，返回false
3. 如果completion.\[\[Target]]是empty，返回true
4. 如果completion.\[\[Target]]是labelSet的任意元素，返回true
5. 返回false
***** 注意 在IterationStatement的Statement部分内，ContinueStatement会被用于开始
            新的遍历。
**** RuntimeSemantics: LoopEvaluation
带参数labelSet
IterationStatement : DoWhileStatement
1. 返回在DoWhileStatement带labelSet参数的?DoWhileLoopEvaluation

IterationStatement : WhileStatement
1. 返回在WhileStatement带labelSet参数的?WhileLoopEvaluation

IterationStatement : ForStatement
1. 返回在ForStatement带labelSet参数的?ForLoopEvaluation

IterationStatement : ForInOfStatement
1. 返回在ForInOfStatement带labelSet参数的?ForInOfLoopEvaluation
*** do-while语句
**** Syntax
DoWhileStatement_[Yield, Await, Return] :
    do Statement_[?Yield, ?Await, ?Return] while ( Expression_[+In, ?Yield, ?Await] ) ;
**** Static Semantics: Early Errors
DoWhileStatement : do Statement while ( Expression ) ;
. 如果IsLabelledFunction(Statement)是true，那么有SyntaxError
***** 注意 只在B.3.2中的扩展规定被实现了，才需要应用本规则。
**** Runtime Semantics: DoWhileLoopEvaluation
带参数labelSet.
DoWhileStatement : do Statement while ( Expression ) ;
1. 让V是undefined
2. 重复
    a. 让stmtResult是评估Statement的结果
    b. 如果LoopContinues(stmtResult, labelSet)是false，返回Completion(UpdateEmpty(stmtResult, V))
    c. 如果stmtResult.\[\[Value]]不是empty，置V是stmtResult.\[\[Value]]
    d. 让exprRef是评估Expression的结果
    e. 让exprValue是?GetValue(exprRef)
    f. 如果!ToBoolean(exprValue)是false，返回NormalCompletion(V)
*** while语句
**** Syntax
WhileStatement_[Yield, Await, Return] :
    while ( Expression_[+In, ?Yield, ?Await] ) Statement_[?Yield, ?Await, ?Return]
**** Static Semantics: Early Errors
WhileStatement : while ( Expression ) Statement
. 如果IsLabelledFunction(Statement)是true，那么有SyntaxError
***** 注意 只在B.3.2中的扩展规定被实现了，才需要应用本规则。
**** Runtime Semantics: DoWhileLoopEvaluation
带参数labelSet.
WhileStatement : while ( Expression ) Statement
1. 让V是undefined
2. 重复
    a. 让exprRef是评估Expression的结果
    b. 让exprValue是?GetValue(exprRef)
    c. 如果!ToBoolean(exprValue)是false，返回NormalCompletion(V)
    d. 让stmtResult是评估Statement的结果
    e. 如果LoopContinues(stmtResult, labelSet)是false，返回Completion(UpdateEmpty(stmtResult, V))
    f. 如果stmtResult.\[\[Value]]不是empty，置V是stmtResult.\[\[Value]]
*** for语句
**** Syntax
ForStatement_[Yield, Await, Return] :
    for ( [lookhead ≠ let \[] Expression_[~In, ?Yield, ?Await]_opt ;
        Expression_[+In, ?Yield, ?Await]_opt ; Expression_[+In, ?Yield, ?Await]_opt )
        Statement_[?Yield, ?Await, ?Return]
    for ( var VariableDeclarationList_[~In, ?Yield, ?Await]_opt ;
        Expression_[+In, ?Yield, ?Await]_opt ; Expression_[+In, ?Yield, ?Await]_opt )
        Statement_[?Yield, ?Await, ?Return]
    for ( LexicalDeclaration_[~In, ?Yield, ?Await]_opt Expression_[+In, ?Yield, ?Await]_opt ;
        Expression_[+In, ?Yield, ?Await]_opt ) Statement_[?Yield, ?Await, ?Return]
**** Static Semantics: Early Errors
ForStatement :
    for ( Expression_opt ; Expression_opt ; Expression_opt ) Statement
    for ( var VariableDeclarationList ; Expression_opt ; Expression_opt ) Statement
    for ( LexcialDeclaration Expression_opt ; Expression_opt ) Statement
. 如果IsLabelledFunction(Statement)是true，那么有SyntaxError
***** 注意 只在B.3.2中的扩展规定被实现了，才需要应用本规则。
ForStatement : for ( LexcialDeclaration Expression_opt : Expression_opt ) Statement
. 如果LexicalDeclaration的BoundNames的元素出现在Statement的VarDeclaredNames中，
  那么有SyntaxError。
**** Runtime Semantics: ForLoopEvaluation
带参数labelSet.
ForStatement : for ( Expression_opt ; Expression_opt ; Expression_opt ) Statement
1. 如果第一个Expression存在，那么
    a. 让exprRef是评估第一个Expression的结果
    b. 执行?GetValue(exprRef)
2. 返回?ForBodyEvaluation(第二个Expression, 第三个Expression, Statement, <<>>, labelSet)

ForStatement : for ( var VariableDeclarationList ; Expression_opt ; Expression_opt ) Statement
1. 让valDcl是评估VariableDeclarationList的结果
2. ReturnIfAbrupt(varDcl)
3. 返回?ForBodyEvaluation(第一个Expression, 第二个Expression, Statement, <<>>, labelSet)

ForStatement : for ( LexcialDeclaration Expression_opt ; Expression_opt ) Statement
1. 让oldEnv是运行时执行背景的LexicalEnvironment
2. 让llpEnv是NewDeclarativeEnvironment(oldEnv)
3. 让isConst是LexicalDeclaration的IsConstantDeclaration
4. 让boundNames是LexicalDeclaration的BoundNames
5. 遍历boundNames的元素记作dn，做
    a. 如果isConst是true，那么
        i. 执行!loopEnv.CreateImmutableBinding(dn, true)
    b. 否则
        i. 执行!loopEnv.CreateImmutableBinding(dn, false)
6. 置运行时执行背景的LexicalEnvironment为loopEnv
7. 让forDcl是评估LexicalDeclaration的结果
8. 如果forDcl是意外完结，那么
    a. 置运行时执行背景的LexicalEnvironment为oldEnv
    b. 返回Completion(forDcl)
9. 如果isConst是false，让perIterationLets是boundNames，否则让perIterationLets是<<>>
10. 让bodyResult是ForBodyEvaluation(第一个Expression, 第二个Expression, Statement, perIterationLets, labelSet)
11. 置运行时执行背景的LexicalEnvironment为oldEnv
12. 返回Completion(bodyResult)
**** ForBodyEvaluation(test, increment, stmt, perIterationBindings, labelSet)
抽象操作ForBodyEvaluation接受参数test、increment、stmt、perIterationBindings和
labelSet。被调用时执行下列步骤：
1. 让V是undefined
2. 执行?CreatePerIterationEnvironment(perIterationBindings)
3. 重复
    a. 如果test不是[empty]，那么
        i. 让testRef是评估test的结果
       ii. 让testValue是?GetValue(testRef)
      iii. 如果!ToBoolean(testValue)是false，返回NormalCompletion(V)
    b. 让result是评估stmt的结果
    c. 如果LoopContinue(result, labelSet)是false，返回Completion(UpdateEmpty(result, V))
    d. 如果result.\[\[Value]]不是empty，置V是to.\[\[Value]]
    e. 执行?CreatePerIterationEnvironment(perIterationBindings)
    f. 如果increment不是[empty]，那么
        i. 让incRef是评估increment的结果
       ii. 执行?GetValue(incRef)
**** CreatePerIterationEnvironemnt(perIterationBindings)
抽象操作CreatePerIterationEnvironment接受参数perIterationBindings。被调用时执行
下列步骤：
1. 如果perIterationBindings有内容，那么
    a. 让lastIterationEnv是运行时执行背景的LexicalEnvironment
    b. 让outer是lastIterationEnv.\[\[OuterEnv]]
    c. Assert：outer不是null
    d. 让thisIterationEnv是NewDeclarativeEnvironment(outer)
    e. 遍历perIterationBindings的元素记作bn，做
        i. 执行!thisIterationEnv.CreateMutableBinding(bn, false)
       ii. 让lastValue是?LatIterationEnv.GetBindingValue(bn, true)
      iii. 执行thisIterationEnv.InitializeBinding(bn, lastValue)
    f. 置运行时执行背景的LexicalEnvironment是thisIterationEnv
2. 返回undefined
*** for-in、for-of和for-await-of语句
**** Syntax
ForInOfStatement_[Yield, Await, Return] :
    for ( [lookhead ≠ let \[] LeftHandSideExpression_[?Yield, ?Await] in
        Expression_[+In, ?Yield, ?Await] ) Statement_[?Yield, ?Await, ?Return]
    for ( var ForBinding_[?Yield, ?Await] in Expression_[+In, ?Yield, ?Await] )
        Statement_[?Yield, ?Await, ?Return]
    for ( ForDeclaration_[?Yield, ?Await] in Expression_[+In, ?Yield, ?Await] )
        Statement_[?Yield, ?Await, ?Return]
    for ( [lookhead ≠ let \[] LeftHandSideExpression_[?Yield, ?Await] of
        AssignmentExpression_[+In, ?Yield, ?Await] ) Statement_[?Yield, ?Await, ?Return]
    for ( var ForBinding_[?Yield, ?Await] of AssignmentExpression_[+In, ?Yield, ?Await] )
        Statement_[?Yield, ?Await, ?Return]
    for ( ForDeclaration_[?Yield, ?Await] of AssignmentExpression_[+In, ?Yield, ?Await] )
        Statement_[?Yield, ?Await, ?Return]
    [+Await]_for await ( [lookhead ≠ let \[] LeftHandSideExpression_[?Yield, ?Await] of
        AssignmentExpression_[+In, ?Yield, ?Await] ) Statement_[?Yield, ?Await, ?Return]
    [+Await]_for await ( var ForBinding_[?Yield, ?Await] of 
        AssignmentExpression_[+In, ?Yield, ?Await] ) Statement_[?Yield, ?Await, ?Return]
    [+Await]_for await ( ForDeclaration_[?Yield, ?Await] of
        AssignmentExpression_[+In, ?Yield, ?Await] ) Statement_[?Yield, ?Await, ?Return]
ForDeclaration_[Yield, Await] :
    LetOrConst ForBinding_[?Yield, ?Await]
ForBinding_[Yield, Await] :
    BindingIdentifier_[?Yield, ?Await]
    BindingPattern_[?Yield, ?Await]
**** 注意 本节在附件B.3.6中进行了扩展。
**** Static Semantics: Early Errors
ForInOfStatement ：
    for ( LeftHandSideExpression in Expression ) Statement
    for ( var ForBinding in Expression ) Statement
    for ( ForDeclaration in Expression ) Statement
    for ( LeftHandSideExpression of AssignmentExpression ) Statement
    for ( var ForBinding of AssignmentExpression ) Statement
    for ( ForDeclaration of AssignmentExpression ) Statement
    for await ( LeftHandSideExpression of AssignmentExpression ) Statement
    for await ( var ForBinding of AssignmentExpression ) Statement
    for await ( ForDeclaration of AssignmentExpression ) Statement
. 如果IsLabelledFunction(Statement)是true，那么有SyntaxError
***** 注意 只在B.3.2中的扩展规定被实现了，才需要应用本规则。
ForInOfStatement :
    for ( LeftHandSideExpression in Expression ) Statement
    for ( LeftHandSideExpression of AssignmentExpression ) Statement
    for await ( LeftHandSideExpression of AssignmentExpression ) Statement
如果LeftHandSideExpression是ObjectLiteral或者ArrayLiteral，应用下列早期错误规则：
. 如果LeftHandSideExpression没有覆盖一个AssignmentPattern，那么有SyntaxError
. 所有适用AssignmentPattern和其派生码型的规则，也适用于被LeftHandSideExpression
  覆盖AssignmentPattern
如果LeftHandSideExpression不是ObjectLiteral和ArrayLiteral，应用下列早期错误规则：
. leftHandSideExpression的AssignmentTargetType不是simple，那么有SyntaxError。

ForInOfStatement
    for ( ForDeclaration in Expression ) Statement
    for ( ForDeclaration of AssignmentExpression ) Statement
    for await ( ForDeclaration of AssignmentExpression ) Statement
. 如果ForDeclaration的BoundNames包含let，那么有SyntaxError
. 如果ForDeclaration的BoundNames的任何元素也出现在Statement的VarDeclarationNames，
  那么有SyntaxError
. 如果ForDeclaration的BoundNames含有任何重复的元素，那么有SyntaxError
**** Static Semantics: IsDestructuring
MemberExpression : PrimaryExpression
1. 如果PrimaryExpression是ObjectLiteral或者ArrayLiteral，返回true
2. 返回false

MemberExpression :
    MemberExpression [ Expression ]
    MemberExpression . IdentifierName
    MemberExpression TempalteLiteral
    SuperProperty
    MetaProperty
    new MemberExpression Arguments
NewExpression : new NewExpression
LeftHandSideExpression :
    CallExpression
    OptionalExpression
1. 返回false

ForDeclaration : LetOrConst ForBinding
1. 返回ForBinding的IsDestructuring

ForBinding : BindingIdentifier
1. 返回false

ForBinding : BindingPattern
1. 返回true
***** 注意 本节在附件B.3.6被扩展
**** Runtime Semantics: ForDeclarationBindingInitialization
带参数value和environment
***** 注意 当environment参数是undefined时，表明应当用PutValue操作赋予初始化值。
            这会出现在非严格模式函数（10.2.10）的形式参数和var语句里。在这些
            情况里词法绑定是主机化的而且在评估之前预先初始化。
ForDeclaration : LetOrConst ForBinding
1. 返回ForBinding上带value和environment参数的BindingInitialization的执行结果
**** Runtime Semantics: ForDeclarationBindingInstantiation
带参数environment
ForDeclaration : LetOrConst ForBinding
1. Assert：environment是DeclarativeEnvironmentRecord
2. 遍历BoundNames的元素记作name，做
    a. 如果LetOrConst的IsConstantDeclaration是true
        i. 执行!environment.CreateImmutableBinding(name, true)
    b. 否
        i. 执行!environment.CreateMutalbeBinding(name, false)
**** Runtime Semantics : ForInOfLoopEvaluation
带参数labelSet
ForInOfStatement : for ( LeftHandSideExpression in Expression ) Statement
1. 让keyResult是?ForIn/OfHeadEvaluation(<<>>, Expression, enumerate)
2. 返回?ForIn/OfBodyEvaluation(LeftHandSideExpression, Statement, keyResult, enumerate,
   assignment, labelSet)

ForInOfStatement : for ( var ForBinding in Expression ) Statement
1. 让keyResult是?ForIn/OfHeadEvaluation(<<>>, Expression, enumerate)
2. 返回?ForIn/OfBodyEvaluation(ForBinding, Statement, keyResult, enumerate,
   varBinding, labelSet)

ForInOfStatement : for ( ForDeclaration in Expression ) Statement
1. 让keyResult是?ForIn/OfHeadEvaluation(ForDeclaration的BoundNames, Expression,
   enumerate)
2. 返回?ForIn/OfBodyEvaluation(ForDeclaration, Statement, keyResult, enumerate,
   lexicalBinding, labelSet)

ForInOfStatement : for ( LeftHandSideExpression of AssignmentExpression ) Statement
1. 让keyResult是?ForIn/OfHeadEvaluation(<<>>, AssignmentExpression, iterate)
2. 返回?ForIn/OfBodyEvaluation(LeftHandSideExpression, Statement, keyResult, iterate,
   assignment, labelSet)

ForInOfStatement : for ( var ForBinding of AssignmentExpression ) Statement
1. 让keyResult是?ForIn/OfHeadEvaluation(<<>>, AssignmentExression, iterate)
2. 返回?ForIn/OfBodyEvaluation(ForBinding, Statement, keyResult, iterate,
   varBinding, labelSet)

ForInOfStatement : for ( ForDeclaration of AssignmentExpression ) Statement
1. 让keyResult是?ForIn/OfHeadEvaluation(ForDeclaration的BoundNames,
   AssignmentExpression, iterate)
2. 返回?ForIn/OfBodyEvaluation(ForDeclaration, Statement, keyResult, iterate,
   lexicalBinding, labelSet)

ForInOfStatement : for await ( LeftHandSideExpression of AssignmentExpression ) Statement
1. 让keyResult是?ForIn/OfHeadEvaluation(<<>>, AssignmentExpression, async-iterate)
2. 返回?ForIn/OfBodyEvaluation(LeftHandSideExpression, Statement, keyResult, iterate,
   assignment, labelSet, async)

ForInOfStatement : for await ( var ForBinding of AssignmentExpression ) Statement
1. 让keyResult是?ForIn/OfHeadEvaluation(<<>>, AssignmentExression, async-iterate)
2. 返回?ForIn/OfBodyEvaluation(ForBinding, Statement, keyResult, iterate,
   varBinding, labelSet, async)

ForInOfStatement : for await ( ForDeclaration of AssignmentExpression ) Statement
1. 让keyResult是?ForIn/OfHeadEvaluation(ForDeclaration的BoundNames,
   AssignmentExpression, async-iterate)
2. 返回?ForIn/OfBodyEvaluationn(ForDeclaration, Statement, keyResult, iterate,
   lexicalBinding, labelSet, async)
***** 注意 本节在附件B.3.6中被扩展了。
**** ForIn/OfHeadEvaluation(uninitializedBoundNames, expr, iterationKind)
抽象操作ForIn/OfHeadEvaluation接受参数uninitializedBoundNames、expr和iterationKind
（enumerate、iterate或async-iterate）。被调用时执行下列步骤：
1. 让oldEnv是运行时执行背景的LexicalEnvironment
2. 如果uninitializedBoundNames是新的空List，那么
    a. Assert：uninitializedBoundNames没有重复实体
    b. 让newEnv是NewDeclarativeEnvironment(oldEnv)
    c. 遍历uninitializedBoundNames的元素记作name，做
        i. 执行!newEnv.CreateMutableBinding(name, false)
    d. 置运行时执行背景的LexicalEnvironment是newEnv
3. 让exprRef是评估expr的结果
4. 置运行时执行背景的LexicalEnvironment是oldEnv
5. 让exprValue是?GetValue(exprRef)
6. 如果iterationKind是enumerate那么
    a. 如果exprValue是undefined或者null，那么
        i. 返回Completion { \[\[Type]]:break, \[\[Value]]:empty, \[\[Target]]:empty }
    b. 让obj是!ToObject(exprValue)
    c. 让iterator是?EnumerateObjectProperties(obj)
    d. 让nextMethod是!GetV(iterator, "next")
    e. 返回Record { \[\[Iterator]]:iterator, \[\[NextMethod]]:nextMethod,
       \[\[Done]]:false }
7. 否则
    a. Assert：iterationKind是iterate或者async-iterate
    b. 如果iterationKind是async-iterate，让iteratorHint是async
    c. 否则，让iteratorHint是sync
    d. 返回?GetIterator(exprValue, iteratorHint)
**** ForIn/OfBodyEvaluation( lhs,stmt, iteratorRcord, iterationKind,
              lhsKind, labeSet[, iteratorKind] )
抽象操作ForIn/OfBodyEvaluation接受参数lhs、stmt、iteratorRecord、iterationKind、
lhsKind（assignment、varBinding或lexicalBinding）和labelSet，以及可选参数
iteratorKind（sync或async）。被调用时执行下列背景。
1. 如果iteratorKind不存在，让iteratorKind是sync
2. 让oldEnv是运行时执行背景的LexicalEnvironment
3. 让V是undefined
4. 让destructuring是lhs的IsDestructuring
5. 如果destructuring是true，而且lhsKind是assignment，那么
    a. Assert：lhs是LeftHandSideExpression
    b. 让assignmentPattern是被lhs覆盖的AssignmentPattern
6. 重复
    a. 让nextResult是?Call(iteratorRecord.\[\[NextMethod]],
       iteratorRecord.\[\[Iterator]])
    b. 如果iteratorKind是async，置nextResult是?Await(nextResult)
    c. 如果Type(nextResult)不是Object，投掷TypeError异常
    d. 让done是?IteratorComplete(nextResult)
    e. 如果done是true，返回NormalCompletion(V)
    f. 让nextValue是?IteratorValue(nextResult)
    g. 如果lhsKind是assignment或者varBinding，那么
        i. 如果destructuring是false，那么
            1. 让lhsRef是评估lhs的结果（可能会反复评估）
    h. 否则
        i. Assert：lhsKind是lexicalBinding
       ii. Assert：lhs是ForDeclaration
      iii. 让iterationEnv是NewDeclarativeEnvironment(oldEnv)
       iv. 在lhs上带iterationEnv参数执行ForDelcarationBindingInstantiation
        v. 置运行时执行背景的LexicalEnvironment是iterationEnv
       vi. 如果destructuring是false，那么
           1. Assert：lhs绑定了唯一名称
           2. lhsName是lhs的BoundNames的唯一元素
           3. 让lhsRef是!ResolveBinding(lhsName)
    i. 如果destructuring是false，那么
        i. 如果lhsRef是意外完结，那么
            1. 让status是lhsRef
       ii. 否则如果lhsKind是lexicalBinding，那么
            1. 让status是InitializeReferencedBinding(lhsRef, nextValue)
      iii. 否则
            1. 让status是PutValue(lhsRef, nextValue)
    j. 否则
        i. 如果lhsKind是assignment，那么
            1. 让status是在assignmentPattern上带nextValue参数的
               DestructuringAssignmentEvaluation
       ii. 否则如果lhsKind是varBinding，那么
            1. Assert：lhs是ForBinding
            2. 让status是lhs上带nextValue和undefined参数的BindingInitialization
      iii. 否则
            1. Assert：lhsKind是lexicalBinding
            2. Assert：lhs是ForDeclaration
            3. 让status是lhs上带nextValue和iterationEnv参数的
               ForDeclarationBindingInitialization
    k. 如果status是意外完结，那么
        i. 置运行时背景的LexicalEnvironment是oldEnv
       ii. 如果iteratorKind是async，返回?AsyncIteratorClose(iteratorRecord, status)
      iii. 如果iterationKind是enumerate，那么
            1. 返回status
       iv. 否则
            1. Assert：iterationKind是iterate
            2. 返回?IteratorClose(iteratorRecord, status)
    l. 让result是评估stmt的结果
    m. 置运行时执行背景的LexicalEnvironment是oldEnv
    n. 如果LoopContinue(result, labelSet)是false，那么
        i. 如果iterationKind是enumerate，那么
            1. 返回Completion(UpdateEmpty(result, V))
       ii. 否则
            1. Assert：iterationKind是iterate
            2. 置status是UpdateEmpty(result, V)
            3. 如果iteatorKind是async，返回?AsyncIteratorClose(iteratorRecord, status)
            4. 返回?IteratorClose(iteratorRecord, status)
    o. 如果result.\[\[Value]]不是empty，置V是result.\[\[Value]]
**** Runtime Semantics : Evaluation
ForBinding : BindingIdentifier
1. 让bindingId是BindingIdentifier的String值
2. 返回?ResolveBinding(bindingId)
**** EnumerateObjectProperties(O)
抽象操作EnumerateObjectProperties接受参数O。被调用时执行下列步骤：
1. Assert：Type(O)是Object
2. 返回遍历器对象（27.1.1.2），其next方法遍历O中全部字符串键的可遍历性质。
   这个遍历器对象无法通过ECMAScript代码直接访问。枚举性质的机制和顺序没有
   特别规定，但是符合下述规定。

遍历器的throw和return方法是null，而且不会被调用。遍历器的next方法处理对象的
性质来明确此性质能否被返回为一个遍历的值。返回的性质键不包含Symbol。在
枚举过程中目标对象的性质可以被删除。忽略在遍历器next方法访问前被删除的性
质。在遍历时新增的性质，不保证活跃的枚举过程处理此性质。在任何枚举过程
中一个性质键仅能被遍历器next方法返回一次。

枚举目标对象的性质过程有需要枚举目标对象原型上的性质，递归辖区。但是如果
next方法已经返回相同的性质键，原型链上的不再返回。在明确原型上的性质是否
被处理过的时候不考虑\[\[Enumerable]]属性的值。原型对象上的可枚举性质必须包含
在以原型对象为参数的正调用EnumerateObjectProperties中。EnumerateObjectProperties
必须含有目标对象的内部方法\[\[OwnPropertyKeys]]返回的自有性质键。目标对象的
性质属性必须被\[\[GetOwnProperty]]内部方法包含。

而且如果O和其原型链的任何对象都不是ProxyExoticObject、IntegerIndexedExoticObjct、
ModuleNamespaceExoticObject或者实现的ExoticObject，那么这个遍历器必须与
CreateForInIterator(O)的行为一致，直到出现下列某种情况：
. O或者原型链上对象的内部占位\[\[Prototype]]值发生了变化
. O或者原型链上对象的性质被移除
. O的原型上加入了新的性质
. O或者原型链上对象的性质的\[\[Enumerable]]属性发生变化
***** 注意1 ECMAScript实现没有要求实现14.7.5.10.2.1的算法。他们可以选择任何与
             其算法没有歧义行为的实现，除非违反了之前描述的限制。

             下面是用ECMAScript生成器函数实现本规则：
             function * EnumerateObjectProperties(obj) {
               const visited = new Set()
               for (const key of Reflect.ownKeys(obj)) {
                 if (typeof key === 'symbol') continume;
                 const desc = Reflect.getOwnPropertyDescriptor(obj, key);
                 if (desc) {
                   visited.add(key)
                   if(desc.enumeralbe) yield key;
                 }
               }
               const proto = Reflect.getPropertyOf(obj);
               if(proto === null) return;
               for (const protoKey of EnumerateObjectProperties(proto)) {
                 if(!visited.has(protoKey)) yield protoKey;
               }
             }
***** 注意2 实现提供的奇异对象不要求匹配CreateForInIterator，因为过去的实现
             在这里的行为是不同，其他行为的也是如此。
**** For-In Iterator Objects
For-In遍历器是表示某些特定对象上的特定遍历器的对象。For-In遍历器对象无法从
ECMAScript代码直接访问，他们独立存在来展示EnumerateObjectProperties的行为。
**** CreateForInIterator(object)
抽象操作CreateForinterator接受参数object。用于创建For-In遍历器对象来按照特定
顺序遍历object的字符串键的自有和继承性质。被调用时执行下列步骤：
1. Assert：Type(object)是Object
2. 让iterator是!OrdinaryObjectCreate(%ForInIteratorPrototype%, <<\[\[Object]],
   \[\[ObjectWasVisited]], \[\[VisitedKey]], \[\[RemainingKeys]]>>)
3. 置iterator.\[\[Object]]是object
4. 置iterator.\[\[ObjectWasVisited]]是false
5. 置iterator.\[\[VisitedKeys]]是新的空List
6. 置iterator.\[\[RemainingKeys]]是新的空List
7. 返回iterator
**** The %ForInIteratorPrototype% Object
%FrInIteratorPrototype% 对象
. 有被所有For-In遍历器对象的性质
. 是一个基本对象
. 有\[\[Prototype]]内部占位，其值是%IteratorPrototype%
. 无法被ECMAScript代码直接访问
. 有下列性质：
**** %ForInIteratorPrototype%.next()
1. 让O是this值
2. Assert: Type(O)是Object
3. Assert: O有For-In遍历器对象（14.7.5.10.3）的所有内部占位
4. 让object是O.\[\[Object]]
5. 让visited是O.\[\[VisitedKeys]]
6. 让remaining是O.\[\[RemainingKeys]]
7. 重复
    a. 如果O.\[\[ObjectWasVisited]]是false，那么
        i. 让keys是?object.\[\[OwnPropertyKeys]]()
       ii. 遍历keys元素记作key，做
            1. 如果Type(key)是String，那么
                a. 追加key到remainings
      iii. 置O.\[\[ObjectWasVisited]]是true
    b. 重复，当remaing不是空的
        i. 让r是remaing的第一个元素
       ii. 移除remaing的第一个元素
      iii. 如果r与visited的任何元素都不能让SameValue(r, v)是true，那么
            1. 让desc是?object.\[\[GetOwnProperty]](r)
            2. 如果desc不是undefined，那么
                a. 追加r到visited
                b. 如果desc.\[\[Enumerable]]是true，
                   返回CreateIterResultObject(f, false)
    c. 置object是?object.\[\[GetPrototypeOf]]()
    d. 置O.\[\[Object]]是object
    e. 置O.\[\[ObjectWasVisited]]是false
    f. 如果object是null，返回CreateIterResultObject(undefined, true)
**** PProperties of For-In Iterator Instance
For-In遍历器实例是从%ForInIteratorPrototype%内部对象继承性质的基本对象。For-In
遍历器实例创建时带有表38所列的内部占位
| Internal Slot          | Description                                                                |
| \[\[Object]]           | 值是：需要遍历其性质的目标对象                                             |
| \[\[ObjectWasVisited]] | 如果已经调用过\[\[Object]]上的\[\[OwnPropertyKeys]]就是true，否则就是false |
| \[\[VisitedKeys]]      | 记录到遍历时已经访问过的字符串性质键的list                                 |
| \[\[RemainingKeys]]    | 在遍历其原型对象之前，尚未发射的字符串键的性质。                           |
** The continue Statement
*** Syntax
ContinueStatemnet_[Yield, Await]
    continue ;
    continue [no LineTerminator here] LabelIdentifier_[?Yield, ?Await] ;
*** Static Semantics: Early Errors
ContinueStatement:
    continue ;
    continue LabelIdentifier ;
如果ContinumeStatement不是在IterationStatement内嵌入的，而是直接或者间接的（没有
穿过函数边界），那么有SyntaxError
*** Runtime Semantics: Evaluation
ContinueStatement: continue ;
1. 返回Completion { \[\[Type]]:continue, \[\[Value]]:empty, \[\[Target]]:empty }

ContinueStatement: continue LabelIdentifier ;
1. 让label是LabelIdentifier的字符串值
2. 返回Completion { \[\[Type]]:continue, \[\[Value]]:empty, \[\[Target]]:label }
** The break Statement
BreakStatement_[Yield, Await]
    break ;
    break [no LineTerminator here] LabelIdentifier_[?Yield, ?Await] ;
*** Static Semantics: Early Errors
BreakStatement: break;
如果ContinumeStatement不是在IterationStatement内嵌入的，而是直接或者间接的（没有
穿过函数边界），那么有SyntaxError
*** Runtime Semantics: Evaluation
ContinueStatement: continue ;
1. 返回Completion { \[\[Type]]:continue, \[\[Value]]:empty, \[\[Target]]:empty }

ContinueStatement: continue LabelIdentifier ;
1. 让label是LabelIdentifier的字符串值
2. 返回Completion { \[\[Type]]:continue, \[\[Value]]:empty, \[\[Target]]:label }
** The return Statement
*** Syntax
ReturnStatement_[Yield, Await] :
    return ;
    return [no LineTerminator here] Expression_[+In, ?Yield, ?Await] ;
*** 注意 return语句会导致函数中止执行，在大多数情况，返回一个值给调用者。
          如果省略了Expression，那么返回值是undefined。否则返回Expression的值。
          根据环绕的背景return语句可能不会实际返回值给调用者。比如在try块里，
          return语句的完结记录可能会被替换为评估在finally块里的其他完结记录。
*** Runtime Semantics: Evaluation
ReturnStatement: return ;
1. 返回Completion { \[\[Type]]:return, \[\[Value]]:empty, \[\[Target]]:empty }

ReturnStatement: return Expression ;
1. 让exprRef是评估Expression的值
2. 让exprValue是?GetValue(exprRef)
3. 如果!GetGenratorKind()是sync，置exprValue是?Await(exprValue)
4. 返回Completion { \[\[Type]]:return, \[\[Value]]:exprValue, \[\[Target]]:empty }
** The with Statement
*** Syntax
WithStatement_[Yield, Await, Return]
    with ( Expression_[+In, ?Yield, ?Await] ) Statement_[?Yield, ?Await, ?Return]
*** 注意 with语句为被计算的对象向运行时执行背景的词法环境里增加了
          ObjectEnvironmentRecord。然后适用这个扩增的词法环境运行语句。
          最后这个词法环境恢复为原来样子。
*** Static Semantics: Early Errors
WithStatement : with ( Expression )  Statement
. 如果匹配此码型的代码在严格模式代码里，那么有SyntaxError
. 如果IsLabelledFunction(Statement)是true，那么有SyntaxError
**** 注意 只在B.3.2中的扩展规定被实现了，才需要应用本规则。
*** Runtime Semantics: Evaluation
WithStatement : with ( Expression ) Statmenet
1. 让val是评估Expression的结果
2. 让obj是?ToObject(?GetValue(val))
3. 让oldEnv是运行时执行背景的LexicalEnvironment
4. 让newEnv是NewObjectEnvironment(obj, oldEnv)
5. 置newEnv的withEnvironment是true
6. 置运行时执行背景的LexicalEnvironment是newEnv
7. 让C是评估Statement的结果
8. 置运行时执行背景的LexicalEnvironment是oldEnv
9. 返回Completion(UpdateEmpty(C, undefined))
**** 注意 无论何种控制离开嵌入的Statement，不管正常完结、异常完结或者
           异常，LexicalEnvironment总是被恢复成之前的状态。
** The switch Statement
*** Syntax
SwitchStatement_[Yield, Await, Return] :
    switch ( Expression_[+In, ?Yield, ?Await]) CaseBlock_[?Yield, ?Await, ?Return]
CaseBlock_[Yield, Await, Return] :
    { CaseClauses_[?Yield, ?Await, ?Return]_opt }
    { CaseClauses_[?Yield, ?Await, ?Return]_opt DefaultClause_[?Yield, ?Await, ?Return]
        CaseClauses_[?Yield, ?Await, ?Return]_opt }
CaseClauses_[Yield, Await, Return] :
    CaseClause_[?Yield, ?Await, ?Return]
    CaseClauses_[?Yield, ?Await, ?Return] CaseClause_[?Yield, ?Await, ?Return]
CaseClause_[Yield, Await, Return] :
    case Expression_[+In, ?Yield, ?Await] : StatementList_[?Yield, ?Await, ?Return]_opt
DefaultClause_[Yield, Await, Return] :
    default : StatementList_[?Yield, ?Await, ?Return]_opt
*** Static Semantics: Early Errors
SwitchStatement : switch ( Expression ) CaseBlock
. 如果CaseBlock的LexicallyDeclaredNames含有重复的实体，那么有SyntaxError
. 如果CaseBlock的LexicallyDeclaredNames有元素出现在CaseBlock的VarDeclaredNames，
  那么有SyntaxError
*** Runtime Semantics: CaseBlockEvaluation
带参数input
CaseBlock : { }
1. 返回NormalCompletion(undefined)

CaseBlock : { CaseClauses }
1. 让V是undefined
2. 让A是在CaseClauses里的CaseClause按照源文本顺序构成的List
3. 让found是false
4. 遍历A中的CaseClause记作C，做
    a. 如果found是false，那么
        i. 置found是?CaseClauseIsSelected(C, input)
    b. 如果found是true，那么
        i. 让R是评估C的结果
       ii. 如果R.\[\[Value]]不空，置V是R.\[\[Value]]
      iii. 如果R是意外完结，返回Compeltion(UdpateEmpty(R, V))
5. 返回NormalCompletion(V)

CaseBlock : { CaseClauses_opt DefaultClause CaseClauses_opt }
1. 让V是undefined
2. 如果存在第一个CaseClauses，那么
    a. 让A是在第一个CaseClauses里的CaseClause按照源文本顺序构成的List
3. 否则
    a. 让A是<< >>
4. 让found是false
5. 遍历A中的CaseClause记作C，做
    a. 如果found是false，那么
        i. 置found是?CaseClauseIsSelected(C, input)
    b. 如果found是true，那么
        i. 让R是评估C的结果
       ii. 如果R.\[\[Value]]不空，置V是R.\[\[Value]]
      iii. 如果R是意外完结，返回Compeltion(UdpateEmpty(R, V))
6. 让foundInB是false
7. 如果存在第二个CaseClauses，那么
    a. 让B是在第二个CaseClauses里的CaseClause按照源文本顺序构成的List
8. 否则
    a. 让B是<< >>
9. 如果found是false，那么
    a. 遍历B中的CaseClause记作C，做
        i. 如果foundInB是false，那么
            1. 置foundInB是?CaseClauseIsSelected(C, input)
       ii. 如果foundInB是true，那么
            1. 让R是评估C的结果
            2. 如果R.\[\[Value]]不空，置V是R.\[\[Value]]
            3. 如果R是意外完结，返回Compeltion(UdpateEmpty(R, V))
10. 如果foundInB是true，返回NormalCompletion(V)
11. 让R是评估DefaultClause的结果
12. 如果R.\[\[Value]]不是empty，置V是R.\[\[Value]]
13. 如果R是意外完结，返回Compeltion(UdpateEmpty(R, V))
14. 注意：随后的内容是第二个CaseClauses的其他完结遍历。
15. 遍历B中的CaseClause记作C，做
    a. 让R是评估C的结果
    b. 如果R.\[\[Value]]不空，置V是R.\[\[Value]]
    c. 如果R是意外完结，返回Compeltion(UdpateEmpty(R, V))
16. 返回NormalCompletion(V)
*** CaseClauseIsSelected(C, iput)
抽象操作CaseClauseIsSelected接受参数C（CaseClause的ParseNode）和input（
ECMAScript语言值）。明确C是否匹配input。被调用时执行下列步骤：
1. Assert：C是CaseClause : case Expression : Statement_opt码型的实例
2. 让exprRef是评估C的Expression
3. 让clauseSelector是?GetValue(epxrRef)
4. 返回执行严格相等比较input \=\=\= clauseSelector的结果
**** 注意 这操作不会执行C的任何Statement。CaseBlock算法使用其返回的值明确
           那个StatementList开始执行
*** Runtime Semantics: Evaluation
SwitchStatement : switch ( Expression ) CaseBlock
1. 让exprRef是评估Expression的结果
2. 让switchValue是?GetValue(exprRef)
3. 让oldEnv是运行时执行背景的LexicalEnvironment
4. 让blockEnv是NewDeclarativeEnvironment(oldEnv)
5. 执行BlockDeclarationInstantiation(CaseBlock, blockEnv)
6. 置运行时执行背景的LexicalEnvironment是lockEnv
7. 让R是在CaseBlock上带switchValue参数的CaseBlockEvaluation
8. 置运行时执行背景的LexicalEnvironment是oldEnv
9. 返回R
**** 注意 无论何种方式离开SwitchStatement，LexicalEnvironment总是恢复到之前的
           状态
CaseClause : case Expression :
    1. 返回NormalCompletion(empty)

CaseClause : case Expression : StatementList
    1. 返回评估StatementList的结果

DefaultClause : default :
    1. 返回NormalCompletion(empty)

DefaultClause : default : StatementList
    1. 返回评估StatementList的结果
** Labelled Statements
*** Syntax
LabelledStatement_[Yield, Await, Return] :
    LabelIdentifier_[?ield, ?Await] : LabelledItem_[?Yield, ?Await, ?Return] :

LabelledItem_[Yield, Await, Return] :
    Statement_[?ield, ?Await, ?Return]
    FunctionDeclaration_[?Yield, ?Await, ~Default] :
**** 注意 语句可以前缀一个label。标记后的语句仅用于连接标记的break和
           continue语句。ECMAScript没有goto语句。Statement可以是
           LabelledStatement的一部分，且这个LabelledStatement是还是其他
           LabelledStatement的一部分，递归下去。在描述独立语句的语义时，
           从此引入的labels被收集起来引用到“当前label集”。
*** Static Semantics: Early Errors
LabelledItem : FunctionDelcaration
. 如果源文本匹配此规则，那么有语法错误。
**** 在B.3.2中的扩展提供了本规则的备选定义。
*** Static Semantics: IsLabelledFunction(stmt)
抽象操作IsLabelledFunction接受参数stmt。被调用时执行下列步骤：
1. 如果stmt不是LabelledStatement，返回false
2. 让item时stmt的LabelledItem
3. 如果item是 LabelledItem : FunctionDeclaration ，返回true
4. 让subStmt是item的Statement
5. 返回IsLabelledFunction(subStmt)
*** Runtime Semantics: Evaluation
LabelledStatement : LabelIdentifier : LabelledItem
1. 让newLabelSet是新的空List
2. 返回本LabelledStatment上带newLabelSet参数的LabelledEvaluation
*** Runtime Semantics: LabelledEvaluation
带参数labelSet
BreakableStatement : IterationStatement
1. 让stmtResult是在IterationStatement上带labelSet参数的LoopEvaluation
2. 如果stmtResult.\[\[Type]]是break，那么
    a. 如果stmtResult.\[\[Target]]是empty，那么
        i. 如果stmtResult.\[\[Value]]是empty，置stmtResult是
           NormalCompeltion(undefined)
       ii. 否则，置stmtResult是NormalCompletion(stmtResult.\[\[Value]])
3. 返回 Completion(stmtResult)

BreakableStatement : SwitchStatement
1. 让stmtResult是评估SwitchStatement的结果
2. 如果stmtResult.\[\[Type]]是break，那么
    a. 如果stmtResult.\[\[Target]]是empty，那么
        i. 如果stmtResult.\[\[Value]]是empty，置stmtResult是
           NormalCompeltion(undefined)
       ii. 否则，置stmtResult是NormalCompletion(stmtResult.\[\[Value]])
3. 返回 Completion(stmtResult)
**** 注意1 BreakableStatement是通过未标记的BreakStatement能退出的。
LabelledStatement : LabelIdentifier : LabelledItem
1. 让label是LabelIdentifier的StringValue
2. 追加label到labelSet中
3. 让stmtResult是在LabelledItem上带labelSet参数的LabelledEvaluation
4. 如果stmtResult.\[\[Type]]是break，而且SameValue(stmtResult.\[\[Target]], label)
   是true，那么
    a. 置stmtResult是NormalCompletion(stmtResult.\[\[Value]])
5. 返回 Completion(stmtResult)

LabelledItem : FunctionDeclaration
1. 返回评估FunctionDeclaration的结果

Statement :
    BlockStatement
    VariableStatmeent
    EmptyStatement
    ExpressionStatement
    IfStatement
    ContinueStatement
    BreakStatement
    ReturnStatement
    WithStatement
    ThrowStatement
    TryStatement
    DebuggerStatement
1. 返回评估Statment的结果
**** 注意2 为LabelledEvaluation有特定语义Statement的码型只有BreakableStatement和
            LabelledStatement
** The throw Statement
*** Syntax
ThrowStatement_[Yield, Await] :
    throw [no LineTerminator here] Expression_[+In, ?Yield, ?Await] ;
*** Runtime Semantics : Evaluation
ThrowStatement : throw Expression
1. 让exprRef是评估Expression的结果
2. 让exprValue是?GetValue(exprRef)
3. 返回ThrowCompeltion(exprValue)
** The try Statement
*** Syntax
TryStatement_[Yield, Await, Return]
    try Block_[?Yield, ?Await, ?Return] Catch_[?Yield, ?Await, ?Return]
    try Block_[?Yield, ?Await, ?Return] Finally_[?Yield, ?Await, ?Return]
    try Block_[?Yield, ?Await, ?Return] Catch_[?Yield, ?Await, ?Return]
        Finally_[?Yield, ?Await, ?Return]
Catch_[Yield, Await, Return] :
    catch ( CatchParameter_[?Yield, ?Awati] ) Block_[?Yield, ?Await, ?Return]
    catch Block_[?Yield, ?Await, ?Return]
Finally_[Yield, Await, Return] :
    finally Block_[?Yield, ?Await, ?Return]
CatchParameter_[Await, Return] :
    BindingIdentifier_[?Await, ?Return]
    BindingPattern_[?Await, ?Return]
*** 注意 try语句封闭一个代码块，在其中可以发生异常，比如运行时错误或者
          投掷语句。catch语句提供了异常处理代码。当catch条款捕获了某个异常，
          其CatchParameter被绑定为此异常。
*** Static Semantics: Early Errors
Catch : catch ( CatchParameter ) Block
. 如果CatchParameter的BoundNames含有任何重复的元素，那么有SyntaxError。
. 如果CatchParameter的BoundNames的任何元素出现在Block的LexicallyDeclaredNames中，
  那么有SyntaxError。
. 如果CatchParameter的BoundNames的任何元素出现在Block的VarDeclaredNames中，
  那么有SyntaxError。
**** 注意 在B.3.5为本码型提供了备选语义。
*** Runtime Sematics: CatchClauseEvaluation
带参数thrownValue
Catch : catch ( CatchParameter ) Block
1. 让oldEnv是运行时执行背景的LexicalEnvironment
2. 让catchEnv时NewDeclarativeEnvironment(oldEnv)
3. 遍历CatchParameter的BoundNames的元素记作argName，做
    a. 执行!catchEnv.CreateMutableBinding(argName, false)
4. 置运行时执行背景的LexicalEnvironment是catchEnv
5. 让status是在CatchParameter上带thrownValue和catchEnv参数的BindingInitialization
6. 如果status是意外完结，那么
    a. 置运行时执行背景的LexicalEnvironment是oldEnv
    b. 返回Completion(status)
7. 让B是评估Block的结果
8. 置运行时执行背景的LexicalEnvironment是oldEnv
9. 返回Completion(B)

Catch : catch Block
1. 返回评估Block的结果
**** 注意 无论何种方式离开Block，LexicalEnvironment总是恢复到之前的状态
*** Runtime Semantics: Evaluation
TryStatement : try Block Catch
1. 让B是评估Block的结果
2. 如果B.\[\[Type]]是throw，让C是在Catch上带B.\[\[Value]]参数的
   CatchClauseEvaluation
3. 否则，让C是B
4. 返回Completion(UpdateEmpty(C, undefined))

TryStatement : try Block Finally
1. 让B是评估Block的结果
2. 让F是评估Finally的结果
3. 如果F.\[\[Type]]是normal，置F是B
4. 返回Completion(UpdateEmpty(F, undefined))

TryStatement : try Block Catch Finally
1. 让B是评估Block的结果
2. 如果B.\[\[Type]]是throw，让C是在Catch上带B.\[\[Value]]参数的
   CatchClauseEvaluation
3. 否则，让C是B
4. 让F是评估Finally的结果
5. 如果F.\[\[Type]]是normal，置F是C
6. 返回Completion(UpdateEmpty(F, undefined))
** The debugger Statement
*** 注意 当实现运行调试时，评估DebuggerStatement会引发中断。如果调试不存在
          或不活跃，本语句没有可观测的效果。
DebuggerStatement : debugger
1. 如果一个实现定义的调试特性是可用的且激活的，那么
    a. 执行实现定义的调试动作
    b. 让result是实现定义的完结值
2. 否则
    a. 让result是NormalCompletion(empty)
3. 返回result
* ECMAScript Language: Functions and Classes
** 注意 各种ECMAScript语言元素引发ECMAScript函数对象（10.2）的创建。评估这些
         函数从执行它们的\[\[Call]]内部方法（10.1）开始。
** Parameter Lists 参数列表
*** Syntax
UniqueFormalParameters_[Yield,Await]:
    FormalParameters [?Yield,?Await]
FormalParameters_[Yield,Await]:
    [empty]
    FunctionRestParameter [?Yield, ?Await]
    FormalParameterList [?Yield, ?Await]
    FormalParameterList [?Yield, ?Await] ,
    FormalParameterList [?Yield, ?Await] , FunctionRestParameter [?Yield,?Await]
FormalParameterList [Yield,Await]:
    FormalParameter [?Yield,?Await]
    FormalParameterList [?Yield,?Await] , FormalParameter [?Yield,?Await]
FunctionRestParameter [Yield,Await]:
    BindingRestElement [?Yield,?Await]
FormalParameter [Yield, Await]:
    BindingElement [?Yield,?Await]
*** Static Semantics: Early Errors
UniqueFormalParameters : FormalParameters
. 如果FormalParameters的BoundNames含有任何重复的元素，那么是SyntaxError。

FormalParameters : FormalParameterList
. 如果FormalParameterList的IsSimpleParameteredList是fasle而且FormalParameterList的
  BoundNames含有任何重复元素，那么是SyntaxError。
**** 注意 只有在非严格模式下的用简单参数列表声明的函数，
           其FormalParameterList中可以出现相同的BindingIdentifier
*** Static Semantics: ContainsExpression
ObjectBindingPattern:
    { }
    { BindingRestProperty }
1. 返回false

ObjectBindingPattern : { BindingPropertyList , BindingRestProperty }
1. 返回BindingPropertyList的ContainsExpression

ArrayBindingPattern : [ Elision_opt ]
1. 返回false

ArrayBindingPattern : [ Elision_opt BindingRestElement ]
1. 返回BindingRestElement的ContainsExpression.

ArrayBindingPattern : [ BindingElementList , Elision_opt ]
1. 返回BindingElementList的ContainsExpression.

ArrayBindingPattern : [ BindingElementList , Elision_opt BindingRestElement ]
1. 让has是BindingElementList的ContainsExpression。
2. 如果has是true，返回true。
3. 返回BindingRestElement的ContainsExpression。

BindingPropertyList : BindingPropertyList , BindingProperty
1. 让has是BindingPropertyList的ContainsExpression。
2. 如果has是true，返回true。
3. 返回BindingProperty的ContainsExpression。

BindingElementList : BindingElementList , BindingElisionElement
1. 让has是BindingElementList的ContainsExpression。
2. 如果has是true，返回true。
3. 返回BindingElisionElement的ContainsExpression。

BindingElisionElement : Elision_opt BindingElement
1. 返回BindingElement的ContainsExpression。

BindingProperty : PropertyName : BindingElement
1. 让has是PropertyName的IsComputedPropertyKey。
2. 如果has是true，返回true。
3. 返回BindingElement的ContainsExpression。

BindingElement : BindingPattern Initializer
1. 返回 true。

SingleNameBinding : BindingIdentifier
1. 返回 false。

SingleNameBinding : BindingIdentifier Initializer
1. 返回 true。

BindingRestElement : ... BindingIdentifier
1. 返回 false。

BindingRestElement : ... BindingPattern
1. 返回BindingPattern的ContainsExpression.

FormalParameters : [empty]
1. 返回 false。

FormalParameters : FormalParameterList , FunctionRestParameter
1. 如果FormalParameterList的ContainsExpression是true，返回 true。
2. 返回FunctionRestParameter的ContainsExpression。

FormalParameterList : FormalParameterList , FormalParameter
1. 如果FormalParameterList的ContainsExpression是true，返回 true。
2. 返回FormalParameter的ContainsExpression。

ArrowParameters : BindingIdentifier
1. 返回 false。

ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList
1. 让formals是CoverParenthesizedExpressionAndArrowParameterList的CoveredFormalsList。
2. 返回formals的ContainsExpression。

AsyncArrowBindingIdentifier : BindingIdentifier
1. 返回 false。
*** Static Semantics: IsSimpleParameterList
BindingElement : BindingPattern
1. 返回 false。

BindingElement : BindingPattern Initializer
1. 返回 false。

SingleNameBinding : BindingIdentifier
1. 返回 true。

SingleNameBinding : BindingIdentifier Initializer
1. 返回 false。

FormalParameters : [empty]
1. 返回 true。

FormalParameters : FunctionRestParameter
1. 返回 false。

FormalParameters : FormalParameterList , FunctionRestParameter
1. 返回 false。

FormalParameterList : FormalParameterList , FormalParameter
1. 如果FormalParameterList的IsSimpleParameterList是false, 返回false。
2. 返回FormalParameter的IsSimpleParameterList。

FormalParameter : BindingElement
1. 返回BindingElement的IsSimpleParameterList。

ArrowParameters : BindingIdentifier
1. 返回 true。

ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList
1. 让formals是CoverParenthesizedExpressionAndArrowParameterList的CoveredFormalsList。
2. 返回 formals的IsSimpleParameterList。

AsyncArrowBindingIdentifier_[Yield] : BindingIdentifier_[?Yield, +Await]
1. 返回 true。

CoverCallExpressionAndAsyncArrowHead : MemberExpression Arguments
1. 让head是CoverCallExpressionAndAsyncArrowHead的CoveredAsyncArrowHead。
2. 返回 head的IsSimpleParameterList。
*** Static Semantics: HasInitializer
BindingElement : BindingPattern
1. 返回 false。

BindingElement : BindingPattern Initializer
1. 返回 true。

SingleNameBinding : BindingIdentifier
1. 返回 false。

SingleNameBinding : BindingIdentifier Initializer
1. 返回 true。

FormalParameterList : FormalParameterList , FormalParameter
1. 如果FormalParameterList的HasInitializer是true，返回 true。
2. 返回 FormalParameter的HasInitializer。
*** Static Semantics: ExprectedArgumentCount
FormalParameters :
    [empty]
    FunctionRestParameter
1. 返回 0。

FormalParameters : FormalParameterList , FunctionRestParameter
1. 返回 FormalParameterList的ExpectedArgumentCount。
<<<<<<< Updated upstream
**** 注意 FormalParameterList的ExprectedArgumentCount就是左侧有剩余参数或者
           带初始化的第一个FormalParameter的FormalParameters的数量。不带初
           始化的FromalParameter允许在带初始化的第一个参数之后，但是这些
           参数被认为使用了undefined作为默认值。

FormalParameterList : FormalParameter
1. 如果FormalParameter的HasInitializer是true, 返回0.
2. 返回1.

FormalParameterList : FormalParameterList , FormalParameter
1. 让count是FormalParameterList的ExpectedArgumentCount。
2. 如果FormalParameterList的HasInitializer是true，或者FormalParameter的HasInitializer是true，
   返回count。
3. 返回count + 1。

ArrowParameters : BindingIdentifier
1. 返回1。

ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList
1. 让formals是CoverParenthesizedExpressionAndArrowParameterList的CoveredFormalsList.
2. 返回formals的ExpectedArgumentCount.

PropertySetParameterList : FormalParameter
1. 如果FormalParameter的HasInitializer是true, 返回0.
2. 返回1.

AsyncArrowBindingIdentifier : BindingIdentifier
1. 返回1.
** Function Definitions
*** Syntax
FunctionDelcaration_[Yield, Await, Default] :
    function BindingIdentifier_[?Yield, ?Await] ( FormalParameters_[~Yield, ~Await] ) {
        FunctionBody_[~Yield, ~Await] }
    [+Default] function( FormalParameters_[~Yield, ~Await] ) { FunctionBody_[~Yield, ~Await] }
FunctionExpression :
    function BindingIdentifier_[~Yield, ~Await]_opt ( FormalParameters_[~Yield, ~Await])  {
        FunctionBody_[~Yield, ~Await] }
FunctionBody_[Yield, Await] :
    FunctionStatementList_[~Yield, ~Await]
FunctionStatementList_[Yield, Await] :
    StatementList_[?Yield, ?Await, +Return]_opt
*** Static Semantics: Early Error
FunctionDeclaration :
    function BindingIdentifier ( FormalParameters ) { FunctionBody }
    function ( FormalParameters ) { FunctionBody }
FunctionExpression :
    function BindingIdentifier_opt { FormalParameters ) { FunctionBody }
. 如果匹配到FormalParameters的源代码是严格模式代码，需要应用UniqueFormalParameters : FormalParameters
  的EarlyError的规则
. 存在BndingIdentifier，而且匹配BindingIdentifier的源码是严格模式代码，如果BindingIdentifier的
  StringValue是"eval"或者“arguments”，那么有SyntaxError。
. 如果FunctionBody的FunctionBodyContainsUseStrict是true而且FormalParameters的IsSimpleParameterList
  是false，那么是SyntaxError。
. 如果FormalParameters的BoundNames有任何元素出现在FunctionBody的LexicallyDeclaredNames，
  那么有SyntaxError。
. 如果FormalParameters包含SuperProperty是true，那么有SyntaxError。
. 如果FunctionBody包含SuperProperty是true，那么有SyntaxError。
. 如果FormalParameters包含SuperCall是true，那么有SyntaxError。
. 如果FunctionBody包含SuperCall是true，那么有SyntaxError。
**** 注意 FunctionBody的LexicallyDelcaredNames不包含用var定义的IdentifierBound或者函数声明。
FunctionBody : FunctionStatementList
. 如果FunctionStatementList的LexicallyDelcaredNames含有重复的实体，那么是SyntaxError。
. 如果FunctionStatementList的LexicallyDelcaredNames的任何元素也出现在FunctionStatementList的
  VarDeclaredNames，那么是SyntaxError。
. 如果FunctionStatementList的带<<>>参数的ContainsDuplicateLabels是true，那么是SyntaxError。
. 如果FunctionStatementList的带<<>>参数的ContainsUndefinedBreakTarget是true，那么是SyntaxError。
. 如果FunctionStatementList的带<<>>和<<>>参数的ContainsUndefinedContinueTarget含有重复的实体，
  那么是SyntaxError。
*** Static Semantics: FunctionBodyContainsUseStrict
FunctionBody : FuncitonStatementList
1. 如果FunctionBody的DrectivePrologue含有UseStrictDirective，返回true。否则返回false。
*** Runtime Semantics: EvaluateFunctionBody
带参数FunctionObject和argumentsList（List类型）
FunctionBody : FunctionStatementList
1. 执行 ?FunctionDeclarationInstantiation(functionObject, argumentsList)。
2. 返回评估FuncitonStatementList的结果。
*** Runtime Semantics: InstantiateOrdinaryFunctionObject
带参数scope
FunctionDeclaration : function BindingIdentifier ( FormalParameters ) { FunctionBody }
1. 让name是BindingIdentifier的StringValue
2. 让sourceText是FunctionDeclaration对应的源代码
3. 让F是OrdinaryFunctionCreate(%Function.prototype%, sourceText, FormalParameters, FunctionBody,
   non-lexical-this, scope)的结果
4. 执行SetFunctionName(F, name)
5. 执行MakeConstructor(F)
6. 返回F

FunctionDeclaration : Function (FormalParameters ) { FunctionBody }
1. 让sourceText是FunctionDeclaration对应的源代码
2. 让F是OrdinaryFunctionCreate(%Function.prototype%, sourceText, FormalParameters, FunctionBody,
   non-lexical-this, scope)的结果
3. 执行SetFunctionName(F, "default")
4. 执行MakeConstructor(F)
5. 返回F
**** 注意 匿名的FunctionDeclaration仅会出现在export default声明的组成里，因此其函数代码也总是严格模式代码。
*** Runtime Semantics: InstantiateOrdinaryFunctionExpression
带可选参数name
FunctionExpression : function ( FormalParameters ) { FunctionBody }
1. 如果name不存在，置name为“”
2. 让scope是运行时执行背景的LexicalEnvironment
3. 让sourceText是FunctionDeclaration对应的源代码
4. 让closure是OrdinaryFunctionCreate(%Function.prototype%, sourceText, FormalParameters, FunctionBody,
   non-lexical-this, scope)的结果
5. 执行SetFunctionName(closure, "default")
6. 执行MakeConstructor(closure)
7. 返回closure

FunctionExpression : function BindingIdentifier ( FormalParameters ) { FunctionBody }
1. Assert：name不存在。
2. 让name是BindingIdentifier的StringValue
3. 让scope是运行时执行背景的LexicalEnvironment
4. 让funcEnv是NewDeclarativeEnvironment(scope)的结果
5. 执行funcEnv.CreateImmutableBinding(name, false)
6. 让sourceText是FunctionExpression对应的源代码
7. 让closure是OrdinaryFunctionCreate(%Function.prototype%, sourceText, FormalParameters, FunctionBody,
   non-lexical-this, funcEnv)的结果
8. 执行SetFunctionName(closure, name)
9. 执行MakeConstructor(closure)
10. 执行funcEnv.InitializeBinding(name, closure)
11. 返回closure。
**** 注意 在FunctionExpression里的BindingIdentifier可以在FunctionExpression的FunctionBody内被
         引用到，以便与能够递归调用自身。然后不同于在FunctionDeclaration，这个FunctionExpression里的
         BindingIdentifier不能影响包围这个FunctionExpression的圈，也不能被其引用到。
*** Runtime Semantics: Evaluation
FunctionDeclaration : fucntion BindingIdentifier ( FormalParameters ) { FunctionBody }
1. 返回NormalCompletion(empty)
**** 注意 在B.3.3中提供了被选语义
FunctionDeclaration : function ( FormalParameters ) { FunctionBody }
1. 返回NormalCompletion(empty)

FunctionExpression : function BindingIdentifier_opt ( FormalParameters ) { FunctionBody }
1. 返回FunctionExpression的InstantiateOrdianaryFunctionExpression
**** 注意 "prototype"性质是在用FunctionDeclaration或FunctionExpression定义函数时自动创建的，以便与
         将来用作构造器。
FunctionStatementList : [empty]
1. 返回NormalCompletion(undefined)
** Arrow Function Definitions
*** Syntax
ArrowFunction_[In, Yield, Await] :
    ArrowParameters_[?Yield, ?Await] [no LineTerminator here] => ConciseBody_[?In]
ArrwoFunction_[?Yield, Await] :
    BindingIdentifier_[?Yield, ?Await]
    CoverParenthesizedExpressionAndArrowParameterList_[?Yield, ?Await]
ConciseBody_[In] :
    [lookahead ≠ \{] ExpressionBody_[?In,~Await]
    { FuncitonBody_[~Yield, ~Await] }
ExpressionBody_[In, Await] :
    AssignmentExpression_[?In, ~Yield, ?Await]
*** Supplemental Syntax
在处理码型
ArrowParameters_[Yield, Await] : ConverParenthesizedExpressionAndArrowParameterList_[?Yield, ?Await]的
实例时，CoverParenthesizedExpressionAndArrowParameterList的翻译行为被优化为下列语法：
ArrowFormalParameters_[Yield, Await] :
    ( UniqueFormalParameters_[?Yield, ?Await] )
*** Static Semantics: Early Errors
ArrowFunction : ArrowParameters => ConciseBody
. 如果ArrowParameters含有YieldExpression，那么有SyntaxError。
. 如果ArrowParameters含有AwaitExpression，那么有SyntaxError。
. 如果ConciseBody的ConciseBodyContainsUseStrict是true，且ArrowParameters的IsSimpleParameterList是false，
  那么有SyntaxError。
. 如果ArrowParameters的BoundNames的任何元素也出现在ConciseBody的LexicallyDeclaredNames里，那么有SyntaxError。

ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList
. 如果CoverParenthesizedExpressionAndArrowParameterList不是ArrowFormalParameters，那么有SyntaxError
. 所有ArrowFormalParameters和其派生码型的早期错误规则也适用于
  CoverParenthesizedExpressionAndArrowParameterList的CoveredFormalsList
*** Static Semantics: ConciseBodyContainsUseSctrict
ConciseBody : ExpressionBody
1. 返回false。

Concisebody : { FunctionBody }
1. 返回FunctionBody的FunctionBodyContainsUseStrict
*** Static Semantics: CoveredFormalsList
ArrowParameters : BindingIdentifier
1. 返回这个ArrowParameters

CoverParenthesizedExpressionAndArrowParameterList :
    ( Expression )
    ( Expression , )
    ( )
    ( ... BindingIdentifier )
    ( ... BindingPattern )
    ( Expression, ... BindingIdentifier )
    ( Expression, ... BindingPattern )
1. 返回被CoverParenthesizedExpressionAndArrowParameterList包装的ArrowPrmalParameters
*** Runtime Semantics: EvaluateConciseBody
带参数functionObject和argumentList（List类型）
ConciseBody : ExpressionBody
1. 执行?FunctionDeclarationInstantiation(functionObject, argumentList)
2. 返回评估ExpressionBody的结果。
*** Runtime Semantics: InstantiateArrowFunctionExpression
带可选参数name
ArrowFunction : ArrowParameters => ConciseBody
1. 如果name不存在，置name为“”
2. 让scope是运行时执行背景的LexicalEnvironment
3. 让sourceText是ArrowFunction对应的源代码
4. 让parameters是ArrowParameters的CoveredFormalList
5. 让closure是OrdinaryFunctionCreate(%Function.prototype%, sourceText, parameters, ConciseBody,
   lexical-this, scope)的结果。
6. 执行SetFunctionName(closure, name)
7. 返回closure
**** 注意 ArrowFunction不会定义方法内的arguments、super、this和new.target。所以ArrowFunction内的
         arguments、super、this和new.target引用都必须解释为外围的词法环境上的绑定。通常this会是包含
         这个函数的的最近的FunctionEnvironment。即使ArrowFunction可能含有到super的引用，在步骤5创建
         的函数对象也不会被通过执行MakeMethod来放到方法里。含有super引用的ArrowFunction总是包含在
         非ArrowFunction里，这样实现super的必要状态可以通过被ArrowFunction的函数对象捕获的圈来访问到。
*** Runtime Semantics: Evaluation
ArrowFunction : ArrowParameters => ConciseBody
1. 返回Arrowfunction的InstantiateArrowFunctionExpression

ExpressionBody : AssignmentExpression
1. 让exprRef是评估AssignmentExpression的结果
2. 让exprValue是?GetValue(exprRef)
3. 返回Completion { \[\[Type]]:return, \[\[Value]]:exprValue, \[\[Target]]:empty }
** Method Definitions
*** Syntax
MethodDefinition_[Yield, Await] :
    PropertyName_[?Yield, ?Await] ( UniqueFormalParamters_[~Yield, ~Await] ) {
        FunctionBody_[~Yield, ~Await] }
    GeneratorMethod_[?Yield, ?Await]
    AsyncMethod_[?Yield, ?Await]
    AsyncGeneratorMethod_[?Yield, ?Await]
    get PropertyName_[?Yield, ?Await] ( ) { FunctionBody_[?Yield, ?Await] }
    set PropertyName_[?Yield, ?Await] ( PropertySetParameterList ) { FunctionBody_[?Yield, ?Await] }
PropertySetParameterList :
    FormalParameter_[?Yield, ~Await]
*** Static Semantics: Early Errors
MethodDefinition : PropertyName ( UniqueFormalParameters ) { FunctionBody }
. 如果FunctionBody的FunctionBodyContainsUseStrict是true，而且UniqueFormalParameters的
  IsSimpleParameterList是false，那么是SyntaxError
. 如果UniqueFormalParameters的BoundNames的元素出现在FunctionBody的LexicallyDeclaredNames中，那么
  是SyntaxError

MethodDefinition : set PropertyName ( PropertySetParameterList ) { FunctionBody }
. 如果PropertySetParameterList的BoundNames含有任何重复的元素，那么是SyntaxError
. 如果FunctionBody的FunctionBodyContainsUseStrict是true，而且PropertySetParameterList的
  IsSimpleParameterList是false，那么是SyntaxError。
. 如果PropertySetParameterList的BoundNames的元素出现在FunctionBody的LexicallyDeclaredNames，
  那么是SyntaxError。
*** Static Semantics: HasDirectSuper
MethodDefinition : PropertyName ( UniqueFormalParameters ) { FunctionBody }
1. 如果UniqueFormalParameters含有SuperCall是true，那么返回true。
2. 返回FunctionBody含有SuperCall。

MethodDefinition : get PropertyName ( ) { FunctionBody }
1. 返回FunctionBody含有SuperCall。

MethodDefinition : set PropertyName ( PropertySetParameterList ) { FunctionBody }
1. 如果PropertySetParameterList含有SuperCall是true，那么返回true。
2. 返回FunctionBody含有SuperCall。

GeneratorMethod : * PropertyName ( UniqueFormalParameters ) { GeneratorBody }
1. 如果UniqueFormalParameters含有SuperCall是true，那么返回true。
2. 返回GeneratorBody含有SuperCall。

AsyncGeneratorMethod : async * PropertyName ( UniqueFormalParameters ) { AsyncGeneratorBody }
1. 如果UniqueFormalParameters含有SuperCall是true，那么返回true。
2. 返回AsyncGeneratorBody含有SuperCall。

AsyncMethod : async PropertyName ( UniqueFormalParameters ) { AsyncFunctionBody }
1. 如果UniqueFormalParameters含有SuperCall是true，那么返回true。
2. 返回AsyncFunctionBody含有SuperCall。
*** Static Semantics: SpecialMethod
MethodDefinition : PropertyName ( UniqueFormalParameters ) { FunctionBody }
1. 返回false

MethodDefinition :
    GeneratorMethod
    AsyncMethod
    AsyncGeneratorMethod
    get PropertyName ( ) { FunctionBody }
    set PropertyName ( PropertySetParameterList ) { FunctionBody }
1. 返回true
*** Runtime Semantics: DefineMethod
带参数object和可选参数functionPrototype
MethodDefinition : PropertyName ( UniqueFormalParameters ) { FunctionBody }
1. 让propKey是评估PropertyName的结果
2. ReturnIfAbrupt(propKey)
3. 让scope是运行时执行背景的LexicalEnvironment
4. 如果functionPrototype存在，那么
    a. 让prototype是functionPrototype
5. 否则
    a. 让prototype是%Function.prototype%
6. 让sourceText是本MethodDeifinition匹配到的源文本
7. 让closure是OrdinaryFunctionCreate(prototype, sourceText, UniqueFormalParameters,
   FunctionBody, non-lexical-this, scope)的结果
8. 执行MakeMethod(closure, object)
9. 返回Record { \[\[Key\]\]:propKey, \[\[Closure\]\]: closure }
*** Runtime Semantics: MethodDefinitionEvaluation
待参数object和enumerable

MethodDefinition : PropertyName ( UniqueFormalParameters ) { FunctionBody }
1. 让methodDef是MethodDefinition带object参数的?DefinitionMethod结果
2. 执行SetFunctionName(methodDef.\[\[Closure\]\], methodDef.\[\[Key\]\])
3. 让desc是PropertyDescriptor { \[\[Value\]\]:methodDef.\[\[Closure\]\],
   \[\[Writable]]:true, \[\[Enumerable]]:enumerable, \[\[Configurable]]:true }。
4. 返回?DefinePropertyOrThrow(object, methodDef.\[\[Key]], desc)

MethodDefinition : get PropertyName ( ) { FunctionBody }
1. 让propKey是评估PropertyName的结果
2. ReturnIfAbrupt(propKey)
3. 让scope是运行时执行背景的LexicalEnvironment
4. 让sourceText是本MethodDeifinition匹配到的源文本
5. 让formalParameterList是一个FormalParameters : [empty]码型的实例。
6. 让closure是OrdinaryFunctionCreate(%Function.prototype%, sourceText,
   formalParameterList, FunctionBody, non-lexical-this, scope)的结果
7. 执行MakeMethod(closure, object)
8. 执行SetFunctionName(closure, propKey, "get")
9. 让desc是PropertyDescriptor { \[\[Get\]\]: closure, \[\[Enumerable]]:enumerable,
   \[\[Configurable]]:true }。
10. 返回?DefinePropertyOrThrow(object,  propKey, desc)

MethodDefinition : set PropertyName ( PropertySetParameterList ) { FunctionBody }
1. 让propKey是评估PropertyName的结果
2. ReturnIfAbrupt(propKey)
3. 让scope是运行时执行背景的LexicalEnvironment
4. 让sourceText是本MethodDeifinition匹配到的源文本
5. 让closure是OrdinaryFunctionCreate(%Function.prototype%, sourceText,
   PropertySetParameterList, FunctionBody, non-lexical-this, scope)的结果
6. 执行MakeMethod(closure, object)
7. 执行SetFunctionName(closure, propKey, "set")
8. 让desc是PropertyDescriptor { \[\[Get\]\]: closure, \[\[Enumerable]]:enumerable,
   \[\[Configurable]]:true }。
9. 返回?DefinePropertyOrThrow(object,  propKey, desc)

GeneratorMethod : * PropertyName ( UniqueFormalParameters ) { GeneratorBody }
1. 让propKey是评估PropertyName的结果
2. ReturnIfAbrupt(propKey)
3. 让scope是运行时执行背景的LexicalEnvironment
4. 让sourceText是本GeneratorMethod匹配到的源文本
5. 让closure是OrdinaryFunctionCreate(%GeneratorFunction.prototype%, sourceText,
   UniqueFormalParameters, GeneratorBody, non-lexical-this, scope)的结果
6. 执行MakeMethod(closure, object)
7. 执行SetFunctionName(closure, propKey)
8. 让prototype是!OrdinaryObjectCreate(%GeneratorFunction.prototype.prototype%)
9. 执行DefinePropertyOrThrow(closure, "prototype", PropertDescriptor {
   \[\[Value]]:prototype, \[\[Writable]]:true, \[\[Enumerable]]: false,
   \[\[Configurable]]: false, }
10. 让desc是PropertyDescriptor { \[\[Value]]:closure, \[\[Writable]]:true,
    \[\[Enumerable]]:enumerable, \[\[Configurable]]: true, }
11. 返回?DefinePropertyOrThrow(object, propKey, desc)

AsyncGeneratorMethod : async * PropertyName ( UniqueFormalParameters ) { AsyncGeneratorBody }
1. 让propKey是评估PropertyName的结果
2. ReturnIfAbrupt(propKey)
3. 让scope是运行时执行背景的LexicalEnvironment
4. 让sourceText是本AsyncGeneratorMethod匹配到的源文本
5. 让closure是OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, sourceText,
   UniqueFormalParameters, AsyncGeneratorBody, non-lexical-this, scope)的结果
6. 执行MakeMethod(closure, object)
7. 执行SetFunctionName(closure, propKey)
8. 让prototype是!OrdinaryObjectCreate(%AsyncGeneratorFunction.prototype.prototype%)
9. 执行DefinePropertyOrThrow(closure, "prototype", PropertDescriptor {
   \[\[Value]]:prototype, \[\[Writable]]:true, \[\[Enumerable]]: false,
   \[\[Configurable]]: false, }
10. 让desc是PropertyDescriptor { \[\[Value]]:closure, \[\[Writable]]:true,
    \[\[Enumerable]]:enumerable, \[\[Configurable]]: true, }
11. 返回?DefinePropertyOrThrow(object, propKey, desc)

AsyncMethod : async PropertyName ( UniqueFormalParameters ) { AsyncFunctionBody }
1. 让propKey是评估PropertyName的结果
2. ReturnIfAbrupt(propKey)
3. 让scope是运行时执行背景的LexicalEnvironment
4. 让sourceText是本AsyncMethod匹配到的源文本
5. 让closure是OrdinaryFunctionCreate(%AsyncFunction.prototype%, sourceText,
   UniqueFormalParameters, GeneratorBody, non-lexical-this, scope)的结果
6. 执行MakeMethod(closure, object)
7. 执行SetFunctionName(closure, propKey)
8. 让desc是PropertyDescriptor { \[\[Value]]:closure, \[\[Writable]]:true,
   \[\[Enumerable]]:enumerable, \[\[Configurable]]: true, }
9. 返回?DefinePropertyOrThrow(object, propKey, desc)
** Generator Function Definitions
*** Syntax
GeneratorMethod_[Yield, Await] :
    * Property_[?Yield, ?Awati] ( UniqueFormalParameters_[+Yield, ~Await] ) { GeneratorBody }
GeneratorDeclaration_[Yield, Await, Default] :
    function * BindingIdentifier_[?Yield, ?Awati] ( FormalParameters_[+Yield, ~Await] ) { GeneratorBody }
    [+Default]_function * ( FormalParameters_[+Yield, ~Await] ) { GeneratorBody }
GeneratorExpression :
    function * BindingIdentifier_[?Yield, ?Awati]_opt ( FormalParameters_[+Yield, ~Await] ) { GeneratorBody }
GeneratorBody :
    FunctionBody_[+Yield, ~Await]
YieldExpression_[In, Await]
    yield
    yield [no LineTerminator here] AssignmentExpression_[?In, +Yield, ?Await]
    yield [no LineTerminator here] * AssignmentExpression_[?In, +Yield, ?Await]
**** 注意1 紧随yield后的句法背景需要使用InputElementRegExpOrTemplateTail词法目标。
**** 注意2 YieldExpression不能用在GeneratorFunction的FormalParameters里，因为
            FormalParamters里的任何表达式都是在生成器对象处于可恢复状态前
            进行评估
**** 注意3 跟生成器对象相关的抽象操作在27.5.3里定义
*** Static Semantics: Early Errors
GeneratorMethod : * PropertyName ( UniqueFormalParamters ) { GeneratorBody }
. 如果GeneratorMethod的HasDirectSuper是true，那么有SyntaxError。
. 如果UniqueFormalParameters包含YieldExpression，那么有SyntaxError
. 如果GeneratorBody的FunctionBodyContainsUseStrict是true，而且
  UniqueFormalParameters的IsSimpleParameterList是false，那么有SyntaxError
. 如果UniqueFormalParameters的BoundNames的任何元素也出现在GeneratorBody的
  LexicallyDeclaredNames里，那么有SyntaxError。

GeneratorDeclaration :
    function * BindingIdentifier ( FormalParameters ) { GeneratorBody }
    function * ( FormalParameters ) { GeneratorBody }
GeneratorExpression :
    function * BindingIdentifier_opt ( FormalParameters ) { GeneratorBody }
. 如果FormalParameters匹配的源代码是严格模式代码，则应用
  UniqueFormalParameters : FormalParameters的早期错误规则。
. 如果BindingIdentifer存在，而且BindingIdentifier匹配的源代码是严格模式代码，
  则当BindingIdentifier的String值是eval或者arguments时，就是SyntaxError。
. 如果GeneratorBody的FunctionBodyContainsUseStrict是true，而且FormalParameterList
  的IsSimpleParameterList是false，那么有SyntaxError。
. 如果FormalParameters的BoundName的任何元素也出现在GeneratorBody的
  LexicallyDeclaredNames里，那么有SyntaxError
. 如果FormalParameters包含YieldExpression，那么有SyntaxError。
. 如果FormalParameters包含SuperProperty，那么有SyntaxError。
. 如果GeneratorBody包含SuperProperty，那么有SyntaxError。
. 如果FormalParameters包含SuperCall，那么有SyntaxError。
. 如果GeneratorBody包含SuperCall，那么有SyntaxError。
*** Runtime Semantics: EvaluateGeneratorBody
带参数functionObject和argumentList（List值）
GeneratorBody : FucntionBody
1. 执行?FunctionDeclarationInstantiation(functionObject, argumentList)
2. 让G是?OrdinaryCreateFromConstructor(functionObject,
   "%GeneratorFunction.prototype.prototype%", <<\[\[GeneratorState]],
   \[\[GeneratorContext]], \[\[GeneratorBand]]>>)
3. 置G.\[\[GeneratorBrand]]是空
4. 执行GeneratorStart(G, FunctionBody)
5. 返回 Completion { \[\[Type]]:return, \[\[Value]]:G, \[\[Target]]:empty }
*** Runtime Semantics: InstantiateGeneratorFunctionObject
带参数scope
GeneratorDeclaration : function * BindingIdentifier ( FormalParamters ) { GeneratorBody }
1. 让name是BindingIdentifer的String值
2. 让sourceText是GeneratorDeclaration匹配的源文本
3. 让F是OrdinaryFunctionCreate(%GeneratorFunction.prototype%, sourceText,
   FormalParameters, GeneratorBody, non-lexical-this, scope)
4. 执行SetFunctionName(F, name)
5. 让prototype是!OrdinaryObjectCreate(%GeneratorFunction.prototype.prototype%)
6. 执行DefinePropertyOrThrow(F, "prototype", PropertyDescriptor {
   \[\[Value]]:prototype, \[\[Writable]]:true, \[\[Enumerable]]:false,
   \[\[Configurable]]:true, }
7. 返回F

GeneratorDeclaration : function * ( FormalParameters ) { GeneratorBody }
1. 让sourceText是GeneratorDeclaration匹配的源文本
2. 让F是OrdinaryFunctionCreate(%GeneratorFunction.prototype%, sourceText,
   FormalParameters, GeneratorBody, non-lexical-this, scope)
3. 执行SetFunctionName(F, "default")
4. 让prototype是!OrdinaryObjectCreate(%GeneratorFunction.prototype.prototype%)
5. 执行DefinePropertyOrThrow(F, "prototype", PropertyDescriptor {
   \[\[Value]]:prototype, \[\[Writable]]:true, \[\[Enumerable]]:false,
   \[\[Configurable]]:true, }
6. 返回F
**** 注意 匿名的GeneratorDeclaration仅会在export default声明里出现，必然是
          严格模式代码。
*** Runtime Semantics: InstantiateGeneratorFunctionExpression
带可选参数name
GeneratorExpression : funciton * ( FormalParameters ) { GeneratorBody }
1. 如果name不存在，置name是""
2. 让scope是运行时执行背景的LexicalEnvironment
3. 让sourceText是本GeneratorExpression匹配到的源文本
4. 让closure是OrdinaryFunctionCreate(%GeneratorFunction.prototype%, sourceText,
   FormalParameters, GeneratorBody, non-lexical-this, scope)的结果
5. 执行SetFunctionName(closure, name)
6. 让prototype是!OrdinaryObjectCreate(%GeneratorFunction.prototype.prototype%)
7. 执行DefinePropertyOrThrow(closure, "prototype", PropertDescriptor {
   \[\[Value]]:prototype, \[\[Writable]]:true, \[\[Enumerable]]: false,
   \[\[Configurable]]: false, }
8. 返回closure

GeneratorExpression : function * BindingIdentifier ( FormalParameters ) { GeneratorBody }
1. Assert：name不存在
2. 让name是BindingIdentifer的String值
3. 让scope是运行时执行背景的LexicalEnvironment
4. 让funcEnv是NewDeclarativeEnvironment(scope)
5. 执行funcEnv.CreateImmutableBinding(name, false)
6. 让sourceText是本GeneratorExpression匹配到的源文本
7. 让closure是OrdinaryFunctionCreate(%GeneratorFunction.prototype%, sourceText,
   FormalParameters, GeneratorBody, non-lexical-this, funcEnv)的结果
8. 执行SetFunctionName(closure, name)
9. 让prototype是!OrdinaryObjectCreate(%GeneratorFunction.prototype.prototype%)
10. 执行DefinePropertyOrThrow(closure, "prototype", PropertDescriptor {
    \[\[Value]]:prototype, \[\[Writable]]:true, \[\[Enumerable]]: false,
    \[\[Configurable]]: false, }
11. 执行funcEnv.InitializeBinding(name, closure)
12. 返回closure
**** 注意 在GeneratorExpression里的BindingIdentifier能被GeneratorExpression的
           FunctionBody引用到来允许生成器代码可以自我递归。然而不同于
           GeneratorDeclaration，GeneratorExpression的BindingIdentifier不能干涉
           封闭GeneratorExpression的圈。
*** Runtime Semantics: Evaluation
GeneratorExpression : funciton * BindingIdentifier_opt ( FormalParameters ) { GeneratorBody }
1. 返回GeneratorExpression的InstantiateGeneratorFunctionExpression

YieldExpression : yield
1. 返回 ?Yield(undefined)

YieldExpression : yield AssignmentExpression
1. 让exprRef是评估AssigmentExpression的结果
2. 让value是?GetValue(exprRef)
3. 返回?Yied(value)

YieldExpression : yield * AssignmentExpression
1. 让generatorKind是!GetGeneratorKind()
2. 让exprRef是评估AssignmentExpression的结果
3. 让value是?GetValue(exprRef)
4. 让iteratorRecord是?GetIterator(value, generatorKind)
5. 让iterator是iteratorRecord.\[\[Iterator]]
6. 让received是NormalCompletion(undefined)
7. 重复
    a. 如果received.\[\[Type]]是normal，那么
        i. 让innerResult是?Call(iteratorRecord.\[\[NextMethod]],
           iteratorRecord.\[\[Iterator]], << received.\[\[Value]] >>)
       ii. 如果generatorKind是async，置innerResult是?Await(innerResult)
      iii. 如果Type(innerResult)不是Object，投掷TypeError异常
       iv. 让done是?IteratorComplete(innerResult)
        v. 如果done是true，那么
            1. 返回?IteratorValue(innerResult)
       vi. 如果generatorKind是async，置received是
           AsyncGeneratorYield(?IteratorValue(innerResult))
      vii. 否则，置received是GeneratorYield(innerResult)
    b. 否则如果received.\[\[Type]]是trhow，那么
        i. 让throw是?GetMethod(iterator, "throw")
       ii. 如果throw不是undefined，那么
            1. 让innerResult是?Call(throw, iterator, << received.\[\[Value]] >>)
            2. 如果generatorKind是async，置innerResult是?Await(innerResult)
            3. 注意：从内层遍历器的throw方法来的异常是被传播的。从内层
               throw方法来的Normal完结当作内层的next一样处理
            4. 如果Type(innerResult)不是Object，投掷TypeError异常
            5. 让done是?IteratorComplete(innerResult)
            6. 如果done是true，那么
                a. 返回?IteratorValue(innerResult)
            7. 如果generatorKind是async，置received是
               AsyncGeneratorYield(?IteratorValue(innerResult))
            8. 否则，置received是GeneratorYield(innerResult)
      iii. 否则
            1. 注意：如果iterator没有throw方法，那么throw会结束yield*循环。但是
               首先我们需要给iterator清理的机会。
            2. 让closeCompletion是Completion { \[\[Type]]:normal, \[\[Value]]:empty,
               \[\[Target]]:empty }
            3. 如果generatorKind是async，执行?AsyncIteratorClose(iteratorRecord,
               closeCompletion)
            4. 否则，执行?IteratorClose(iteratorRecord, closeCompletion)
            5. 注意：下一步会投掷一个TypeError来表明有一个违反yield*协议的
               地方：iterator没有throw方法
            6. 投掷TypeError异常
    c. 否则
        i. Assert：received.\[\[Type]]是return
       ii. 让return是?GetMethod(iterator, "return")
      iii. 如果return是undefined，那么
            1. 如果generatorKind是async，置received.\[\[Value]]是
               ?Await(received.\[\[Value]])
            2. 返回Completion(received)
       iv. 让innerReturnResult是?Call(return, iterator, << received.\[\[Value]] >>)
        v. 如果generatorKind是aysnc，置innerReturnResult是?Await(innerReturnResult)
       vi. 如果Type(innerReturnResult)不是Object， 投掷TypeError异常
      vii. 如果done是true，那么
            1. 让value是?IteratorValue(innerReturnResult)
            2. 返回Completion { \[\[Type]]:return, \[\[Value]]:value,
               \[\[Target]]:empty }
       ix. 如果generatorKind是async，置received是
           AsyncGeneratorYield(?IteratorValue(innerReturnResult))
        x. 否则，置received是GeneratorYield(innerReturnResult)
** Async Generator Function Definitions 
*** Syntax
AsyncGeneratorMethod_[Yield, Await] :
    async [no LineTerminator here] * PropertyName_[?Yield, ?Await] (
        UniqueFormalParameters_[+Yield, +Await] ) { AsyncGeneratorBody }
AsyncGeneratorDeclaration_[Yield, Await, Default] :
    async [no LineTerminator here] function * BindingIdentifier_[?Yield, ?Await] (
        FormalParameters_[+Yield, +Await] ) { AsyncGeneratorBody }
    [+Default]_async [no LineTerminator here] function * (
        FormalParameters_[+Yield, +Await] ) { AsyncGeneratorBody }
AsyncGeneratorExpression_[Yield, Await, Default] :
    async [no LineTerminator here] function * BindingIdentifier_[?Yield, ?Await]_opt (
        FormalParameters_[+Yield, +Await] ) { AsyncGeneratorBody }
AsyncGeneratorBody:
    FunctionBody_[+Yield, +Await]
**** 注意1 YieldExpression和AwaitExpresson不能出现在异步生成器函数的
            FormalParameters里，因为FormalParamters里的任何表达式都是在
            异步生成器对象处于可恢复状态前进行评估。
**** 注意2 跟异步生成器对象相关的抽象操作在27.6.3里定义
*** Static Semantics: Early Errors
AsyncGeneratorMethod : async * PropertyName ( UniqueFormalParameters ) { AsyncGeneratorBody }
. 如果AsyncGeneratorMethod的HasDirectSuper是true，那么有SyntaxError
. 如果UniqueFormalParameters含有YieldExpression，那么有SyntaxError
. 如果UniqueFormalParameters含有AwaitExpression，那么有SyntaxError
. 如果AsyncGeneratorBody的FunctionBodyContainsUseStrict是true，而且
  UniqueFormalParameters的IsSimpleParameterList是false，那么有SyntaxError。
. 如果UniqueFormalParameters的BoundNames的任何元素也出现在AsyncGeneratorBody的
  LexicallyDeclaredNames里，那么有SyntaxError。

AsyncGeneratorDeclaration :
    async function * BindingIdentifier ( FormalParameters ) { AsyncGeneratorBody }
    async function * ( FormalParameters ) { AsyncGeneratorBody }
AsyncGeneratorExpression :
    async function * BindingIdentifier_opt ( FormalParameters ) { AsyncGeneratorBody }
. 如果FormalParameters匹配的源代码是严格模式代码，则应用
  UniqueFormalParameters : FormalParameters的早期错误规则。
. 如果BindingIdentifer存在，而且BindingIdentifier匹配的源代码是严格模式代码，
  则当BindingIdentifier的String值是eval或者arguments时，就是SyntaxError。
. 如果AsyncGeneratorBody的FunctionBodyContainsUseStrict是true，而且
  FormalParameterList的IsSimpleParameterList是false，那么有SyntaxError。
. 如果FormalParameters的BoundName的任何元素也出现在AsyncGeneratorBody的
  LexicallyDeclaredNames里，那么有SyntaxError
. 如果FormalParameters包含YieldExpression，那么有SyntaxError。
. 如果FormalParameters包含AwaitExpression，那么有SyntaxError。
. 如果FormalParameters包含SuperProperty，那么有SyntaxError。
. 如果AsyncGeneratorBody包含SuperProperty，那么有SyntaxError。
. 如果FormalParameters包含SuperCall，那么有SyntaxError。
. 如果AsyncGeneratorBody包含SuperCall，那么有SyntaxError。
*** Runtime Semantics: EvaluateAsyncGeneratorBody
带参数functionObject和argumentList（List值）
AsyncGeneratorBody : FucntionBody
1. 执行?FunctionDeclarationInstantiation(functionObject, argumentList)
2. 让generator是?OrdinaryCreateFromConstructor(functionObject,
   "%AsyncGeneratorFunction.prototype.prototype%", <<\[\[AsyncGeneratorState]],
   \[\[AsyncGeneratorContext]], \[\[GeneratorBand]]>>)
3. 置generator.\[\[GeneratorBrand]]是空
4. 执行!AsyncGeneratorStart(generator, FunctionBody)
5. 返回 Completion { \[\[Type]]:return, \[\[Value]]:generator, \[\[Target]]:empty }
*** Runtime Semantics: InstantiateAsyncGeneratorFunctionObject
带参数scope
AsyncGeneratorDeclaration : async function * BindingIdentifier ( FormalParamters ) { AsyncGeneratorBody }
1. 让name是BindingIdentifer的String值
2. 让sourceText是AsyncGeneratorDeclaration匹配的源文本
3. 让F是!OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, sourceText,
   FormalParameters, AsyncGeneratorBody, non-lexical-this, scope)
4. 执行!SetFunctionName(F, name)
5. 让prototype是!OrdinaryObjectCreate(%AsyncGeneratorFunction.prototype.prototype%)
6. 执行DefinePropertyOrThrow(F, "prototype", PropertyDescriptor {
   \[\[Value]]:prototype, \[\[Writable]]:true, \[\[Enumerable]]:false,
   \[\[Configurable]]:true, }
7. 返回F

AsyncGeneratorDeclaration : async function * ( FormalParameters ) { AsyncGeneratorBody }
1. 让sourceText是AsyncGeneratorDeclaration匹配的源文本
2. 让F是OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, sourceText,
   FormalParameters, AsyncGeneratorBody, non-lexical-this, scope)
3. 执行SetFunctionName(F, "default")
4. 让prototype是!OrdinaryObjectCreate(%AsyncGeneratorFunction.prototype.prototype%)
5. 执行DefinePropertyOrThrow(F, "prototype", PropertyDescriptor {
   \[\[Value]]:prototype, \[\[Writable]]:true, \[\[Enumerable]]:false,
   \[\[Configurable]]:true, }
6. 返回F
**** 注意 匿名的AsyncGeneratorDeclaration仅会在export default声明里出现，必然是
          严格模式代码。
*** Runtime Semantics: InstantiateGeneratorFunctionExpression
带可选参数name
AsyncGeneratorExpression : async funciton * ( FormalParameters ) { AsyncGeneratorBody }
1. 如果name不存在，置name是""
2. 让scope是运行时执行背景的LexicalEnvironment
3. 让sourceText是本AsyncGeneratorExpression匹配到的源文本
4. 让closure是!OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, sourceText,
   FormalParameters, AsyncGeneratorBody, non-lexical-this, scope)的结果
5. 执行SetFunctionName(closure, name)
6. 让prototype是!OrdinaryObjectCreate(%AsyncGeneratorFunction.prototype.prototype%)
7. 执行!DefinePropertyOrThrow(closure, "prototype", PropertDescriptor {
   \[\[Value]]:prototype, \[\[Writable]]:true, \[\[Enumerable]]: false,
   \[\[Configurable]]: false, }
8. 返回closure

AsyncGeneratorExpression : async function * BindingIdentifier ( FormalParameters ) { AsyncGeneratorBody }
1. Assert：name不存在
2. 让name是BindingIdentifer的String值
3. 让scope是运行时执行背景的LexicalEnvironment
4. 让funcEnv是NewDeclarativeEnvironment(scope)
5. 执行!funEnv.CreateImmutableBinding(name, false)
6. 让sourceText是本AsyncGeneratorExpression匹配到的源文本
7. 让closure是!OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, sourceText,
   FormalParameters, AsyncGeneratorBody, non-lexical-this, funcEnv)的结果
8. 执行!SetFunctionName(closure, name)
9. 让prototype是!OrdinaryObjectCreate(%AsyncGeneratorFunction.prototype.prototype%)
10. 执行!DefinePropertyOrThrow(closure, "prototype", PropertDescriptor {
    \[\[Value]]:prototype, \[\[Writable]]:true, \[\[Enumerable]]: false,
    \[\[Configurable]]: false, }
11. 执行!funcEnv.InitializeBinding(name, closure)
12. 返回closure
**** 注意 在AsyncGeneratorExpression里的BindingIdentifier能被
           AsyncGeneratorExpression的AsyncFunctionBody引用到来允许生成器代码可以
           自我递归。然而不同于AsyncGeneratorDeclaration，AsyncGeneratorExpression
           的BindingIdentifier不能干涉封闭AsyncGeneratorExpression的圈。
*** Runtime Semantics: Evaluation
AsyncGeneratorExpression : async funciton * BindingIdentifier_opt ( FormalParameters ) { AsyncGeneratorBody }
1. 返回AsyncGeneratorExpression的InstantiateAsyncGeneratorFunctionExpression
** Class Definitions
*** Syntax
ClassDeclaration_[Yield, Await, Default]:
    class BindingIdentifier_[?Yield, ?Awati] ClassTail_[?Yield, ?Await]
    [+Default] class ClassTail_[?Yield, ?Await]
Class Expression_[Yield, Await] :
    class BindingIdentifier_[?Yield, ?Await]_opt ClassTail_[?Yield, ?Await]
ClassTail_[Yield, Await] :
    ClassHeritage_[?Yield, ?Await]_opt { ClassBody_[?Yield, ?Await]_opt }
ClassHeritage_[Yield, Await] :
    extends LeftHandSideExpression_[?Yield, ?Await]
ClassBody_[Yield, Await] :
    ClassElementList_[?Yield, ?Await]
ClassElementList_[Yield, Await] :
    ClassElement_[?Yield, ?Await]
    ClassElementList_[?Yield, ?Await] ClassElement_[?Yield, ?Await]
ClassElement_[Yield, Await] :
    MethodDefinition_[?Yield, ?Await]
    static MethodDefinition_[?Yield, ?Await]
    ;
**** 注意 class定义永远是严格模式代码
*** Static Semantics: Early Errors
ClassTail : ClassHeritage_opt { ClassBody }
. 如果ClassHeritage不存在，但是下列算法评估是true，那么有SyntaxError
    1. 让constructor是ClassBody的ConstructorMethod
    2. 如果constructor是空，返回false
    3. 返回constructor的HasDirectSuper

ClassBody : ClassElementList
. 如果ClassElementList的PrototypePropertyNameList含有超过一个constructor，那么
  有SyntaxError。

ClassElement : MethodDefinition
. 如果MethodDefinition的PropName不是constructor，而且MethodDeifnition的
  HasDirectSuper是true，那么有SyntaxError。
. 如果MethodDefinition的PropName是constructor，而且MethodDeifnition的
  SpecialMethod是true，那么有SyntaxError。

ClassElement : static MethodDefinition
. 如果MethodDefinition的HasDirectSuper是true，那么有SyntaxError。
. 如果MethodDefinition的PropName是prototype，那么有SyntaxError。
*** Static Semantics : ClassElementKind
ClassElemnt : MethodDefinition
1. 如果MethodDefinition的PropName是constructor，返回ConstructorMethod
2. 返回NoConstructorMethod

ClassElement : static MethodDeifnition
1. 返回NonConstructorMethod

ClassElement : ;
1. 返回空
*** Static Semantics : ConstructorMethod
ClassElementList : ClassElement
1. 如果ClassElement的ClassElementKind是ConstructorMethod，返回ClassElement
2. 返回空

ClassElementList : ClassElementList ClassElement
1. 让head是ClassElementList的ConstructorMethod。
2. 如果head不是空，返回head
3. 如果ClassElement的ClassElementKind是ConstructorMethod，返回ClassElement
4. 返回empty
**** 注意 EarlyError规则保证了只有一个方法定义叫constructor，而且它不是一个
           访问性质或者生成器定义。
*** Static Semantics : IsStatic
ClassElement : MethodDefinition
1. 返回false

ClassElement : static MethodDefinition
1. 返回true

ClassElement : ;
1. 返回false
*** Static Semantics : NonConstructorMethodDefinitions
ClassElementList : ClassElement
1. 如果ClassElement的ClassElementKind是NonConstructorMethod，那么
    a. 返回<< ClassElement >>
2. 返回<< >>

ClassElementList : ClassElementList ClassElement
1. 让list是ClassElementList的NonConstructorMethodDefiniations
2. 如果ClassElement的ClassElementKind是NonConstructorMethod，那么
    a. 追加ClassElement到list的末端
3. 返回list
*** Static Semantics : PrototypePropertyNameList
ClassElementList : ClassElement
1. 如果ClassElement的PropName是空，返回<< >>
2. 如果ClassElement的IsStatic是true，返回 << >>
3. 返回 << ClassElement的PropName >>

ClassElementList : ClassElementList ClassElement
1. 让list是ClassElementList的PrototypePropertyNameList
2. 如果ClassElement的PropName是空，返回list
3. 如果ClassElement的IsStatic是true，返回list
4. 追加ClassElement的PropName到list的末端
5. 返回list
*** Runtime Semantics : ClassDefinitionEvaluation
带参数classBinding和className
ClassTail : ClassHeritage_opt { ClassBody_opt }
1. 让env是运行时执行背景的LexicalEnvironment
2. 让classScope是NewDeclarativeEnvironment(env)
3. 如果classBinding不是undefined，那么
    a. 执行classScope.CreateImmutableBinding(classBinding, true)
4. 如果ClassHeritage_opt不存在，那么
    a. 让protoParent是%Object.prototype%
    b. 让constructorParent是%Function.prototype%
5. 否则
    a. 置运行时背景的LexicalEnvironment是classScope
    b. 让superclassRef是评估ClassHeritage的结果
    c. 置运行时背景的LexicalEnvironment是env
    d. 让superclass是?GetValue(superClassRef)
    e. 如果superclass是null，那么
        i. 让protoParent是null
       ii. 让constructorParenet是%Function.prototype%
    f. 否则，如果IsConstructor(superclass)是false，投掷TypeError异常。
    g. 否则
        i. 让protoParent是?Get(superclass, "prototype")
       ii. 如果Type(protoParent)不是Object或Null，投掷TypeError异常
      iii. 让constructorParent是superclass
6. 让proto是!OrdinaryObjectCreate(protoParent)
7. 如果ClassBody_opt不存在，让constructor是空
8. 否则，让constructor是ClassBody的ConstructorMethod
9.  置运行时背景的LexicalEnvironment是classScope
10. 如果constructor是空，那么
    a. 让steps是DefaultConstructorFunctions的算法步骤
    b. 让F是!CreateBuiltinFucntion(steps, 0, className, << \[\[ConstructorKind]],
       \[\[SourceText]] >> , empty, constructorParent)
11. 否则
    a. 让constructorInfo是constructor带proto和constructorParent参数的!DefineMethod
    b. 让F是constructorInfo.\[\[Closure]]
    c. 执行!MakeClassConstructor(F)
    d. 执行!SetFucntionName(F, className)
12. 执行!MakeConstructor(F, false, proto)
13. 如果ClassHeritage_opt存在，置F.\[\[ConstructorKind]]是derived
14. 执行!CrateMethodProperty(proto, "constructor", F)
15. 如果ClassBody_opt不存在，让methods是<< >>
16. 否则，让methods是ClassBody的NonConstructorMethodDefinitions
17. 遍历methods的每个ClassElement记作m，做
    a. 如果m的IsStatic是false，那么
        i. 让status是m的带proto和false参数PropertyDefinitionEvaluation
    b. 否则
        i. 让status是m的带F和false参数PropertyDefinitionEvaluation
    c.  如果status是意外完结，那么
        i. 置运行时背景的LexicalEnvironment是env
       ii. 返回Completion(status)
18. 置运行时背景的LexicalEnvironment是env
19. 如果classBinding不是undefined，那么
    a. 执行classScope.InitializeBinding(classBinding, F)
20. 返回F
**** Default Constructor Functions
当DefaultConstructorFunction被调用时，前参数记作args数组，执行下列步骤：
1. 如果NewTarget是undefined，那么投掷TypeError异常
2. 让F是激活的函数对象
3. 如果F.\[\[ConstructorKind]]是derived，那么
    a. 注意：本分支的行为类似于constructor(...args) { super(...args); }
       最显著的区别是前述的ECMAScript源文本明显调用%Array.prototype%上的
       @@iterator方法，而DefaultConstructorFunction不会
    b. 让func是!F.\[\[GetPrototypeOf]]()
    c. 如果哦IsConstructor(func)是false，投掷TypeError异常
    d. 返回?Construct(func, args, NewTarget)
4. 否则
    a. 注意：本分支行为类似于 constructor() { }
    b. 返回?OrdinaryCreateFromConstructor(newTarget, %Object.prototype%)
defaultConstructorFunction的length性质是+0_F    
*** Runtime Semantics : BindingClassDeclarationEvaluation
ClassDeclaration : class bindingIdentifier ClassTail
1. 让className是BindingIdentifier的StringValue
2. 让value是ClassTail带className和className参数的?ClassDefinitionEvaluation
3. 置value.\[\[SourceText]]是ClassDeclaration匹配的源文本
4. 让env是运行时背景的LexicalEnvironment
5. 执行?InitializeBoundName(className, value, env)
6. 返回value

ClassDeclaration : class ClassTail
1. 让value是ClassTail带undefined和"default"参数的?ClassDefinitionEvaluation
2. 置value.\[\[SourceText]]是ClassDeclaration匹配的源文本
3. 返回value
**** 注意 ClassDeclaration : class ClassTail只会出现在ExportDeclaration中，它的
           绑定也是在评估其码型时处理的。见于16.2.3.7
*** Runtime Semantics : Evaluation
ClassDeclaration : class BindingIdentifier ClassTail
1. 执行ClassDeclaration的?BindingClassDeclarationEvaluation
2. 返回NormalCompletion(empty)
**** 注意 ClassDeclaration : class ClassTail只会出现在ExportDeclaration中，不会
           被直接评估
ClassExpression : class ClassTail
1. 让value是ClassTails的带undefined和""参数的?ClassDefinitionEvaluation
2. 置value.\[\[SourceText]]是ClassExpression匹配的源文本
3. 返回value

ClassExpression : class BindingIdentifier ClassTail
1. 让className是BindingIdentifier的StringValue
2. 让value是ClassTails的带className和className参数的?ClassDefinitionEvaluation
3. 置value.\[\[SourceText]]是ClassExpression匹配的源文本
4. 返回value
** Async Function Definitions
*** Syntax
AsynctFunctionDeclaration_[Yield, Await, Default] :
    async [no LineTerminator here] function * BindingIdentifier_[?Yield, ?Await] (
        FormalParameters_[~Yield, +Await] ) { AsyncFunctionBody }
    [+Default]_async [no LineTerminator here] function * (
        FormalParameters_[~Yield, +Await] ) { AsyncFunctionBody }
AsyncFunctionExpression :
    async [no LineTerminator here] function * BindingIdentifier_[~Yield, ?Await]_opt (
        FormalParameters_[~Yield, +Await] ) { AsyncFunctionBody }
AsyncMethod_[Yield, Await] :
    async [no LineTerminator here] * PropertyName_[?Yield, ?Await] (
        UniqueFormalParameters_[~Yield, +Await] ) { AsyncFunctionBody }
AsyncFunctionBody :
    FucntionBody_[~Yield, +Awati]
AwaitExpression_[Yield] :
    await UnaryExpression_[?Yield, +Await]
**** 注意1 [Await]参数存在时，await被解析成AwaitExpression。[Await]参数出现在
            下列背景中：
              . AsyncFucntionBody
              . 在SyncFunctionDeclaration、AsyncFunctionExpression、
                AsyncGeneratorDeclaration或者AsyncGeneratorExpression的
                FormalParameters里。不过，在这个位置的AwaitExpression通过
                静态语义定为SyntaxError。
            当Module是句法的目标符，而且缺失[Await]参数，await被解析做一个
            关键词，从而是SyntaxError。在Script是句法的目标符，而且缺失[Await]
            参数时，await可以被解析成一个标识。这包含下列背景：
              . 在AsyncFunctionBody外，或者在AsyncFunctonDeclaration、
                AsyncFunctionExpression、AsyncGeneratorDeclaration或
                AsyncGeneratorExpression的FormalParameters外
              . 在FunctionExpression、GeneratorExpression或者AsyncGeneratorExpression
                的BindingIdentifier里。
**** 注意2 不同于YieldExpression，缺失AwaitExpression的操作项会是SyntaxError。
            必须await某个东西。
*** Static Semantics: Early Errors
AsyncMethod : async PropertyName ( UniqueFormalParameters ) { AsyncFunctionBody }
. 如果AsyncFunctionBody的FunctionBodyContainsUseStrict是true，而且
  UniqueFormalParameters的IsSimpleParameterList是false，那么是SyntaxError
. 如果AsyncMethod的HasDirectSuper是true，那么有SyntaxError
. 如果UniqueFormalParameters含有AwaitExpression，那么有SyntaxError
. 如果UniqueFormalParameters的BoundNames的任何元素也出现在AsyncFunctionBody的
  LexicallyDeclaredNames里，那么有SyntaxError。

AsyncFunctionDeclaration :
    async function BindingIdentifier ( FormalParameters ) { AsyncFunctionBody }
    async function ( FormalParameters ) { AsyncFunctionBody }
AsyncFunctionExpression :
    async function BindingIdentifier_opt ( FormalParameters ) { AsyncFunctionBody }
. 如果AsyncFunctionBody的FunctionBodyContainsUseStrict是true，而且
  FormalParameterList的IsSimpleParameterList是false，那么有SyntaxError。
. 如果FormalParameters包含AwaitExpression，那么有SyntaxError。
. 如果FormalParameters匹配的源代码是严格模式代码，则应用
  UniqueFormalParameters : FormalParameters的早期错误规则。
. 如果BindingIdentifer存在，而且BindingIdentifier匹配的源代码是严格模式代码，
  则当BindingIdentifier的String值是eval或者arguments时，就是SyntaxError。
. 如果FormalParameters的BoundName的任何元素也出现在AsyncFunctionBody的
  LexicallyDeclaredNames里，那么有SyntaxError
. 如果FormalParameters包含SuperProperty，那么有SyntaxError。
. 如果AsyncFunctionBody包含SuperProperty，那么有SyntaxError。
. 如果FormalParameters包含SuperCall，那么有SyntaxError。
. 如果AsyncFunctionBody包含SuperCall，那么有SyntaxError。
*** Runtime Semantics: InstantiateAsyncFunctionObject
带参数scope
AsyncFunctionDeclaration : async function BindingIdentifier ( FormalParamters ) { AsyncFunctionBody }
1. 让name是BindingIdentifer的StringValue
2. 让sourceText是AsyncFunctionDeclaration匹配的源文本
3. 让F是!OrdinaryFunctionCreate(%AsyncFunctionFunction.prototype%, sourceText,
   FormalParameters, AsyncFunctionBody, non-lexical-this, scope)
4. 执行!SetFunctionName(F, name)
5. 返回F

AsyncFunctionDeclaration : async function ( FormalParameters ) { AsyncFunctionBody }
1. 让sourceText是AsyncFunctionDeclaration匹配的源文本
2. 让F是OrdinaryFunctionCreate(%AsyncFunctionFunction.prototype%, sourceText,
   FormalParameters, AsyncFunctionBody, non-lexical-this, scope)
3. 执行SetFunctionName(F, "default")
4. 返回F
*** Runtime Semantics: InstantiateAsyncFunctionExpression
带可选参数name
AsyncFunctionExpression : async funciton ( FormalParameters ) { AsyncFunctionBody }
1. 如果name不存在，置name是""
2. 让scope是运行时执行背景的LexicalEnvironment
3. 让sourceText是本AsyncFunctionExpression匹配到的源文本
4. 让closure是!OrdinaryFunctionCreate(%AsyncFunction.prototype%, sourceText,
   FormalParameters, AsyncFunctionBody, non-lexical-this, scope)的结果
5. 执行SetFunctionName(closure, name)
6. 返回closure

AsyncFunctionExpression : async function BindingIdentifier ( FormalParameters ) { AsyncFunctionBody }
1. Assert：name不存在
2. 让name是BindingIdentifer的String值
3. 让scope是运行时执行背景的LexicalEnvironment
4. 让funcEnv是!NewDeclarativeEnvironment(scope)
5. 执行!funEnv.CreateImmutableBinding(name, false)
6. 让sourceText是本AsyncFunctionExpression匹配到的源文本
7. 让closure是!OrdinaryFunctionCreate(%AsyncFunction.prototype%, sourceText,
   FormalParameters, AsyncFunctionBody, non-lexical-this, funcEnv)的结果
8. 执行!SetFunctionName(closure, name)
9. 执行!funcEnv.InitializeBinding(name, closure)
10. 返回closure
**** 注意 在AsyncFuncionExpression里的BindingIdentifier能被
           AsyncFunctionExpression的AsyncFunctionBody引用到来允许函数代码可以
           自我递归。然而不同于FunctionDeclaration，AsyncFunctionExpression
           的BindingIdentifier不能干涉封闭AsyncFunctionExpression的圈。
*** Runtime Semantics: EvaluateAsyncFunctionBody
带参数functionObject和argumentList（List值）
AsyncFunctionBody : FucntionBody
1. 让promiseCapability是!NewPromiseCapability(%Promise%)
2. 让declResult是FunctionDeclarationInstantiation(functionObject, argumentList)
3. 如果declResult不是意外完结，那么
    a. 执行!AsyncFucntionStart(promiseCapability, FunctionBody)
4. 否则
    a. 执行!Call(promiseCapability.\[\[Reject]], undefined,
       << declResult.\[\[Value]] >>)
5. 返回 Completion { \[\[Type]]:return, \[\[Value]]: promiseCapability.\[\[Promsie]]
   , \[\[Target]]:empty }
*** Runtime Semantics: Evaluation
AsyncFunctionDeclaration : async function BindingIdentifier ( FormalParameters ) { AsyncFunctionBody }
1. 返回NormalCompletion(empty)

AsyncFucntionDeclaration : async funciton ( FormalParameters ) { AsyncFucntionBody }
1. 返回NormalCompletion(empty)

AsyncFunctionExpression :
    async function BindingIdentifier_opt ( FormalParameters ) { AsyncFunctionBody }
1. 返回AsyncFunctionExpression的InstantiateAsyncFuncitonExpression

AwaitExpression : await UnaryExpression
1. 让exprRef是评估UnaryExpression的结果
2. 让value是?GetValue(exprRef)
3. 返回?Await(value)
** Async Arrow Function Definitions 
*** Syntax
AsyncArrowFunction_[In, Yield, Await] :
    async [no LineTerminator here] AsyncArrowBindingIdentifier_[?Yield] [no LineTerminator here] =>
        AsyncConciseBody_[?In]
    CoverCallExpressionAndAsyncArrowHead_[?Yield, ?Await] [no LineTerminator here] =>
        AyncConciseBody_[?In]

AsyncConciseBody_[In] :
    [lookahead ≠ { ] ExpressionBody_[?In, +Await]
    { AsyncFucntionBody }

AsyncArrowBidningIdentifier_[Yield] :
    BindingIdentifier_[?Yield, +Await]

CoverCallExpressionAndAsyncArrowHead_[Yield, Await] :
    MemberExpression_[?Yield, ?Await] Arguments_[?Yield, ?Await]
*** Supplemental Syntax
在处理AsyncArrowFunction : ConverCallExpressionAndAsyncArrowHead => AsyncConciseBody
码型的实例时，对CoverCallExpressionAndAsyncArrowHead的解释优化为下列语法：
    AsyncArrowHead: async [no LineTerminator here] ArrowFormalParameters_[~Yield, +Await]
*** Static Semantics: Early Errors
AsynctArrowFunction : async AsyncArrowBindingIdentifier => AsyncConciseBody
. 如果AsyncArrowBindingIdentifier的BoundNames的任何元素也出现在AsyncConciseBody的
  LexicallyDeclaredNames里，那么有SyntaxError。

AsyncArrowFunction : CoverCallExpressionAndAsyncArrowHead => AsyncConciseBody
. 如果CoverCallExpressionAndAsyncArrowHead含有YieldExpression，那么有SyntaxError。
. 如果CoverCallExpressionAndAsyncArrowHead含有AwaitExpression，那么有SyntaxError。
. 如果CoverCallExpressionAndAsyncArrowHead没有覆盖AsyncArrowHead，那么有句法
  错误。
. 如果CoverCallExpressionAndAsyncArrowHead的BoundNames的任何元素也出现在
  AsyncConciseBody的LexicallyDeclaredNames里，那么有SyntaxError。
. 如果AsycnConciseBody的AsyncConciseBodyContainsUseStrict是true，且
  CoverCallExpressionAndAsyncArrowHead的IsSimpleParameterList是false，那么有句法
  错误。
. 所有AsyncArrowHead和其派生码型的EarlyError规则也适用于
  CoverCallExpressionAndAsyncArrowHead的CoveredAsyncArrowHead
*** Static Semantics: CoveredAsyncArrowHead
CoverCallExpressionAndAsyncArrowHead : MemberExpression Arguments
1. 返回被CoverCallExpressionAndAsyncArrowHead覆盖的AsyncArrowHead
*** Static Semantics: AsyncConciseBodyContainsUseStrict
AsyncConciseBody : ExpressionBody
1. 返回 false

AsyncConciseBody : { AsyncFunctionBody }
1. 返回AsyncFunctionBody的FunctionBodyContainsUseStrict
*** Runtime Semantics: EvaluateAsyncConciseBody
带参数functionObject和argumentList（List值）
AsyncConciseBody : ExpressionBody
1. 让promiseCapability是!NewPromsieCapability(%Promise%)
2. 让declResult是FunctionDeclarationInstantiation(functionObject, argumentList)
3. 如果declResult不是意外完结，那么
    a. 执行!AsyncFucntionStart(promiseCapability, ExpressionBody)
4. 否则
    a. 执行!Call(promiseCapability.\[\[Reject]], undefined,
       << declResult.\[\[Value]] >>)
5. 返回 Completion { \[\[Type]]:return, \[\[Value]]: promiseCapability.\[\[Promsie]]
   , \[\[Target]]:empty }
*** Runtime Semantics: InstantiateAsyncArrowFunctionExpression
带可选参数name
AsyncArrowFunction : async AsyncArrowBindingIdentifier => AsyncConciseBody
1. 如果name不存在，置name是""
2. 让scope是运行时执行背景的LexicalEnvironment
3. 让sourceText是本AsyncArrowFunction匹配到的源文本
4. 让parameters是AsyncArrowBindingIdentifier
5. 让closure是!OrdinaryFunctionCreate(%AsyncFunction.prototype%, sourceText,
   parameters, AsyncConciseBody, lexical-this, scope)的结果
6. 执行SetFunctionName(closure, name)
7. 返回closure

AsyncArrowFunction : CoverCallExpressionAndAsyncArrowHead => AsyncConciseBody
1. 如果name不存在，置name是""
2. 让scope是运行时执行背景的LexicalEnvironment
3. 让sourceText是本AsyncArrowFunction匹配到的源文本
4. 让head是CoverCallExpressionAndAsyncArrowHead的CoveredAsyncArrowHead
5. 让parameters是head的ArrowFormalParameters
6. 让closure是!OrdinaryFunctionCreate(%AsyncFunction.prototype%, sourceText,
   parameters, AsyncConciseBody, lexical-this, scope)的结果
7. 执行SetFunctionName(closure, name)
8. 返回closure
*** Runtime Semantics: Evaluation
AsyncArrowFunciton
    async AsyncArrowBindingIdentifier => AsyncConciseBody
    CoverCallExpressionAndAsyncArrowHead => AsyncConciseBody
1. 返回AsyncArrowFunction的InstantiateAsyncArrowFunctonExpression
** Tail Position Calls
*** Static Semantics: IsInTailPostion( call )
抽象操作IsInTailPosition接受参数call。被调用时执行下列步骤：
1. Assert：call是一个ParseNode
2. 如果call匹配的源文本不是严格模式代码，返回false
3. 如果call没有被包含在FucnitonBody、ConciseBody或者AsyncConciseBody，返回false。
4. 让body是含有call的最近的FunctionBody、ConciseBody或者AsyncConciseBody。
5. 如果body是GeneratorBody的FunctionBody，返回false。
6. 如果body是AsyncFunctionBody的FunctionBody，返回false。
7. 如果body是AsyncGeneratorBody的FunctionBody，返回false
8. 如果body是AsyncConciseBody，返回false。
9. 返回body带参数call的HasCallInTailPosition
**** 注意 TailPositionCall只在严格模式代码里定义，因为有一个常用的非标准的
           语言扩展（见于10.2.4）允许监测调用者背景链。
*** Static Semantics: HasCallInTailPosition
带参数call
**** 注意 call是一个ParseNode，标识特定范围的源文本。当随后的算法比较call与
           其他ParseNode时，实际是比较它们是不是标识同一段源文本。
**** Statement Rules
StatementLsit : StatementList StatementListItem 
1. 让has是StatementList的带参数call的HasCallInTailPosition
2. 如果has是true，返回true
3. 返回StatementListItem的带参数call的HasCallInTailPosition

FunctionStatementList : [empty]
StatementLitItem : Declaration
Statement :
    VariableStatement
    EmptyStatement
    ExpressionStatement
    ContinueStatement
    BreakStatement
    ThrowStatement
    DebuggerStatement
Block : { }
ReturnStatement : return ;
LabelledItem : FunctionDeclaration
ForInOfStatement :
    for ( LeftHandSideExpression of AssignmentExpression ) Statement
    for ( var ForBinding of AssignmentExpression ) Statement
    for ( ForDeclaration of AssignmentExpression ) Statement
CaseBlock : { }
1. 返回false

IfStatement : if ( Expression ) Statement else Statement
1. 让has是第一个Statement带参数call的HasCallInTailPosition
2. 如果has是true，返回true
3. 返回第二个Statement带参数call的HasCallInTailPosition

IfStatement : if ( Expression ) Statement
DoWhileStatement : do Statement while ( Expression )
WhileStatement : while ( Expression ) Statement
ForStatement :
    for ( Expression_opt ; Expression_opt ; Expression_opt ) Statement
    for ( var VariableDeclarationList ; Expression_opt ; Expression_opt ) Statement
    for ( LexicalDeclaration Expression_opt ; Expression_opt ) Statement
ForInOfStatement
    for ( LeftHandSideExpression in Expression ) Statement
    for ( var ForBinding in Expression ) Statement
    for ( ForDeclaration in Expression ) Statement
    for await ( LeftHandSideExpression of AssignmentExpression ) Statement
    for await ( var FroBinding of AssignmentExpression ) Statement
    for await ( ForDeclaration of AssignmentExpression ) Statement
WithStatement : with ( Expression ) Statement
1. 返回Statement带参数call的HasCallInTailPosition

LabelledStatement :
    LabelIdentifier : LabelledItem
1. 返回LabelledItem带参数call的HasCallInTailPosition

ReturnStatement : return Expression ;
1. 返回Expression带参数call的HasCallInTailPosition

SwitchStatement : switch ( Expression ) CaseBlock ;
1. 返回CaseBlock带参数call的HasCallInTailPosition

CaseBlock : { CaseClauses_opt DefaultClause CaseClauses_opt }
1. 让has是false
2. 如果第一个CaseClauses存在，让has是第一个CaseClauses带参数call
   的HasCallInTailPosition
3. 如果has是true，那么返回true
4. 让has是DefaultClause带参数call的HasCallInTailPosition
5. 如果has是true，那么返回true
6. 如果第二个CaseClauses存在，让has是第二个CaseClauses带参数call
   的HasCallInTailPosition
7. 返回has

CaseClauses : CaseClauses CaseClause
1. 让has是CaseClauses带参数call的HasCallInTailPosition
2. 如果has是true，那么返回true
3. 返回CaseClause带参数call的HasCallInTailPosition

CaseClause : case Expression : StatementList_opt
DefaultClause : default : StatementList_opt
1. 如果StatementList存在，返回StatementList带参数call的HasCallInTailPosition
2. 返回false

TryStatement : try Block Catch
1. 返回Catch带参数call的HasCallInTailPosition

TryStatement : try Block Finally
TryStatement : try Blcok Catch Finally
1. 返回Finally带参数call的HasCallInTailPosition

Catch : catch ( CatchParameter ) Block
1. 返回Block带参数call的HasCallInTailPosition
**** Expression Rules
***** 注意 紧随其调用后就返回调用结果的GetValue的潜在的尾部调用也有可能是
            尾部调用。函数调用不能返回ReferenceRecord，因此GetValue操作总是
            返回相同的值作为函数调用的实际结果。
AssignmentExpression :
    YieldExpression
    ArrowFunction
    AsyncArrowFunction
    LeftHandSideExpression = AssignmentExpression
    LeftHandSideExpression AssignmentOperator AssignmentExpression
    LeftHandSideExpression &&= AssignmentExpression
    LeftHandSideExpression ||= AssignmentExpression
    LeftHandSideExpression ??= AssignmentExpression
BitwiseANDExpression : BitwiseANDExpression & EqualityExpression
BitwiseXORExpression : BitwiseXORExpression ^ BitwiseANDExpression
BitwiseORExpression : BitwiseORExpression | BitwiseXORExpression
EqualityExpression :
    EqualityExpression \=\= RelationalExpression
    EqualityExpression !\= RelationalExpression
    EqualityExpression \=\=\= RelationalExpression
    EqualityExpression !\=\= RelationalExpression
RelationalExpression :
    RelationalExpression < ShiftExpression
    RelationalExpression > ShiftExpression
    RelationalExpression <= ShiftExpression
    RelationalExpression >= ShiftExpression
    RelationalExpression instanceof ShiftExpression
RelationalExpression in ShiftExpression
ShiftExpression :
    ShiftExpression << AdditiveExpression
    ShiftExpression >> AdditiveExpression
    ShiftExpression >>> AdditiveExpression
AdditiveExpression :
    AdditiveExpression + MultiplicativeExpression
    AdditiveExpression - MultiplicativeExpression
MultiplicativeExpression :
    MultiplicativeExpression MultiplicativeOperator ExponentiationExpression
ExponentiationExpression :
    UpdateExpression ** ExponentiationExpression
UpdateExpression :
    LeftHandSideExpression ++
    LeftHandSideExpression --
    ++ UnaryExpression
    -- UnaryExpression
UnaryExpression :
    delete UnaryExpression
    void UnaryExpression
    typeof UnaryExpression
    + UnaryExpression
    - UnaryExpression
    ~ UnaryExpression
    ! UnaryExpression
    AwaitExpression
CallExpression :
    SuperCall
    CallExpression [ Expression ]
    CallExpression . IdentifierName
NewExpression : new NewExpression
MemberExpression :
    MemberExpression [ Expression]
    MemberExpression . IdentifierName
    SuperProperty
    MetaProperty
    new MemberExpression Arguments
PrimaryExpression :
    this
    IdentifierReference
    Literal
    ArrayLiteral
    ObjectLiteral
    FunctionExpression
    ClassExpression
    GeneratorExpression
    AsyncFunctionExpression
    AsyncGeneratorExpression
    RegularExpressionLiteral
    TemplateLiteral
1. 返回false

Expression :
    AssignmentExpression
    Expression , AssignmentExpression
1. 返回AssignmentExpression带参数call的HasCallInTailPosition

ConditionalExpression : ShortCircuitExpression ? AssignmentExpression : AssignmentExpression
1. 让has是第一个AssignmentExpression带参数call的HasCallInTailPosition
2. 如果has是true，返回true
3. 返回第二个AssignmentExpression带参数call的HasCallInTailPosition

LogicalANDExpression : LogicalANDExpression && BitwiseORExpression
1. 返回BitwiseORExpression带参数call的HasCallInTailPosition

LogicalORExpression : LogicalORExpression || LogicalANDExpression
1. 返回LogicalANDExpression带参数call的HasCallInTailPosition

CoalesceExpression : CoalesceExpressionHead ?? BitwiseORExpression
1. 返回BitwiseORExpression带参数call的HasCallInTailPosition

CallExpression :
    CoverCallExpressionAndAsyncArrowHead
    CallExpression Arguments
    CallExpression TemplateLiteral
1. 如果本CallExpression是call，返回true
2. 返回false

OptionalExpression :
    MemberExpression OptionalChain
    CallExpression OptionalChain
    OptionalExpression OptionalChain
1. 返回OptionalChain带参数call的HasCallInTailPosition

OptionalChain :
    ?. \[ Expression ]
    ?. IdentifierName
    OptionalChain \[ Expression ]
    OptionalChain . IdentifierName
1. 返回false

OptionalChain:
    ?. Arguments
    OptionalChain Arguments
1. 如果本OptionalChain是call，返回true
2. 返回false

MemberExpression :
    MemberExpression TemplateLiteral
1. 如果本MemberExpression是call，返回true
2. 返回false

PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList
1. 让expr是CoverParenthesizedExpressionAndArrowParameterList的
   CoveredParenthesizedExpression
2. 返回expr带参数call的HasCallInTailPosition

ParenthesizedExpression :
    ( Expression )
1. 返回Expression带参数call的HasCallInTailPosition
*** PrepareForTailCall( )
抽象操作PrepareForTailCall不接受参数，被调用时执行下列步骤：
1. 让leafContext是运行时执行背景
2. 挂起leafContext
3. 将leafContext从执行背景栈中弹出。栈中的顶层执行背景成为运行时执行背景。
4. Assert：leafContext不再使用。再也不会成为运行时执行背景。

一个TailPositionCall要么在调用目标函数前释放跟执行中函数的执行背景相关的
任何临时内部资源，要么重用这些资源到目标函数的支持里。
**** 注意 例如，一个TailPositionCall应该只根据目标函数的激活记录超出执行
           函数的激活记录的数量增长一个实现上的激活记录。如果目标函数的
           激活记录更小，那么这个栈会萎缩。 
* ECMAScript Language: Scripts and Modules
** Scripts
*** Syntax
Script :
    ScriptBody_opt
ScriptBody :
    StatementList_[~Yield, ~Await, ~Return]
*** Static Semantics: Early Errors
Script : ScriptBody
. 如果ScriptBody的LexicallyDeclaredNames含有重复的实体，那么有SyntaxError
. 如果ScriptBody的LexicallyDeclaredNames的元素也出现ScriptBody的VarDeclaredNames，
  那么有SyntaxError。

ScriptBody : StatementList
. 如果StatementList含有super，而且含有super的源代码不是被directEval处理的eval
  代码，那么有SyntaxError。另外关于directEval中super的earlyError规则在
  19.2.1.1中定义。
. 如果StatementList含有NewTarget，而且含有NewTarget的源代码不是被directEval处理
  的eval代码，那么有SyntaxError。另外关于directEval中NewTarget的earlyError规则在
  19.2.1.1中定义
. 如果StatementList带参数<< >>的ContainsDuplicateLabels是true，那么有SyntaxError。
. 如果StatementList带参数<< >>的ContainsUndefinedBreakTarget是true，那么有句法
  错误。
. 如果StatementList带参数<< >>和<< >>的ContainsUndefinedContinueTarget是true，那么
  有SyntaxError。
*** Static Semantics: IsStrict
Script : ScriptBody_opt
1. 如果ScriptBody存在而且ScriptBody的DirectivePrologue含有UseStrictDirective，
   返回true，否则返回false。
*** Runtime Semantics: Evaluation
Script : [empty]
1. 返回NormalCompletion(undefined)
*** Script Records
ScriptRecord封装着被评估的脚本信息。每个scriptRecord含有列在表39的字段。

| 字段名               | 值类型                           | 含义                                                            |
| \[\[Realm]]          | RealmRecord 或者 undefined       | 创建本脚本的领。没有被指定时是undefined                         |
| \[\[Environment]]    | EnvironmentRecord 或者 undefined | EnvironmentRecord持有此脚本顶层绑定。本字段在脚本被初始时设置。 |
| \[\[ECMAScriptCode]] | ParseNode                        | 用Script作为全局目标解析此脚本的结果                            |
| \[\[HostDefined]]    | 任何值，默认是空                 | host环境保留的字段，方便其联结附加的信息                        |
*** ParseScript(sourceText, realm, hostDefined)
抽象操作ParseScript结束参数sourceText、realm和hostDefined。在解析sourceText成为
Script的基础上创建ScriptRecord。被调用时执行下列步骤：
1. Assert：sourceText是ECMAScript源文本（见于11）
2. 让body是ParseText(sourceText, Script)
3. 如果body是错误列表，返回body
4. 返回ScriptRecord { \[\[Realm]]:realm, \[\[Environment]]:undefined,
   \[\[ECMAScriptCode]]:body, \[\[HostDefined]]:hostDefined }
**** 注意 实现可能会在评估ParseScript之前就解析其源文本并分析早期错误条件。
           然而这些错误报告必须延后到本规范实际执行到此源文本的ParseScript
           处。
*** ScriptEvaluation( scriptRecord )
抽象操作ScriptEvaluation接受参数scriptRecord。被调用时执行下列步骤：
1. 让globalEnv是scriptRecord.\[\[Realm]].\[\[GlobalEnv]]
2. 让scriptContext是新的ECMAScript代码执行背景。
3. 置scriptContext的Function是null
4. 置scriptContext的Realm是scriptRecord.\[\[Realm]]
5. 置scriptContext的ScriptOrModule是scriptRecord
6. 置scriptContext的VariableEnvironment是globalEnv
7. 置scriptContext的LexicalEnvironment是globalEnv
8. 挂起当前的运行时执行背景
9. 将scriptContext推到执行背景栈上。scriptContext现在是运行时执行背景
10. 让scriptBody是scriptRecord.\[\[ECMAScriptCode]]
11. 让result是GlobalDeclarationInstantiation(scriptBody, globalEnv)
12. 如果result.\[\[Type]]是normal，那么
    a. 置result是评估scriptBody的结果
13. 如果result.\[\[Type]]是normal而且result.\[\[Value]]是empty，那么
    a. 置result是NormalCompletion(undefined)
14. 挂起scriptContext，并将其从执行背景栈中移除。
15. Assert：执行背景栈不空
16. 唤起执行背景栈顶层的背景作为运行时执行背景
17. 返回Completion(result)
*** GlobalDecalarationInstantiation( script, env )
**** 注意1 当评估脚本的执行背景建立完，声明就初始化在当前全局环境里。在代
           码里声明的每个全局绑定都被初始化。
抽象操作GlobalDeclarationInstantiation接受参数script（ScriptBody的ParseNode）和
env（EnvironmentRecord）。script是为之建立执行背景的ScriptBody。env是在其上创建
绑定的全局环境。被调用时执行下列步骤：
1. Assert: env是globalEnvironmentRecord
2. 让lexNames是script的LexicallyDeclaredNames
3. 让varNames是script的VarDeclaredNames
4. 遍历lexNames的元素，记作name，做
    a. 如果env.HasVarDeclaration(name)是true，投掷SyntaxError异常
    b. 如果env.HasLexicalDeclaration(name)是true，投掷SyntaxError异常
    c. 让hasRestrictedGlobal是?env.HasRestrictedGlobalProperty(name)
    d. 如果hasRestrictedGlobal是true，投掷SyntaxError异常
5. 遍历varNames的元素，记作varName，做
    a. 如果env.HasLexicalDeclaration(name)是true，投掷SyntaxError异常。
6. 让varDeclarations是script的VarScopedDeclarations
7. 让functionsToInitialize是新的空List
8. 让declaredFunctionNames是新的空List
9. 按照List的反序遍历varDeclarations的元素，记作d，做
    a. 如果d不是VariableDeclaration，不是ForBinding，也不是BindingIdentifier，那么
        i. Assert：d是FunctionDeclaration、GeneratorDeclaration、
           AsyncFunctionDeclaration或者AsyncGeneratorDeclaration之一。
       ii. 注意：如果有多个函数声明，应用最后一个
      iii. 让fn是d的BoundNames的唯一元素
       iv. 如果fn不是declaredFunctionNames的元素，那么
            1. 让fnDefinable是?env.CanDeclareGlobalFunction(fn)
            2. 如果fnDefinable是false，投掷TypeError异常
            3. 附加fn到declaredFunctionNames
            4. 插入d到functionsToInitialize作为的一个元素。
10. declaredVarNames是新的空List
11. 遍历varDeclarations的元素记作d，做
    a. 如果d是VariableDeclaration，或ForBinding，或BindingIdentifier，那么
        i. 遍历d的BoundNames的String值，记作vn，做
            1. 如果vn不是declaredFunctionNames的元素，那么
                a. 让vnDefinable是?env.CanDeclareGlobalVar(vn)
                b. 如果vnDefinable是false，投掷TypeError异常
                c. 如果vn不是declaredVarNames的元素，那么
                    i. 附加vn到declaredVarNames
12. 注意：如果globalObject是ordinaryObject，那么在本算法步骤后，不会出现
    意外终结。然而如果globalObject是Proxy奇异对象，他可能展示会在下列步骤
    中导致意外终结的行为
13. 注意：附件B.3.3.2在本步骤附加了算法。
14. 让lexDeclarations是script的LexicallyScopedDeclarations
15. 遍历lexDeclarations的元素，记作d，做
    a. 注意：词法声明的名称在这里只是实例化，不并初始化。
    b. 遍历d的BoundNames的元素，记作dn，做
        i. 如果d的IsConstantDeclaration是true，那么
            1. 执行?env.CreateImmutableBinding(dn, true)
       ii. 否则
            1. 执行?env.CreateMutableBinding(dn, false)
16. 遍历functionToInitialize的每个ParseNode，记作f，做
    a. 让fn是f的BoundNames的唯一元素
    b. 让fo是f带参数env的InstantiateFunctionObject
    c. 执行?env.CreateGlobalFuncitonBinding(fn, fo, fasle)
17. 遍历declaredVarNames的String值，记作vn，做
    a. 执行?env.CreateGlobalVarBinding(vn, false)
18. 返回NormalCompletion(empty)
**** 注意2 16.1.1中规定的早期错误阻止了function/var声明与let/const/class声明
            导致的名称混淆，以及在单个script中let/const/class绑定导致的重复
            声明。然而跨越Script导致的混淆与重复声明在
            GlobalDeclarationInstantiation中被侦测为运行时错误。如果有这种错误
            出现，脚本不实例化任何绑定。但如果globalObject是Proxy奇异对象，
            那么运行时检测到混淆声明可能不可靠，从而导致意外完结而且有些
            全局声明没有被实例化。一旦出现，Script代码没有被评估。

            不同于显式的var或者函数声明，直接创建在全局对象上的性质产生的
            全局绑定可以被let/const/class声明覆盖。（注意这里说的是绑定，而
            不是绑定指引的值）。
** Modules
*** Syntax
Module :
    ModuleBody_opt
ModuleBody :
    ModuleItemList
ModuleItemList :
    ModuleItem
    MoudleItemList ModuleItem
ModuleItem :
    ImportDeclaration
    ExportDeclaration
    StatemntListItem_[~Yield, ~Await, ~Return]
*** Module Semantics
**** Static Semantics: Early Errors
ModuleBody : ModuleItemList
. 如果ModuleItemList的LexicallyDeclaredNames含有重复实体，那么有SyntaxError。
. 如果ModuleItemList的LexicallyDeclaredNames的元素也出现在ModuleItemList的
  VarDeclaredNames，那么有SyntaxError。
. 如果ModuleItemList的ExportedNames含有任何重复的实体，那么有SyntaxError。
. 如果ModuleItemList的ExportedBindings的任何元素没有出现在ModuelItemList
  的VarDeclaredNames，也没有出现在LexicallyDeclaredNames，那么有SyntaxError。
. 如果ModuleIemtList含有super，那么有SyntaxError
. 如果ModuleItemList含有NewTarget，那么有SyntaxError
. 如果ModuleItemList带参数<< >>的ContainsDuplicateLabels是true，那么有SyntaxError。
. 如果ModuleItemList带参数<< >>的ContainsUndefinedBreakTarget是true，那么有句法
  错误。
. 如果ModuleItemList带参数<< >>和<< >>的ContainsUndefinedContinueTarget是true，那么
  有SyntaxError。
***** 注意 ExportedNames的重复规则暗示了在一个ModuleBody里出现多次
            export default这种ExportDeclaration是SyntaxError。另外关于混淆或者重复
            声明的错误条件在评估Module之前的模块链接时进行检查。如果任何检测
            到任何错误那么不评估Module。
**** Static Semantics: ImportedLcoalNames( importEntries )
抽象操作ImprotedLocalNames接受参数importEntries（ImportEntryRecord的List，
ImportEntryRecord在表45里描述）。创建一个由importEntries定义的本地的绑定名称的
列表。被调用时执行下列步骤:
1. 让localName是新的空列表
2. 遍历importEntries的ImportEntryRecord记作i，做
    a. 附加a.\[\[LocalName]]到localNames
3. 返回localNames
**** Static Semantics: ModuleRequests
Module : [empty]
1. 返回新的空列表

ModuleItemList : ModuleItem
1. 返回ModuleItem的ModuleRequests

ModuleItemList : ModuleItemList ModuleItem
1. 让moduleNames是ModuleItemList的ModuleRequests
2. 让additionalNames是ModuleItem的ModuelRequests
3. 依次的将在additionalNames中，且不在moduleNames中的元素，附加到moduleNames中
4. 返回moduleNames

ModuleItem : StatementListItem
1. 返回新的空列表

ImportDeclaration : import ImportClause FromClause ;
1. 返回fromClause的ModuleRequests

ModuleSpecifier : StringLiteral
1. 返回只有<< StringLiteral的SV >>

ExportDeclaration : export ExportFromClause FromClause ;
1. 返回FromClause的ModuleRequest

ExportDeclaration :
    export NamedExports ;
    export VariableStatement
    export Declaration
    export default HoistableDeclaration
    export default ClassDeclaration
    export default AssignmentExpression ;
1. 返回新的空列表
**** Abstract Module Records
ModuleRequest封装着单个模块的引入与导出的构造信息。用于在联通的模块集合里
链接引入与导出。ModuleRecord包含四个只用在评估模块的字段

为了规范，ModuleRecord的值是Record规范类型的，可以看作是简单的面向对象
继承，其中ModuleRecord是同时由抽象子类和具体子类的抽象类。规范定义了名为
CyclicModuleRecord的抽象子类，以及其具体子类SourceTextModuleRecord。其他规范
和实现可以定义额外的ModuleRecord的子类以符合它们定义的备选模型定义特性。

ModuleRecord定义了列在表40的字段。所有模型定义的子类至少要包含这些字段。
ModuleRecord在表41定义了抽象方法。所有模型定义的字列必须提供这些抽象方法的
具体实现。
表40
| 字段名               | 值类型                           | 含义                                                            |
| \[\[Realm]]          | RealmRecord 或者 undefined       | 创建本模块的领。没有被指定时是undefined                         |
| \[\[Environment]]    | EnvironmentRecord 或者 undefined | EnvironmentRecord持有此模块的顶层绑定。本字段在模块被链接时设置。 |
| \[\[NameSpace]] | Object或者undefined       | ModuleNamespaceObject（28.3），如果由创建的，否则是undefined |
| \[\[HostDefined]]    | 任何值，默认是undefined         | host环境保留的字段，方便其联结附加的信息                        |
表41
| 方法                                    | 目的                                                                                                                                                                                                                                                                                                                                                                                                      |
| GetExportedNames([exportStarSet])       | 返回含有从本模块直接或者间接导出全部名称的列表                                                                                                                                                                                                                                                                                                                                                            |
| ResolveExport(exportName[, resolveSet]) | 返回本模块导出的名称对应的绑定。绑定被表示为ResolvedBindingRecord，形式为 { \[\[Module]]: ModuleRecord, \[\[BindingName]]: String }。 如果这个导出是一个在任何模块中都没直接绑定的ModuleNamespaceObject，\[\[BindingName]]被置成"*namespace*"。如果名称无法解决，返回null。如果名称找到多个绑定，返回"ambiguous"。 本操作在给定exportName和resolveSet对上的每次调用，如果是普通完结，必须返回相同的结果。 |
| Link()                                  | 通过传递式的解决模块依赖和创建moduleEnvironmentRecord来为评估准备模块。                                                                                                                                                                                                                                                                                                                                   |
| Evaluate()                              | 如果模块曾被成功的评估，那么返回undefined。如果评估不成功，投掷已经产出的异常。否则传递式评估本模块依赖的模块，然后评估本模块。在调用此方法前必须已经成功Link完                                                                                                                                                                                                                                           |
**** Cyclic Module Records
CyclickModuleRecord用于表示和其他也是CyclicModuleRecord子类的模块形成循环依赖的
模块的信息。不是CyclicModuleRecord子类的ModuleRecords不能与SourceTextModuleRecords
形成依赖循环。

除了表40列出的字段之外，CyclicModuleRecord需要表42列出的额外字段。
表42
| 字段名                 | 值类型                                                               | 含义                                                                                                                                                                  |
| \[\[Status]]           | unlinked \vert linking \vert linked \vert evaluating \vert evaluated | 初始是unlinked。按顺序经历linking、linked、evaluating和evaluated，表示在其生命周期的处理内容                                                                          |
| \[\[EvaluationError]]  | 意外完结 或者 undefined                                              | 类型是throw的完结记录，表示在评估过程中发生的异常。如果\[\[Statu]]不是evaluated，或者没有异常发生，就是undefined                                                      |
| \[\[DFSIndex]]         | Integer或者undefined                                                 | 仅用在Link和Evaluate的辅助字段。如果\[\[Status]]是linking或者evaluating，这个非负数字记录了在进行深度优先遍历依赖图时，第一次访问到本模块的点。                       |
| \[\[DFSAncesotrIndex]] | Integer或者undefined                                                 | 仅用在Link和Evaluate的辅助字段。如果\[\[Status]]是linking或者evaluating，它是本模块自己的\[\[DFSIndex]]，或者是与本模块在同一个强联通组件中靠前的模块的\[\[DFSIndex]] |
| \[\[RequestModules]]   | String的List                                                         | 被本记录表示的模块用来引入模块的所有ModuleSpecifier字符串组成的列表。按照源代码出现顺序进行排序。                                                                     |

除了表41列出的方法外，CyclicModuleRecord需要表43列出的额外方法。
表43
| 方法                    | 目的                                                                                                                                                                                                                                                                                                                                                                                                      |
| InitializeEnvironment() | 初始化模块的EnvironmentRecord，包括解决所有的引入绑定，创建模块的执行背景                                                                                                                                                                                                                                                                                                                                 |
| ExecuteModule()         | 在其执行背景里评估模块代码。                                                                                                                                                                                                                                                                                                                                                                                            |
***** Link() Concrete Method
CyclicModuleRecord型module的Link具体方法不接受参数。当成功时，Link将本模块的
\[\[Status]]从unlinked迁移到linked。在失败时，投掷异常，并且本模块的
\[\[Status]]保持unlinked。（大多数工作由辅助函数InnerMeduleLinking处理）被调用
时执行下列步骤：
1. Assert：module.\[\[Status]]不是linking，也不是evaluating
2. 让stack是新的空列表
3. 让result是InnerModuleLinking(module, stack, 0)
4. 如果result是意外完结，那么
    a. 遍历stack的每个CyclicModuleRecord记作m，做
        i. Assert：m.\[\[Status]]是linking
       ii. 置m.\[\[Status]]是unlinked
      iii. 置m.\[\[Environment]]是undefined
       iv. 置m.\[\[DFSIndex]]是undefined
        v. 置m.\[\[DFSAncestorIndex]]是undefined
    b. Assert：module.\[\[Status]]是unlinked
    c. 返回result
5. Assert：module.\[\[Status]]是linked或者evaluated
6. Assert：stack是空的
7. 返回undefined
****** InnerModuleLinking(module, stack, index)
抽象操作InnerModuleLinking接受参数module（ModuleRecord）、stack和index（
非负整数）。被Link用来实际执行module的链接处理，也递归处理在其依赖图上的
其他全部模块。stack和index参数，以及module的\[\[DFSIndex]]和\[\[DFSAncestorIndex]]
字段，保持深度优先遍历的轨迹。尤其是，\[\[DFSAncestorIndex]]用于发现强联通
组件（SCCs，Strongly Connected Components），因此全部模块由SCC经历链接到一起。
被调用时执行下列步骤：
1. 如果module不是CyclicModuleRecord，那么
    a. 执行?module.Link()
    b. 返回index
2. 如果module.\[\[Status]]是linking、linked或者evaluated，那么
    a. 返回index
3. Assert：module.\[\[Status]]是unlinked。
4. 置module.\[\[Status]]是linking
5. 置module.\[\[DFSIndex]]是index
6. 置module.\[\[DFSAncestorIndex]]是index
7. 置index是index+1
8. 附加module到stack
9. 遍历module.\[\[RequestedModules]]的字符串记作required，做
    a. 让requiredModule是?HostResolveImportedModule(module, required)
    b. 置index是?InnerModuleLinking(requiredModule, stack, index)
    c. 如果requiredModule是CyclicModuleRecord，那么
        i. Assert：requiredModule.\[\[Status]]是linking、linked或者evaluated
       ii. Assert：当且仅当requiredModule在stack中时，requiredModule.\[\[Status]]
           是linking。
      iii. 如果requiredModule.\[\[Status]]是linking，那么
            1. 置module.\[\[DFSAncestorIndex]]是min(module.\[\[DFSAncestorIndex]],
               requiredModule.\[\[DFSAncestorIndex]])
10. 执行?module.InitializeEnvironment()
11. Assert：module在stack中只出现一次。
12. Assert：module.\[\[DFSAncestorIndex]] <= module.\[\[DFSIndex]]
13. 如果module.\[\[DFSAncestorIndex]] == module.\[\[DFSIndex]]，那么
    a. 让done是false
    b. 当done是false时，重复
        i. 让requiredModule是stack的最后一个元素
       ii. 移除stack的最后一个元素
      iii. Assert：requiredModule是CyclicModuleRecord
       iv. 置requiredModule.\[\[Status]]是linked
        v. 如果requiredModule和module是相同的ModuleRecord，置done是true
14. 返回index
***** Evaluate() Concrete Method
CyclicModuleRecord型module的具体方法Evaluate不接受参数。Evaluate将本模块的
\[\[Status]]从linked迁移到evaluated。如果执行结果异常，这个异常记录在
\[\[EvaluationError]]字段里，被以后调用的Evaluate重新投掷。（大多数工作由
辅助函数InnerModuleEvaluation处理）被调用时执行下列步骤：
1. Assert：在环境媒介中，当其他Evaluate调用时，当前Evaluate调用不会发生。
2. Assert：module.\[\[Status]]是linked或者evaluated
3. 让stack是新的空列表
4. 让result是InnerModuleEvaluation(module, stack, 0)
5. 如果result是意外完结，那么
    a. 遍历stack的每个CyclicModuleRecord记作m，做
        i. Assert：m.\[\[Status]]是evaluating
       ii. 置m.\[\[Status]]是evaluated
      iii. 置m.\[\[EvaluationError]]是result
    b. Assert：module.\[\[Status]]是evaluated，而且module.\[\[EvaluationError]]是
       result
    c. 返回result
6. Assert：module.\[\[Status]]是evaluated，而且module.\[\[EvaluationError]]是
   undefined
7. Assert：stack是空的
8. 返回undefined
****** InnerModuleEvaluation(moudle, stack, index)
抽象操作InnerModuleEvaluation接受参数module(ModuleRecord)、stack和index（非负
整数）。被Evaluate用来实际执行module的评估处理，也递归处理其依赖图上的其他
全部模块。stack和index参数，以及module的\[\[DFSIndex]]和\[\[DFSAncestorIndex]]
字段，用途与InnerModuleLinking中相同。被调用时执行下列步骤：
1. 如果module不是CyclicModuleRecord，那么
    a. 执行?module.Evaluate()
    b. 返回index
2. 如果module.\[\[Status]]是evaluated，那么
    a. 如果module.\[\[EvaluationError]]是undefined，返回index
    b. 否则，返回module.\[\[EvaluationError]]
3. 如果module.\[\[Status]]是evaluating，返回index
4. Assert：module.\[\[Status]]是linked。
5. 置module.\[\[Status]]是evaluating
6. 置module.\[\[DFSIndex]]是index
7. 置module.\[\[DFSAncestorIndex]]是index
8. 置index是index+1
9. 附加module到stack
10. 遍历module.\[\[RequestedModules]]的字符串记作required，做
     a. 让requiredModule是!HostResolveImportedModule(module, required)
     b. 注意：在调用此方法前，Link已经成功结束了，所以每个请求的模块都是
        可以保证成功的。
     c. 置index是?InnerModuleEvaluation(requiredModule, stack, index)
     d. 如果requiredModule是CyclicModuleRecord，那么
         i. Assert：requiredModule.\[\[Status]]是evaluating或者evaluated
        ii. Assert：当且仅当requiredModule在stack中时，requiredModule.\[\[Status]]
            是evaluating。
       iii. 如果requiredModule.\[\[Status]]是evaluating，那么
             1. 置module.\[\[DFSAncestorIndex]]是min(module.\[\[DFSAncestorIndex]],
                requiredModule.\[\[DFSAncestorIndex]])
11. 执行?module.ExecuteModule()
12. Assert：module在stack中只出现一次。
13. Assert：module.\[\[DFSAncestorIndex]] <= module.\[\[DFSIndex]]
14. 如果module.\[\[DFSAncestorIndex]] == module.\[\[DFSIndex]]，那么
    a. 让done是false
    b. 当done是false时，重复
        i. 让requiredModule是stack的最后一个元素
       ii. 移除stack的最后一个元素
      iii. Assert：requiredModule是CyclicModuleRecord
       iv. 置requiredModule.\[\[Status]]是evaluated
        v. 如果requiredModule和module是相同的ModuleRecord，置done是true
15. 返回index
***** Example Cyclic Module Record Graphs
此辅助章节给出了一系列在常见模块图上链接和评估的例子，了解会发生哪些错
误。

首先考虑如下的简单模块图：
A -> B -> C

我们先假设没有错误条件。在主机第一次调用A.Link()时，假设这会成功完
成，而且递归的链接模块B和C，因此A.\[\[Status]] \=\= B.\[\[Status]] \=\=
C.\[\[Status]] == linked。这个准备可以在任何时间执行。随后当主机准备好引发
这些模块上可能的负作用时，它可以调用A.Evaluate()，这也会成功完成（再次
假设），递归的完成C，然后B。在此刻，每个模块的\[\[Status]]都是evaluated。

随后考虑涉及链接错误的案例。如果C的InnerModuleLinking成功了，但是之后的B失败了，
比如B引入了C没有提供的东西，那么源初的A.Link()也会失败，这样A和B的
\[\[Status]]保持unlinked，而C的\[\[Status]]变成linked。

最后考虑涉及评估错误的案例。
****** TODO [440,441]
./figure2.svg
**** Source Text Module Records
SourceTextModuleRecord用于表示由使用Module做全局符号解析的ECMAScript源文
本（条款11）定义的模型。其字段包含被模块引入的名称的已理解信息，让其
具体方法能够使用这种理解去链接和评估本模块。

SourceTextModuleRecord能与抽象ModuleRecord型的其他子类共存于一个模块图中，
也能与CyclicModuleRecord型的其他子类形成环。

除表42之外，SourceTextModuleRecord还有列在表44中字段。这些字段在ParseModule时
被初始化值。
表44
| 字段名                      | 值类型                      | 含义                                                                                                     |
| \[\[ECMAScript]]            | ParseNode                   | 本模块匹配的源文本使用Module作为全局符号解析的结果                                                       |
| \[\[Context]]               | ECMAScript执行背景          | 联结到本模块的执行背景                                                                                   |
| \[\[ImportMeta]]            | Object                      | 通过import.meta方式暴露出来的对象。它是空的，直到被ECMAScript代码访问。                                  |
| \[\[ImportEntries]]         | ImportEntryRecord组成的List | 本模块代码派生的ImportEntryRecord组成的List                                                              |
| \[\[LocalExportEntries]]    | ExportEntryRecord组成的List | 本模块代码内声明，从而派生的ExportEntryRecord组成的List。                                                |
| \[\[IndirectExportEntries]] | ExportEntryRecord组成的List | 本模块代码重新导出引入的内容，或者通过export * as namespect声明的导出，派生的ExportEntryRecord构成的List |
| \[\[StarExportEntries]]     | ExportEntryRecord组成的List | 本模块代码用export *声明，不包含export * as namespace声明，派生的ExportEntryRecord构成的List                                  |
ImportEntryRecord是关于单一声明引入的信息的理解记录。每个ImportEntryRecord有
表45列出的字段。
表45
| 字段名              | 值类型 | 含义                                                                                               |
| \[\[ModuleRequest]] | String | ImportDeclaration的ModuleSpecifier的String值                                                       |
| \[\[ImportName]]    | String | \[\[ModuleRequest]]标识的模块暴露出的预期绑定的名称。"*"表明这个引入请求是要目标模块的命名空间对象 |
| \[\[LocalName]]     | String | 在模块本地访问从引入模块引入的值时的名称。                                                               |
***** 注意1  表46给出了用ImportEntryRecord字段表示import句法形式的例子
表46
| import语句形式                | \[\[ModuleRequest]]     | \[\[ImportName]] | \[\[LocalName]] |
| import v from "mod";          | "mod"                   | "default"        | "v"             |
| import * as ns from "mod";    | "mod"                   | "*"              | "ns"            |
| import { x } from "mod";      | "mod"                   | "x"              | "x"             |
| import { x as v } from "mod"; | "mod"                   | "x"              | "v"             |
| import "mod"                  | 不创建ImportEntryRecord                                    |

ExportEntryRecord是关于单一声明导出的信息的理解记录。每个ExportEntryRecord有
表47列出的字段
表47
| 字段名              | 值类型       | 含义                                                                                                                                             |
| \[\[ExportName]]    | String或null | 本模块用于导出其绑定的名称。                                                                                                                     |
| \[\[ModuleRequest]] | String或null | ExportDeclaration中ModuleSpecifier的字符串值。如果ExportDeclaration没有ModuleSpecifier，则是null                                                 |
| \[\[ImportName]]    | String或null | \[\[ModuleRequest]]标识的模块暴露出的预期绑定的名称。如果ExportDeclaration没有ModuleSpecifier，则是null。"*"标识这个导出要请求全部的导出的绑定。 |
| \[\[LocalName]]     | String或null | 在模块本地访问从引入模块导出的值时的名称。如果在这个模块中无法访问导出的值，则是null                                                                                                     |
***** 注意2 表48给出了用ExportEntryRecord字段表示export句法形式的例子
表48
| epxort语句形式                 | \[\[ExportName]] | \[\[ModuleRequest]] | \[\[ImportName]] | \[\[LocalName]] |
| export var v;                  | "v"              | null                | null             | "v"             |
| export default function f() {} | "default"        | null                | null             | "f"             |
| export default function() {}   | "default"        | null                | null             | "default"       |
| export default 42;             | "default"        | null                | null             | "default"       |
| export { x };                  | "x"              | null                | null             | "x"             |
| export { v as x };             | "x"              | null                | null             | "v"             |
| export { x } from "mod";       | "x"              | "mod"               | "x"              | null            |
| export { v as x } from "mod";  | "x"              | "mod"               | "v"              | null            |
| export * from "mod";           | null             | "mod"               | "*"              | null            |
| export * as ns from "mod";     | "ns"             | "mod"               | "*"              | null            |
后续的定义规定了SourceTextModuleRecord要求的具体方法和其他抽象操作。
***** ParseModule(sourceText, realm, hostDefined)
抽象操作ParseModule接受参数sourceText（ECMAScript源文本），realm和hostDefined。
基于解析sourceText成Module的结果创建SourceTextModuleRecord。被调用时执行下列
步骤：
1. Assert：sourceText是ECMAScript的源文本（见于11章）
2. 让body是ParseText(sourceText, Module)
3. 如果body是错误列表，返回body
4. 让requestedModules是body的ModuleRequests
5. 让importEntries是body的ImportEntries
6. 让importedBoundNames是ImportedLocalNames(importEntries)
7. 让indirectExportEntries是新的空列表
8. 让localExportEntries是新的空列表
9. 让starExportEntries是新的空列表
10. 让exportEntries是body的ExportEntries
11. 遍历exportEntries的ExportEntryRecord记作ee，做
    a. 如果ee.\[\[ModuleRequest]]是null，那么
        i. 如果e.\[\[LocalName]]不是importBoundNames的名称，那么
            1. 附加ee到localExportEntries
       ii. 否则
            1. 让ie是importEntries中其\[\[LocalName]]与ee.\[\[LocalName]]相同的元素
            2. 如果ie.\[\[ImportName]]是"*"，那么
                a. 注意：这是将引入模块的命名空间对象重新导出。
                b. 附加ee到localExportEntries
            3. 否则
                a. 注意：这是重新导出单独名称。
                b. 附加ExportEntryRecord { \[\[ModuleRequest]]:ie.\[\[ModuelRequest]],
                   \[\[ImportName]]:ie.\[\[ImportName]], \[\[LocalName]]:null,
                   \[\[ExportName]]:ee.\[\[ExportName]] }到indirectExportEntries。
    b. 否则如果ee.\[\[ImprotName]]是"*"而且ee.\[\[ExportName]]是null，那么
        i. 附加ee到startExportEntries
    c. 否则
        i. 附加ee到indirectExportEntries
12. 返回SourceTextModuleRecord { \[\[Realm]]:realm, \[\[Environment]]:undefined,
    \[\[Namespace]]:undefined, \[\[Status]]:unlinked, \[\[EvaluationError]]:undefined,
    \[\[HostDefined]]:hostDefined, \[\[ECMAScriptCode]]:body, \[\[Context]]:empty,
    \[\[ImportMeta]]:empty, \[\[RequestedModules]]:requestedModules,
    \[\[ImportEntries]]:importEntries, \[\[LocalExportEntries]]:localExportEntries,
    \[\[IndirectExportEntries]]:indirectExportEntries,
    \[\[StarExportEntries]]:starExportEntries, \[\[DFSIndex]]:undefined,
    \[\[DFSAncestorIndex]]:undefined, }
***** GetExportedNames(\[exportStarSet]) Concrete Method
SourceTextModuleRecord型module的GetExportedNames具体方法接受可选参数
exportStarSet。被调用时执行步骤：
1. 如果exportStarSet不存在，置exportStarSet为新的空列表
2. Assert：exportStarSet是SourceTextModuleRecords的列表
3. 如果exportStarSet含有module，那么
    a. Assert：我们到达环形export *的起始点
    b. 返回新的空列表
4. 附加module到exportStarSet中
5. 让exportedNames是新的空列表
6. 遍历module.\[\[LocalExportEntries]]的ExportEntryRecord记作e，做
    a. Assert：module为本导出提供了直接绑定
    b. 附加e.\[\[ExportName]]到exportedNames
7. 遍历module.\[\[IndirectExportEntries]]的ExportEntryRecord记作e，做
    a. Assert：module为本导出引入了特定的绑定
    b. 附加e.\[\[ExportName]]到exportedNames
8. 遍历module.\[\[StarExportEntries]]的ExportEntryRecord记作e，做
    a. 让requestedModule是?HostResolveImportedModule(module, e.\[\[ModuleRequest]])
    b. 让starNames是?requestedModule.GetExportedNames(exportStarSet)
    c. 遍历startNames的元素记作n，做
        i. 如果SameValue(n, "default")是false，那么
            1. 如果n不是exportedNames的元素，那么
                a. 附加n到exportedNames
9. 返回exprotedNames
****** 注意 GetExportedNames不会过滤或者投掷异常由星号导出产生的名称混淆。
***** ResolveExport(exportName\[, resovleSet]) Concrete Method
SourceTextModuleRecord型module的ResolveExport具体方法接受参数exportName（String）
和可选参数resolveSet。

ResolveExport试图将引入的绑定解释为实际定义在其模块上的本地绑定。定义所在
模块可以是在其上调用此方法用ModuleRecord表示的模块，或者那个模块引入的其他
模块。参数resolveSet用于侦测未解释的import/export环路。如果由特定ModuleRecord
和exportName构成的对被放到resolveSet并被到达（什么鬼，不知道怎么翻译。估计
是eportName和对应ModuleRecord，放到resolveSet中，并被用到），记作一个引入
环。在调用ResolveExport进行递归解释前，由module和exportName构成的对会放到
resolveSet中。

如果定义所在模型被找到，返回ResolveBindingRecord { \[\[Module]],
\[\[BindingName]] }。本记录标识解释处的源初导出，除非这是一个没有本地绑定的
命名空间的导出。此时，\[\[BindingName]]被置成"*namespace*"。如果没有找到定义，
或者请求是环形请求，返回null。如果请求是混淆的，返回"ambiguous"。

本具体函数被调用时执行下列步骤：
1. 如果resolveSet不存在，置resolveSet是新的空列表
2. Assert：resovleSet是Record { \[\[Module]], \[\[ExportName]] }的列表
3. 遍历resolveSet的Record { \[\[Module]], \[\[ExportName]] }，记作r，做
    a. 如果module和r.\[\[Module]]是相同的ModuelRecord，而且SameValue(exportName,
       r.\[\[ExportName]]是true，那么
        i. Assert：这是一个循环引入
       ii. 返回null
4. 附加 Record { \[\[Module]]: module, \[\[ExportName]]:exportName } 到resovleSet
5. 遍历module.\[\[LocalExportEntries]]的ExportEntryRecord记作e，做
    a. 如果SameValue(exportName, e.\[\[ExportName]])是true，那么
        i. Assert：module提供了本导出的直接绑定。
       ii. 返回ResolveBindingRecord { \[\[Module]]:module,
           \[\[BindingName]]:e.\[\[LocalName]] }
6. 遍历module.\[\[IndirectExportEntries]]的ExportEntryRecord记作e，做
    a. 如果SameValue(exportName, e.\[\[ExportName]])是true，那么
        i. 让importedModule是?HostResolveImportedModule(module, e.\[\[ModuleRequest]])
       ii. 如果e.\[\[ImportName]]是"*"，那么
            1. Assert：module没有为此导出提供直接绑定
            2. 返回ResolveBindingRecord { \[\[Module]]: importedModule,
               \[\[BindingName]]: "*namespace*", }
      iii. 否则
            1. Assert：module为此导出引入了特定绑定
            2. 返回importedMoudle.ResolveExport(e.\[\[ImportName]], resolveSet)
7. 如果SameValue(exportName, "default")是true，那么
    a. Assert：本模块没有显示定义一个default导出
    b. 返回null
    c. 注意：export * 或者 export * from "mod"不会提供default导出。
8. 让starResolution是null
9. 遍历module.\[\[StartExportEntries]]的ExportEntryRecord记作e，做
    a. 让importedModule是?HostResolveImportedModule(module, e.\[\[ModuleRequest]])
    b. 让resolution是?importedModule.ResolveExport(exportName, resolveSet)
    c. 如果resolution是"ambiguous"，返回"ambiguous"
    d. 如果resolution不是null，那么
        i. Assert：resolution是ResolvedBindingRecord
       ii. 如果starResolution是null，置starResolution是resolution
      iii. 否则
            1. Assert：多个*引入包含了请求的名称。
            2. 如果resolution.\[\[Module]]和starResolution.\[\[Module]]是不同的
               ModuleRecord，或者SameValue(resolution.\[\[BindingName]],
               starResolution.\[\[BindingName]])是false，返回"ambiguous"
10. 返回starResolution
***** InitializeEnvironment() Concrete Method
SourceTextModuleRecord型module的InitializeEnvironment具体方法不接受参数。被调用时
执行下列步骤：
1. 遍历module.\[\[IndirectExportEntries]]的ExportEntryRecord记作e，做
    a. 让resolution是?module.ResolveExport(e.\[\[ExportName]])
    b. 如果resolution是null或者"ambiguous"，投掷SyntaxError异常
    c. Assert：resolution是ResolvedBindingRecord
2. Assert：module所有导出都已经解释。
3. 让realm是module.\[\[Realm]]
4. Assert：realm不是undefined
5. 让env是NewModuleEnvironment(realm.\[\[GlobalEnv]])
6. 置module.\[\[Environment]]是env
7. 遍历module.\[\[ImportEntries]]的ImportEntryRecord记作in，做
    a. 让importedModule是!HostResolveImportedModule(module, in.\[\[ModuleRequest]])
    b. 注意：上面的调用不会失败，因为这些模块引入请求是
       module.\[\[RequestedModule]]的子集，在本算法之前就应解释了。
    c. 如果in.\[\[ImportName]]是"*"，那么
        i. 让namespace是?GetModuleNamespace(importedModule)
       ii. 执行!env.CreateImmutableBinding(in.\[\[LocalName]], true)
      iii. 调用env.InitializeBinding(in.\[\[LocalName]], namespace)
    d. 否则
        i. 让resolution是?importedModule.ResolveExport(in.\[\[ExportName]])
       ii. 如果resolution是null或者"ambiguous"，投掷SyntaxError异常
      iii. 如果resolution.\[\[BindingName]]是"*namespace*"，那么
            1. 让namespace是?GetModuleNamespace(resolution.\[\[Module]])
            2. 执行!env.CreateImmutableBinding(in.\[\[LocalName]], true)
            3. 调用env.InitializeBinding(in.\[\[LocalName]], namespace)
       iv. 否则
            1. 调用env.CreateImportBinding(in.\[\[LocalName]], resolution.\[\[Module]],
               resolution.\[\[BindingName]])
8. 让moduleContext是新的ECMAScript代码的执行背景
9. 置moduleContext的Funtion是null
10. Assert：module.\[\[Realm]]不是undefined
11. 置moduleContext的Realm是module.\[\[Realm]]
12. 置ScriptOrModule的Realm是module
13. 置VariableEnvironment的Realm是module.\[\[Environment]]
14. 置LexicalEnvironment的Realm是module.\[\[Environment]]
15. 置module.\[\[Context]]是moduleContext
16. 推送moduleContext到执行背景栈，moduleContext目前是运行时执行背景
17. 让code是module.\[\[ECMAScriptCode]]
18. 让varDeclarations是code的VarScopedDeclarations
19. 让declaredVarNames是新的空列表
20. 遍历varDeclarations的元素记作d，做
    a. 遍历d的BoundNaems的元素记作dn，做
        i. 如果dn不是declaredVarNames的元素，那么
            1. 执行!env.CreateMutableBinding(dn, false)
            2. 调用env.InitializeBinding(dn, undefined)
            3. 附加dn到declaredVarNames
21. 让lexDeclarations是code的LexicallyScopedDeclarations
22. 遍历lexDeclarations的元素就做d，做
    a. 遍历d的BoundNaems的元素记作dn，做
        i. 如果d的IsConstantDeclaration是true，那么
            1. 执行!env.CreateImmutableBinding(dn, true)
        i. 否则
            1. 执行!env.CreateMutableBinding(dn, false)
        i. 如果d是FunctionDeclaration、GeneratorDeclaration、AsyncFunctionDeclaration
           或者AsyncGeneratorDeclaration，那么
            1. 让fo是d带参数env的InstantiateFunctionObject
            2. 调用env.InitializeBinding(dn, fo)
23. 从执行背景栈移除moduleContext
24. 返回NormalCompletion(empty)
***** ExecuteModule() Concrete Method
SourceTextModuleRecord型module的ExecuteModule具体方法不接受参数。被调用时执行
下列步骤：
1. 挂起运行时执行背景
2. 让moduleContext是module.\[\[Context]]
3. 推送moduleContext到执行背景栈，moduleContext目前是运行时执行背景
4. 让result是评估module.\[\[ECMAScriptCode]]的结果
5. 挂起moduleContext并从执行背景栈移除moduleContext
6. 重新启用执行背景栈的顶层背景，作为运行时执行背景
7. 返回Completion(result)
**** HostResolveImportedModule(referencingScriptOrModule, specifier)
主机定义的抽象操作HostResolveImportedModule接受参数referencingScriptOrModule（
ScriptRecord、ModuleRecord或者null）和specifier（ModuleSpecifier字符串）。它根据
出现在referencingScriptOrModule表示的脚本或模块的背景里的specifier提供具体的
ModuleRecord子类。referencingScriptOrModule可能是null，如果这个解释行为发生在
import()表达式的背景里，在那时也没有活跃脚本或者模块。
***** 注意 在浏览器主机发生的一个referencingScriptOrMoudle是null的例子。当点击
            下方代码表示的按钮
            <button type="button" onlick="import('./foo.js')">Click Import</button>
            ，在运行import()表达式时，没有活跃脚本或者模块。更广泛的说，在
            将带有null ScriptOrModule组件的执行背景推送到执行背景栈处，就可能
            发生上述情况（referencingScriptOrModule是null）。
HostResolveImportedModule的实现必须遵循随后的要求：
. 正常返回必须是ModuleRecord的具体类的实例
. 如果与referencingScriptOrModule和specifier一致的ModuleRecord不存在或者无法创建，
  必须投掷异常
. 带着给定referencingScriptOrModule和sepcifier调用本操作，如果能够正常完结，返回
  的必须是同一个ModuleRecord实例

多个不同的referencingScriptOrModule和specifier对可以映射到相同ModuleRecord实例
上。实际的映射语法是主机定义的，但是通常在映射过程里会有一部分是正规化
specifier的过程。常见的正规化过程会包含例如字母大小写折叠和相对路径与路径
缩写的展开等动作。
**** HostImportModuleDynamically(referencingScriptOrModule, specifier, promiseCapability)
主机定义的抽象操作HostImportModuleDynamically接受参数referencingScriptOrModule（
ScriptRecord、ModuleRecord或者null）、specifier（ModuleSpecifier字符串）和
promiseCapability（PromiseCapabilityRecord）。它根据出现在referencingScriptOrModule
表示的脚本或模块的背景里的specifier执行任何必要的安装工作，以使模块可用。
referencingScriptOrModule可能是null，如果这个解释行为发生在import()表达式的背
景里。本操作随后执行FinishDynamicImport来完成动态导入过程。

HostImportModuleDynamically实现必须遵循如下要求：
. 此抽象操作总是以undefined正常完结。成功或者失败必须使用下方的方式标记。
. 主机环境必须遵循随后其要求
  成功路径
    。其后，主机环境必须执行FinishDynmaicImport(referencingScriptOrModule,
      specifier, promiseCapability, NormalCompletion(undefined))
    。给定的referencingScriptOrModule和specifier，完成过FinisDynamicImport，
      再调用HostResolveImportedModule，必须返回正常完结。
    。给定的referencingScriptOrModule和specifier，完成过FinisDynamicImport，
      再调用HostResolveImportedModule，返回值必须是已经评估过的模块，也就是说
      其Evaluated具体方法已经被调用过，且返回了正常完结
  失败路径
    。其后，主机环境必须执行FinishDynmaicImport(referencingScriptOrModule,
      specifier, promiseCapability, AbruptCompletion)，AbruptCompletion表示失败的
      原因。
. 如果主机环境从给定的referencingScriptOrModule和specifier给出了成功路径，随后
  必须总是相同的结果。
. 本操作不能调用promiseCapability.\[\[Resolve]]或者promiseCapability.\[\[Reject]]，
  只是将promiseCapability作为可见的标识传递给FinishDynamicImport

实际的过程是主机定义执行的，但是通常会执行必要的I/O操作，让
HostResolveImportedModule同步接受恰当的ModueRecord，然后调用他的Evaluate具体方
法。在进行HostResolveImportedModule时，可能需要执行编码正规化。
**** FinishDynamicImport(referencingScriptOrModule, specifier, promiseCapability, completion)
抽象操作FinishDynamicImport接受参数referencingScriptOrModule、sepcififer、
promiseCapabiltiy（PromiseCapabilityRecord）和completion。FinishDynamicImport完成由
调用import()引起的动态引入过程，本承诺根据completion返回合适的解释或者拒绝。
它作为HostImportModuleDynamically的一部分被主机环境执行。被调用时执行下列步
骤：
1. 如果completion是意外完结，执行!Call(promiseCapability.\[\[Reject]], undefined, <<
   completion.\[\[Value]] >>)
2. 否则
    a. Assert：completion是正常完结，而且completion.\[\[Value]]是undefined
    b. 让moduleRecord是!HostResolveImportedModule(referencingScriptOrModule, specifier)
    c. Assert：Evaluate已经在moduleRecord上唤起过，并且成功完结
    d. 让namespace是GetModuleNamepspace(moduleRecord)
    e. 如果namespace是意外完结，执行!Call(promiseCapability.\[\[Reject]], undefined,
       << namespace.\[\[Value]] >> )
    f. 否则，执行!Call(promiseCapability.\[\[Resolve]], undefined, <<
       namespace.\[\[Value]] >> )
**** GetModuleNamespace(module)
抽象操作GetModuleNamespace接受参数module。查找表示module导出信息的ModuleNamespace
对象，在第一次请求它时，才创建它，并存储在module.\[\[Namespace]]上，方便以后
的查找。被调用时执行下列步骤：
1. Assert：module时ModuleRecord的具体子类的实例
2. Assert：如果module是CyclicModuleRecord，那么module.\[\[Status]]不是unlinked
3. 让namespace是module.\[\[Namespace]]
4. 如果namespace是undefined，那么
    a. 让exportedNames是?module.GetExportedNames()
    b. 让unambiguousNames是新的空列表
    c. 遍历exportedNames的元素记作name，做
        i. 让resolution是?module.ResolveExport(name)
       ii. 如果resolution是ResolvedBindingRecord，附加name到unambiguousNames。
    d. 置namespace是ModuleNamespaceCreate(module, unambiguousNames)
5. 返回namespace。
***** 注意 只有在GetModuleNamespace里通过触发HostResolveImportedModule调用，才可能
            会投掷异常。此处无法解释的名称就简单排除在命名空间之外。它们会在
            以后导致实际链接错误，除非它们都是星号导出的混淆，而且任何地方
            都没有显式请求。
**** Runtime Semantics: Evaluation
Module : [empty]
1. 返回NormalCompleion(undefined)

ModuleBody : ModuleItemList
1. 让resul是评估ModuleItemList的结果
2. 如果result.\[\[Type]]是normal，而且result.\[\[Value]]是空，那么
    a. 返回NormalCompletion(undefined)
3. 返回Completion(result)

ModuleItemList : ModuleItemLit ModuleItem
1. 让st是评估ModuleItemList的结果
2. ReturnIfAbrupt(st)
3. 让s是评估ModuleItem的结果
4. 返回Completion(UpdateEmpty(s, sl))
***** 注意 ModuleItemList的值是ModuleItemList最有一个有值码型的值
ModuleItem : ImportDeclaration
1. 返回NormalCompletion(empty)
*** Imports
**** Synax
ImportDeclaration:
    import ImportClause FromClause ;
    import ModuleSpecifier ;

ImportClause :
    ImportedDefaultBinding
    NameSpaceImport
    NamedImports
    ImportedDefaultBinding , NameSpaceImport
    ImportedDefaultBinding , NamedImports

ImportedDefalutBinding :
    ImportedBinding

NameSpaceImport : 
    * as ImportedBinding

NamedImports :
    { }
    { ImportsList }
    { ImportsList , }

FromClause :
    from ModuleSpecifier

ImportsList :
    ImportSpecifier
    ImportsList , ImportSpecifier

ImportSpecifier :
    ImportedBinding
    IdentifierName as ImportedBinding

ModuleSpecifier :
    StringLiteral

ImportedBinding :
    BindingIdentifier_[~Yield, ~Await]
**** Static Semantics: Early Errors
ModuleItem : ImportDeclaration
. 如果ImportDeclaration的BoundNames里包含任何重复实体，那么有SyntaxError。
**** Static Semantics: ImportEntries
Module : [empty]
1. 返回新的空列表

ModuleItemList : ModuleItemList ModuleItem
1. 让entries是ModuleItemList的ImportEntries
2. 将ModuleItem的ImportEntries的元素依次附加到entries
3. 返回entries

ModuleItem
    ExportDeclaration
    StatementListItem
1. 返回新的空列表

ImportDeclaration : import ImportClause FromClause ;
1. 让module是FromClause的ModuleRequests里的唯一元素
2. 返回ImportClauses带参数module的ImportEntriesFromModule

ImportDeclaration : import ModuleSepcifier ;
1. 返回新的空列表
**** Static Semantics: ImportEntriesForModule
带参数module
ImportClause : ImportedDefaultBinding , NameSapceImport
1. 让entries是ImportedDefaultBinding带参数module的ImportEntriesFromModule
2. 将NameSpaceImport带参数module的ImportEntriesForModule的元素符加到entries
3. 返回entries

ImportClause : ImportedDefaultBinding , NamedImports
1. 让entries是ImportedDefaultBinding带参数module的ImportEntriesFromModule
2. 将NamedImports带参数module的ImportEntriesForModule的元素符加到entries
3. 返回entries

ImportedDefaultBinding : ImportedBinding
1. 让localName是ImportedBinding的BoundNames的唯一元素
2. 让defaultEntry是ImportEntryRecord { \[\[ModuleRequest]]:module,
   \[\[ImportName]]:"default", \[\[LocalName]]: localName }
3. 返回 << defaultEntry >>

NameSapceImport : * as ImportedBinding
1. 让localName是ImportedBinding的字符串值
2. 让entry是ImportEntryRecord { \[\[ModuleRequest]]:module,
   \[\[ImportName]]:"*", \[\[LocalName]]: localName }
3. 返回 << entry >>

NamedImports : { }
1. 返回新的空列表

ImportsList : ImportsList , ImportSpecifier
1. 让specs是ImportsList带参数module的ImportEntriesForModule
2. 将ImportSpecifier带参数module的ImportEntriesForModule的元素符加到entries
3. 返回specs

ImportSpecifier : ImportedBinding
1. 让localName是ImportedBinding的BoundNames的唯一元素
2. 让entry是ImportEntryRecord { \[\[ModuleRequest]]:module,
   \[\[ImportName]]: localName, \[\[LocalName]]: localName }
3. 返回 << entry >>

ImportSpecifier : IdentifierName as ImportedBinding
1. 让importName是IdentifierName的字符串值
2. 让localName是ImportedBinding的字符串值
3. 让entry是ImportEntryRecord { \[\[ModuleRequest]]:module,
   \[\[ImportName]]: importName, \[\[LocalName]]: localName }
4. 返回 << entry >>
*** Exports
**** Syntax
ExportDeclaration :
    export ExportFromClause FromClause ;
    export NamedExports ;
    export VariableStatement_[~Yield, ~Await]
    export Declaration_[~Yield, ~Await]
    export default HoistableDeclaration_[~Yield, ~Await, +Default]
    export default ClassDeclaration_[~Yield, ~Await, +Default]
    export default [lookahead ∉ { function , async [no LineTerminator here]
        function , class }] AssignmentExpression_[+In, ~Yield, ~Await] ;
ExportFromClause :
    *
    * as IdentifierName
    NamedExports
NamedExports :
    { }
    { ExportsList }
    { ExportsList , }
ExportsList :
    ExportSpecifier
    ExportsList , ExportSpecifier
ExportSepcifier
    IdentifierName
    IdentifierName as IdentifierName
**** Static Semantics: Early Errors
ExportDeclaration : export NamedExports ;
. 遍历NamedExports的ReferencedBindings里IdentifierName记作n：如果n的字符串值是
  某个ReservedWord，或者是"implements"、"interface"、"let"、"package"、"private"、
  "protected"、"public"或"static"，那么有SyntaxError。
***** 注意 上述规则意味着NamedExports的ReferencedBindings的每个元素都被看作是
            IdentifierReference
**** Static Semantics: ExportedBindings
***** 注意 ExportedBindings是与Module的ExprotedNames显示联结的本地绑定的名称。
ModuleItemList : ModuleItemList ModuleItem
1. 让names是ModuleItemList的ExportedBindings
2. 将ModuleItem的ExportedBindings的元素符加到names
3. 返回names

ModuleItem :
    ImportDeclaration
    StatementListItem
1. 返回新的空列表

ExportDeclaration :
    export ExportFromClause FromClause ;
1. 返回新的空列表

ExportDeclaration : export NamedExpors ;
1. 返回NamedExports的ExportedBindings

ExportDeclaration : export VariableStatement
1. 返回VariableStatement的BoundNames

ExportDeclaration : export Declaration
1. 返回Declaration的BoundNames

ExportDeclaration :
    export default HoistableDeclaration
    export default ClassDeclaration
    export default AssignmentExpression ;
1. 返回本ExportDeclaration的BoundNames

NamedExports : { }
1. 返回新的空列表

ExportsList : ExportsList , ExportSepecifier
1. 让names是ExportList的ExportedBindings
2. 将ExportSpecifier的ExportedBindings的元素符加到names
3. 返回names

ExportSpecifier : IdentifierName
1. 返回<< IdentifierName的String值 >>

ExportSpecifier : IdentifierName as IdentifierName
1. 返回<< 第一个IdentifierName的String值 >>
**** Static Semantics: ExportedNames
***** 注意 ExportedNames是Module显式地将本地绑定暴露给外部的名字。
ModuleItemList : ModuleItemList ModuleItem
1. 让names是ModuleItemList的ExportedNames
2. 将ModuleItem的ExportedNames的元素符加到names
3. 返回names

ModuleItem : ExportDeclaration
1. 返回ExportDeclaration的ExportedNames

ModuleItem :
    ImportDeclaration
    StatementListItem
1. 返回新的空列表

ExportDeclaration : export ExportFromClause FromClause ;
1. 返回ExportFromClause的ExportedNames

ExportFromClause : *
1. 返回新的空列表

ExportFromClause : * as IdentifierName
1. 返回 << IdentifierName字符串值 >>

ExportFromClause : NamedExports
1. 返回NamedExports的ExportedNames

ExportDeclaration : export VariableStatement
1. 返回VariableStatement的BoundNames

ExportDeclaration : export Declaration
1. 返回Declaration的BoundNames

ExportDeclaration :
    export default HoistableDeclaration
    export default ClassDeclaration
    export default AssignmentExpression ;
1. 返回 << "default" >>

NamedExports : { }
1. 返回新的空列表

ExportsList : ExportsList , ExportSepecifier
1. 让names是ExportList的ExportedNames
2. 将ExportSpecifier的ExportedNames的元素符加到names
3. 返回names

ExportSpecifier : IdentifierName
1. 返回<< IdentifierName的String值 >>

ExportSpecifier : IdentifierName as IdentifierName
1. 返回<< 第二个IdentifierName的String值 >>
**** Static Semantics: ExportEntries
Module : [empty]
1. 返回新的空列表

ModuleItemList : ModuleItemList ModuleItem
1. 让entries是ModuleItemList的ExportEntries
2. 将ModuleItem的ExportEntries的元素依次附加到entries
3. 返回entries

ModuleItem
    ExportDeclaration
    StatementListItem
1. 返回新的空列表

ExportDeclaration : export ExportFromClause FromClause ;
1. 让moudle是FromClause的ModuleRequests的唯一元素
2. 返回ExportFromClause带参数module的ExportEntriesForModule

ExportDeclaratin : epxort NamedExports ;
1. 返回NamedExports带参数module的ExportEntriesForModule

ExportDeclaratin : epxort VariableStatement
1. 让entries是新的空列表
2. 让names是VariableStatement的BoundNames
3. 遍历names元素记作name,做
    a. 附加ExportEntryRecord { \[\[ModuleRequest]]:null, \[\[ImportName]]: null,
       \[\[LocalName]]:name, \[\[ExportName]]:name }到entries
4. 返回entries

ExportDeclaration : export Declaration
1. 让entries是新的空列表
2. 让names是Declaration的BoundNames
3. 遍历names元素记作name,做
    a. 附加ExportEntryRecord { \[\[ModuleRequest]]:null, \[\[ImportName]]: null,
       \[\[LocalName]]:name, \[\[ExportName]]:name }到entries
4. 返回entries

ExportDeclaration : export default HoistableDeclaration
1. 让names是HoistableDeclaration的BoundNames
2. 让localName是names中的唯一元素
3. 返回<< ExportEntryRecord { \[\[ModuleRequest]]:null, \[\[ImportName]]: null,
       \[\[LocalName]]: localName, \[\[ExportName]]:"default" } >>

ExportDeclaration : export default ClassDeclaration
1. 让names是ClassDeclaration的BoundNames
2. 让localName是names中的唯一元素
3. 返回<< ExportEntryRecord { \[\[ModuleRequest]]:null, \[\[ImportName]]: null,
       \[\[LocalName]]: localName, \[\[ExportName]]:"default" } >>

ExportDeclaration : export default AssignmentExpression
1. 让entry是 ExportEntryRecord { \[\[ModuleRequest]]:null, \[\[ImportName]]: null,
       \[\[LocalName]]: "*default*", \[\[ExportName]]:"default" } 
2. << entry >>
***** 注意 "*default*"是本规范用于识别匿名导出值的合成名称。
**** Static Semantics: ExportEntriesForModule
带参数module
ExportFromClause : *
1. 让entry是ExportEntryRecord  { \[\[ModuleRequest]]:module, \[\[ImportName]]: "*",
       \[\[LocalName]]: null, \[\[ExportName]]:null }
2. 返回 << entry >>

ExportFromClause : * as IdentifierName
1. 让exportName是IdentifierName的字符串值
2. 让entry是ExportEntryRecord { \[\[ModuleRequest]]:module, \[\[ImportName]]: "*",
       \[\[LocalName]]: null, \[\[ExportName]]: exportName }
3. 返回 << entry >>

NamedExports :  { }
1. 返回新的空列表

ExportsList : ExportsList , ExportSepcifier
1. 让specs是ExportList带参数module的ExportEntriesForModule
2. 将ExportSpecifier带参数module的ExportEntriesForModule的元素依次附加到entries
3. 返回specs

ExportSpecifier : IdentifierName
1. 让sourceName是IdentifierName的字符串值
2. 如果module是null，那么
    a. 让localName是sourceName
    b. 让importName是null
3. 否则
    a. 让localName是null
    b. 让importName是sourceName
4. 返回 << ExportEntryRecord { \[\[ModuleRequest]]:module, \[\[ImportName]]: importName,
       \[\[LocalName]]: localName, \[\[ExportName]]: sourceName } >>

ExportSpecifier : IdentifierName as IdentifierName
1. 让sourceName是第一个IdentifierName的字符串值
2. 让exportName是第二个IdentifierName的字符串值
3. 如果module是null，那么
    a. 让localName是sourceName
    b. 让importName是null
4. 否则
    a. 让localName是null
    b. 让importName是sourceName
5. 返回 << ExportEntryRecord { \[\[ModuleRequest]]:module, \[\[ImportName]]: importName,
       \[\[LocalName]]: localName, \[\[ExportName]]: exportName } >>
**** Static Semantics: ReferencedBindings
NamedExports : { }
1. 返回新的空列表

ExportsList : ExportsList , ExportSpecifier
1. 让names是ExportList的ReferencedBindings
2. 将ExportSpecifier的ReferencedBindings的元素符加到names
3. 返回names

ExportSpecifier : IdentifierName
1. 返回 << IdentifierName >>

ExportSpecifier : IdentifierName as IdentifierName
1. 返回 << 第一个IdentifierName >>
**** Runtime Semantics: Evaluation
ExportDeclaration :
    export ExportNameClause FromClause ;
    export NamedExports ;
1. 返回NormalCompletion(empty)

ExportDeclaration : export VariableStatement
1. 返回评估VariableStatement的结果

ExportDeclaration : export Declaration
1. 返回评估Declaration的结果

ExportDeclaration : export default HoistableDeclaration
1. 返回评估HoistableDeclaration的结果
    
ExportDeclaration : export default ClassDeclaration
1. 让value是ClassDeclaration的?BindingClassDeclarationEvaluation
2. 让className是ClassDeclaration的BoundNames里的唯一元素
3. 如果className是default，那么
    a. 让env是运行时执行背景的LexicalEnvironment
    b. 执行?InitializeBoundName("*default*", value, env)
4. 返回NormalCompletion(emtpy)

ExportDeclaration : export default AssignmentExpression ;
1. 如果IsAnonymousFunctionDefinition(AssignmentExpression)是true，那么
    a. 让value是AssignmentExpression上带参数"default"的?NamedEvaluation
2. 否则
    a. 让rhs是评估AssignmentExpression的结果
    b. 让value是?GetValue(rhs)
3. 让env是运行时执行背景的LexicalEnvironment
4. 执行?InitializeBoundName("*default*", value, env)
5. 返回NormalCompletion(emtpy)
* Error Handling and Language Extensions
实现在ECMAScript语言结构被评估的是后，必须报告最多的错误信息。EarlyError是
那些包含在Script结构里，在评估前，能够侦测和报告的错误。存在EarlyError，
将会阻止结构的评估。实现必须将报告EarlyError作为以ParseScript解析Script的环
节。在Module中的EarlyError是在Module将被评估时报告，若有则Module不会被初始
化。在eval代码中的EarlyError是在被调用eval时才报告，并阻止评估eval代码。其他
不是EarlyError的错误都是运行时错误。

实现必须报告在本规范值中" Static Semantics : Early Errors "子条目里指出的早期
错误。

实现不能像早期错误一样的对待其他错误，即使编译器能证明某个结构无法在某个
情况下无错的执行。实现可以在这种情况下发出警告，除非相应结构真的被执行了，
不然不能报告错误。

除了随后的内容，实现应该报告规定内的全部错误：
. 除在17.1限制的，主机或者实现可以扩展Script、Module或者正则表达式的语句。
  因此，所有应投掷SyntaxError错误的操作（包括eval，使用正则文法，
  或者是Funciton或RegExp构造范），在遇到是主机定义的脚本语句或者正则表达式
  语句时，可以替换为展示主机定义的行为，而不是投掷SyntaxError异常。
. 除在17.1限制的，主机或者实现可以提供额外的超出本规范描述的类型、值、
  对象、性质和函数。这会导致结构（比如在全局圈查找某个变量）拥有主机定义
  的行为，而不是投掷错误（比如ReferenceError）
** Forbidden Extensions
任何实现不能随后列出的方式扩展本规范
. 在严格模式代下，使用构造句法定义的ECMAScript函数对象，不能被创建caller和
  arguments自有性质。无论是否在严格模式代码，这两个自有性质也不能在被
  ArrowFunction、MethodDefinition、GeneratorDeclaration、GeneratorExpression、
  AsyncGeneratorDeclaration、AsyncGeneratorExpression、ClassDeclaration、
  ClassExpression、AsyncFunctionDeclaration、AsyncFunctionExpression或者
  AsyncArrowFunction定义的函数对象上创建。内建函数、使用Function构造范创建
  的严格函数、用Generator构造范创建的生成器函数、使用AysncFunction构造范创建
  的异步函数和使用bind方法创建的函数也同样不可以创建这两个自有性质。
. 如果实现扩展函数对象，使其有caller自有性质，而且使用\[\[Get]]或者
  \[\[GetOwnProperty]]能观察到，绝对不能是严格函数对象。如果它是访问性质，
  此性质\[\[Get]]属性值对应的函数在被调用时，绝对不能返回严格函数。
. 无论是映射的还是非映射的参数对象都可以被创建caller自有性质。
. 在ECMA-402中规定的内建方法的行为，比如toLocaleString，只能按照ECMA-402规定
  的进行扩展
. 22.2.1和B.1.4中的正则表达式语法不能扩展为：存在_[U]语法参数时将A-Za-Z字符
  识别为IdentityEscape_[+U]
. SyntacticGrammer不能以任何方式扩展为：允许符号:紧随在BindingIdentifier非终结符
  匹配的源文本后
. 在处理严格模式代码时，NumericLiteral语句绝对不能被扩展为包含
  LagacyOctalIntegerLiteral，DecimalIntegerLiteral语句绝对不能被扩展为包含在
  B.1.1中定义的NonOctalDecimalIntegerLiteral
. TemplateCharacter决定不能被扩展为包含在B.1.2中定义的LegacyOctalEscapeSequence
  或者NonOctalDecimalEscapeSequence
. 在处理严格模式时，定义在B.3.2、B.3.3、B.3.4或者B.3.6的扩展内容，绝对不能
  被支持。
. 在以Module为目标符进行解析时，定义在B.1.3中的扩展词法绝对不能被支持。
. ImportCall绝对不能被扩展。
* ECMAScript Standard Built-in Objects
在ECMAScript的Script或者Module开始执行时，有些特定内建对象是可用的。其一是
全局对象，是执行程序的全局环境的一部分。其二是作为全局对象上可访问的初始
性质或者间接的作为可访问内建对象的性质。

除非另有规定，一个内建对象像函数一样可调用，就是一个带有10.3描述的特质的
内建函数对象。除非另有规定，内建对象的\[\[Extensible]]内部占位初始化为true。
每个内建对象都有一个\[\[Realm]]内部占位，其值是对象最初创建时所在领的
RealmRecord。

很多内建对象是函数，可以被带参数调用。有些更是构造范：它们是可以用new操作
符的函数。针对每个内建函数，本规范描述了函数需要的参数和函数带有的性质。
针对每个构造范，本规范还描述了构造范原型的性质和用new表达式调用构造范时
返回的对象的性质。

除非本规范针对特定函数另有说明，如果内建函数或者构造范拿到的参数个数少于
规定需要的数量，函数或者构造范应该认为给足了剩余参数，只是这些参数的值是
undefined。这些缺失的参数被描述为不存在，并用规范算法进行标识。在特定函数的
描述里，术语"this value"和"NewTarget"按照10.3中规定的含义。

除非本规范针对特定函数另有说明，如果内建函数或者构造范拿到的参数个数多于
规定需要的数量，额外的参数会被评估然后被函数忽略。然而，实现会有独特的行为
来处理这些额外参数，比如不回投掷发生在这些额外参数上的TypeError。
** 注意1 实现在添加额外能力到内建函数集时，一般是鼓励增加新函数，而不是
          在已有函数上增加参数。
除非另有规定每个内建函数或构造范都有Function原型对象（20.2.3描述的
Function.prototype表达式的初始值）作为\[\[Porotype]]内部占位的值。

除非另有规定，每个内建原型对象都用Object原型对象，即20.1.3描述的
Object.prototype表达式的初始值，做为\[\[Prototype]]内部占位的值，除了Object原型
对象自身。

没有实现\[\[Constructor]]内部占位的内建函数不被认作构造范，除非在特定函数的
描述里有特殊规定。

本规范内建函数通过调用CreateBuiltinFunction抽象操作（10.3.3）来创建。参数
length和name是后面讨论的"length"和"name"性质的初始值。

每个内建函数对象，包括构造范，有"length"性质，其值是一个非负数字。除非另有
规定，这个值与函数子条款描述的参数数量一致。可选参数和剩余参数不参与计数。
** 注意2 比如Array原型对象上的"map"性质的初始化值的函数对象，使用子条款
          \<\<Array.prototype.map(callbackFn[,thisArg])>>描述，表明其接受两个名称化
          参数callbackFn和thisArg，后一个是可选的。因此这个函数的"length"性质
          的值是1_F。
除非另有规定，内建函数对象的"length"的属性是{ \[\[Writable]]:false,
\[\[Enumerable]]:false, \[\[Configurable]]:true }

每个内建函数，包括构造范，有"name"性质，其值是字符串。除非另有规定，其值
是本规范给此函数的名称。被标识为匿名函数的函数其"name"性质的值是空字符串。
作为对象性质值的函数，其值是访问此函数的字符串性质键的字符串值。被规定为
内建性质的get或set访问函数的函数在调用CreateBuiltinFunction对应有"get"或"set"
传递给prefix参数。

对于性质键是Symbol值的内建函数，"name"性质值是显示规定的。如果这个函数显示
规定以"get"或"set"为前缀，而且被规定为某内建性质的get或set访问函数，在调用
CreateBuiltinFunction时，其不带前缀的值传递给name参数，"get"或"set"对应作为
prefix参数值。

除非另有规定，内建函数对象的"name"性质有属性是 { \[\[Writable]]: false,
\[\[Enumerable]]:false, \[\[Configurable]]: true }

除非另有规定，在章节19到章节28和符录B.2中描述的数据性质有属性
{ \[\[Writable]]:true, \[\[Enumerable]]:false, \[\[Configurable]]: true }。

除非另有规定，在章节19到章节28和符录B.2中描述的访问性质有属性
{ \[\[Enumerable]]:false, \[\[Configurable]]: true }。如果只描述了get访问函数，那么
set访问函数是默认值undefined。如果只描述了set访问函数，那么get访问函数是默认
值undefined。
* The Global Object
全局对象：
. 在进入任何执行背景前创建。
. 没有\[\[Constructor]]内部方法，不能当作构造范使用new操作符。
. 没有\[\[Call]]内部方法，不能当函数调用。
. 有\[\[Prototype]]内部占位，由主机定义其值。
. 可以在本规范定义的性质外由主机定义性质。可以让全局对象的某个性质的值
  是全局对象自身。
** Value Properties of the Global Object
*** globalThis
在RealmRecord型realm里的globalObject的globalThis性质的初始值是
realm.\[\[GlobalEnv]].\[\[GlobalThisValue]]

这个性质有属性 { \[\[Writable]]:true, \[\[Enumerable]]:false,
\[\[Configurable]]:true }
*** Infinity
Infinity的值是+∞_F（见于6.1.6.1）。这个性质有数项 { \[\[Writable]]:false,
\[\[Enumerable]]:false, \[\[Configurable]]:false }
*** NaN
NaN的值是NaN（见于6.1.6.1）。这个性质有数项 { \[\[Writable]]:false,
\[\[Enumerable]]:false, \[\[Configurable]]:false }
*** undefined
undefined的值是undefined（见于6.1.1）。这个性质有数项 { \[\[Writable]]:false,
\[\[Enumerable]]:false, \[\[Configurable]]:false }
** Function Properties of the Global Object
*** eval(x)
eval函数就是%eval%内在对象。当带参数x调用eval函数时，执行下列步骤：
1. Assert：执行背景栈至少有两个元素。
2. 让callerContext是执行背景栈的第二顶部元素
3. 让callerRealm是callerContext的RealmRecord
4. 返回?PerformEval(x, callerRealm, false, false)
**** PerformEval(x, callerRealm, strictCaller, direct)
抽象操作PerformEval接受参数x、callerRealm、strictCaller和direct。被调用时执行
下列步骤：
1. Assert：如果direct是false，那么strictCaller也一定是false。
2. 如果Type(x)不是String，返回x
3. 让evalRealm是当前RealmRecord
4. 执行?HostEnsureCanCompileStrings(callerRealm, evalRealm)
5. 让inFunction是false
6. 让inMethod是false
7. 让inDerivedConstructor是false
8. 如果direct是true，那么
    a. 让thisEnvRec是!GetThisEnvironment()
    b. 如果thisEnvRec是函数环境记录，那么
        i. 让F是thisEnvRec.\[\[FunctionObject]]
       ii. 置inFunction是true
      iii. 置inMethod是thisEnvRec.HasSuperBinding()
       iv. 如果F.\[\[ContructorKind]]是derived，置inDerivedConstructor是true
9. 按照主机定义的顺序执行子步骤，可以是解析源码和检测错误交替进行
    a. 让script是ParseText(!StringToCodePoint(x), Script)
    b. 如果script是错误列表，投掷SyntaxError异常
    c. 如果script含有ScriptBody是false，返回undefined
    d. 让body是script的ScriptBody
    e. 如果inFucntion是false，而且body含有NewTarget，投掷SyntaxError异常
    f. 如果inMethod是false，而且body含有SuperProperty，投掷SyntaxError异常
    g. 如果inDerivedConstructor是false，而且body含有SuperCall，投掷SyntaxError异常
10. 如果strictCaller是true，让strictEval是true
11. 否则让strictEval是script的IsStrict
12. 让runningContext是运行时执行背景
13. 注意：如果direct是true，runningContext是运行diretEval的执行背景。如果direct
    是false，runningContext会是调用eval函数时的执行背景。
14. 如果direct是true，
    a. 让lexEnv是NewDeclarativeEnvironment(runningContext的LexicalEnvironment)
    b. 让varEnv是runningContext的VariableEnvironment
15. 否则
    a. 让lexEnv是NewDeclarativeEnvironment(evalRealm.\[\[GlobalEnv]])
    b. 让varEnv是evalRealm.\[\[GlobalEnv]]
16. 如果strictEval是true，置varEnv是lexEnv
17. 如果runningContext没有被挂起，挂起runningContext
18. 让evalContext是新的ECMAScript执行背景
19. 置evalContext的Function是null
20. 置evalContext的Realm是evalRealm
21. 置evalContext的ScriptOrModule是runningContext的ScriptOrModule
22. 置evalContext的VariableEnvironment是varEnv
23. 置evalContext的LexicalEnvironment是lexEnv
24. 将evalContext推送到执行背景栈。evalContext现在是运行时执行背景
25. 让result是EvalDeclarationInstantiation(body, varEnv, lexEnv, strictEval)
26. 如果reuslt.\[\[Type]]是normal，那么
    a. 置result是评估body的结果
27. 如果result.\[\[Type]]是normal，而且result.\[\[Value]]是空，那么
    a. 置result是NormalCompletion(undefined)
28. 挂起evalContext，将其从执行背景栈中移除
29. 恢复执行背景栈中的顶部元素做为运行时执行背景
30. 返回Completion(result)
***** 注意 如果调用背景是在评估形式参数初始化，或者调用背景的代码是严格
            模式，或者eval代码是严格模式，那么eval代码无法在调用eval的
            调用背景里变量环境里实例化变量和函数绑定。那些绑定会在新的
            VariableEnvironment里实例化，而且只能被eval代码访问。用lex、const
            和class声明的绑定总是在新的LexicalEnvironment里实例化。
**** HostEnsureCanCompileStrings(callerRealm, calleeRealm)
主机定义的抽象操作HostEnsureCanCompileStrings接受参数callerRealm（RealmRecord）
和calleeRealm（RealmRecord）。允许主机环境阻塞某些让开发者编译ECMAScript代码
的ECMAScript函数。

HostEnsureCanCompileStrings实现可以常规完结或者意外完结。任何意外完结会被
传播给它的调用者。HostEnsureCanCompileStrings的默认实现是无条件返回一个空
的常规完结。
**** EvalDeclaratinInstantiation(body, varEnv, lexEnv, strict)
抽象操作EvalDeclarationInstantiation接受参数body、varEnv、lexEnv和strict。被调用时
执行下列步骤：
1. 让varNames是body的VarDelcaredNames
2. 让varDeclarations是body的VarScopedDeclarations
3. 如果strict是false，那么
    a. 如果varEnv是全局环境记录，那么
        i. 遍历varNames的元素记作name，做
            1. 如果varEnv.HasLexicalDeclaration(name)是true，投掷SyntaxError异常
            2. 注意：eval不会创建被全局词法声明覆盖的全局var声明
    b. 让thisEnv是lexEnv
    c. Assert：随后的循环必定能结束
    d. 当thisEnv与varEnv不相同时，重复
        i. 如果thisEnv不是对象环境记录，那么
            1. 注意：with语句的环境不能含有任何词法声明，所以不需要检查
               var/let混淆。
            2. 遍历varNames的元素记作name，做
                a. 如果thisEnv.HasBinding(name)是true，那么
                    i. 投掷SyntaxError异常
                   ii. 注意符录B.3.5对上述步骤备选语义
                b. 注意：直接eval不会提升var声明到同名词法声明之上。
       ii. 置thisEnv是thisEnv.\[\[OuterEnv]]
4. 让functionsToInitialize是新的空列表
5. 让declaredFunctionNames是新的空列表
6. 按照逆序遍历varDeclaraions的元素记作d
    a. 如果d不是VariableDeclaration、ForBinding或者BindingIdentifier，那么
        i. Assert：d是FunctionDeclaration、GeneratorDeclaration、
           AsyncFunctionDeclaration或者AsyncGeneratorDeclaration
       ii. 注意：如果有多个相同名称的函数声明，最后一个生效
      iii. 让fn是d的BoundNames里的那个唯一元素
       iv. 如果fn不是declaredFunctionNames的元素，那么
            1. 如果varEnv是全局环境记录那么
                a. 让fnDefinable是?varEnv.CanDeclareGlobalFunction(fn)
                b. 如果fnDefinable是false，投掷TypeError异常
            2. 附加fn到declaredFunctionNames的末端
            3. 将d插入functionsToInitialize的首端
7. 注意：符录B.3.33在此处增加了算法步骤
8. 让declaredVarNames是新的空列表
9. 遍历varDeclarations的元素，做
    a. 如果d是VariableDeclaration、ForBinding或者BindingIdentifier，那么
        i. 遍历d的BoundNames的字符串值vn，做
            1. 如果vn不是declaredFunctionNames的元素，那么
                a. 如果varEnv是全局环境，那么
                    i. 让vnDefinable是?varEnv.CanDeclareGlobal(vn)
                   ii. 如果vnDefinable是false，投掷TypeError异常
                b. 如果vn不是declaredVarNames的元素，那么
                    i. 附加vn大量declaredVarNames
10. 除非varEnv是全局环境记录，而且全局对象是代理奇异对象，否则后续算法不会
    意外完结。
11. 让lexDeclaration是body的LexicallyScopedDeclarations
12. 遍历lexDeclaration的元素记作d，做
    a. 注意：词法声明的名称只是实例化，并不初始化。
    b. 遍历d的BoundNames的元素记作dn，做
        i. 如果d的IsConstantDeclaration是true，那么
            1. 执行?lexEnv.CreateImmutableBinding(dn, true)
       ii. 否则
            1. 执行?lexEnv.CreateMutableBinding(dn, false)
13. 遍历functionsToInitialized的ParseNode记作f，做
    a. 让fn是f的BoundNames中的唯一元素
    b. 让fo是f上带参数lexEnv的InstantiageFunctionObject
    c. 如果varEnv是全局环境记录，那么
        i. 执行?varEnv.CreateGlobalFunctionBinding(fn, fo, true)
    d. 否则
        i. 让bindingExists是varEnv.HasBinding(fn)
       ii. 如果bindingExists是false，那么
            1. 让status是!varEnv.CreateMutableBinding(fn, true)
            2. Assert：因为步骤10之前的校验，status不会是意外完结。
            3. 执行!varEnv.InitializeBinding(fn, fo, false)
      iii. 否则
            1. 执行!varEnv.SetMutableBinding(fn, fo, false)
14. 遍历declaredVarNames中的字符串记作vn，做
    a. 如果varEnv是全局环境记录，那么
        i. 执行?varEnv.CreateGlobalVarBinding(vn, true)
    b. 否则
        i. 让bindingExists是varEnv.HasBinding(vn)
       ii. 如果bindingExists是false，那么
            1. 让status是!varEnv.CreateMutableBinding(vn, true)
            2. Assert：因为步骤10之前的校验，status不会是意外完结。
            3. 执行!varEnv.InitializeBinding(vn, undefined)
15. 返回NormalCompletion(empty)
***** 注意 在符录B.3.5中有备选版本的算法。
*** isFinite( number )
isFinite函数是%isFinite%内在对象。当isFinite函数被带参数number调用时，执行
下列步骤：
1. 让num是?ToNumber(number)
2. 如果num是NaN、+∞_F或者-∞_F，返回false。
3. 其他情况返回true
*** isNaN( number )
isNaN函数是%isNaN%内在对象。当isNaN函数被带参数number调用时，执行
下列步骤：
1. 让num是?ToNumber(number)
2. 如果num是NaN，返回true
3. 其他情况返回false
**** 注意 ECMAScript代码有可靠的表达式 X !== X 检查X是否是NaN。有且只有X是
           NaN，表达式结果才是true
*** parseFloat(string)
parseFloat函数根据参数string内容表示的数值产生一个Nubmer值。

parseFloat函数是%parseFloat%内在对象。当parseFloat函数被带参数string调用时，执行
下列步骤：
1. 让inputString是?ToString(string)
2. 让trimmedString是!TrimString(inputString, start)
3. 如果trimmedString或者trimmedString的前缀都不满足StrDecimalLiteral（7.1.4.1)的语
   法，返回NaN
4. 让numberString是trimmedString里符合StrDecimalLiteral语法的最长前缀，有可能是
   trimmedString自身。
5. 让mathFloat是numberString的MV
6. 如果mathFloat是0，那么
    a. 如果trimmedString第一个编码单元是0x002D（HYPHEN-MINUS），返回-0_F
    b. 否则返回 +0_F
7. 返回F(mathFloat)
**** 注意 parseFloat只能将string头部解释为Number值；它会忽略所有不能解释成
           数值的编码单元，而且不会给出已经忽略了哪些编码单元的指示。
*** parseInt(string, radix)
parseInt函数根据指定的radix将string的内容解释成整数数值。会忽略string起始部位
的空白。如果radix是undefined或者0，会被当作10来处理，除非string以0x或者0X开始，
这时radix会被认为是16。如果radix是16，string也可以选择用0x或者0X开始。

parseInt函数是%parseInt%内在对象。当parseInt被调用时，执行下列步骤：
1. 让inputString是?ToString(string)
2. 让S是!TrimString(inputString, start)
3. 让sign是1
4. 如果S不空，而且S的第一个编码单元是0x002D（HYPHEN-MINUS），置sign是-1
5. 如果S不空，而且S的第一个编码单元是0x002B（PLUS SIGN）或者是
   0x002D（HYPHEN-MINUS），移除S上的第一个编码单元
6. 让R是R(?ToInt32(radix))
7. 让stripPrefix是true
8. 如果R ≠ 0,那么
    a. 如果 R < 2或者 R > 36，返回NaN
    b. 如果R ≠ 16，置stripPrefix是false
9. 否则
    a. 置R是10
10. 如果stripPrefix是true，那么
    a. 如果S的长度大于等于2，而且前两个编码单元是'0x'或者'0X'，那么
        i. 移除S的前两个编码单元
       ii. 置R是16
11. 如果S含有编码单元不是radix进制允许的，让end是S中第一个这种编码的位置。
    否则让end是S的长度
12. 让Z是S从0到end的子字符串
13. 如果Z是空，返回NaN
14. 让mathInt是字符串Z按照radix进制表示的整数。使用A—Z和a-z表示10到35的值
    （然而如果R是10，而Z含有超过20个有效数字，第20个数字之后的有效数字都会
    被替换成0，这个要看实现的选择。如果R不是2、4、6、8、10、16或者32，那么
    mathInt会是字符串Z按照radix进制表示的数按照实现近似的整数）。
15. 如果mathInt=0，那么
    a. 如果sign=-1，那么-0_F
    b. 否则返回+0_F
16. 返回F(sign * mathInt)
**** 注意 parseInt只会将string头部解释成整数值；它会忽略所有不能解释成
           数值的编码单元，而且不会给出已经忽略了哪些编码单元的指示。

*** URI Handling Functions
Uniform Resources Identifiers或者URIs，是标识资源（如网页或者文件）和其被网络访
问时传输协议的字符串。ECMAScript语言本身只提供了URIs的编码与解码，在
19.2.6.2、19.2.6.3、19.2.6.4和19.2.6.5中进行了描述，不提供其他使用URIs的支持。
**** 注意 很多ECMAScript实现提供了额外的函数和方法用于操作网页，这些函数都
           在本规范的圈外。
**** URI Syntax and Semantics
URI是由一系列组件分隔符分隔的组件组成。一般形式
Scheme : First / Second ; Third ? Fourth
其中名称表示组件，而":"、"/"、";"和"?"是用于分隔的保留符。encodeURI和decodeURI
函数用于完整URI，它们会假设任何出现在URI里的保留编码单元有特殊含义，也就
不会对其编码。encodeURIComponent和decodeURIComponent函数用于URI的组件部分，它们
会假设任何保留编码单元表示文本，也就必然对其编码，而不是当作URI组件上的
保留编码单元不对其解释。

随后的词法语法规定了编码后URIs的形式。
***** Syntax
uri :::
    uriCharacters_opt
uriCharacters :::
    uriCharacter uriCharacters_opt
uriCharacter :::
    uriReserved
    uriUnescaped
    uriEscaped
uriReserved ::: one of
    ; / ? : @ & = + $ ,
uriUnescaped :::
    uriAlpha
    DecimalDigit
    uriMark
uriEscaped :::
    % HexDigit HexDigit
uriAlpha ::: one of
    a b c d e f g h i j k l m n o p q r s t u v w x y z A B C D E F G H I J K L M N
        O P Q R S T U V W X Y Z 
uriMark :: one of
    - _ . ! ~ * ' ( ) 
***** 注意 上述句法是在RFC2396上的，而且不受最近RFC3986变化的影响。
***** Runtime Semantics
当URI里的编码单元不在上述所列范围，或者有时不是用于规定含义的保留编码单元，
都必须被编码。编码单元被转换成UTF-8编码，而替代对先从UFF—16转换成编码点值
（注意在[0,127]范围内的编码单元只需一个相同的值的字节）。这个字节序列
随后被转换成字符串，每个字节用转义序列'%xx'的形式表示。
***** Encode(string, unescapedSet)
抽象操作Encode接受参数string（String）和unescapedSet（String）。用于URI编码和
转义。被调用时执行下列步骤：
1. 让strLen是string中编码单元的数量
2. 让R是空字符串
3. 让k是0
4. 重复
    a. 如果k=strLen，返回R
    b. 让C是string上k处的编码单元
    c. 如果C在unescapedSet里，那么
        i. 置k为k+1
       ii. 置R为R和C的字符串拼接
    d. 否则
        i. 让cp是!CodePointAt(string, k)
       ii. 如果cp.\[\[IsUnpairedSurrogate]]是true，投掷URIError异常
      iii. 置k为k+cp.\[\[CodeUnitCount]]
       iv. 让Octets是在cp.\[\[CodePoint]]上使用UTF-8转换的字节结果列表
        v. 遍历Octets的元素记作octet，做
            1. 置R是如下的字符串拼接
                . R
                . "%"
                . octet数值以左侧补零规则用两位16进制数格式表示的字符串
***** Decode(string, reservedSet)
抽象操作Decode接受参数string（String）和reservedSet（String）。用于URI解码和
还原。被调用时执行下列步骤：
1. 让strLen是string的长度
2. 让R是空字符串
3. 让k是0
4. 重复
    a. 如果k=strLen，返回R
    b. 让C是string上k处的编码单元
    c. 如果C不是编码单元0x0025（PERCENT SIGN），那么
        i. 让S是只含有编码单元C的字符串值
    d. 否则
        i. 让start是k
       ii. 如果k+2 ≥ strLen，投掷URIError异常
      iii. 如果string上(k+1)和(k+2)处的编码单元不是16进制数字，投掷URIError异常
       iv. 让B是string上(k+1)和(k+2)处16进制数的8位二进制值
        v. 置k是k+2
       vi. 让n是B中1启头的数量
      vii. 如果n=0，那么
            1. 让C是B值的编码单元
            2. 如果C不在reservedSet，那么
                a. 让S是只含有编码单元C的字符串
            3. 否则
                a. 让S是string从start到k+1位置的子字符串。
     viii. 否则
            1. 如果n=1或者n>4，投掷URIError异常
            2. 如果k+(3*(n-1))≥ strLen，投掷URIError异常
            3. 让Octets是<< B >>
            4. 让j是1
            5. 重复，当j<n是
                a. 置k是k+1
                b. 如果string上k处的编码单元不是0x0025（PERCENT SIGN），投掷
                   URIError异常
                c. 如果string上(k+1)和(k+2)处的编码单元不是16进制数字，投掷
                   URIError异常
                d. 让B是string上(k+1)和(k+2)处16进制数的8位二进制值
                e. 置k是k+2
                f. 附加B到Octets
                g. 置j是j+1
            6. Assert：Octets的长度是n
            7. 如果Octets没有包含有效的UTF-8编码点，投掷URIError异常
            8. 让V是Octets按照UTF-8转换出的编码点，也就是说，从字节列表转换
               成21-位值。
            9. 让S是UTF16EncodeCodePoint(V)
    e. 置R是R和S的字符串拼接
    f. 置k是k+1
****** 注意 这里的统一资源标识是基于RFC2396的，而且不受最近替换了RFC2396的
             RFC3986上的变化影响。在RFC3629中给出了正式的UTF-8描述和实现。

             在UTF-8里字符使用1到6个字节进行编码。一个只有一个字节的序列，
             其最高位是0，剩下的7位用于编码字符值。在有n个字节的序列里，其
             中n>1，起始字节高位有n个位是1，且随后的位是0。此字节剩余的字位
             用于编码字符值。随后的字节高位都是1，然后是0，剩下的6个字位用于
             编码字赋值。可能存在的UTF-8编码ECMAScript字符在表49中规定。
             | Code Unit Value                        | Representation                          | 1st Octect | 2nd Octect | 3rd Octect | 4th Octect |
             | 编码单元值                             | 表示                                    | 第一字节   | 第二字节   | 第三字节   | 第四字节   |
             | 0x0000 - 0x007f                        | 00000000 0zzzzzzz                       | 0zzzzzzz   |            |            |            |
             | 0x0080 - 0x07ff                        | 00000yyy yyzzzzzz                       | 110yyyyy   | 10zzzzzz   |            |            |
             | 0x0800 - 0xD7ff                        | xxxxyyyy yyzzzzzz                       | 1110xxxx   | 10yyyyyy   | 10zzzzzz   |            |
             | 0xD800 - 0xDBFF 跟随 0xDC00-0xDFFF     | 110110vv vvwwwxx 跟随 110111yy yyzzzzzz | 11110uuu   | 10uuwwww   | 10xxyyyy   | 10zzzzzz   |
             | 0xD800 - 0xDBFF 没有跟随 0xDC00-0xDFFF | 导致URIError                            |            |            |            |            |
             | 0xDC00 - 0xDFFF                        | 导致URIError                            |            |            |            |            |
             | 0xE000 - 0xFFFF                        | xxxxyyyy yyzzzzzz                       | 1110xxxx   | 10yyyyyy   | 10zzzzzz   |            |
             Unicode标准（替代）3.8节中对0x10000的附加说明可以解释为啥
             uuuuu = vvvv + 1（u比v多了1个）。

             上述的转换将每个替代对（从0xD800到0xDFFF的编码单元值会被保留）组
             合成UTF-32的表示，并将21位二进制值编码成UTF-8。解码是组装替代对。

             RFC3629阻止解析无效的UTF-8字节序列。例如，无效的序列C0 80绝对不能
             解析位编码单元0x0000。解码算法的实现被要求在遇到这种无效序列时
             投掷URIError异常。（这里C0 80是UTF-8序列，C0表示第一个字节全是0，
             那么就被省略掉，应该只有80表示的内容。但是80应该用00表示）。
**** decodeURI(encodedURI)
decodeURI函数将可能是被encodeURI函数引入的转义序列和UTF-8编码，按照顺序替换为
其表示的UTF-16编码点，从而计算出新版本的URI。不会被encodeURI引入的转义序列也
不会被替换。decodeURI函数是%decodeURI%内在对象。当decodeURI被带参数encodedURI调
用时，执行下列步骤：
1. 让uriString是?ToString(encodedURI)
2. 让reservedURISet是包含uriReserved元素和"#"的字符串（即";/?:@&=+$,#"）。
3. 返回?Decode(uriString, reservedURISet)
***** 注意 #是不会被从转义序列里解码的，尽管它不是URI保留编码点。
**** decodeURIComponent(encodedURIComponent)
decodeURIComponent函数将可能是被encodeURIComponent函数引入的转义序列和UTF-8
编码，按照顺序替换为其表示的UTF-16编码点，从而计算出新版本的URI。

decodeURIComponent函数是%decodeURIComponent%内在对象。当decodeURIComponent被带参
数encodedURIComponent调用时，执行下列步骤：
1. 让componentString是?ToString(encodedURIComponent)
2. 让reservedURIComponentSet空字符串
3. 返回?Decode(componentString, reservedURIComponentSet)
**** encodeURI(uri)
encodeURI函数计算出一个新版的按照UTF-16（6.1.4）编码后的URI，其中每个编码点
再按照UTF-8编码替换为对应的1/2/3或4个转义序列。

ecodeURI函数是%encodeURI%内在对象。当encodeURI被带参数uri调用时，执行下列步骤：
1. 让uriString是?ToString(uri)
2. 让unescapedURISet是包含uriReserved和uriUnescaped的元素和"#"的字符串（即
   ";/?:@&=+$abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_
   .!~*'()#"）。
3. 返回?Encode(uriString, unescapedURISet)
***** 注意 编码点#尽管不是保留字符，也不是非转义字符，就是不进行转义
**** encodeURIComponent(uriComponent)
encodeURIComponent函数计算出一个新版的按照UTF-16（6.1.4）编码后的URI，其中每个
编码点再按照UTF-8编码替换为对应的1/2/3或4个转义序列。

ecodeURIComponent函数是%encodeURIComponent%内在对象。当encodeURIComponent被带参数
uriComponent调用时，执行下列步骤：
1. 让componentString是?ToString(uriComponent)
2. 让unescapedURIComponentSet是包含uriUnescaped元素的字符串（即
   "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_
   .!~*'()"）。
3. 返回?Encode(componentString, unescapedURIComponentSet)
** Constructor Properties of the Global Object
*** Array(...)
见于23.1.1
*** ArrayBuffer(...)
见于25.1.3
*** BigInt(...)
见于23.2.1
*** BigIntArray(...)
见于23.2.5
*** BigUint64Array(...)
见于23.2.5
*** Boolean(...)
见于20.3.1
*** DataView(...)
见于25.3.2
*** Date(...)
见于21.4.2
*** Error(...)
见于20.5.1
*** EvalError(...)
见于20.5.5.1
*** FinalizationRegistry(...)
见于26.2.1
*** Float32Array(...)
见于23.2.5
*** Float64Array(...)
见于23.2.5
*** Function(...)
见于20.2.1
*** Int8Array(...)
见于23.2.5
*** Int16Array(...)
见于23.2.5
*** Int32Array(...)
见于23.2.5
*** Map(...)
见于24.1.1
*** Number(...)
见于21.1.1
*** Object(...)
见于20.1.1
*** Promise(...)
见于27.2.3
*** Proxy(...)
见于28.2.1
*** RangeError(...)
见于20.5.5.3
*** ReferenceError(...)
见于20.5.5.4
*** RegExp(...)
见于22.2.3
*** Set(...)
见于24.2.1
*** SharedArrayBuffer(...)
见于25.2.2
*** String(...)
见于22.1.1
*** Symbol(...)
见于20.4.1
*** SyntaxError(...)
见于20.5.5.4
*** TypeError(...)
见于20.5.5.5
*** Uint8Array(...)
见于23.2.5
*** Uint8ClampedArray(...)
见于23.2.5
*** Uint16Array(...)
见于23.2.5
*** Uint32 Array(...)
见于23.2.5
*** URIError(...)
见于20.5.5.6
*** WeakMap(...)
见于24.3.1
*** WeakRef(...)
见于26.1.1
*** WeakSet(...)
见于24.4
*** Array(...)
见于2
** Other Properties of the Global Object
*** Atomics
见于25.4
*** JSON
见于25.5
*** Math
见于21.3
*** Reflect
见于28.1
* Fundamental Objects
** Object Objects
*** The Object Constructor
Object构造范:
. 是%Object%
. 是全局对象上"Object"性质的初始值
. 当作为构造范调用时创建一个基本对象
. 当作为函数而不是构造范被调用时，执行类型转换
. 被设计成可继承。也就是说可以用在定义class时的extends语句里
**** Object([value])
当Object函数被带可选参数value调用时，执行下列步骤：
1. 如果NewTarget即不是undefined，也不是活跃的函数，那么
    a. 返回?OrdinaryCreateFromConstructor(NewTarget, "%Object.prototype%")
2. 如果value是undefined或者null，返回!OrdinaryObjectCreate(%Object.prototype%)
3. 返回!ToObject(value)
Object函数的"length"性质是1_F。
*** Properties of the Object Constructor
Object构造范：
. 有\[\[Prototype]]内部占位，值是%Function.prototype%
. 有"length"性质
. 有随后额外性质：
**** Obejct.assign(target, ...sources)
assign函数用于从一个或多个源对象上复制所有可枚举的自有性质到target对象上。
当assign函数被调用时，执行下列步骤：
1. 让to是?ToObject(target)
2. 如果只传递了一个参数，返回to
3. 遍历sources中每个元素记作nextSource，做
    a. 如果nextSource不是undefined也不是null，那么
        i. 让from是!ToObject(nextSource)
       ii. 让keys是?from.\[\[OwnPropertyKeys]]()
      iii. 遍历keys中的每个元素记作nextKey，做
            1. 让desc是?from.\[\[GetOwnProperty]](nextKey)
            2. 如果desc不是undefined，而且desc.\[\[Enumerable]]是true，那么
                a. 让propValue是?Get(from, nextKey)
                b. 执行?Set(to, nextKey, propValue, true)
4. 返回to
assign函数的"length"性质是2_F
**** Object.create(O, Properties)
create函数用指定的原型创建新的对象。当create函数被调用时，执行下列步骤：
1. 如果Type(O)即不是Object也不是Null，投掷TypeError异常
2. 让obj是!OrdinaryObjectCreate(O)
3. 如果Properties不是undefined，那么
    a. 返回?ObjectDefineProperties(obj, Properties)
4. 返回obj
**** Object.defineProperties(O, Properties)
defineProperties函数用于新增对象的自有性质，和/或更新对象的已有性质的属性。
当defineProperties函数被调用时，执行下列步骤：
1. 如果Type(O)不是Object，投掷TypeError异常
2. 返回?ObjectDefineProperties(O, Properties)
***** ObjectDefineProperties(O, Properties)
抽象操作ObjectDefineProperties接受参数O和Properties。被调用时执行下列步骤：
1. Assert：Type(O)是Object
2. 让props是?ToObject(Properties)
3. 让keys是?props.\[\[OwnPropertyKeys]]()
4. 让descriptors是新的空列表
5. 遍历keys中元素记作nextKey，做
    a. 让propDesc是?props.\[\[GetOwnProperty]](nextKey)
    b. 如果propDesc不是undefined，而且propDesc.\[\[Enumerable]]是true，那么
        i. 让descObj是?Get(props, nextKey)
       ii. 让desc是?ToPropertyDescriptor(descObj)
      iii. 将由nextKey和desc组成的对（有两个元素的列表）附加到descriptors上。
6. 遍历descriptors中元素记作pair，做
    a. 让P是pair的第一个元素
    b. 让desc是pair的第二个元素
    c. 执行?DefinePropertyOrThrow(O, P, desc)
7. 返回O
**** Object.defineProperty(O, P, Attributes)
defineProperty函数用于新增对象某个自有性质，和/或更新对象的某个已有性质
的属性。defineProperty函数被调用时，执行下列步骤：
1. 如果Type(O)不是Object，投掷TypeError异常
2. 让key是?ToPropertyKey(P)
3. 让desc是?ToPropertyDescriptor(Attributes)
4. 执行?DefinePropertyOrThrow(O, key, desc)
5. 返回O
**** Object.entries(O)
当entries被带参数O调用时，执行下列步骤：
1. 让obj是?ToObject(O)
2. 让nameList是?EnumerableOwnPropertyNames(obj, key+value)
3. 返回CreateArrayFromList(nameList)
**** Object.freeze(O)
当freeze函数被调用时，执行下列步骤：
1. 如果Type(O)不是Object，返回O
2. 让status是?SetIntegrityLevel(O, frozen)
3. 如果status是false，投掷TypeError异常
4. 返回O
**** Object.fromEntries(iterable)
当fromEntries函数被带参数iterable调用时，执行下列步骤：
1. 执行?RequireObjectCoercible(iterable)
2. 让obj是!OrdinaryObjectCreate(%Object.prototype%)
3. Assert：obj是没有自有性质的可扩展基本对象。
4. 让stepsDefine是定义在CreateDataPropertyOnObject函数的算法步骤
5. 让lengthDefine是定义在CreateDataPropertyOnObject函数的非可选参数的数量
6. 让adder是!CreateBuiltinFunction(stepsDefine, lengthDefine, '""', << >>)
7. 返回?AddEntriesFromIterable(obj, iterable, adder)
***** 注意 创建的adder函数永远不会被ECMAScript代码直接访问到。
***** CreateDataPropertyOnObject Functions
CreateDataPropertyOnObject函数是内建匿名函数。当CreateDataPropertyOnObject被带参数
key和value调用时，执行下列步骤：
1. 让O是this值
2. Assert：Type(O)是Object
3. Assert：O是可扩展的基本对象
4. 让propertyKey是?ToPropertyKey(key)
5. 执行!CreateDataPropertyOrThrow(O, propertyKey, value)
6. 返回undefined
**** Object.getOwnPropertyDescriptor(O, P)
当getOwnPropertyDescriptor函数被调用时，执行下列步骤：
1. 让obj是?ToObject(O)
2. 让key是?ToPropertyKey(P)
3. 让desc是?obj.\[\[GetOwnProperty]](key)
4. 返回FromPropertyDescriptor(desc)
**** Object.getOwnPropertyDescriptors(O)
当getOwnPropertyDescriptors被调用时，执行下列步骤：
1. 让obj是?ToObject(O)
2. 让ownKeys是?obj.\[\[OwnPropertyKeys]]()
3. 让descriptors是!OrdinaryObjectCreate(%Object.prototype%)
4. 遍历ownKeys元素记作ownKey，做
    a. 让desc是?obj.\[\[GetOwnProperty]](key)
    b. 让descriptor是!FromPropertyDescriptor(desc)
    c. 如果descriptor不是undefined，
       执行!CreateDataPropertyOrThrow(descriptors, key, descriptor)
5. 返回descriptors
**** Object.getOwnPropertyNames(O)
当getOwnerPropertyNames被调用时，执行下列步骤
1. 返回?GetOwnPropertyKeys(O, string)
**** Object.getOwnPropertySymbols(O)
当getOwnerPropertySymbols被调用时，执行下列步骤
1. 返回?GetOwnPropertyKeys(O, symbol)
***** GetOwnPropertyKeys(O, type)
抽象操作GetOwnPropertyKeys接受参数O和type（string或者symbol）。被调用时执行
下列步骤：
1. 让obj是?ToObject(O)
2. 让keys是?obj.\[\[OwnPropertyKeys]]()
3. 让nameList是新的空列表
4. 遍历keys的元素记作nextKey，做
    a. 如果Type(nextKey)是Symbol而且type是symbol，或者Type(nextKey)是String而且
       type是string，那么
        i. 附加nextKey到nameList的末端
5. 返回CreateArrayFromList(nameList)
**** Object.getPrototypeOf(O)
当getPrototypeOf被带参数O调用时，执行下列步骤：
1. 让obj是?ToObject(O)
2. 返回?obj.\[\[GetPrototypeOf]]()
**** Object.is(value1, value2)
当is被带参数value1和value2调用时，执行下列步骤：
1. 返回SameValue(value1, value2)
**** Object.isExtensible(O)
当isExtensible被带参数O调用时，执行下列步骤：
1. 如果Type(O)不是Object，返回false。
2. 返回?IsExtensible(O)
**** Object.isFrozen(O)
当isFrozen被带参数O调用时，执行下列步骤：
1. 如果Type(O)不是Object，返回true。
2. 返回?TestIntegrityLevel(O, frozen)
**** Object.isSealed(O)
当isSealed被带参数O调用时，执行下列步骤：
1. 如果Type(O)不是Object，返回true。
2. 返回?TestIntegrityLevel(O, sealed)
**** Object.keys(O)
当keys被带参数O调用时，执行下列步骤：
1. 让obj是?ToObject(O)
2. 让nameList是?EnumerableOwnPropertyNames(obj, key)
3. 返回CreateArrayFromList(nameList)
**** Object.preventExtensions(O)
当preventExtensions被带参数O调用时，执行下列步骤：
1. 如果Type(O)不是Object，返回O。
2. 让status是?O.\[\[PreventExtensions]]()
3. 如果status是false，投掷TypeError异常
4. 返回O
**** Object.prototype
Object.prototype的初始值是Object原型对象。

其性质的属性是{ \[\[Writable]]:false, \[\[Enumerable]]:false,
\[\[Configurable]]:false }
**** Object.seal(O)
当seal被调用时，执行下列步骤：
1. 如果Type(O)不是Object，返回O。
2. 让status是?SetIntegrityLevel(O, seal)
3. 如果status是false，投掷TypeError异常
4. 返回O
**** Object.setPrototypeOf(O, proto)
当setPrototypeOf被带参数O和proto调用时，执行下列步骤：
1. 值O是?RequireObjectCoercible(O)
2. 如果Type(proto)不是Object或者Null，投掷TypeError异常
3. 如果Type(O)不是Object，返回O。
4. 让status是?O.\[\[SetPrototypeOf]](proto)
5. 如果status是false，投掷TypeError异常
6. 返回O
**** Object.values(O)
当values被带参数O调用时，执行下列步骤：
1. 让obj是?ToObject(O)
2. 让nameList是?EnumerableOwnPropertyNames(obj, value)
3. 返回CreateArrayFromList(nameList)
*** Properties of the Object Prototype Object
Object原型对象：
. 是%Object.prototype%
. 有\[\[Extensible]]内部占位，其值是true
. 有10.4.7.1中定义的基本对象的内部方法，\[\[SetPrototypeOf]]方法除外（
  因此这是一个原型不可变的奇异对象）。
. 有\[\[Prototype]]内部占位，值是null
**** Object.prototype.constructor
Object.prototype.constructor的初始值是%Object%
**** Object.prototype.hasOwnProperty(V)
当hasOwnProperty方法被带参数V调用时，执行下列步骤：
1. 让P是?ToPropertyKey(V)
2. 让O是?ToObject(this值)
3. 返回?HasOwnProperty(O, P)
***** 注意 步骤1和步骤2的顺序是用来确保在之前版本中，即使this值是undefined
            或者null也会在步骤1投掷的异常，现在扔会投掷。
**** Object.prototype.isPrototypeOf(V)
当isPrototypeOf方法被带参数V调用时，执行下列步骤：
1. 如果Type(V)不是Object，返回fasle
2. 让O是?ToObject(this值)
3. 重复
    a. 置V是?V.\[\[GetPrototypeOf]]()
    b. 如果V是null，返回false
    c. 如果SameValue(O, V)是true，返回true
***** 注意 步骤1和步骤2的的顺序用于保留在之前版本的规范中当V不是对象
            且this值是undefined或者null时的行为。
**** Object.prototype.propertyIsEnummerable(V)
当propertyIsEnumerable方法被带参数O调用时，执行下列步骤：
1. 让P是?ToPropertyKey(V)
2. 让O是?ToObject(this值)
3. 让desc是?O.\[\[GetOwnProperty]](P)
4. 如果desc是undefined，返回false
5. 返回desc.\[\[Enumerable]]
***** 注意1 这个方法不考虑原型链上的性质
***** 注意2 步骤1和步骤2的顺序是用来确保在之前版本中，即使this值是undefined
             或者null也会在步骤1投掷的异常，现在扔会投掷。
**** Object.prototype.toLocaleString([reserved1 [,reserved2]])
当toLocaleString方被调用时，执行下列步骤：
1. 让O是this值
2. 返回?Invoke(O, "toString")

本函数的可选参数没有被用到，但是试图与ECMA-402 toLocaleString函数的参数一致。
没有包含ECMA-402支持的实现，不能将这些参数位置用于其他目的。
***** 注意1 这个函数给没有定制toString行为的对象提供了通用的实现。Array、
             Number、Date和%TypeArray%提供了各自定制的toLocaleString方法。
***** 注意2 ECMA-402根本就没想过提供此实现的备用算法。
             
**** Object.prototype.toSring()
当toString被调用时，执行下列步骤：
1. 如果this值是undefined，返回"\[object Undefined]"
2. 如果this值是null，返回"\[object Null]"
3. 让O是!ToObject(this值)
4. 让isArray是?IsArray(O)
5. 如果isArray是true，让builtTag是"Array"
6. 否则如果O有\[\[ParameterMap]]内部占位，让builtTag是"Arguments"
7. 否则如果O有\[\[Call]]内部方法，让builtTag是"Function"
8. 否则如果O有\[\[ErrorData\]\]内部占位，让builtTag是"Error"
9. 否则如果O有\[\[BooleanData]]内部占位，让builtTag是"Boolean"
10. 否则如果O有\[\[NumberData]]内部占位，让builtTag是"Number"
11. 否则如果O有\[\[StringData]]内部占位，让builtTag是"String"
12. 否则如果O有\[\[DateValue]]内部占位，让builtTag是"Date"
13. 否则如果O有\[\[RegExpMatcher]]内部占位，让builtTag是"RegExp"
14. 否则，让builtTag是"Object"
15. 让tag是?Get(O,@@toStringTag)
16. 如果Type(tag)不是String，置tag是builtTag
17. 返回"\[object",tag和"]"的字符串拼接。
***** 注意 历史上这个函数偶尔被用于访问\[\[Class]]内部占位的字符串值。
            而\[\[Class]]内部占位在之前版本的规范中用于不同内部对象的标准类
            型。上述toString的定义保留了使用toString检测内建对象类型的遗留代
            码的兼容性。它不对程序定义的对象和其他内建对象提供可靠的类型
            检测机制。另外，程序可以用@@toStringTag方式，抛弃之前遗留的类型
            测试。
**** Object.prototype.valueOf()
当valueOf被调用时，执行下列步骤：
1. 返回?ToObject(this值)
*** Properties of Object Instances
Object实例没有超出继承自Object原型对象的特定性质。
** Function Objects
*** The Function Constructor
Function构造范
. 是%Funciton%
. 是全局对象上"Function"性质的初始值
. 当作为函数而不是构造调用时，创建和初始化新的函数对象。因此相同参数的
  Function(...)函数调用与new Function(...)表达式创建的对象等价。
. 被设计成可继承。也就是说可以用在定义class时的extends语句里。子类的构造范
  如果要继承Functinon的特定行为，必须含有super调用，以使用Function构造范创建
  和初始化一个拥有内建函数行为必需的内部占位的子类实例。所有ECMAScript定义
  函数对象的句法形式创建了Function的实例。任何句法无法创建除了
  GeneratorFunciton、AsyncFucntion和AsyncGeneratorFunction子类之外的Function子类。
**** Function(p1, p2, ..., pn, body)
最后的参数规定了函数体（执行代码），之前的参数规定了形式参数。

当Function函数被带p1, p2, ..., pn, body（当n是0时，没有p参数，而且也可以没有
body）参数调用时，执行下列步骤：
1. 让C是活跃函数对象。
2. 让args是被\[\[Call]]或者\[\[Constructor]]传给此函数的argumentsList
3. 返回?CreateDynamicFunction(C, NewTarget, normal, args)
***** 注意 可以不为每个形参提供特定的参数。比如，下列三个表达式产生相同
            的结果：
            new Function("a", "b", "c", "return a+b+c")
            new Funciton("a, b, c", "return a+b+c")
            new Funciton("a,b", "c", "return a+b+c")
***** CreateDynamicFunction(constructor, newTarget, kind, args)
抽象操作CreateDynamicFunction接受参数constructor（构造范）、newTarget（构造范）
、kind（normal、generator、async或者asyncGenerator之一），和args（ECMAScript语言
值的列表）。constructor是执行这个动作的构造范函数。newTarget是初始应用new行为
的构造范。args是传递个constructor的参数值。被调用时执行下列步骤：
1. Assert：执行背景栈最少有两个元素
2. 让callerContext是执行背景栈次顶部的元素
3. 让callerRealm是callerContext的Realm
4. 让calleeRealm是当前RealmRecord
5. 执行?HostEnsureCanCompileStrings(callerRealm, calleeRealm)
6. 如果newTarget是undefined，值newTarget是constructor
7. 如果kind是normal
    a. 让goal是FunctionBody_[~Yield, ~Await]语法标识
    b. 让parameterGoal是FormalParameters_[~Yield, ~Await]语法标识
    c. 让fallbackProto是"%Function.prototype%"
8. 否则如果kind是generator，那么
    a. 让goal是GeneratorBody语法标识
    b. 让parameterGoal是FormalParameters_[~Yield, ~Await]语法标识
    c. 让fallbackProto是"%GeneratorFunction.prototype%"
9. 否则如果kind是async，那么
    a. 让goal是AsyncFunctionBody语法标识
    b. 让parameterGoal是FormalParameters_[~Yield, ~Await]语法标识
    c. 让fallbackProto是"%AsyncFunction.prototype%"
10. 否则
    a. Assert：kind是asyncGenerator
    b. 让goal是AsyncGeneratorBody语法标识
    c. 让parameterGoal是FormalParameters_[~Yield, ~Await]语法标识
    d. 让fallbackProto是"%AsyncGeneratorFunction.prototype%"
11. 让argCount是args中的元素数量
12. 让P是空字符串
13. 如果argCount=0，让bodyArg是空字符串
14. 否则如果argCount=1，让bodyArg是args[0]
15. 否则
    a. Assert：argCount >=1
    b. 让firstArg是args[0]
    c. 值P是?ToString(firstArg)
    d. 让k是1
    e. 重复，当k< argCount - 1时
        i. 让nextArg是args[k]
       ii. 让nextArgString是?ToString(nextArg)
      iii. 置P是P "," 和nextArgString的字符串拼接
       iv. 置k是k+1
    f. 让bodyArg是args[k]
16. 让bodyString是0x000A（LINE FEED）,?ToString(bodyArg)和0x000A（LINE FEED）的
    字符串拼接
17. 让prefix是表50中与kind关联的前缀
18. 让sourceString是prefix, " anonymous(", P, 0x000A（LINE FEED）, "){", bodyString
    和"}"的字符串拼接
19. 让sourceText是!StringToCodePoints(sourceString)
20. 按照实现顺序执行随后的子步骤，解析和错误检测交替进行。
    a. 让parameters是ParseText(!StringToCodePoints(P)), parameterGoal)
    b. 如果parameters是错误列表，投掷SyntaxError异常
    c. 让body是ParseText(!StringToCodePoint(bodyString), goal)
    d. 如果body是错误列表，投掷SyntaxError异常
    e. 让strict是body的FunctionBodyContainsUseStrict
    f. 如果strict是true，应用UniqueFormalParameters : FormalParameters的早期错误
       规则到parameters上。
    g. 如果strict是true且parameters的IsSimpleParameterList是false，投掷Syntax异常
    h. 如果parameters的BoundNames中任何元素也出现在body的LexicallyDeclaredNames
       中，投掷Syntax异常
    i. 如果body含有SuperCall，投掷Syntax异常。
    j. 如果parameters含有SuperCall，投掷Syntax异常。
    k. 如果body含有SuperProperty，投掷Syntax异常。
    l. 如果parameters含有SuperProperty，投掷Syntax异常。
    m. 如果kind是generator或者asyncGenerator，那么
        i. 如果paramters含有YieldExpression，投掷Syntax异常
    n. 如果kind是async或者asyncGenerator，那么
        i. 如果parameters含有AwaitExpression，投掷Syntax异常
    o. 如果strict是true，那么
        i. 如果paramters的BoundNames含有重复元素，投掷Syntax异常
21. 让proto是?GetPrototypeFromConstructor(newTarget, fallbackProto)
22. 让realmF是当前RealmRecord
23. 让scope是realmF.\[\[GlobalEnv]]
24. 让F是!OrdinaryFunctionCreate(proto, sourceText, paramters, body, non-leixical-this,
    scope)
25. 执行SetFunctionName(F, "anonymous")
26. 如果kind是generator，那么
    a. 让prototype是!OrdinaryObjectCreate(%GeneratorFunction.prototype.prototype%)
    b. 执行DefinePropertyOrThrow(F, "prototype", PropertyDescriptor {
       \[\[Value]]:prototype, \[\[Writable]]:true, \[\[Enumerable]]:false,
       \[\[Configurable]]:false })
27. 否则，如果kind是asyncGenerator，那么
    a. 让prototype是!OrdinaryObjectCreate(%AsyncGeneratorFunction.prototype.prototype%)
    b. 执行DefinePropertyOrThrow(F, "prototype", PropertyDescriptor {
       \[\[Value]]:prototype, \[\[Writable]]:true, \[\[Enumerable]]:false,
       \[\[Configurable]]:false })
28. 否则如果kind是normal，执行MakeConstructor(F)
29. 注意：kind是async的函数不能是构造范，也没有\[\[Construct]]内部方法，和
    "prototype"性质
30. 返回F
****** 注意 CreateDynamicFunction在创建kind不是async的函数是都定义了"prototype"
             性质，让函数具有作为构造范的可能。
表50 Dynamic Function SourceText Prefixes
| Kind 类型      | Prefix 前缀      |
| normal         | "function"       |
| generator      | "function*" |
| async          | "async function" |
| asyncGenerator | "async function*" |
*** Properties of the Function Constructor
Function构造范：
. 本身就是内建函数对象
. 有\[\[Prototype]]内部占位，值是%Function.prototye%
. 有下列性质：
**** Function.length
这是数据性质，其值是1。性质的属性是{ \[\[Writable]]:false, \[\[Enumerable]]:false,
\[\[Configurable]]:true, }
**** Function.prototype
其值是Function原型对象。

这个性质的属性是{ \[\[Writable]]:false, \[\[Enumerable]]:false,
\[\[Configurable]]:false, }
*** Properties of the Function Prototype Object
函数原型对象：
. 是%Function.prototype%
. 本身就是内建函数对象
. 接受任意参数，被调用时返回undefined
. 没有\[\[Constructor]]内部方法，也不能用new操作符当作构造范。
. 有\[\[Prototype]]内部占位，值是%Object.prootype%
. 没有"prototype"性质
. 有"length"性质，值是+0_F
. 有"name"性质，值空字符串
**** 注意 函数原型对象被规定为函数对象，是为了兼容ECMAScript2015版之前的
           ECMAScript代码。
**** Function.prototype.apply(thisArg, argArray)
当apply方法被带参数thiArg和argArray调用时，执行下列步骤：
1. 让func是this值
2. 如果IsCallable(func)是false，投掷TypeError异常
3. 如果argArray是undefind或者null，那么
    a. 执行PrepareForTailCall()
    b. 返回?Call(func, thisArg)
4. 让argList是?CreateListFromArrayLike(argArray)
5. 执行PrepareForTailCall()
6. 返回?(func, thisArg, argList)
***** 注意1 thisArg是直接传递，没有修正为this值。这从版本3有的变化，此前在
             thisArg是undefined或者null时，被替换为全局对象，而且ToObject被应用
             到其他全部值上，全部结果再传递给this值。即使thisArg是无修正传递，
             非严格模式函数仍会执行上述转换行为到函数上。
***** 注意2 如果func是箭头函数或者已绑函数奇异对象，那么thisArg会被步骤6的
             \[\[Call]]函数忽略。
**** Function.prototype.bind(thisArg, ...args)
当bind方法被带参数thiArg和可数个arg调用时，执行下列步骤：
1. 让Target是this值
2. 如果IsCallable(Target)是false，投掷TypeError异常。
3. 让F是?BoundFunctionCreate(Target, thisArg, args)
4. 让L是0
5. 让targetHasLength是?HasOwnProperty(Target, "length")
6. 如果targetHasLength是true，那么
    a. 让targetLen是?Get(Target, "length")
    b. 如果Type(targetLen)是Number，那么
        i. 如果targetLen是+∞_F，置L是+∞.
       ii. 否则如果targetLen是-∞_F，置L是0.
      iii. 否则
            1. 让targetLenAsInt是!ToIntegerOrInfinity(targetLen)
            2. Assert：targetLenAsInt是有限的
            3. 让argCount是args的元素数量
            4. 置L是max(targetLenAsInt - argCount), 0)
7. 执行!SetFunctionLength(F, L)
8. 让targetName是?Get(Target, "name")
9. 如果Type(targetName)不是String，置targetName是空字符串
10. 执行SetFunctionName(F, targetName, "bound")
11. 返回F
***** 注意1 使用Function.prototype.bind创建的函数对象是奇异对象。它们还没有
             "prototype"性质
***** 注意2 如果Target是箭头函数或者已绑函数奇异对象，那么传递给本方法的
             thisArg不会被用于随后的F调用。
**** Function.prototype.call(thisArg, ...args)
当call方法被带参数thiArg和可数个arg调用时，执行下列步骤：
1. 让func是this值
2. 如果IsCallable(func)是false，投掷TypeError异常
3. 执行PrepareToTailCall()
4. 返回?Call(func, thisArg, args)
***** 注意1 thisArg是直接传递，没有修正为this值。这是从版本3有的变化，此前在
             thisArg是undefined或者null时，被替换为全局对象，而且ToObject被应用
             到其他全部值上，全部结果再传递给this值。即使thisArg是无修正传递，
             非严格模式函数仍会执行上述转换行为到函数上。
***** 注意2 如果func是箭头函数或者已绑函数奇异对象，那么thisArg会被步骤4的
             \[\[Call]]函数忽略。
**** Function.prototype.constructor
Function.prototype.constructor的初始值是%Function%
**** Function.prototype.toString()
当toString方法被调用时，执行下列步骤：
1. 让func是this值
2. 如果Type(func)是Object，func有\[\[SourceText]]内部占位，func.\[\[SourceText]]是
   Unicode编码点的序列，而且!HostHasSourceTextAvailable(func)是true，那么
    a. 返回!CodePointsToString(func.\[\[SourceText]])
3. 如果func是内建函数对象，返回实现定义表述func源码的字符串。这个表述必须有
   NativeFuncion句法。另外，如果func有\[\[InitialName]]内部占位而且
   func.\[\[InitialName]]是字符串，那么返回字符串中被
   NativeFunctionAccessor_opt PropertyName匹配的部分必须是func.\[\[InitialName]]的
   值。
4. 如果Type(func)是对象，而且IsCallable(func)是true，返回实现定义的表述func源码
   的字符串。这个表述必须有NativeFunciton句法。
5. 投掷TypeError异常
NativeFunciton :
    function NativeFunctionAccessor_opt PropertyName_[~Yield, ~Await]_opt (
        FormalParameters_[~Yield, ~Await] ) { [ native code ] }
NativeFunctionAccessor :
    get
    set
**** Function.prototype[@@hasInstance](V)
当@@hasInstance方法被带参数V调用时，执行下列步骤：
1. 让F是this值
2. 返回?OrdinaryHasInstance(F, V)

本函数的"name"性质是"[Symbol.hasInstance]"

本性质的属性是{ \[\[Writable]]:false, \[\[Enumerable]]:false,
\[\[Configurable]]:false }
***** 注意 这是大多数函数继承的@@hasInstance的默认实现。@@hasInstance会被
            instanceof操作调用，用于判断某个值是不是特定构造范的实例。如
            表达式
            v instanceof F
            评估为
            F[@@hasInstance](v)
            构造范函数能够控制instanceof识别其实例行为，通过给函数暴露不同的
            @@hasInstance函数
这个性质是不可写、不可设置的以便防止篡改，否则可以全局的暴露已绑函数的
目标函数。
*** Funciton Instances
每个函数实例都是ECMAScript函数对象，都有列在表29的内部占位。用
Function.prototype.bind方法（20.2.3.2）创建的函数对象有列在表30的内部占位。

函数实例有随后的性质
**** length
"length"性质的值是整数值，用于指明函数期望的参数长度。然而，语言允许函数
带不同长度的参数进行调用。当函数调用时的参数长度不同规定的"length"性质时，
具体行为依赖函数。这个性质的属性是{ \[\[Writable]]:false, \[\[Enumerable]]:false,
\[\[Configurable]]:true }
**** name
"name"性质的值是字符串，用于描述函数。这个名字没有语义含义，但是一般是
用于引用这个ECMAScript定义代码处函数的某个变量或者性质名称。这个性质的属性
是{ \[\[Writable]]:false, \[\[Enumerable]]:false, \[\[Configurable]]:true }

匿名函数对象在本规范中没有联结到他们的背景名称，使用空字符串作为"name"性质
的值。
**** prototype
函数实例可以用作有"prototype"性质的构造范。当这种函数实例被创建时，另一个
基本对象也同时被创建，而且是函数的"prototype"初始值。除非另有说明，本函数
被作为构造范调用时创建的对象，其\[\[Prototype]]内部占位的初始化值是
"prototype"性质的值。

这个性质的属性是{ \[\[Writable]]:true, \[\[Enumerable]]:false,
\[\[Configurable]]:false }
***** 注意 使用Function.prototype.bind创建，或者由评估MethodDefinition（
            同时不是是GeneratorMethod也不是AsyncGeneratorMethod）或者
            ArrowFunction产生的函数对象，没有"prototype"性质
*** HostHasSourceTextAvailable(func)
主机定义的HostHasSourceTextAvailable抽象操作接受参数func（函数对象）。允许主机
环境阻止func提供的源文本。

HostHasSourceTextAvailable实现必须正常完结。这个操作必须是参数确定性的。每次
使用特定func作为参数时，它必须返回相同的完结记录。HostHasSourceTextAvailable的
默认实现无条件的返回一个含有true的正常完结。
** Boolean Objects
*** The Boolean Constructor
Boolean构造范
. 是%Boolean%
. 是全局对象上"Boolean"性质的初始值。
. 作为构造范调用时，创建并初始化一个新的Boolean对象
. 当作为函数而不是构造范调用时，执行类型转换
. 被设计成可继承。也就是说可以用在定义class时的extends语句里。子类的构造范
  如果要继承Boolean的特定行为，必须含有super调用，以使用Boolean构造范创建
  和初始化一个拥有\[\[BooleanData]]内部占位的子类实例。
**** Boolean(value)
当Boolean方法被带参数value调用时，执行下列步骤：
1. 让b是!ToBoolean(value)
2. 如果NewTarget是undefined，返回b
3. 让O是?OrdinaryCreateFromConstructor(NewTarget, "%Boolean.prototype%",
   << \[\[BooleanData]] >> )
4. 置O.\[\[BooleanData]]是b
5. 返回O
*** Properties of the Boolean Constructor
Boolean构造范
. 有\[\[Prototype]]内部占位，其值是%Function.prototype%
. 有以下性质
**** Boolean.prototype
Boolean.prototype的初始化值是Boolean原型对像。

这个性质的属性是{ \[\[Writable]]:false, \[\[Enumerable]]:false,
\[\[Configurable]]:false, }
*** Properties of the Boolean Prototype Object
Boolean原型对象：
. 是%Boolean.prototype%
. 是基本对象
. 本身是Boolean对象，其\[\[BooleanData]]内部占位的值是false
. 有\[\[Prototype]]占位，其值是%Object.prototype%

抽象操作thisBooleanValue接受参数value。被调用时执行下列步骤：
1. 如果Type(value)是Boolean，返回value
2. 如果Type(value)是Object，而且value有\[\[BooleanData]]内部占位，那么
    a. 让b是value.\[\[BooleanData]]
    b. Assert：Type(b)是Boolean
    c. 返回b
3. 投掷TypeError异常
**** Boolean.prototype.constructor
Boolean.prototype.constructor的初始化值是%Boolean%
**** Boolean.prototype.toString()
被调用时，执行下列步骤
1. 让b是?thisBooleanValue(this值)
2. 如果b是true，返回"true"，否则返回"false"。
**** Boolean.prototype.valueOf()
被调用时，执行下列步骤
1. 返回?thisBooleanValue(this值)
*** Properties Of Boolean Instances
Boolean实例都是基本对象，继承Boolean原型对象的性质。Boolean实例有
\[\[BooleanData]]内部占位。\[\[BooleanData]]内部占位是表述Boolean对象的Boolean值。
** Symbol Objects
*** The Symbol Constructor
Symbol构造范
. 是%Symbol%
. 是全局对象"Symbol"性质的初始值。
. 作为函数调用时，返回新的Symbol值
. 不能与new操作符合用
. 不能被继承
. 可以用在class定义的extends语句里，但super调用，会导致异常。
**** Symbol([description])
当Symbol被带可选参数description调用时，执行下列步骤：
1. 如果NewTarget不是undefined，投掷TypeError异常
2. 如果description是undefined，让descString是undefined
3. 否则，让descString是?ToString(description)
4. 返回一个新的唯一Symbol，其\[\[Description]]内部占位的值descString
*** Properties of the Symbol Constructor
Symbol构造范：
. 有\[\[Prototype]]内部占位，其值是%Function.prototype%
. 有随后性质：
**** Symbol.asyncIterator
Symbol.asyncIterator的初始值是表1中的符号@@asyncIterator

此性质具有属性 { \[\[Writable]]:false, \[\[Enumerable]]:false,
\[\[Configurable]]:false, }.
**** Symbol.for(key)
当Symbol.for被带参数key调用时，执行下列步骤：
1. 让stringKey是?ToString(key)
2. 遍历GlobalSymbolRegistry列表的元素记作e，做
    a. 如果SameValue(e.\[\[key]], stringKey)是true，返回e.\[\[Symbol]]
3. Assert：GlobalSymbolRegistry没有stringKey的条目
4. 让newSymbol是新的Symbol值，其\[\[Description]]值是stringKey
5. 附加记录{\[\[key]]:stringKey, \[\[Symbol]]:newSymbol}到GlobalSymbolRegistry末端。
6. 返回newSymbol

GlobalSymbolRegistry是全局可见的列表，被全部的领共享。在评估任何ECMAScript代码
前，就初始化为新的空列表。GlobalSymbolRegistry的元素是按照表51定义的结构组成
的记录。
表51
| 字段名       | 值     | 用途                     |
| \[\[Key]]    | 字符串 | 用于标识Symbol的字符串键 |
| \[\[Symbol]] | Symbol | 领可以查到的Symbol值     |
**** Symbol.hasInstance
Symbol.hasInstance的初始值是表1中的符号@@hasInstance

此性质具有属性 { \[\[Writable]]:false, \[\[Enumerable]]:false,
\[\[Configurable]]:false, }.
**** Symbol.isConcatSpreadable
Symbol.isConcatSpreadable的初始值是表1中的符号@@isConcatSpreadable

此性质具有属性 { \[\[Writable]]:false, \[\[Enumerable]]:false,
\[\[Configurable]]:false, }.
**** Symbol.iterator
Symbol.iterator的初始值是表1中的符号@@iterator

此性质具有属性 { \[\[Writable]]:false, \[\[Enumerable]]:false,
\[\[Configurable]]:false, }.
**** Symbol.keyFor(sym)
当Symbol.keyFor被带参数sym调用时，执行下列步骤：
1. 如果Type(sym)不是Symbol，投掷TypeError异常
2. 遍历GlobalSymbolRegistry列表（20.4.2.2）的元素记作e，做
    a. 如果SameValue(e.\[\[Symbol]], sym)是true，返回e.\[\[Key]]
3. Assert：GlobalSymbolRegistry没有sym的条目
4. 返回undefined
**** Symbol.match
Symbol.match的初始值是表1中的符号@@match

此性质具有属性 { \[\[Writable]]:false, \[\[Enumerable]]:false,
\[\[Configurable]]:false, }.
**** Symbol.matchAll
Symbol.matchAll的初始值是表1中的符号@@matchAll

此性质具有属性 { \[\[Writable]]:false, \[\[Enumerable]]:false,
\[\[Configurable]]:false, }.
**** Symbol.prototype
Symbol.prototype的初始值是Symbol原型对象

此性质具有属性 { \[\[Writable]]:false, \[\[Enumerable]]:false,
\[\[Configurable]]:false, }.
**** Symbol.replace
Symbol.replace的初始值是表1中的符号@@replace

此性质具有属性 { \[\[Writable]]:false, \[\[Enumerable]]:false,
\[\[Configurable]]:false, }.
**** Symbol.search
Symbol.search的初始值是表1中的符号@@serach

此性质具有属性 { \[\[Writable]]:false, \[\[Enumerable]]:false,
\[\[Configurable]]:false, }.
**** Symbol.species
Symbol.species的初始值是表1中的符号@@species

此性质具有属性 { \[\[Writable]]:false, \[\[Enumerable]]:false,
\[\[Configurable]]:false, }.
**** Symbol.split
Symbol.split的初始值是表1中的符号@@split

此性质具有属性 { \[\[Writable]]:false, \[\[Enumerable]]:false,
\[\[Configurable]]:false, }.
**** Symbol.toPrimitive
Symbol.toPrimitive的初始值是表1中的符号@@toPrimitive

此性质具有属性 { \[\[Writable]]:false, \[\[Enumerable]]:false,
\[\[Configurable]]:false, }.
**** Symbol.toStringTag
Symbol.toStringTag的初始值是表1中的符号@@toStringTag

此性质具有属性 { \[\[Writable]]:false, \[\[Enumerable]]:false,
\[\[Configurable]]:false, }.
**** Symbol.unscopables
Symbol.unscopables的初始值是表1中的符号@@unscopables

此性质具有属性 { \[\[Writable]]:false, \[\[Enumerable]]:false,
\[\[Configurable]]:false, }.
*** Properties of the Symbol Prototype Object
Symbol原型对象：
. 是%Symbol.prototype%
. 是基本对象
. 不是Symbol实例，也没有\[\[SymbolData]]内部占位
. 有\[\[Prototype]]内部占位，值是%Object.prototype%

抽象操作thisSymbolValue接受参数value。被调用时执行下列步骤：
1. 如果Type(value)是Symbol，返回value
2. 如果Type(value)是Object，而且value有\[\[SymbolData]]内部占位，那么
    a. 让s是value.\[\[SymbolData]]
    b. Assert：Type(s)是Symbol
    c. 返回s
3. 投掷TypeError异常
**** Symbol.prototype.constructor
Symbol.prototype.constructor的初始值是%Symbol%
**** get Symbol.prototype.description
Symbol.protoype.description是访问性质，其set访问器是undefined。其get访问器执行
下列步骤：
1. 让s是this值
2. 让sym是?thisSymbolValue(s)
3. 返回sym.\[\[Description]]
**** Symbol.prototype.toString()
被调用时，执行下列步骤
1. 让sym是?thisSymbolValue(this值)
2. 返回SymbolDescriptionString(sym)
***** SymbolDescriptiveString(sym)
抽象操作SymbolDescriptionString接受参赛数sym。被调用时执行下列步骤：
1. Assert：Type(sym)是Symbol
2. 让desc是sym的\[\[Description]]的值
3. 如果desc是undefined，置desc是空字符串
4. Assert：Type(desc)是String
5. 返回"Symbol(",desc,")"的字符串拼接
**** Symbol.prototype.valueOf()
被调用时执行下列步骤：
1. 返回?thisSymbolValue(this值)
**** Symbol.prototype[@@toPrimitive](hint)
ECMAScript语言操作Symbol转换为基础值调用此函数。

当@@toPrimitive方法被带参数hint调用时，执行下列步骤：
1. 返回?thisSymbolValue(this值）

这个函数"name"性质值是"[Symbol.toPrimitive]"

此性质的属性是{ \[\[Writable]]:false, \[\[Enumerable]]:false,
\[\[Configurable]]:true }
***** 注意 参数被忽略了。
**** Symbol.prototype[@@toStringTag]
@@toStringTag性质的初始值是"Symbol"

此性质的属性是{ \[\[Writable]]:false, \[\[Enumerable]]:false,
\[\[Configurable]]:true }
*** Properties of Symbol Instances
Symbol实例都是基本对象，继承Symbol原型对象的性质。Symbol实例有\[\[SymboData]]
内部占位。\[\[SymbolData]]内部占位是表述Symbol对象的Symbol值。
** Error Objects
当出现运行错误时，会抛出Error对象的实例。本Error对象还可以作为用户定义的
异常类的基础对象。

当ECMAScript实现侦测到运行时错误时，会投掷一个2.5.5定义的NativeError的新实例，
或者投掷一个2.5.7定义的AggregateError的实例。这些对象都有下方描述的结构，
区别在与：name使用构造范的name而不是NativeError，原型对象的name性质不同，原型对象上
实现定义的message性质不同，%AggregateError%的errors性质有差异。
*** The Error Constructor
Error构造范：
. 是%Error%
. 是全局对象上"Error"性质的初始值
. 作为函数而不是构造范调用是，创建和初始化新的Error对象。因此相同参数的
  Error(...)函数调用与new Error(...)表达式创建的对象等价。
. 被设计成可继承。也就是说可以用在定义class时的extends语句里。子类的构造范
  如果要继承Error的特定行为，必须含有super调用，以使用Error构造范创建
  和初始化一个拥有\[\[ErrorData]]内部占位的子类实例。
**** Error(message)
当Error函数被带参数message调用时，执行下列步骤：
1. 如果NewTarget是undefined，让newTarget是活跃函数对象，否则让newTarget
   是NewTarget
2. 让O是?OrdinaryCreateFromConstructor(newTarget, "%Error.prototype%", <<
   \[\[ErrorData]] >> )
3. 如果message不是undefined，那么
    a. 让msg是?ToString(message)
    b. 让msgDesc是PropertyDescriptor { \[\[Value]]:msg, \[\[Writable]]:true,
       \[\[Enumerable]]:false, \[\[Configurable]]:true }
    c. 执行!DefinePropertyOrThrow(O, "message", msgDesc)
4. 返回O
*** Properties of the Error Constructor
Error构造范：
. 有\[\[Prototype]]内部占位，初始值是%Function.prototype%
. 有下列性质
**** Error.prototype
Error.prototype的初始值是Error原型对象

此性质的属性是{ \[\[Writable]]:false, \[\[Enumerable]]:false,
\[\[Configurable]]:false, }
*** Properties of the Error Prototype Object
Error原型对象：
. 是%Error.prototype%
. 是基本对象
. 不是Error实例，也没有\[\[ErrorData]]内部占位
. 有\[\[Prototype]]内部占位，其值是%Object.prototype%
**** Error.prototype.constructor
Error.prototype.constructor的初始值是%Error%
**** Error.prototype.message
Error.prototype.message的初始值是空字符串
**** Error.prototype.name
Error.prototype.name的初始值是"Error"
**** Error.prototype.toString()
被调用时执行下列步骤：
1. 让O是this值
2. 如果Type(O)不是Object，投掷TypeError异常
3. 让name是?Get(O, "name")
4. 如果name是undefined，置name是"Error"，否则置name是?ToString(name)
5. 让msg是?Get(O, "message")
6. 如果msg是undefined，置msg是空字符串；否则置msg是?ToString(msg)
7. 如果name是空字符串，返回msg
8. 如果msg是空字符串，返回name
9. 返回name,0x003A（COLON）,0x0020（SPACE）,msg的字符串拼接
*** Properties of Error Instances
Error实例都是基本对象，继承Error原型对象的性质。Error实例有\[\[ErrorData]]内
部占位，其值是undefined。\[\[ErrorData]]内部占位的唯一指定用途是在
Object.prototype.toString调用到Error对象时识别是Error、AggregateError或者NativeError
的实例。
*** Native Error Types Used in This Standard
在发现运行时错误时，投掷下方所列的NativeError的实例或者AggregateError
**** EvalError
EvalError构造范是%EvalError%

目前本规范不使用这个异常。这个对象被保留下来兼容之前的版本的规范。
**** RangeError
RangeError构造范是%RangeError%

指明某个值不在允许的范围内。
**** ReferenceError
ReferenceError构造范是%ReferenceError%

指明使用了无效的引用
**** SyntaxError
SyntaxError构造范是%SyntaxError%

指明解析时有错误。
**** TypeError
TypeError构造范是%TypeError%

TypeError用于指明无法成功的操作，而且没有其他合适的NativeError指明这个错误
原因。
**** URIError
URIError构造范是%URIError%

用于指明某个全局URI处理函数被用在不符合其用途的地方。
*** NativeError Object Constructor
当ECMAScript实现侦测到运行时错误时，它投掷某个在20.5.5定义的NativeError对象
的实例。这些对象都有下方描述的结构，区别在与：name使用构造范的name而不
是NativeError，原型对象的name性质不同，原型对象上实现定义的message性质不同。

每个错误对象，在定义中使用到NativeError的地方应当替换为20.5.5所列的名称。
**** The NativeError Constructors
每个NativeError构造范
. 当作为函数而不是构造范调用时，创建并初始化新的NativeError对象。
  因此相同参数时作为函数还是构造范调用是等价的。因此NativeError(...)函数调
  用与new NativeError(...)表达式在参数相同时创建的对象等价。
. 被设计成可继承。也就是说可以用在定义class时的extends语句里。子类的构造范
  如果要继承NativeError的特定行为，必须含有super调用，以使用NativeError构造范
  创建和初始化拥有\[\[ErrorData]]内部占位的子类实例。
***** NativeError(message)
当NativeError被带参数message调用时，执行下列步骤：
1. 如果NewTarget是undefined，让newTarget是活跃函数对象，否则让newTarget
   是NewTarget
2. 让O是?OrdinaryCreateFromConstructor(newTarget, "%NativeError.prototype%", <<
   \[\[ErrorData]] >> )
3. 如果message不是undefined，那么
    a. 让msg是?ToString(message)
    b. 让msgDesc是PropertyDescriptor { \[\[Value]]:msg, \[\[Writable]]:true,
       \[\[Enumerable]]:false, \[\[Configurable]]:true }
    c. 执行!DefinePropertyOrThrow(O, "message", msgDesc)
4. 返回O

步骤2的实际值根据定义的NativeError构造范分别是"%EvalError.prototype%"、
"%RangeError.prototype%"、"%ReferenceError.prototype%"、"%SyntaxError.prototype%"
"%TypeError.prototype%"或者"%URIError.prototype%"
**** Properties of the NativeError Constructors
每个NativeError构造范
. 有\[\[Prototype]]内部占位，值是%Error%
. 有"name"性质，值是"NativeError"
. 有下列性质：
***** NativeError.prototype
NativeError.prototype的初始值是NativeError原型对象（20.5.6.3）。每个NativeError
构造范有不同的原型对象。

此性质的属性是{ \[\[Writable]]:false, \[\[Enumerable]]:false,
\[\[Configurable]]:false, }
**** Properties of the NativeError Prototype Objects
每个NativeError原型对象：
. 是基本对象
. 不是Error实例，也没有\[\[ErrorData]]内部占位
. 有\[\[Prototype]]内部占位，值是%Error.prototype%
***** NativeError.prototype.constructor
给定NativeError构造范的原型上的"constructor"性质的初始值是对应内部对象
%NativeError%（20.5.6.1）。
***** NativeError.prototype.message
给定NativeError构造范的原型上的"message"性质的初始值是空字符串
***** NativeError.prototype.name
给定NativeError构造范的原型上的"那么"性质的初始值是由对应构造范名称（用
名称替换NativeError）组成的字符串。
**** Properties of NativeError Instances
NativeError实例都是基本对象，继承NativeError原型对象的性质，实例有
\[\[ErrorData]]内部占位，其值是undefined。\[\[ErrorData]]内部占位的唯一指定用
途是在Object.prototype.toString调用时识别是Error、AggregateError或者NativeError
的实例。
*** AggregateError Objects
**** The AggregateError Constructors
AggregateError构造范：
. 是%AggregateError%
. 是全局对象上"AggregateError"性质的初始值
. 当作为函数而不是构造调用时，创建和初始化新的函数对象。因此相同参数的
  AggregateError(...)函数调用与new AggregateError(...)表达式创建的对象等价。
. 被设计成可继承。也就是说可以用在定义class时的extends语句里。子类的构造范
  如果要继承AggregateError的特定行为，必须含有super调用，以使用AggregateError
  构造范创建和初始化一个拥有\[\[ErrorData]]内部占位的子类实例。
***** AggregateError(errors, message)
当AggregateError函数被带参数errors和message调用时，执行下列步骤：
1. 如果NewTarget是undefined，让newTarget是活跃函数对象，否则让newTarget
   是NewTarget
2. 让O是?OrdinaryCreateFromConstructor(newTarget, "%AggregateError.prototype%", <<
   \[\[ErrorData]] >> )
3. 如果message不是undefined，那么
    a. 让msg是?ToString(message)
    b. 让msgDesc是PropertyDescriptor { \[\[Value]]:msg, \[\[Writable]]:true,
       \[\[Enumerable]]:false, \[\[Configurable]]:true }
    c. 执行!DefinePropertyOrThrow(O, "message", msgDesc)
4. 让errorList是?IterableToList(errors)
5. 执行!DefinePropertyOrThrow(O, "errors", ProperDescriptor { \[\[Configurable]]:true,
   \[\[Enumerable]]:false, \[\[Writable]]:true,
   \[\[Value]]:!CreateArrayFromList(errorsList) })
6. 返回O
**** Properties of the AggregateError Constructor
AggregateError构造范：
. 有\[\[Prototype]]内部占位，初始值是%Error%
. 有下列性质:
***** AggregateError.prototype
AggregateError.prototype的初始值是%AggregateError.prototype%

此性质的属性是{ \[\[Writable]]:false, \[\[Enumerable]]:false,
\[\[Configurable]]:false, }
**** Properties of the AggregateError Prototype Object
AggregateError原型对象：
. 是%AggregateError.prototype%
. 是基本对象
. 不是Error或者AggregateError实例，也没有\[\[ErrorData]]内部占位
. 有\[\[Prototype]]内部占位，其值是%Error.prototype%
***** AggregateError.prototype.constructor
AggregateError.prototype.constructor的初始值是%AggregateError%
***** AggregateError.prototype.message
AggregateError.prototype.message的初始值是空字符串
***** AggregateError.prototype.name
AggregateError.prototype.name的初始值是"AggregateError"
**** Properties of AggregateError Instances
AggregateError实例都是基本对象，继承AggregateError原型对象的性质，而且
有\[\[ErrorData]]内部占位，其值是undefined。\[\[ErrorData]]内部占位的唯一指定
用途是在Object.prototype.toString（20.1.3.6）调用时识别是Error、AggregateError或
者NativeError的实例。
* Numbers and Dates
** Number Objects
*** The Number Constructor
Number构造范
. 是%Number%
. 是全局对象"Number"性质的初始值。
. 作为构造范调用时，返回新的Number值
. 作为函数而不是构造范调用时，执行类型转换
. 被设计成可继承。也就是说可以用在定义class时的extends语句里。子类的构造范
  如果要继承Number的特定行为，必须含有super调用，以使用Number构造范创建和初
  始化一个拥有\[\[NumberData]]内部占位的子类实例。
**** Number(value)
当Number方法被带参数value调用时，执行下列步骤：
1. 如果value存在，那么
    a. 让prim是?ToNumber(value)
    b. 如果Type(prim)是BigInt，让n是F(R(prim))
    c. 其他情况让n是prim
2. 否则
    a. 让n是+0_F
3. 如果NewTarget是undefined，返回n
4. 让O是?OrdinaryCreateFromConstructor(NewTarget, %Number.prototype%, <<
   \[\[NumberData]] >>)
5. 置O.\[\[NumberData]]是n
6. 返回O
*** Properties of the Number Constructor
Number构造范：
. 有\[\[Prototype]]内部占位，值是%Function.prototype%
. 有如下性质
**** Number.EPSILON
Number.EPSILON的值是Number值，是大于1的最小Number值与1的差，大约是
2.2204460492503130808472633361816 × 10^-16。

此性质的属性是{ \[\[Writable]]:false, \[\[Enumerable]]:false,
\[\[Configurable]]:false, }
**** Number.isFinite( number )
当Number.isFinite被带参数number调用时，执行下列步骤：
1. 如果Type(number)不是Number，返回false
2. 如果number是NaN、+∞_F或-∞_F，返回false
3. 其他返回true
**** Number.isInteger( number )
当Number.isInteger被带参数number调用时，执行下列步骤：
1. 返回!IsIntegerNumber(number)
**** Number.isNaN( number)
当Number.isNaN被带参数number调用时，执行下列步骤：
1. 如果Type(number)不是Number，返回false
2. 如果number是NaN，返回true
3. 其他返回false
***** 注意 与全局的isNaN函数（19.2.3）不同，本函数在检测是否是NaN前，不进行
            类型转换。
**** Number.isSafeInteger( number )
当Number.isSafeInteger被带参数number调用时，执行下列步骤：
1. 如果!IsIntegerNaumber(number)是true，那么
    a. 如果abs(R(number)) <= 2^53 - 1，返回true
2. 返回false
**** Number.MAX_SAFE_INTEGER
***** 注意 Number.MAX_SAFE_INTEGER的值是最大的整数Number，记作n，因此R(n)和
            R(n)+1都能被Number值准确的表示。
Number.MAX_SAFE_INTEGER的值是9007199254740991_F（F(2^53 - 1)）。

此性质的属性是{ \[\[Writable]]:false, \[\[Enumerable]]:false,
\[\[Configurable]]:false, }
**** Number.MAX_VALUE
Number.MAX_VALUE的值是最大的正有限Number值，大约是
1.7976931348623157 × 10^308

此性质的属性是{ \[\[Writable]]:false, \[\[Enumerable]]:false,
\[\[Configurable]]:false, }
**** Number.MIN_SAFE_INTEGER
***** 注意 Number.MIN_SAFE_INTEGER的值是最小的整数Number，记作n，因此R(n)和
            R(n)-1都能被Number值准确的表示。
Number.MIN_SAFE_INTEGER的值是-9007199254740991_F（F(-(2^53 - 1))）。

此性质的属性是{ \[\[Writable]]:false, \[\[Enumerable]]:false,
\[\[Configurable]]:false, }
**** Number.MIN_VALUE
Number.MIN_VALUE的值是最小的正Number值，大约是
5 × 10^-324。

在IEEE-752 2019规范里，双精度字节表示，可能的最小值是非标准的。如果实现不
提供非标准值，那么Number.MIN_VALUE值必须是可以被规范准确表示的最小非零正
有理数。

此性质的属性是{ \[\[Writable]]:false, \[\[Enumerable]]:false,
\[\[Configurable]]:false, }
**** Number.NaN
Number.EPSILON的值是Number值，是大于1的最小Number值与1的差，大约是
2.2204460492503130808472633361816 × 10^-16。

此性质的属性是{ \[\[Writable]]:false, \[\[Enumerable]]:false,
\[\[Configurable]]:false, }
**** Number.NEGATIVE_INFINITY
Number.NEGATIVE_INFINITY的值是-∞_F。

此性质的属性是{ \[\[Writable]]:false, \[\[Enumerable]]:false,
\[\[Configurable]]:false, }
**** Number.parseFloat( string )
Number.parseFloat数据性质的值与定义在19.2.4中全局对象上"parseFloat"性质的初始
值是相同的内建函数对象。
**** Number.parseInt( string, radix )
Number.parseInt数据性质的值与定义在19.2.5中全局对象上"parseInt"性质的初始
值是相同的内建函数对象。

**** Number.POSITIVE_INFINITY
Number.POSITIVE_INFINITY的值是+∞_F。

此性质的属性是{ \[\[Writable]]:false, \[\[Enumerable]]:false,
\[\[Configurable]]:false, }
**** Number.prototype
Number.prototype的初始值是Number原型对象

此性质的属性是{ \[\[Writable]]:false, \[\[Enumerable]]:false,
\[\[Configurable]]:false, }
*** Properties of the Number Prototype Object
Number原型对象：
. 是%Number.prototype%
. 是基本对象
. 本身是Number对象，有\[\[NumberData]]内部占位，其值是+0_F
. 有\[\[Prototype]]占位，其值是%Object.prototype%

除非显示说明，否则，下方定义的Number原型对象上的方法都不是泛用的，因此传递
给它们的this值必须是Number值，或者是含有已初始化为Number值的\[\[NumberData]]内
部占位的对象。

抽象操作thisNumberValue接受参数value。被调用时执行下列步骤：
1. 如果Type(value)是Number，返回value
2. 如果Type(value)是Object，而且value有\[\[NumberData]]内部占位，那么
    a. 让n是value.\[\[NumberData]]
    b. Assert：Type(n)是Number
    c. 返回n
3. 投掷TypeError异常

在本规范里方法的短语"thisNumber值"指将方法的this值作为调用参数传递给抽象操作
thisNumberValue后获得的结果。
**** Number.prototype.constructor
Number.prototype.constructor的初始值是%Number%
**** Number.prototype.toExponential( fractionDigits )
返回thisNumber值的十进制指数形式的字符串，包含一位整数和fractionDigits位小数。
如果fractionDigits是undefined，尽可能多的包含有效数字以唯一表示这个Number（
就像ToString，除了本方法总是输出指数形式）。执行下列步骤：
1. 让x是?thisNumberValue(this值)
2. 让f是?ToIntegerOrInfinity(fractionDigits)
3. Assert：如果fractionDigits是undefined，那么f是0
4. 如果x不是finite，返回!Number::toSring(x)
5. 如果f < 0或者f > 100，投掷RangeError异常
6. 置x是R(x)
7. 让s是空字符串
8. 如果x < 0，那么
    a. 置s是"-"
    b. 置x是-x
9. 如果x = 0，那么
    a. 让m是由f+1个0x0030编码单元（DIGIT ZERO）组成的字符串
    b. 让e是0
10. 否则
    a. 如果fractionDigits不是undefined，那么
        i. 让e和n是合于10^f <= n < 10^(f+1)而且n * 10^(e-n)-x最接近0的整数。如果
           由多组e和n，选择n*10^(e-f)最大的那组e和f
    b. 否则
        i. 让e、n和f是合于f>=0，10^f <= n < 10 ^(f+1)，n * 10^(e-f)是x，而且f尽可
           能小的整数。注意n的十进制表示有f+1个数字，n被不能被10整除，而且
           按照本准则，n的最小有效位数不是唯一的。
    c. 让m是由n表示的十进制数数字（去掉头部的0，按照顺序）组成的字符串。
11. 如果f!=0，那么
    a. 让a的m的第一个编码单元
    b. 让b是m中剩下的f个编码单元
    c. 置m是a、"."和b字符串拼接
12. 如果e=0，那么
    a. 让c是"+"
    b. 让d是"0"
13. 否则
    a. 如果e>0，让c是"+"
    b. 否则
        i. Assert：e < 0
       ii. 让c是"-"
      iii. 置e是-e
    c. 让d是由e表示十进制数数字（去掉头部0，按照顺序）组成的字符串
14. 置m是m、"e"、c和d组成字符串拼接
15. 返回s和m的字符串拼接
***** 注意 为了实现提供超出上述规则精度的转换，建议步骤10.b.i使用建议的
            备用算法：
            i. 让e、n和f是合于f>=0，10^f <= n < 10^(f+1)，n*10^(e-f)是x，而且f尽
               可能小。如果有多个n，选择n*10^(e-f)最接近x的n。如果仍有两个n，
               选择偶数的那个n
**** Number.prototype.toFixed( fractionDigits )
***** 注意1 toFixed返回thisNumber值以固定fractionDigits小数位表示的字符串。如果
             fractionDigits是undefined，假设为0
执行如下步骤：
1. 让x是?thisNumberValue(this值)
2. 让f是?ToIntegerOrInfinity(fractionDigits)
3. Assert：如果fractionDigits是undefined，f是0
4. 如果f不是有限的，投掷RangeError异常
5. 如果f<0或者f>100，投掷RangeError异常
6. 如果x不是有限的，返回!Number::toString(x)
7. 置x是R(x)
8. 让s是空字符串
9. 如果x<0，那么
    a. 置s是"-"
    b. 置x是-x
10. 如果 x>= 10^21，那么
    a. 让m是!ToString(F(x))
11. 否则
    a. 让n是满足n/(10^f)-x最接近0的整数。如果有两个n，选择大的那个
    b. 如果n是0，让m是"0"。否则让m由n表示的十进制数数字（去掉头部0，
       按照顺序）组成的字符串。
    c. 如果f!=0，那么
        i. 让k是m的长度
       ii. 如果k<=f，那么
            1. 让z是由f+1-k个0x0030编码单元（DIGIT ZERO）组成的字符串
            2. 置m是z和m字符串拼接
            3. 置k是f+1
      iii. 让a是m的前k-f个编码单元
       iv. 让b是m中其他f个编码单元
        v. 置m是a、"."和b字符串拼接
12. 返回s和m字符串拼接
***** 注意2 某些值toFixed的输出精度可能高于toString，因为toString只是根据近似
             的Number值打印足够区分的有效位。比如
             (1000000000000000128).toString() returns "1000000000000000100"，而
             (1000000000000000128).toFixed(0) returns "1000000000000000128".
**** Number.prototype.toLocaleString( [reserved1[, reserved2]] )
包含了ECMA-402国际化接口的ECMAScript实现必须按照ECMA-402规范的规定实现
Number.prototype.toLocaleString方法。如果是不包含ECMA-402接口的ECMAScript实现
使用下方的toLocaleString规定

根据主机环境的当前本地习俗产生thisNumber值的有格式字符串。这个函数是
实现定义的，因此可以，但是不鼓励，返回toString相同的结果。

这意味着本方法的可选参数是在ECMA-402规范里定义的。没有支持ECMA-402的实现
不能将这些参数位用于其他。
**** Number.prototype.toPrecision( precision )
返回thisNumber值的十进制，包含一位整数和precition-1位小数的指数形式的字符串，
或者以固定precision位有效数字的字符串。如果precision是undefined，以ToString替
代。规定执行下列步骤：
1. 让x是?thisNumberValue(this值)
2. 如果precision是undefined，返回!ToString(x)
3. 让p是?toIntegerOrInfinity(precision)
4. 如果x不是有限的，返回Number::toString(x)
5. 如果p<1或者p>100，投掷RangeError异常
6. 值x是R(x)
7. 让s是空字符串
8. 如果x<0，那么
    a. 置s是0x002D编码单元（HYPHEN-MINUS）
    b. 置x是-x
9. 如果x=0，那么
    a. 让m是由p个0x0030编码单元（DIGIT ZERO）组成的字符串
    b. 让e是0
10. 否则
    a. 让e和n是合于10^(p-1) <= n < 10^n，且n*10^(e-p+1)-x最接近0.如果有两组
       e和n，选择让n*10^(e-p+1)更大的那组e和n
    b. 让m是由n表示的十进制数数字（去掉头部0，按照顺序）组成的字符串
    c. 如果e<-6或者e>=p，那么
        i. Assert：e!=0
       ii. 如果p!=1，那么
            1. 让a是m的第一个编码单元
            2. 让b是m中其他p-1个编码单元
            3. 置m是a、"."和b的字符串拼接
      iii. 如果e>0，那么
            1. 让c是编码单元0x002B（PLUS SIGN）
       iv. 否则
            1. Assert：e < 0
            2. 让c是0x002D编码单元（HYPHEN-MINUS）
            3. 置e是-e
        v. 让d是由e表示的十进制数数字（去掉头部0，按照顺序）组成的字符串
       vi. 返回s、m、编码单元0x0065（LATIN SMALL LETTER E）、c和d的字符串拼接
11. 如果e = p-1，返回s和m的字符串拼接
12. 如果e >= 0，那么
    a. 置m是m的前e+1个编码单元、0x002E（FULL STOP）和m剩余p-e-1个编码单元的
       字符串拼接
13. 否则
    a. 置m是0x0030（DIGIT ZERO）、0x002E（FULL STOP）、-(e+1)个0x0030（DIGIT ZERO）
       和m的字符串拼接。
14. 返回s和m的字符串拼接
**** Number.prototype.toString( [radix] )
***** 注意 可选参数radix的整数值在[2,36]内。如果radix是undefined，用10_F代替。
被调用时执行下列步骤：
1. 让x是?thisNumberValue(this值）
2. 如果radix是undefined，让radixMV是10
3. 否则，让radixMV是?ToIntegerOrInfinity(radix)
4. 如果radixMV < 2或者radixMV > 36，投掷RangeError异常
5. 如果radixMV = 10，返回!ToString(x)
6. 返回以randixMV进制表示thisNumber值的字符串。字母a-z被用作10到35的数字。确切
   的算法是实现定义的，但是应该规范6.1.6.1.20定义的归纳。

toString函数不是泛型的。如果this值不是Number或者Number对象，会投掷TypeError异
常。所以不能传递给别的对象，作为方法使用。

toString方法的"length"性质是1_F
**** Number.prototype.valueOf()
1. 返回?thisNumberValue(this值)
*** Properties of Number Instances
Number实例都是基本对象，继承Number原型对象的性质。Number实例有\[\[NumberData]]
内部占位。\[\[NumberData]]内部占位是表述Number对象的Number值。
** BigInt Objects
*** The BigInt Constructor
BigInt构造范
. 是%BigInt%
. 是全局对象"BigInt"性质的初始值。
. 作为函数而不是构造范调用时，执行类型转换
. 不能与new操作符合用，不能被继承。可以用在class定义的extends语句里，
  但super调用，会导致异常。
**** BigInt(value)
当BigInt被带可选参数value调用时，执行下列步骤：
1. 如果NewTarget不是undefined，投掷TypeError异常
2. 如果prim是?ToPrimitive(value, number)
3. 如果Type(prim)是Number，返回?NumberToBigInt(prim)
4. 否则返回?ToBigInt(value)
***** NumberToBigInt(number)
抽象操作NumberToBigInt接受参数number（Number值）。被调用时执行下列步骤：
1. 如果IsIntegralNumber(number)是false，投掷RangeError异常
2. 返回表示R(number)的BigInt值
*** Properties of the BigInt Constructor
BigInt构造范的\[\[Prototype]]值是%Function.prototype%

BigInt构造范有随后性质：
**** BigInt.asIntN( bits, bigint )
当BigInt.asIntN被带参数bits和bigint调用时，执行下列步骤：
1. 置bits是?ToIndex(bits)
2. 置bigint是?ToBigInt(bigint)
3. 让mod是R(bigint)对2^bits求模
4. 如果mod>=2^(bits-1)，返回Z(mod - 2^bits)，否则返回Z(mod)
**** BigInt.asUintN( bits, bigint )
当BigInt.asUintN被带参数bits和bigint调用时，执行下列步骤：
1. 置bits是?ToIndex(bits)
2. 置bigint是?ToBigInt(bigint)
3. 返回表示R(bigint)对2^bits求模结果的BigInt
**** BigInt.prototype
BigInt.prototype的初始值是BigInt原型对象

此性质具有属性 { \[\[Writable]]:false, \[\[Enumerable]]:false,
\[\[Configurable]]:false, }.
*** Properties of the BigInt Prototype Object
BigInt原型对象：
. 是%BigInt.prototype%
. 是基本对象
. 不是BigInt对象，没有\[\[BigIntData]]内部占位
. 有\[\[Prototype]]内部占位，其值是%Object.prototype%

抽象操作thisBigIntValue接受参数value。被调用时执行下列步骤：
1. 如果Type(value)是BigInt，返回value
2. 如果Type(value)是Object，而且value有\[\[BigIntData]]内部占位，那么
    a. Assert：Type(value.\[\[BigIntData]])是BigInt
    b. 返回value.\[\[BigIntData]]
3. 投掷TypeError异常

在本规范里方法的短语"thisBigInt值"指将方法的this值作为调用参数传递给抽象操作
thisBigIntValue后获得的结果。
**** BigInt.prototype.constructor
BigInt.prototype.constructor的初始值是%BigInt%
**** BigInt.prototype.toLocaleString( [reserved1[, reserved2]] )
包含了ECMA-402国际化接口的ECMAScript实现必须按照ECMA-402规范的规定实现
BigInt.prototype.toLocaleString方法。如果是不包含ECMA-402接口的ECMAScript实现
使用下方的toLocaleString规定

根据主机环境的当前本地习俗产生thisBigInt值的有格式字符串。这个函数是
实现定义的，因此可以，但是不鼓励，返回toString相同的结果。

这意味着本方法的可选参数是在ECMA-402规范里定义的。没有支持ECMA-402的实现
不能将这些参数位用于其他。
**** BigInt.prototype.toString( [radix] )
***** 注意 可选参数radix的整数值在[2,36]内。如果radix是undefined，用10_F代替。
被调用时执行下列步骤：
1. 让x是?thisBigIntValue(this值）
2. 如果radix是undefined，让radixMV是10
3. 否则，让radixMV是?ToIntegerOrInfinity(radix)
4. 如果radixMV < 2或者radixMV > 36，投掷RangeError异常
5. 如果radixMV = 10，返回!ToString(x)
6. 返回以randixMV进制表示thisNumber值的字符串。字母a-z被用作10到35的数字。确切
   的算法是实现定义的，但是应该规范6.1.6.1.23定义的归纳。

toString函数不是泛型的。如果this值不是BigInt或者BigInt对象，会投掷TypeError异
常。所以不能传递给别的对象作为方法使用。
**** BigInt.prototype.valueOf()
1. 返回?thisBigIntValue(this值)
**** BigInt.prototype[@@toStringTag]
@@toStringTag性质的初始值是"BigInt"

此性质的属性是{ \[\[Writable]]:false, \[\[Enumerable]]:false,
\[\[Configurable]]:true }
** The Math Object
Math对象：
. 是%Math%
. 是全局对象"Math"性质的初始值
. 是基本对象
. 有\[\[Prototype]]内部占位，值是%Object.prototype%
. 不是函数对象
. 没有\[\[Constructor]]内部方法；不能与new操作符合用
. 没有\[\[Call]]内部方法；不能作为函数调用
*** 注意 在本规范里，短语"x的Number值"使用6.1.6.1定义的含义。
*** Value Properties of the Math Object
**** Math.E
e的Number值，自然对数的底，大约是2.7182818284590452354。

此性质具有属性 { \[\[Writable]]:false, \[\[Enumerable]]:false,
\[\[Configurable]]:false, }.
**** Math.LN10
10的自然对数的Number值，大约是2.302585092994046。

此性质具有属性 { \[\[Writable]]:false, \[\[Enumerable]]:false,
\[\[Configurable]]:false, }.
**** Math.LN2
10的自然对数的Number值，大约是0.6931471805599453。

此性质具有属性 { \[\[Writable]]:false, \[\[Enumerable]]:false,
\[\[Configurable]]:false, }.
**** Math.LOG10E
以10为底，e的对数的Number值，大约是0.4342944819032518。

此性质具有属性 { \[\[Writable]]:false, \[\[Enumerable]]:false,
\[\[Configurable]]:false, }.
***** 注意 Math.LOG10E近似于Math.LN10的倒数。
**** Math.LOG2E
以2为底，e的对数的Number值，大约是1.4426950408889634。

此性质具有属性 { \[\[Writable]]:false, \[\[Enumerable]]:false,
\[\[Configurable]]:false, }.
***** 注意 Math.LOG2E近似于Math.LN2的倒数。
**** Math.PI
π的Number值，圆周长与直径的比值，大约是3.1415926535897932。

此性质具有属性 { \[\[Writable]]:false, \[\[Enumerable]]:false,
\[\[Configurable]]:false, }.
**** Math.SQRT1_2
1/2平方根的Number值，大约是0.7071067811865476。

此性质具有属性 { \[\[Writable]]:false, \[\[Enumerable]]:false,
\[\[Configurable]]:false, }.
***** 注意 Math.SQRT1_2近似于Math.SQRT2的倒数。
**** Math.SQRT2
2平方根的Number值，大约是1.4142135623730951。

此性质具有属性 { \[\[Writable]]:false, \[\[Enumerable]]:false,
\[\[Configurable]]:false, }.
**** Math[@@toStringTag]
@@toStringTag性质的初始值是"Math"

此性质的属性是{ \[\[Writable]]:false, \[\[Enumerable]]:false,
\[\[Configurable]]:true }
*** Function Properties of the Math Object
**** 注意 acos, acosh, asin, asinh, atan, atanh, atan2, cbrt, cos, cosh, exp, expm1,
           hypot, log, log1p, log2, log10, pow, random, sin, sinh, sqrt, tan和tanh这里
           没有准确规范，除了因为兴趣使用的边界值作为参数的结果规定。其他的
           参数，这些函数一般试图计算出相应数学方法的近似值，但是有些度数
           允许使用近似值算法。一般在这些实现里应当为ECMAScript使用平台上C向
           数学库。

           尽管算法选择权在实现，推荐使用（不是本标准的规定）包含在fdlibm里
           为IEEE754-2019的近似算法实现，它是Sun Microsytems的自由数学库。
**** Math.abs( x )
返回x的绝对值，结果与x大小一样，但是是正数。

当Math.abs被带参数x调用时，执行下列步骤：
1. 让n是?ToNumber(x)
2. 如果n是NaN，返回NaN
3. 如果n是-0_F，返回+0_F
4. 如果n是-∞_F，返回+∞_F
5. 如果n < +0_F，返回-n
6. 返回n
**** Math.acos( x )
返回x的反余弦结果。结果以弧度表示，在[+0_F,F(π)]上。

当Math.acos方法被带参数x调用时，执行下列步骤：
1. 让n是?ToNumber(x)
2. 如果n是NaN，n > 1_F或者n <-1_F，返回NaN
3. 如果n是1_F，返回+0_F
4. 返回表示R(x)的反余弦结果的实现近似值。
**** Math.acosh( x )
返回x的反双曲余弦结果。

当Math.acos方法被带参数x调用时，执行下列步骤：
1. 让n是?ToNumber(x)
2. 如果n是NaN或n是+∞_F，返回n
3. 如果n是1_F，返回+0_F
4. 如果n<1_F，返回NaN
5. 返回表示R(x)的反双曲余弦结果的实现近似值。
**** Math.asin( x )
返回x的反正弦结果。结果以弧度表示，在[F(-π/2),F(π/2)]上。

当Math.asin方法被带参数x调用时，执行下列步骤：
1. 让n是?ToNumber(x)
2. 如果n是NaN，n是+0_F或者n是-0_F，返回n
3. 如果n>1_F，或者n<-1_F，返回NaN
4. 返回表示R(x)的反正弦结果的实现近似值。
**** Math.asinh( x )
返回x的反双曲正弦结果。

当Math.asinh方法被带参数x调用时，执行下列步骤：
1. 让n是?ToNumber(x)
2. 如果n是NaN，n是+0_F，n是-0_F，n是+∞_F或者n是-∞_F，返回n
3. 返回表示R(x)的反双曲正弦结果的实现近似值。
**** Math.atan( x )
返回x的反正切结果。结果以弧度表示，在[F(-π/2),F(π/2)]上。

当Math.atan方法被带参数x调用时，执行下列步骤：
1. 让n是?ToNumber(x)
2. 如果n是NaN，n是+0_F或者n是-0_F，返回n。
3. 如果n是+∞_F，返回表示π/2的实现近似值
4. 如果n是-∞_F，返回表示-π/2的实现近似值
5. 返回表示R(x)的反正切结果的实现近似值。
**** Math.atanh( x )
返回x的反双曲正切结果。

当Math.atanh方法被带参数x调用时，执行下列步骤：
1. 让n是?ToNumber(x)
2. 如果n是NaN，n是+0_F或者n是-0_F，返回n。
3. 如果n > 1_F或者n <-1_F，返回NaN
4. 如果n是1_F，返回+∞_F
5. 如果n是-1_F，返回-∞_F
6. 返回表示R(x)的反双曲正切结果的实现近似值。
**** Math.atan2( y, x )
返回参数y和x表示的商y/x的反正切结果，y和x的符号表示结果所在的像限。注意
先是y再是x，这一点是有意的，惯例的双参数反正切函数。结果以弧度表示，在
[-π,+π]上。

当Math.atan2方法被带参数y和x调用时，执行下列步骤：
1. 让ny是?ToNumber(y)
2. 让nx是?ToNumber(x)
3. 如果ny是NaN或者nx是NaN，返回NaN
4. 如果ny是+∞_F，那么
    a. 如果nx是+∞_F，返回表示π/4的实现近似值
    b. 如果nx是-∞_F，返回表示3π/4的实现近似值
    c. 返回表示π/2的实现近似值
5. 如果ny是-∞_F，那么
    a. 如果nx是+∞_F，返回表示-π/4的实现近似值
    b. 如果nx是-∞_F，返回表示-3π/4的实现近似值
    c. 返回表示-π/2的实现近似值
6. 如果ny是+0_F，那么
    a. 如果nx>+0_F或者nx是+0_F，然会+0_F
    b. 返回表示π的实现近似值。
7. 如果ny是-0_F，那么
    a. 如果nx>+0_F或者nx是+0_F，然会-0_F
    b. 返回表示-π的实现近似值。
8. Assert：ny是有限的，而且不是+0_F或-0_F
9. 如果ny>+0_F，那么
    a. 如果nx是+∞_F，返回+0_F
    b. 如果nx是-∞_F，返回表示π的实现近似值。
    c. 如果nx是+0_F或者-0_F，返回表示π/2的实现近似值。
10. 如果ny<+0_F，那么
    a. 如果nx是+∞_F，返回-0_F
    b. 如果nx是-∞_F，返回表示-π的实现近似值。
    c. 如果nx是+0_F或者-0_F，返回表示-π/2的实现近似值。 
11. Assert：nx是有限的，而且不是+0_F或-0_F。
12. 如果n是1_F，返回+0_F
13. 返回表示R(ny)/R(nx)商的反正切结果的实现近似值。
**** Math.cbrt( x )
返回x的立方根。

当Math.cbrt方法被带参数x调用时，执行下列步骤：
1. 让n是?ToNumber(x)
2. 如果n是NaN，n是+0_F，n是-0_F，n是+∞_F或者n是-∞_F，返回n
3. 返回表示R(x)的立方根的实现近似值。
**** Math.ceil( x )
返回不小于x的最小（接近-∞）的整数Number。如果x已经是整数Number，结果就
是x。

当Math.ceil方法被带参数x调用时，执行下列步骤：
1. 让n是?ToNumber(x)
2. 如果n是NaN，n是+0_F，n是-0_F，n是+∞_F或者n是-∞_F，返回n
3. 如果n<+0_F，而且n>-1_F，返回-0_F
4. 如果n是整数Number，返回n
5. 返回不小于x的最小（接近-∞_F）的整数Number
***** 注意 Math.ceil(x)的值与-Math.floor(-x)的值相同。
**** Math.clz32( x )
当Math.clz32方法被带参数x调用时，执行下列步骤：
1. 让n是?ToUint32(x)
2. 让p是以无符号32位二进制表示n时头部0的个数。
3. 返回F(p)
***** 注意 如果n是+0_F或者-0_F，会返回32_F。32位二进制编码的最大位是1，会返回
            +0_F
**** Math.cos( x )
返回x的余弦结果。参数以弧度表示。

当Math.cos方法被带参数x调用时，执行下列步骤：
1. 让n是?ToNumber(x)
2. 如果n是NaN，n是+0_F或者n是-0_F，返回n
3. 如果n是+∞_F或者n是-∞_F，返回NaN
4. 返回表示R(x)的余弦结果的实现近似值。
**** Math.cosh( x )
返回x的双曲余弦结果。

当Math.cosh方法被带参数x调用时，执行下列步骤：
1. 让n是?ToNumber(x)
2. 如果n是NaN，n是+∞_F或者n是-∞_F，返回n
3. 如果n是+0_F或者n是-0_F，返回1_F
4. 返回表示R(x)的余弦结果的实现近似值。
***** 注意 Math.cos(x)的结果与(Math.exp(x) + Math.exp(-x)) / 2的结果相同。
**** Math.exp( x )
返回x的指数结果（以e为底，x为指数的结果。e是自然对数）。

当Math.exp方法被带参数x调用时，执行下列步骤：
1. 让n是?ToNumber(x)
2. 如果n是NaN，或者n是+∞_F，返回n。
3. 如果n是+0_F或者n是-0_F，返回+1_F
4. 如果n是-∞_F，返回+0_F。
5. 返回表示R(x)的指数结果的实现近似值。
**** Math.expm1( x )
返回x的指数结果（以e为底，x为指数的结果。e是自然对数）减去1的结果。即使x
接近0，计算的结果也是准确的。

当Math.expm1方法被带参数x调用时，执行下列步骤：
1. 让n是?ToNumber(x)
2. 如果n是NaN，n是+0_F，n是-0_F或者n是+∞_F，返回n。
4. 如果n是-∞_F，返回-1_F。
4. 返回表示R(x)的指数结果减去1的结果的实现近似值。
**** Math.floor( x )
返回不大于x的最大（接近+∞）的整数Number。如果x已经是整数Number，结果就
是x。

当Math.ceil方法被带参数x调用时，执行下列步骤：
1. 让n是?ToNumber(x)
2. 如果n是NaN，n是+0_F，n是-0_F，n是+∞_F或者n是-∞_F，返回n
3. 如果n<1_F，而且n>+0_F，返回+0_F
4. 如果n是整数Number，返回n
5. 返回不大于x的最大（接近+∞）的整数Number。
***** 注意 Math.floor(x)的值与-Math.ceil(-x)的值相同。
**** Math.fround( x )
当Math.fround方法被带参数x调用时，执行下列步骤：
1. 让n是?ToNumber(x)
2. 如果n是NaN，返回NaN
3. 如果n是+0_F，n是-0_F，n是+∞_F或者n是-∞_F，返回n
4. 让n32是使用roundTiesToEvent模式将n转换为IEEE 754-2019二进制32格式的值的结果
5. 让n64是将n32转换为IEEE 754-2019二进制64格式的值的结果
6. 返回n64的ECMAScript的Number值。
**** Math.hypot( ...args )
返回参数的平方和的平方根。

当Math.hypot方法被带可数参数args调用时，执行下列步骤：
1. 让coerced是新的空列表
2. 遍历args的元素记作arg，做
    a. 让n是?ToNumber(arg)
    b. 附加n到coerced末端
3. 让onlyZero是true
4. 遍历coerced的元素记作number，做
    a. 如果number是NaN，或者是+∞_F，返回number
    b. 如果number是-∞_F，返回+∞_F
    c. 如果number不是是+0_F或者-0_F，置onlyZero是false
5. 如果onlyZero是true，返回+0_F
6. 返回表示coerced元素数学值的平方和的平方根的实现近似值。

hypot方法的"length"性质值是2_F。
***** 注意 实现需要避免因为上溢或者下溢导致的精度丢失。通常在一些幼稚的
            实现里带多个参数调用此方法时容易出现这种错误。
**** Math.imul( x, y )
当Math.imul方法被带参数x和y调用时，执行下列步骤：
1. 让a是R(?ToUint32(x))
2. 让b是R(?ToUint32(y))
3. 让product是(a * b)对2^32取模的结果
4. 如果product>=2^31，返回F(product - 2^32)；否则返回F(product)
5. 返回不小于x的最小（接近-∞_F）的整数Number
**** Math.log( x )
返回x自然对数。

当Math.log方法被带参数x调用时，执行下列步骤：
1. 让n是?ToNumber(x)
2. 如果n是NaN，或者n是+∞_F，返回n
3. 如果n是1_F，返回+0_F
4. 如果n是+0_F或者n是-0_F，返回-∞_F。
5. 如果n<+0_F，返回NaN
6. 返回表示R(x)的自然对数的实现近似值。
**** Math.log1p( x )
返回1+x的自然对数。即使x接近0，计算的结果也是准确的。

当Math.log1p方法被带参数x调用时，执行下列步骤：
1. 让n是?ToNumber(x)
2. 如果n是NaN，n是+0_F，n是-0_F或者n是+∞_F，返回n
3. 如果n是-1_F，返回-∞_F
4. 如果n<-1_F，返回NaN
5. 返回表示1+R(x)的自然对数的实现近似值。
**** Math.log10( x )
返回x的以10为底的对数。

当Math.log10方法被带参数x调用时，执行下列步骤：
1. 让n是?ToNumber(x)
2. 如果n是NaN，或者n是+∞_F，返回n
3. 如果n是1_F，返回+0_F
4. 如果n是+0_F或者n是-0_F，返回-∞_F。
5. 如果n<+0_F，返回NaN
6. 返回表示R(x)的以10为底对数的实现近似值。
**** Math.log2( x )
返回x的以2为底的对数。

当Math.log2方法被带参数x调用时，执行下列步骤：
1. 让n是?ToNumber(x)
2. 如果n是NaN，或者n是+∞_F，返回n
3. 如果n是1_F，返回+0_F
4. 如果n是+0_F或者n是-0_F，返回-∞_F。
5. 如果n<+0_F，返回NaN
6. 返回表示R(x)的以2为底对数的实现近似值。
**** Math.max( ...args )
给定可数个参数，每个参数调用ToNumber的结果中最大的值。

当Math.max方法被带可数参数args调用时，执行下列步骤：
1. 让coerced是新的空列表
2. 遍历args的元素记作arg，做
    a. 让n是?ToNumber(arg)
    b. 附加n到coerced末端
3. 让highest是-∞_F
4. 遍历coerced的元素记作number，做
    a. 如果number是NaN，返回number
    b. 如果number是+0_F，而且highest是-0_F，置heighest是+0_F
    c. 如果number > highest，置highest是number。
5. 返回highest
***** 注意 除了认为+0_F大于-0_F，其他用于检测最大值的比较使用抽象关系比较。
max方法的"length"性质值是2_F。
**** Math.min( ...args )
给定可数个参数，每个参数调用ToNumber的结果中最小的值。

当Math.min方法被带可数参数args调用时，执行下列步骤：
1. 让coerced是新的空列表
2. 遍历args的元素记作arg，做
    a. 让n是?ToNumber(arg)
    b. 附加n到coerced末端
3. 让lowest是+∞_F
4. 遍历coerced的元素记作number，做
    a. 如果number是NaN，返回number
    b. 如果number是-0_F，而且lowest是+0_F，置lowest是-0_F
    c. 如果number < lowest，置lowest是number。
5. 返回lowest
***** 注意 除了认为+0_F大于-0_F，其他用于检测最大值的比较使用抽象关系比较。
min方法的"length"性质值是2_F。
**** Math.pow( base, exponent )
当Math.pow方法被带参数base和exponent调用时，执行下列步骤：
1. 置base是?ToNumber(base)
2. 置exponent是?ToNumber(exponent)
3. 返回!Number::exponentiate(base, exponent)
**** Math.random( )
返回正的大于等于+0_F，并且严格小于1_F的Number值，在此范围内近似均匀分布的
随机或者伪随机选择，使用实现定义的算法或者策略。本方法不接受参数。

为不同realms创建Math.random函数的连续调用产生不同随机序列。
**** Math.round( x )
返回最接近x的整数Number值。如果有两个数同样接近x，那么选择接近+∞_F的那个
Number值。如果x已经是整数，结果是x。

当Math.round方法被带参数x调用时，执行下列步骤：
1. 让n是?ToNumber(x)
2. 如果n是NaN，n是+∞_F，n是-∞_F或者n是整数Number，返回n
3. 如果n<+0.5_F而且n>+0_F，返回+0_F
4. 如果n<+0_F而且n>=-0.5_F，返回-0_F
5. 返回最接近n的整数Number，优先接近+∞_F的Number。
***** 注意1 Math.round(3.5)返回4，但是Math.round(-3.5)返回-3
***** 注意2 Math.round(x)的值不总是与Math.floor(x + 0.5)的结果相同。当x是-0_F或者
             小于+0_F，但是大于-0.5_F，Math.round(x)返回-0_F，但是
             Math.floor(x+0.5)返回+0_F。Math.round(x)与Math.floor(x + 0.5)不同，有
             可能因为在计算x+0.5时内部修圆了。
**** Math.sign( x )
返回x的符号，指明x时正的，负的或者是0

当Math.sign方法被带参数x调用时，执行下列步骤：
1. 让n是?ToNumber(x)
2. 如果n是NaN，n是+0_F或者n是-0_F，返回n
3. 如果n<+0_F，返回-1_F
4. 返回1_F
**** Math.sin( x )
返回x的正弦结果。结果以弧度表示，在[+0_F,F(π)]上。

当Math.sin方法被带参数x调用时，执行下列步骤：
1. 让n是?ToNumber(x)
2. 如果n是NaN，n是+0_F或者n是-0_F，返回n。
3. 如果n是+∞_F，n是-∞_F，返回NaN。
4. 返回表示R(x)的正弦结果的实现近似值。
**** Math.sinh( x )
返回x的双曲正弦结果。

当Math.sinh方法被带参数x调用时，执行下列步骤：
1. 让n是?ToNumber(x)
2. 如果n是NaN，n是+0_F，n是-0_F或者n是+∞_F，返回n
3. 返回表示R(x)的双曲正弦结果的实现近似值。
***** 注意 Math.sinh(x)与(Math.exp(x) - Math.exp(-x)) / 2结果相同。
**** Math.sqrt( x )
返回x的平方根。

当Math.sqrt方法被带参数x调用时，执行下列步骤：
1. 让n是?ToNumber(x)
2. 如果n是NaN，n是+0_F，n是-0_F或者n是+∞_F，返回n。
3. 如果n<+0_F，返回NaN
4. 返回表示R(x)的平方根结果的实现近似值。
**** Math.tan( x )
返回x的正切结果。结果以弧度表示。

当Math.tan方法被带参数x调用时，执行下列步骤：
1. 让n是?ToNumber(x)
2. 如果n是NaN，n是+0_F，n是-0_F，返回n。
3. 如果n是+∞_F，n是-∞_F，返回NaN
4. 返回表示R(x)的正切结果的实现近似值。
**** Math.tanh( x )
返回x的双曲正切结果。

当Math.tanh方法被带参数x调用时，执行下列步骤：
1. 让n是?ToNumber(x)
2. 如果n是NaN，n是+0_F或者n是-0_F，返回n
3. 如果n是+∞_F，返回+1_F
3. 如果n是-∞_F，返回-1_F
4. 返回表示R(x)的双曲正切结果的实现近似值。
***** 注意 Math.tanh(x)与(Math.exp(x) - Math.exp(-x)) / (Math.exp(x) + Math.exp(-x))
            是相同结果
**** Math.trunc( x )
返回x的整数部分，移除任意小数部分。如果x是整数，返回x。

当Math.trunc方法被带参数x调用时，执行下列步骤：
1. 让n是?ToNumber(x)
2. 如果n是NaN，n是+0_F，n是-0_F，n是+∞_F或者n是-∞_F，返回n
3. 如果n<1_F，而且n>+0_F，返回+0_F
4. 如果n<+0_F，而且n>-1_F，返回-0_F。
5. 返回向+0最接近n的整数Number。
** Date Objects
*** Overview of Date Objects And Definitions of Abstract Operations
随后的函数都是操作时间值（21.4.1.1）的抽象操作。注意，任何情况下，如果某个
参数是NaN，那么结果就是NaN。
**** Time Values and Time Range
在ECMAScript中的时间度量方式与POSIX类似，尤其是共享了公历的术语，从UTC1970年
1月1日的0时0分0秒000的时标开始，而且认为每天86400秒（每秒1000毫秒）。

ECMAScript时间值是Number，要么是表示毫秒精度的具体时间的整数，要么是NaN，表示
不合规的时刻。时间值是24*60*60*1000=86,400,000（记作dt）的倍数（比如
86,400,000*d，d是整数）表示时标后d个UTC整天的开始（负数表示时标之前）。其他
有限时间值t被定义成t前最大的dt的倍数，记作s，和在s所表示的那天的t-s毫秒数。

时间值不考虑UTC闰秒，没有时间值表示正闰秒的时刻，但是去掉负闰秒的UTC时刻有
时间值表示。不过，尽管时间值定义与UTC分片对齐，也只在闰秒边界和闰秒后的0
秒处中断。

Number值可以精确的表示-9,007,199,254,740,992到9,007,199,254,740,992（21.1.2.8和
21.1.2.6）的整数。时间值支持范围的稍微小些，从-8,640,000,000,000,000到
8,640,000,000,000,000毫秒数。这也就是表明支持-100,000,000到100,000,000天的范围，
以时标UTC1970-01-01 00:00:00:000为原点。
***** 注意 在公历里每400年有97个闰年。因此平均每年365.2425天，也就是
            31,556,952,000毫秒。因此Number值相对于1970年大约最多可以表示
            -285,426到285,426年。而更小的时间值相对于1970年按规定大约可以表示
            -273,790到273,790年。
**** Day Number and Time within Day
给定时间值t，属于的天数
Day(t) = F(floor(R(t/msPerDay)))
这里每天毫秒数是
msPerDay = 86400000_F

余数称作是这天的时间：
TimeWithinDay(t)=F(R(t) modulo R(msPerDay))
**** Year Number
ECMAScript使用公历将天数映射到年数，然后明确年内的月份和日期。本日历里，润
年是4的倍数不是100的倍数，或者是400的倍数。因此年内天数由年数y确定：
DaysInYear(y)
  = 365_F 如果 (R(y) modulo 4) != 0
  = 366_F 如果 (R(y) modulo 4) = 0 and (R(y) modulo 100) != 0
  = 365_F 如果 (R(y) modulo 100) = 0 and (R(y) modulo 400) != 0
  = 366_F 如果 (R(y) modulo 400) = 0

所有的非闰年都是365天，每月的天数是正常的天数，而如年在二月会多一天。年y的
第一天：
DayFromYear(y) = F( 365 * (R(y) - 1970) + floor( (R(y) - 1969) / 4 ) -
  floor( (R(y) - 1901) / 100 ) + floor( (R(y) - 1601) / 400 ) )

年开始的时间值是
TimeFromYear(y) = msPerDay * DayFromYear(y)

时间值确定年：
YearFromTime(t) = TimeFromYear(y) <= t的最大整数值y（接近+∞）

闰年函数在闰年返回1，否则返回0
InLeapYear(t)
  = +0_F 如果DaysInYear(YearFromTime(t)) = 365_F
  = +1_F 如果DaysInYear(YearFromTime(t)) = 366_F
**** Month Number
月份以[+0_F,11_F]的整数标识。MonthFromTime(t)将时间值t按照如下定义映到月份：
MonthFromTime(t)
  = +0_F 如果 +0_F <= DayWithYear(t) < 31_F
  = +1_F 如果 +31_F <= DayWithYear(t) < 59_F
  = +2_F 如果 +59_F + InLeapYear(t) <= DayWithYear(t) < 90_F + InLeapYear(t)
  = +3_F 如果 +90_F + InLeapYear(t) <= DayWithYear(t) < 120_F + InLeapYear(t)
  = +4_F 如果 +120_F + InLeapYear(t) <= DayWithYear(t) < 151_F + InLeapYear(t)
  = +5_F 如果 +151_F + InLeapYear(t) <= DayWithYear(t) < 181_F + InLeapYear(t)
  = +6_F 如果 +181_F + InLeapYear(t) <= DayWithYear(t) < 212_F + InLeapYear(t)
  = +7_F 如果 +212_F + InLeapYear(t) <= DayWithYear(t) < 243_F + InLeapYear(t)
  = +8_F 如果 +243_F + InLeapYear(t) <= DayWithYear(t) < 273_F + InLeapYear(t)
  = +9_F 如果 +273_F + InLeapYear(t) <= DayWithYear(t) < 304_F + InLeapYear(t)
  = +10_F 如果 +304_F + InLeapYear(t) <= DayWithYear(t) < 334_F + InLeapYear(t)
  = +11_F 如果 +334_F + InLeapYear(t) <= DayWithYear(t) < 365_F + InLeapYear(t)
这里
DayWithinYear(t) = Day(t) - DayFromYear(YearFromTime(t))

月份+0_F是一月；1_F是二月；2_F是三月；3_F是四月；4_F是五月；5_F是六月；
6_F是七月；7_F是八月；8_F是九月；9_F是十月；10_F是十一月；11_F是十二月。注意
MonthFromTime(+0_F)=+0_F，标识1970年1月。
**** Date Number
日数是[1_F,31_F]内的整数。DateFromTime(t)将时间值t按照如下定义映到日数：
DateFromTime(t)
  = DayWithinYear(t) + 1_F 如果 MonthFromTime(t) = +0_F
  = DaywithinYear(t) - 30_F 如果 MonthFromTime(t) = 1_F
  = DaywithinYear(t) - 58_F - InLeapYear(t) 如果 MonthFromTime(t) = 2_F
  = DaywithinYear(t) - 89_F - InLeapYear(t) 如果 MonthFromTime(t) = 3_F
  = DaywithinYear(t) - 119_F - InLeapYear(t) 如果 MonthFromTime(t) = 4_F
  = DaywithinYear(t) - 150_F - InLeapYear(t) 如果 MonthFromTime(t) = 5_F
  = DaywithinYear(t) - 180_F - InLeapYear(t) 如果 MonthFromTime(t) = 6_F
  = DaywithinYear(t) - 211_F - InLeapYear(t) 如果 MonthFromTime(t) = 7_F
  = DaywithinYear(t) - 242_F - InLeapYear(t) 如果 MonthFromTime(t) = 8_F
  = DaywithinYear(t) - 272_F - InLeapYear(t) 如果 MonthFromTime(t) = 9_F
  = DaywithinYear(t) - 303_F - InLeapYear(t) 如果 MonthFromTime(t) = 10_F
  = DaywithinYear(t) - 333_F - InLeapYear(t) 如果 MonthFromTime(t) = 11_F
**** Week Day
时间值t是星期几（简称：星日）由如下定义
WeekDay(t) = F(R(Day(t) + 4_F) modulo 7)
星日+0_F是星期日；1_F是星期一；2_F是星期二；3_F是星期三；4_F是星期四；
5_F是星期五；6_F是星期六。注意WeekDay(+0_F)=4_F，与1970年1月1日星期四一致。
Sunday Monday TuesDay WednesDay ThursDay Friday Saturday。
**** LocalTZA(t, isUTC)
LocalTZA(t, isUTC)是实现定义的算法，返回一个根据本地时区调整的时间，以毫秒
表示的整数。在t上生效的标准时间的本地政策和夏令时应该按照本节规定产生作
用。

当isUTC是true，LocalTZA(t_UTC,true)应当返回用毫秒表示的时间值t_UTC对应的时间
在本地时间上的偏移，记作t_off。t_UTC+t_off的结果应与本地时间t_local一致。

当isUTC是false，localTZA(t_local, false)应当返回用毫秒表示的本地时间t_local与UTC
时间的偏移，记作t_off。t_local - t_off的结果应与时间值t_UTC一致。

输入t是常规的时间值，但可能是任意Number值。因为若isUTC是false，而t_local表示的
时间值可能因为偏移而超出时间值的范围。算法不能限制t_local要在时间值范围内，
因此这种输入也是允许的。

如果t_local表示的是在负时区多次重复（比如：在夏令时结束或者或者因为时区规
则变更导致的偏移减少）的时间，或者在正时区略过本地时间（比如：在夏令时开
始或者因为时取变更规则导致的偏移增加）的时间，t_local必须先被时区偏移解释
后再做转换。

如果实现不支持上述描述的转换，或者因为时间t的政策规则时间在实现里不可用，
结果必须是+0_F。

msPerHour = 3600 * 1000;
***** 注意 推荐实现是选用LANA时区数据库的时区信息。
            https://www.iana.org/time-zones/

            美国/纽约2017年11月5号1:30AM出现两次（回退了），但是必须被翻译为
            1:30AM UTC-04而不是1:30AM UTC-05。
            LocalTZA(TimeClip(MakeDate(MakeDay(2017, 10, 5), MakeTime(1, 30, 0, 0))),
            false)是-4 * msPerHour

            美国/纽约2017年3月12号2:30AM不存在，但是必须被解释为2:30AM UTC-05（
            与3:30AM UTC-04一致）
            LocalTZA(TimeClip(MakeDate(MakeDay(2017, 2, 12), MakeTime(2, 30, 0, 0))),
            false)是-5 * msPerHour

            时区偏移值是正数或者负数。
**** LocalTime( t )
抽象操作LocalTime接受参数t。将t从UTC转换为本地时间。被调用时执行下列步骤：
1. 返回 t + LocalTZA(t, true)
***** 注意 两个不同的t_UTC在负时区有重复时间是会被转换为相同的本地时间
            t_local（比如：夏令时结束，或者时区调整减少了）

            LocalTime(UTC(t_local))不必总是等于t_lcoal。同样UTC(LocalTime(t_UTC))
            不必总是等于t_UTC。
**** UTC(t)
抽象操作UTC接受参数t。将t从本地时间转换为UTC。被调用时执行下列步骤：
1. 返回 t - LocalTZA(t, false)
***** 注意 UTC(LocalTime(t_UTC))不必总是等于t_UTC。同样LocalTime(UTC(t_local))不
            必总是等于t_lcoal。
**** Hours, Minutes, Second and Milliseconds
下列抽象操作用于分解时间值
HourFromTime(t) = F(floor(R(t / msPerHour)) modulo HoursPerDay)
MinFromTime(t) = F(floor(R(t / msPerMinute)) modulo MinutesPerHour)
SecFromTime(t) = F(fllor(R(t / msPerSecond)) modulo SecondsPerMinute)
msFromTime(t) = F(R(t) modulo msPerSecond)
其中
HoursPerDay = 24
MinutesPerHour = 60
SecondsPerMinute = 60
msPerSecond = 1000_F
msPerMinute = 60000_F = msPerSecond * F(SecondsPerMinute)
msPerHour = 3600000_F = msPerMinute * F(MinutesPerHour)
**** MakeTime(hour, min, sec, ms)
抽象操作MakeTime接受参数hour（Number值），min（Number值），sec（Number值）
和ms（Number值）。计算出毫秒数的值。被调用时执行下列步骤：
1. 如果hour不是有限的或者min不是有限的或者sec不是有限的或者ms不是有限的，
   返回NaN。
2. 让h是F(!ToIntegerOrInfinity(hour))
3. 让m是F(!ToIntegerOrInfinity(min))
4. 让s是F(!ToIntegerOrInfinity(sec))
5. 让milli是F(!ToIntegerOrInfinity(ms))
6. 让t是((h * msPerHour + m * msPerMinute) + s * msPerSecond) + milli。执行
   IEEE 754-2019的规则（也就是 *和+表述 ECMAScript操作符）
7. 返回t
**** MakeDay(year, month, date)
抽象操作MakeDay接受参数year（Number值），month（Number值）和date（Number值）。
计算出天数。被调用时执行下列步骤：
1. 如果year不是有限的或者month不是有限的或者date不是有限的，返回NaN。
2. 让y是F(!ToIntegerOrInfinity(year))
3. 让m是F(!ToIntegerOrInfinity(month))
4. 让dt是F(!ToIntegerOrInfinity(date))
5. 让ym是y+F(floor(R(m) / 12))
6. 如果ym不是有限的，返回NaN
7. 让mn是F(R(m) modulo 12)
8. 找到某个时间值t合于YearFromTime(t)是ym，MonthFromTime(t)是mn，且DateFromTime(t)
   是1_F。如果不存在t（因为超出时间范围了），返回NaN。
9. 返回Day(t) + dt - 1_F
**** MakeDate(day, time)
抽象操作MakeDate接受参数day（Number值）和time（Number值）。计算出毫秒数数。
被调用时执行下列步骤：
1. 如果day不是有限的或者time不是有限的，返回NaN。
2. 让tv是day * msPerDay + time
3. 如果tv不是有限的，返回NaN
4. 返回tv
**** TimeClip(time)
抽象操作TimeClip接受参数time（Number值）。计算出毫秒数。被调用时执行下列步
骤：
1. 如果time不是有限的，返回NaN
2. 如果abs(R(time)) > 8.64*10^15，返回NaN
3. 返回F(!ToIntegerOrInfinity(time))
**** Date Time String Format
ECMAScript在ISO 8601日历扩展格式的简化型上定义了时间值输出格式。格式如:
YYYY-MM-DDTHH:mm:ss.sssZ

元素如下所述：
| YYYY | 是公历年的四位十进制数字表述，从0000到9999，或者是扩展年形式， |
|      | 即"+"或"-"跟随六位十进制数字。                                 |
| \-   | "-"（连字符）在字符串出现两次。                                |
| MM   | 用两位十进制数表示的年内的月数，从01（一月）到12（十二月）     |
| DD   | 月内的天数，从01到31。                                         |
| T    | "T"子符出现在字符串中，以表明开始时间元素                      |
| HH   | 天内两个午夜间的小时数，两位十进制数，从00到24。               |
| ：   | ":"（分号）在字符串出现了两次                                  |
| mm   | 小时内包含开始的分钟数，两位十进制数，从00到59。               |
| ss   | 分钟内包含开始的秒数，两位十进制数，从00到59                   |
| .    | "."（点）出现在字符串中                                        |
| sss  | 秒内包含开始的毫秒数，三位十进制数。                           |
| Z    | UTC偏移量用"Z"表述（UTC没有偏移），或者用"+"或"-"跟随时间      |
|      | 表达HH:mm（指明本地时间在UTC前或者后的时间）                                 |

这个格式包含仅有日期的形式：
YYYY
YYYY-MM
YYYY-MM-DD

也包含日时形式，由上述日期形式跟随下方的时间形式和追加可选的UTC偏移组成：
THH:mm
THH:mm:ss
THH:mm:ss.sss

字符串日期越出日期边界了，或者有不合法的元素，都不是本格式的实例。
***** 注意1 每天都是在午夜开始和结束，所以00:00和24:00用于区分一天上的两个
             午夜。这就意味着类似1995-02-04T24:00和1995-02-05T00:00严格表示同一
             个时刻。日期结束形式的解释是与ISO 8601一致的，尽管规范保留它
             用于描述时间间隔，而且不允许它出现在时间点的表示上。
***** 注意2 没有国际标准规定民用时区的缩写比如CET、EST等，甚至有时同样的
             缩写表示不同的时区。因此ISO 8601和本格式规定用数字表示时区的
             偏移。
***** Expanded Years
从1970年1月1日（21.4.1.1）向前或后大约可以表示273,790年，这要求能够表示0之前
或者9999之后的年份。ISO 8601允许扩展年的表述，但是只能通过信息交换伙伴的
相互协议。在间化的ECMAScript格式里，这种扩展年应当有六位数字和前缀"+"或"-"
符号。第0年被认为是正的，因此前缀是"+"。匹配到日期时间字符串格式的带有
超出时间值范围的扩展年的字符串被Date.parse当作不可识别的，从而返回NaN，而
不是返回实现规定的行为或者实现探索行为。
****** 注意 带有扩展年的日期时间
             | -271821-04-20T00:00:00Z | 271822 B.C. |
             | -000001-01-01T00:00:00Z | 2 B.C.      |
             | +000000-01-01T00:00:00Z | 1 B.C.      |
             | +000001-01-01T00:00:00Z | 1 A.D.      |
             | +001970-01-01T00:00:00Z | 1970 A.D.   |
             | +002009-12-15T00:00:00Z | 2009 A.D.   |
             | +275760-09-13T00:00:00Z | 275760 A.D. |
*** The Date Constructor
日期构造范
. 是%Date%
. 是全局对象上"Date"性质的初始值
. 被作为构造范调用时，传键和初始化新的日期对像
. 被作为函数，而不是构造范，调用时，返回表示当前UTC时间的字符串
. 是函数，不同数量和类型的参数，行为不同。
. 被设计成可继承。也就是说可以用在定义class时的extends语句里。子类的构造范
  如果要继承Date的特定行为，必须含有super调用，以使用Date构造范创建和初始
  化一个拥有\[\[DateValue]]内部占位的子类实例。
. "length"性质是7_F
**** Date( ...values )
当Date函数被调用时，执行下列步骤：
1. 如果NewTarget是undefined，那么
    a. 让now是当前时间的UTC时间值
    b. 返回ToDateString(now)
2. 让numberOfArgs是values元素的数量
3. 如果numberOfArgs = 0，那么
    a. 让dv是当前时间的UTC时间值
4. 如果numberOfArgs = 1，那么
    a. 让value是values[0]
    b. 如果Type(value)是Object，而且value有\[\[DateValue]]内部占位，那么
        i. 让tv是!thisTimeValue(value)
    c. 否则
        i. 让v是?ToPrimitive(value)
       ii. 如果Type(v)是字符串，那么
            1. Assert：下一步不会返回异常完结，因为Type(v)是字符串
            2. 让tv是解析日期v得到的时间值，严格按照parse（21.4.3.2）方法解析。
      iii. 否则
            1. 让tv是?ToNumber(v)
    d. 让dv是TimeClip(tv)
5. 否则
    a. Assert：numberOfArgs >= 2
    b. 让y是?ToNumber(values[0])
    c. 让m是?ToNumber(values[1])
    d. 如果numberOfArgs > 2, 让dt是?ToNumber(values[2])，否则让dt是1_F
    e. 如果numberOfArgs > 3, 让h是?ToNumber(values[3])，否则让h是+0_F
    f. 如果numberOfArgs > 4, 让min是?ToNumber(values[4])，否则让min是+0_F
    g. 如果numberOfArgs > 5, 让s是?ToNumber(values[5])，否则让5是+0_F
    h. 如果numberOfArgs > 6, 让milli是?ToNumber(values[6])，否则让milli是+0_F
    i. 如果y是NaN，让yr是NaN
    j. 否则
        i. 让yi是!ToIntegerOrInfinity(y)
       ii. 如果0<= yi <= 99，让yr是1900_F + F(yi)；否则让yr是y
    k. 让finalDate是MakeDate(MakeDay(yr, m, dt), MakeTime(h, min, s, milli))
    l. 让dv是TimClip(UTC(finalDate))
6. 让O是?OrdinaryCreateFromConstructor(NewTarget, %Date.prototype%, << \[\[DateValue]]
   >>)
7. 置O.\[\[DateValue]]是dv
8. 返回O
*** Properties of the Date Constructor
Date构造范：
. 有\[\[Prototype]]内部占位，值是%Function.prototype%
. 有如下性质：
**** Date.now()
now函数返回在调用now的时刻的UTC时间值。
**** Date.parse( string )
parse函数会对参数应用ToString。如果ToString是意外完结，那么立刻返回。其他时，
parse将结果字符串当作一个日期时间；返回表示日期时间对应的UTC时间值的数值。
字符串根据内容是本地时间，是UTC时间，或者其他时区的时间。函数先试图用日期
时间格式（21.4.1.15），包含扩展年，来解析字符串。如果字符串与格式不一致，
函数会再尝试实现规定的探索式格式或者是实现规定的日期格式。无法识别的日期
或者含有超限值的元素，会让Date.parse返回NaN

如果字符串符合日期时间文本格式，缺省元素使用替代值占位。当MM或者DD缺少时，
使用"01"替代。当HH、mm或者ss缺省时，使用"00"替代。在sss缺省时，使用"000"替
代。如果没有UTC偏移，独日期形式的被翻译成UTC时间，而日期时间形式的被翻译成
本地时间。

在ECMAScript的某个实现里，如果x是Date对象，其毫秒数是0，那么随后的表达式都
产生相同的数值，如果这些形式还是初始值的话：
x.valueOf()
Date.parse(x.toString())
Date.parse(x.toUTCString())
Date.parse(x.toISOString())

然而，表达式
Date.parse(x.toLocaleString()) 不需要与上述几个表达式的结果一致，通常，在字符
串不符合日期时间格式（21.4.1.15），也无法在实现里通过Date对象的toString或者
toUTCString方法产生是，Date.parse产生的值由实现定义。
**** Date.prototype
Date.prototype的初始值是Date原型对象。

此性质的属性是{ \[\[Writable]]:false, \[\[Enumerable]]:false,
\[\[Configurable]]:false, }
**** Date.UTC(year[, month[, date[, hours[, minutes[, seconds[, ms ]]]]]])
当UTC函数被调用时，执行下列步骤：
1. 让y是?ToNumber(year)
2. 如果month存在，让m是?ToNumber(month)；否则让m是+0_F
3. 如果date存在，让dt是?ToNumber(date)；否则让dt是+1_F
4. 如果hours存在，让h是?ToNumber(hours)；否则让h是+0_F
5. 如果minutes存在，让min是?ToNumber(minutes)；否则让min是+0_F
6. 如果seconds存在，让s是?ToNumber(seconds)；否则让s是+0_F
7. 如果ms存在，让milli是?ToNumber(ms)；否则让milli是+0_F
8. 如果y是NaN，让yr是NaN
9. 否则
    a. 让yi是!ToIntegerOrInfinity(y)
    b. 如果0 <= yi <= 99，让yr是1900_F+F(yi)；否则让yr是y
10. 返回TimeClip(MakeDate(MakeDay(yr, m, dt), MakeTime(h, min, s, milli)))

UTC函数的"length"性质值是7_F

***** 注意 UTC函数与Date构造范有两处不同：1、返回时间值的毫秒数，而不是Date
            对象；2、将参数翻译成UTC时间，而不是本地时间。
*** Properties of the Date Prototype Object
Date原型对象：
. 是%Date.prototype%
. 本身是一个基本对象
. 不是Date实例，没有\[\[DateValue]]内部占位
. 有\[\[Prototype]]内部占位，值是%Object.prototype%

除非另有显式定义，下方定义的Date原型上的方法都不是泛型的，传递它们的this值
必须是对象，而且要有\[\[DateValue]]内部占位，并且初始化了时间值。

抽象操作thisTimeValue接受参数value。被调用时，执行下列步骤：
1. 如果Type(value)是对象，而且内部占位\[\[DateValue]]，那么
    a. 返回value.\[\[DateValue]]
2. 投掷TypeError异常

在随后的是Date原型对像上性质的函数的定义里，短语"this Date对象"指的是在其上
调用此函数的对象，记作this。如果this的类型不是Object，投掷TypeError异常。而
在本规范方法内的短语"this时间值"指的是带this值调用thisTimeValue抽象操作后的
结果。
**** Date.prototype.constructor
Date.prototype.constructor的初始值是%Date%
**** Date.prototype.getDate()
被调用时执行下列步骤：
1. 让t是?thisTimeValue(this值)
2. 如果t是NaN，返回NaN
3. 返回DateFromTime(LocalTime(t))
**** Date.prototype.getDay()
被调用时执行下列步骤：
1. 让t是?thisTimeValue(this值)
2. 如果t是NaN，返回NaN
3. 返回WeekDay(LocalTime(t))
**** Date.prototype.getFullYear()
被调用时执行下列步骤：
1. 让t是?thisTimeValue(this值)
2. 如果t是NaN，返回NaN
3. 返回YearFromTime(LocalTime(t))
**** Date.prototype.getHours()
被调用时执行下列步骤：
1. 让t是?thisTimeValue(this值)
2. 如果t是NaN，返回NaN
3. 返回HourFromTime(LocalTime(t))
**** Date.prototype.getMilliseconds()
被调用时执行下列步骤：
1. 让t是?thisTimeValue(this值)
2. 如果t是NaN，返回NaN
3. 返回msFromTime(LocalTime(t))
**** Date.prototype.getMinutes()
被调用时执行下列步骤：
1. 让t是?thisTimeValue(this值)
2. 如果t是NaN，返回NaN
3. 返回MinFromTime(LocalTime(t))
**** Date.prototype.getMonth()
被调用时执行下列步骤：
1. 让t是?thisTimeValue(this值)
2. 如果t是NaN，返回NaN
3. 返回MonthFromTime(LocalTime(t))
**** Date.prototype.getSeconds()
被调用时执行下列步骤：
1. 让t是?thisTimeValue(this值)
2. 如果t是NaN，返回NaN
3. 返回SecFromTime(LocalTime(t))
**** Date.prototype.getTime()
被调用时执行下列步骤：
1. 返回?thisTimeValue(this值)
**** Date.prototype.getTimezoneOffset()
被调用时执行下列步骤：
1. 让t是?thisTimeValue(this值)
2. 如果t是NaN，返回NaN
3. 返回(t - LocalTime(t)) / msPerMinute
**** Date.prototype.getUTCDate()
被调用时执行下列步骤：
1. 让t是?thisTimeValue(this值)
2. 如果t是NaN，返回NaN
3. 返回DateFromTime(t)
**** Date.prototype.getUTCDay()
被调用时执行下列步骤：
1. 让t是?thisTimeValue(this值)
2. 如果t是NaN，返回NaN
3. 返回WeekDay(t)
**** Date.prototype.getUTCFullYear()
被调用时执行下列步骤：
1. 让t是?thisTimeValue(this值)
2. 如果t是NaN，返回NaN
3. 返回YerFromTime(t)
**** Date.prototype.getUTCHours()
被调用时执行下列步骤：
1. 让t是?thisTimeValue(this值)
2. 如果t是NaN，返回NaN
3. 返回HourFromTime(t)
**** Date.prototype.getUTCMilliseconds()
被调用时执行下列步骤：
1. 让t是?thisTimeValue(this值)
2. 如果t是NaN，返回NaN
3. 返回msFromTime(t)
**** Date.prototype.getUTCMinutes()
被调用时执行下列步骤：
1. 让t是?thisTimeValue(this值)
2. 如果t是NaN，返回NaN
3. 返回MinFromTime(t)
**** Date.prototype.getUTCMonth()
被调用时执行下列步骤：
1. 让t是?thisTimeValue(this值)
2. 如果t是NaN，返回NaN
3. 返回MonthFromTime(t)
**** Date.prototype.getUTCSeconds()
被调用时执行下列步骤：
1. 让t是?thisTimeValue(this值)
2. 如果t是NaN，返回NaN
3. 返回SecFromTime(t)
**** Date.prototype.setDate( date )
被调用时执行下列步骤：
1. 让t是LocalTime(?thisTimeValue(this值))
2. 让dt是?ToNumber(date)
3. 让newDate是MakeDate(MakeDay(YearFromTime(t), MonthFromTime(t), dt),
   TimeWithinDay(t))。
4. 让u是TimeClip(UTC(newDate))
5. 置this Date对象的\[\[DateValue]]内部占位的值是u。
6. 返回u
**** Date.prototype.setFullYear( year[, month[, date ]] )
被调用时执行下列步骤：
1. 让t是?thisTimeValue(this值)
2. 如果t是NaN，置t是+0_F；其他，置t是LocalTime(t)
3. 让y是?ToNumber(year)
4. 如果month不存在，让m是MonthFromTime(t)；其他，让m是?ToNumber(month)
5. 如果date不存在，让dt是DateFromTime(t)；其他，让dt是?ToNumber(date)
6. 让newDate是MakeDate(MakeDay(y, m, dt), TimeWithinDay(t))。
7. 让u是TimeClip(UTC(newDate))
8. 置this Date对象的\[\[DateValue]]内部占位的值是u。
9. 返回u

setFullYear方法"length"性质是3_F
***** 注意 如果month不存在，本方法的行为就像month以getMonth()结果出现。如果
            date不存在，本方法的行为就像date以getDate()结果出现。
**** Date.prototype.setHours(hour[, min[, sec[, ms ]]] )
被调用时执行下列步骤：
1. 让t是LocalTime(?thisTimeValue(this值))
2. 让h是?ToNumber(hour)
3. 如果min不存在，让m是MinFromTime(t)；其他，让m是?ToNumber(min)
4. 如果sec不存在，让s是SecFromTime(t)；其他，让s是?ToNumber(sec)
5. 如果ms不存在，让milli是msFromTime(t)；其他，让milli是?ToNumber(ms)
6. 让newDate是MakeDate(Day(t),MakeTime(h, m, s, milli))
7. 让u是TimeClip(UTC(newDate))
8. 置this Date对象的\[\[DateValue]]内部占位的值是u。
9. 返回u

setHours方法"length"性质是4_F
***** 注意 如果min不存在，本方法的行为就像min以getMinutes()结果出现。如果
            sec不存在，本方法的行为就像sec以getSeconds()结果出现。如果ms不存
            在，本方法的行为就像ms以getMilliseconds()结果出现。
**** Date.prototype.setMilliseconds( ms )
被调用时执行下列步骤：
1. 让t是LocalTime(?thisTimeValue(this值))
2. 让ms是?ToNumber(ms)
3. 让time是MakeTime(HourFromTime(t), MinFromTime(t), SecondFromTime(t), ms)。
4. 让u是TimeClip(UTC(MakeDate(Day(t), time)))
5. 置this Date对象的\[\[DateValue]]内部占位的值是u。
6. 返回u
**** Date.prototype.setMinutes( min[, sec[, ms ]] )
被调用时执行下列步骤：
1. 让t是LocalTime(?thisTimeValue(this值))
2. 让m是?ToNumber(min)
3. 如果sec不存在，让s是SecFromTime(t)；其他，让s是?ToNumber(sec)
4. 如果ms不存在，让milli是msFromTime(t)；其他，让milli是?ToNumber(ms)
5. 让date是MakeDate(Day(t), MakeTime(HourFromTime(t, m, s, milli)
6. 让u是TimeClip(UTC(date))
7. 置this Date对象的\[\[DateValue]]内部占位的值是u。
8. 返回u

setMinutes方法"length"性质是3_F
***** 注意 如果sec不存在，本方法的行为就像sec以getSeconds()结果出现。如果ms
            不存在，本方法的行为就像ms以getMilliseconds()结果出现。
**** Date.prototype.setMonth( month[, date ] )
被调用时执行下列步骤：
1. 让t是LocalTime(?thisTimeValue(this值))
2. 让m是?ToNumber(month)
3. 如果date不存在，让dt是DateFromTime(t)；其他，让dt是?ToNumber(date)
4. 让newDate是MakeDate(MakeDay(YearFromTime(t), m, dt), TimeWithinDay(t))。
5. 让u是TimeClip(UTC(newDate))
6. 置this Date对象的\[\[DateValue]]内部占位的值是u。
7. 返回u

setMonth方法"length"性质是2_F
***** 注意 如果date不存在，本方法的行为就像date以getDate()结果出现。
**** Date.prototype.setSeconds( sec[, ms ] )
被调用时执行下列步骤：
1. 让t是LocalTime(?thisTimeValue(this值))
2. 让s是?ToNumber(set)
3. 如果ms不存在，让milli是msFromTime(t)；其他，让milli是?ToNumber(ms)
4. 让date是MakeDate(Day(t),MakeTime(HourFromTime(t),MinFromTime(t), s, milli))
5. 让u是TimeClip(UTC(newDate))
6. 置this Date对象的\[\[DateValue]]内部占位的值是u。
7. 返回u。

setSeconds方法"length"性质是2_F
***** 注意 如果ms不存在，本方法的行为就像ms以getMilliseconds()结果出现。
**** Date.prototype.setTime( time )
被调用时执行下列步骤：
1. 执行?thisTimeValue(this值)
2. 让t是?ToNumber(time)
3. 让v是TimeClip(t)
4. 置this Date对象的\[\[DateValue]]内部占位的值是v。
5. 返回v。
**** Date.prototype.setUTCDate( date )
被调用时执行下列步骤：
1. 让t是?thisTimeValue(this值)
2. 让dt是?ToNumber(date)
3. 让newDate是MakeDate(MakeDay(YearFromTime(t), MonthFromTime(t), dt),
   TimeWithinDay(t))。
4. 让v是TimeClip(newDate)
5. 置this Date对象的\[\[DateValue]]内部占位的值是v。
6. 返回v。
**** Date.prototype.setUTCFullYear( year[, month[, date ]] )
被调用时执行下列步骤：
1. 让t是?thisTimeValue(this值)
2. 如果t是NaN，置t是+0_F。
3. 让y是?ToNumber(year)
4. 如果month不存在，让m是MonthFromTime(t)；否则，让m是?ToNumber(month)
5. 如果date不存在，让dt是DateFromTime(t)；否则，让dt是?ToNumber(date)
6. 让newDate是MakeDate(MakeDay(y, m, dt), TimeWithinDay(t))。
7. 让v是TimeClip(newDate)
8. 置this Date对象的\[\[DateValue]]内部占位的值是v。
9. 返回v。

setUTCFullYear方法"length"性质是3_F
***** 注意 如果month不存在，本方法的行为就像month以getUTCMonth()结果出现。如果
            date不存在，本方法的行为就像date以getUTCDate()结果出现。
**** Date.prototype.setUTCHours(hour[, min[, sec[, ms ]]] )
被调用时执行下列步骤：
1. 让t是?thisTimeValue(this值)
2. 让h是?ToNumber(hour)
3. 如果min不存在，让m是MinFromTime(t)；其他，让m是?ToNumber(min)
4. 如果sec不存在，让s是SecFromTime(t)；其他，让s是?ToNumber(sec)
5. 如果ms不存在，让milli是msFromTime(t)；其他，让milli是?ToNumber(ms)
6. 让newDate是MakeDate(Day(t),MakeTime(h, m, s, milli))
7. 让v是TimeClip(newDate)
8. 置this Date对象的\[\[DateValue]]内部占位的值是v。
9. 返回v。

setUTCHours方法"length"性质是4_F
***** 注意 如果min不存在，本方法的行为就像min以getUTCMinutes()结果出现。如果
            sec不存在，本方法的行为就像sec以getUTCSeconds()结果出现。如果ms不存
            在，本方法的行为就像ms以getUTCMilliseconds()结果出现。
**** Date.prototype.setUTCMilliseconds( ms )
被调用时执行下列步骤：
1. 让t是?thisTimeValue(this值)
2. 让milli是?ToNumber(ms)
3. 让time是MakeTime(HourFromTime(h), MinFromTime(m), SecondFromTime(s), milli)
4. 让v是TimeClip(MakeDate(Day(t), time))
5. 置this Date对象的\[\[DateValue]]内部占位的值是v。
6. 返回v。
**** Date.prototype.setUTCMinutes( min[, sec[, ms ]] )
被调用时执行下列步骤：
1. 让t是?thisTimeValue(this值)
2. 让m是?ToNumber(min)
3. 如果sec不存在，让s是SecFromTime(t)；其他，让s是?ToNumber(sec)
4. 如果ms不存在，让milli是msFromTime(t)；其他，让milli是?ToNumber(ms)
5. 让date是MakeDate(Day(t),MakeTime(HourFromTime(h), m, s, milli))
6. 让v是TimeClip(date)
7. 置this Date对象的\[\[DateValue]]内部占位的值是v。
8. 返回v。

setUTCMinutes方法"length"性质是3_F
***** 注意 如果sec不存在，本方法的行为就像sec以getUTCSeconds()结果出现。如
            果ms不存在，本方法的行为就像ms以getUTCMilliseconds()结果出现。
**** Date.prototype.setUTCMonth( month[, date ] )
被调用时执行下列步骤：
1. 让t是?thisTimeValue(this值)
2. 让m是?ToNumber(month)
3. 如果date不存在，让dt是DateFromTime(t)；否则，让dt是?ToNumber(date)
4. 让newDate是MakeDate(MakeDay(YearFromTime(t), m, dt), TimeWithinDay(t))。
5. 让v是TimeClip(newDate)
6. 置this Date对象的\[\[DateValue]]内部占位的值是v。
7. 返回v。

setUTCMonth方法"length"性质是2_F
***** 注意 如果date不存在，本方法的行为就像date以getUTCDate()结果出现。
**** Date.prototype.setUTCSeconds( sec[, ms ] )
被调用时执行下列步骤：
1. 让t是?thisTimeValue(this值)
2. 让s是?ToNumber(sec)
3. 如果ms不存在，让milli是msFromTime(t)；其他，让milli是?ToNumber(ms)
4. 让date是MakeDate(Day(t),MakeTime(HourFromTime(h), MinFromTime(m), s, milli))
5. 让v是TimeClip(date)
6. 置this Date对象的\[\[DateValue]]内部占位的值是v。
7. 返回v。

setUTCSeconds方法"length"性质是2_F
***** 注意 如果ms不存在，本方法的行为就像ms以getUTCMilliseconds()结果出现。
**** Date.prototype.toDateString()
被调用时执行下列步骤：
1. 让O是this Date对象
2. 让tv是?thisTimeValue(O)
3. 如果tv是NaN，返回"Invalid Date"
4. 让t是LocalTime(tv)
5. 返回DateString(t)
**** Date.prototype.toISOString()
如果this时间值不是有限的Number或者它对应的年不能用日期时间格式表示，本函数
会投掷RangeError异常。其他情况，会返回在UTC时间尺度上的表述此this时间值的
字符串，包括全部格式元素和UTC偏移"Z"。
**** Date.prototype.toJSON( key )
本函数用在JSON.stringify（25.5.2）给Date对象提供字符串表述。

当toJSON方法被带参数key调用时，执行下列步骤：
1. 让O是?ToObject(this值）
2. 让tv是?ToPrimitive(O, number)
3. 如果Type(tv)是Number，而且tv不是有限的，返回null
4. 返回?Invoke(O, "toISOString")
***** 注意1 参数被忽略了
***** 注意2 toJSON函数会尝试泛型，不要求this值是Date对象。因此可以提供给其他
             对象作为方法。然而需要那些对象有toISOString方法。
**** Date.prototype.toLocaleDateString( [reserved1[, reserved2 ]] )
包含ECMA-402国际API的ECMAScript实现必须按照ECMA-402规范的规定来实现
Date.prototype.toLocaleDateString方。如果没有包含ECMA-402的API，按照随后的规范
实现toLocaleDateString方法。

本函数返回字符串。内容是实现定义的，但是应当用简便、易读的形式表示当前时区
时间的日期部分，且符合主机环境本地的习惯。

这意味着本方法的可选参数定义在ECMA-402规范；不支持ECMA-402的实现不能将参数用
做他途。
**** Date.prototype.toLocaleString( [reserved1[, reserved2 ]] )
包含ECMA-402国际API的ECMAScript实现必须按照ECMA-402规范的规定来实现
Date.prototype.toLocaleString方。如果没有包含ECMA-402的API，按照随后的规范
实现toLocaleString方法。

本函数返回字符串。内容是实现定义的，但是应当用简便、易读的形式表示当前时区
时间，且符合主机环境本地的习惯。

这意味着本方法的可选参数定义在ECMA-402规范；不支持ECMA-402的实现不能将参数用
做他途。
**** Date.prototype.toLocaleTimeString( [reserved1[, reserved2 ]] )
包含ECMA-402国际API的ECMAScript实现必须按照ECMA-402规范的规定来实现
Date.prototype.toLocaleTimeString方。如果没有包含ECMA-402的API，按照随后的规范
实现toLocaleTimeString方法。

本函数返回字符串。内容是实现定义的，但是应当用简便、易读的形式表示当前时区
时间的时间部分，且符合主机环境本地的习惯。

这意味着本方法的可选参数定义在ECMA-402规范；不支持ECMA-402的实现不能将参数用
做他途。
**** Date.prototype.toString()
被调用时执行下列步骤：
1. 让tv是?thisTimeValue(this值)
2. 返回ToDateString(tv)
***** 注意1 任意Date对象d，比如d.\[\[DaeValue]]是1000的倍数，那么
             Date.parse(d.toString()) == d.valueOf()。见于21.4.3.2
***** 注意2 toString方法不支持泛型。如果this值不是Date对象投掷TypeError异常。
             因此不能传递它给别的对象，将之作为方法。
***** TimeString( tv )
抽象操作TimeString接受参数tv。被调用时执行下列步骤：
1. Assert：Type(tv)是Number
2. Assert：tv不是NaN
3. 让hour是HourFromTime(tv)的字符串表示，两位10进制数形式，
   左侧补0（DIGIT ZERO 0x0030）
4. 让minute是MinFromTime(tv)的字符串表示，两位10进制数形式，
   左侧补0（DIGIT ZERO 0x0030）
5. 让second是SecondFromTime(tv)的字符串表示，两位10进制数形式，
   左侧补0（DIGIT ZERO 0x0030）
6. 返回hour ":" minute ":" second 编码单元0x0020（SPACE）和"GMT"的字符串拼接
***** DateString( tv )
抽象操作DateString接受参数tv。被调用时执行下列步骤：
1. Assert：Type(tv)是Number
2. Assert：tv不是NaN
3. 让weekday是WeekDay(tv)的Number值在表52中映射的名称
4. 让month是MonthFromTime(tv)的Number值在表53中映射的名称
5. 让day是DateFromTime(tv)的字符串表示，两位10进制数形式，
   左侧补0（DIGIT ZERO 0x0030）
6. 让yv是YearFromTime(tv)
7. 如果yv >= +0_F，让yearSign是空字符串，否则让yearSign是"-"
8. 让year是abs(R(yv))的十进制字符串表示
9. 让paddedYear是!StringPad(year, 4_F, "0", start)
10. 返回weekday 编码单元0x0020（SPACE） month 编码单元0x0020（SPACE） day
    编码单元0x0020（SPACE） yearSign和paddedYear的字符串拼接。

表52
| Number 值 | Name 名称 |
| +0_F      | Sun       |
| 1_F       | Mon       |
| 2_F       | Tue       |
| 3_F       | Win       |
| 4_F       | Thu       |
| 5_F       | Fri       |
| 6_F       | Sat       |
表53
| Number 值 | Name 名称 |
| +0_F      | Jan       |
| 1_F       | Feb       |
| 2_F       | Mar       |
| 3_F       | Apr       |
| 4_F       | May       |
| 5_F       | Jun       |
| 6_F       | Jul       |
| 7_F       | Aug       |
| 8_F       | Sep       |
| 9_F       | Oct       |
| 10_F      | Nov       |
| 11_F      | Dec       |
***** TimeZoneString( tv )
抽象操作TimeZoneString接受参数tv。被调用时执行下列步骤：
1. Assert：Type(tv)是Number
2. Assert：tv不是NaN
3. 让offset是LocalTZA(tv, true)
4. 如果offset >= +0_F，那么
    a. 让offsetSign是"+"
    b. 让absOffset是offset
5. 否则
    a. 让offsetSign是"-"
    b. 让absOffset是-offset   
6. 让offsetMin是MinFromTime(absOffset)的字符串表示，两位10进制数形式，
   左侧补0（DIGIT ZERO 0x0030）
7. 让offsetHour是HourFromTime(absOffset)的字符串表示，两位10进制数形式，
   左侧补0（DIGIT ZERO 0x0030）
8. 让tzName是实现定义的字符串，要么是空字符串，要么是编码单元0x0020（SPACE）
   编码单元0x0028（LEFT PARENTHESIS） 实现定义的时区名称
   编码单元0x0029（RIGHT PARENTHESIS）的字符串拼接
9. 返回 offsetSign offsetHour offsetMin和tzName的字符串拼接
***** ToDateString( tv )
抽象操作ToDateString接受参数tv。被调用时执行下列步骤：
1. Assert：Type(tv)是Number
2. 如果tv是NaN，返回"Invalid Date"
3. 让t是LocalTime(tv)
4. 返回 DateString(t) 编码单元0x0020（SPACE） TimeString(t)和TimeZoneString(tv)的
   字符串拼接
**** Date.prototype.toTimeString()
被调用时执行下列步骤：
1. 让O是thisDate对象
2. 让tv是?thisTimeValue(O)
3. 如果tv是NaN，返回"Invalid Date"
4. 让t是LocalTime(tv)
5. 返回TimeString(t)和TimeZoneString(tv)字符串拼接
**** Date.prototype.toUTCString()
toUTCString方法返回表示this时间值时刻的字符串。字符串格式是基于RFC 7231的
"HTTP-date"表述，全面支持ECMAScript Date对象。被调用时执行下列步骤：
1. 让O是thisDate对象
2. 让tv是?thisTimeValue(O)
3. 如果tv是NaN，返回"Invalid Date"
4. 让weekday是WeekDay(tv)的Number值在表52中映射的名称
5. 让month是MonthFromTime(tv)的Number值在表53中映射的名称
6. 让day是DateFromTime(tv)的字符串表示，两位10进制数形式，
   左侧补0（DIGIT ZERO 0x0030）
7. 让yv是YearFromTime(tv)
8. 如果yv >= +0_F，让yearSign是空字符串，否则让yearSign是"-"
9. 让year是abs(R(yv))的十进制字符串表示
10. 让paddedYear是!StringPad(year, 4_F, "0", start)
11. 返回weekday "," 编码单元0x0020（SPACE）day 编码单元0x0020（SPACE） month
    编码单元0x0020（SPACE） yearSign paddedYear 编码单元0x0020（SPACE）
    和TimeString(tv)的字符串拼接。
**** Date.prototype.valueOf()
被调用时执行下列步骤：
1. 返回?thisTimeValue(this值）
**** Date.prototype[@@toPrimitive]( hint )
本方法用于ECMAScript语言将Date对象转换为基本值。hint允许的值有"default"、
"number"或者"string"。在ECMAScript语言内建对象里，唯有Date对象将"default"当作
"string"对待，其他内建对象都是将"default"当作"number"对待。

当@@toPrimitive方法被带参数hint调用时，执行下列步骤：
1. 让O是this值
2. 如果Type(O)不是Object，投掷TypeError异常
3. 如果hint是"string"或者"default"，那么
    a. 让tryFirst是string
4. 否则，如果hint是"number"，那么
    a. 让tryFirst是number
5. 否则 投掷TypeError异常
6. 返回?OrdinaryToPrimitive(O, tryFirst)

本方法的"name"性质值是"[Symbol.toPrimitive]"

本性质的属性是{ \[\[Writable]]:false, \[\[Enumerable]]:false,
\[\[Configurable]]:true }
*** Properties of Date Instances
Date实例都是基本对象，继承Date原型对象的性质。Date实例都有\[\[DateValue]]内部
占位。\[\[DateValue]]内部占位是表述this Date对象的时间值。
* Text Processing
** String Objects
*** The String Constructor
String构造范
. 是%String%
. 是全局对象"String"性质的初始值。
. 作为构造范调用时，返回新的String对象
. 作为函数而不是构造范调用时，执行类型转换
. 被设计成可继承。也就是说可以用在定义class时的extends语句里。子类的构造范
  如果要继承String的特定行为，必须含有super调用，以使用String构造范创建和初
  始化一个拥有\[\[StringData]]内部占位的子类实例。
**** String( value )
当String被带参数value调用是，执行下列步骤：
1. 如果value不存在，让s是空字符串
2. 否则
    a. 如果NewTarget是undefined，而且Type(value)是Symbol，返回
       SymbolDescriptiveString(value)
    b. 让s是?ToString(value)
3. 如果NewTarget是undefined，返回s
4. 返回!StringCreate(s, ?GetPrototypeFromConstructor(NewTarget, "%String.prototype%"))
*** Properties of the String Constructor
String构造范
. 有\[\[Prototype]]内部占位，值是%Function.prototype%
. 有如下性质：
**** String.fromCharCode( ...codeUnits )
String.fromCharCode函数可以被带任意数量的参数调用，参数形式为剩余参
数codeUnit。被调用时执行下列步骤：
1. 让length是codeUnits里元素的数量
2. 让elements是新的空列表
3. 遍历codeUnits的元素记作next，做
    a. 让nextCU是R(?ToUnit16(next))
    b. 附件nextCU到elements的末端
4. 返回以elements元素为编码单元的字符串。如果codeUnits是空的，返回空字符串。

fromCharCode函数的"length"性质的值是1_F。
**** String.fromCodePoint( ...codePoints )
String.fromCharPoint函数可以被带任意数量的参数调用，参数形式为剩余参
数codePoints。被调用时执行下列步骤：
1. 让result是空字符串
2. 遍历codePoints的元素记作next，做
    a. 让nextCP是?ToNumber(next)
    b. 如果!IsIntegerNumber(nextCP)是false，投掷RangeError异常
    c. 如果R(nextCP) < 0或者R(nextCP)>0x10FFFF，投掷RangeError异常
    d. 置s是 s !UTF16EncodeCodePoint(R(nextCP))的字符串拼接
3. Assert：如果codePoints是空，那么result是空字符串
4. 返回result

fromCharPoint函数的"length"性质的值是1_F。
**** String.prototype
String.prototype的初始值是String原型对象

此性质的属性是{ \[\[Writable]]:false, \[\[Enumerable]]:false,
\[\[Configurable]]:false, }
**** String.raw( template, ...substitutions )
String.raw函数可以被带若干参数调用。第一个参数是template，剩余的参数组成列表
substitutions。被调用时执行下列步骤：
1. 让numberOfSubstitutions是substitutions的数量
2. 让cooked是?ToObject(template)
3. 让raw是?ToObject(?Get(cooked, "raw"))
4. 让literalSegments是?LengthOfArrayLike(raw)
5. 如果literalSegments <= 0，返回空字符串
6. 让stringElements是新的空List
7. 让nextIndex是0
8. 重复
    a. 让nextKey是!ToString(F(nextIndex))
    b. 让nextSeg是?ToString(?Get(raw, nextKey))
    c. 追加nextSeg的编码单元到stringElements的末端
    d. 如果nextIndex+1 == literalSegments，那么
        i. 返回stringElements元素为编码单元组成的字符串。如果stringElements没有
           元素，返回空字符串。
    e. 如果nextIndex < numberOfSubstitutions，让next是substitutions[nextIndex]
    f. 否则，让next是空字符串
    g. 让nextSub是?ToString(next)
    h. 追加nextSub的编码单元到stringElements的末端
    i. 让nextIndex是nextIndex + 1
***** 注意 试图用raw函数作为Tagged Templated（13.3.11）的标记函数。那时，第一个
            参数是正确形式的模板对象，剩余参数保持替换对象的值。
*** Properties of the String Proptotype Object
String原型对象：
. 是%String.prototype%
. 是String奇异对象，有特定的内部方法。
. 有\[\[StringData]]内部占位，值是空字符串
. 有"length"性质，初始值是+0_F，属性是{ \[\[Writable]]:false,
  \[\[Enumerable]]:false, \[\[Configurable]]:false, }。
. 有\[\[Prototype]]内部占位，值是%Object.prototype%

除非另有显式定义，下方定义的String原型对象上的方法都不是泛型的，传递它们
的this值必须是String值或者是有\[\[StringData]]内部占位，并初始化了String值的对
象。

抽象操作thisStringValue接受参数value。被调用时执行下列步骤：
1. 如果Type(value)是String，返回value
2. 如果Type(value)是Object，而且value有\[\[StringData]]内部占位，那么
    a. 让s是value.\[\[StringData]]
    b. Assert：Type(s)是String
    c. 返回s
3. 投掷TypeError异常
**** String.prototype.charAt( pos )
***** 注意1 返回只有一个元素的字符串，值是在this值转换出的String值
                        post位置的编码单元的值。如果pos处没有元素，结果就是空
                        字符串。结果是String值，不是String对象。

                        如果pos是整数Number，那么x.charAt(pos)的结果与
                        x.substring(pos, pos+1)的结果相等。

当charAt是被带参数pos调用时，执行下列步骤：
1. 让O是?RequrieObjectCoercible(this值）
2. 让S是?ToString(O)
3. 让position是?ToInetegerOrInfinity(pos)
4. 让size是S的length
5. 如果position < 0或者position >= size，返回空字符串
6. 返回String值，长度为1，含有S的一个编码单元，也就是position处的编码单元。
***** 注意2 chartAt函数试图支持泛型，不要求this值是String对象。
                        因此可以被传递给任意对象，作为其的方法。
**** String.prototype.charCodeAt( pos )
***** 注意1 返回Number值（小于2^16的非负整数），值是在this值转换出
                        的String值pos位置的编码单元的值。如果pos处没有元素，
                        结果就是NaN。

当charCodeAt是被带参数pos调用时，执行下列步骤：
1. 让O是?RequrieObjectCoercible(this值）
2. 让S是?ToString(O)
3. 让position是?ToInetegerOrInfinity(pos)
4. 让size是S的length
5. 如果position < 0或者position >= size，返回NaN
6. 返回表示String S在position处编码单元数值的Number值。
***** 注意2 chartCodeAt函数试图支持泛型，不要求this值是String对象。
                        因此可以被传递给任意对象，作为其的方法。
**** String.prototype.codePointAt( pos )
***** 注意1 返回不大于0x10FFFF的非负整数Number，值是在this值转换出
                        的String值以pos开始的编码点按UTF-16编码（6.1.4）的编码
                        点值。如果pos处没有元素，结果就是undefined。如果pos位置
                        不是有效UTF-16的替代对，结果就是pos处的编码单元的值。

当codePointAt是被带参数pos调用时，执行下列步骤：
1. 让O是?RequrieObjectCoercible(this值）
2. 让S是?ToString(O)
3. 让position是?ToInetegerOrInfinity(pos)
4. 让size是S的length
5. 如果position < 0或者position >= size，返回undefined
6. 让cp是!CodePointAt(S, position)
7. 返回F(cp.\[\[CodePoint]])
***** 注意2 codePointAt函数试图支持泛型，不要求this值是String对象。
                        因此可以被传递给任意对象，作为其的方法。
**** String.prototype.concat( ...args )
***** 注意1 返回只有一个元素的字符串，值是在this值转换出的String值
                        的编码单元跟随每个参数转换为String值的编码单元。结果
                        是String值，不是String对象。

当concat是被带可数参数args调用时，执行下列步骤：
1. 让O是?RequrieObjectCoercible(this值）
2. 让S是?ToString(O)
3. 让R是S
4. 遍历args的元素，记作next，做
    a. 让nextString是?ToString(next)
    b. 置R是R和nextString的字符串拼接
5. 返回R
***** 注意2 chartAt函数试图支持泛型，不要求this值是String对象。
                        因此可以被传递给任意对象，作为其的方法。
**** String.prototype.constructor
String.prototype.constructor的初始值是%String%
**** String.prototype.endsWith( searchString [, endPoint ] )
被调用时执行下列步骤：
1. 让O是?RequrieObjectCoercible(this值）
2. 让S是?ToString(O)
3. 让isRegExp是?isRegExp(searchString)
4. 如果isRegExp是true，投掷TypeError异常
5. 让searchStr是?ToString(searchString)
6. 让len是S的长度
7. 如果endPosition是undefined，让pos是len，否则让pos是?ToIntegerOrInfinity(endPosition)
8. 让end是将pos局限在0与len间的结果。
9. 让searcLength是searchStr的长度
10. 如果searchLength==0，返会true
11. 让start是end-searchLength
12. 如果start<0，返回false
13. 让substring是S上从start到end的子字符串
14. 返回!SameValueNonNumeric(substring, searchStr)
***** 注意1 当searchString转换出的String与this对象转换为String后从endPosition - length(this)
                      开始每个编码单元都依次相同，返回true。其他返回false。
***** 注意2 如果第一个参数是正则表达式，投掷异常，以便将来的版本允许定义相应参数的扩展。
***** 注意3 endsWith函数试图是泛型的；不需要this值是String对象，因此他可以被传递给其他兑现作为方法。
**** String.prototype.includes( searchString [, position ] )
includes方法接受searchString和postion两个参数，被调用时执行下列步骤：
1. 让O是?RequrieObjectCoercible(this值）
2. 让S是?ToString(O)
3. 让isRegExp是?isRegExp(searchString)
4. 如果isRegExp是true，投掷TypeError异常
5. 让searchStr是?ToString(searchString)
6. 让pos是?ToIntegerOInfinity(position)
7. Assert：如果position是undefined，那么pos是0
8. 让len是S的长度
9. 让start是将pos局限在0和len间的结果
10. 让index是!StringIndexOf(S, searchStr, start)
11. 如果index不是-1，返回true
12. 返回false
***** 注意1 当searchString转换出的String作为this对象转换为String的某个子字符串，有一个或者多个索引
                      大于等于position，返回true；否则返回false。如果position是undefined，假设为0，搜索全部
                      字符串
***** 注意2 如果第一个参数是正则表达式，投掷异常，以便将来的版本允许定义相应参数的扩展。
***** 注意3 includes函数试图是泛型的；不需要this值是String对象，因此他可以被传递给其他对象作为方法。
**** String.prototype.indexOf( searchString [, position ] )
***** 注意1 当searchString转换出的String作为this对象转换为String的某个子字符串，有一个或者多个索引
                      大于等于position，返回其中最小的索引；否则返回-1_F。如果position是undefined，假设为+0_F，
                      搜索全部字符串

当indexOf是被带参数searchString和position调用时，执行下列步骤：
1. 让O是?RequrieObjectCoercible(this值）
2. 让S是?ToString(O)
3. 让searchStr是?ToString(searchString)
4. 让pos是?ToIntegerOrInfinity(position)
5. Assert：如果position是undefined，那么pos是0
6. 让len是S的长度
7. 让start是将pos局限在0和len间的结果
8. 返回F(!StringIndexOf(S, searchStr, start))
***** 注意2 indexOf函数试图支持泛型，不要求this值是String对象。 因此可以被传递给任意对象，作为其的方法。
**** String.prototype.lastIndexOf( searchString [, position ] )
***** 注意1 当searchString转换出的String作为this对象转换为String的某个子字符串，有一个或者多个索引
                      小于等于position，返回其中最大的索引；否则返回-1_F。如果position是undefined，假设为
                      字符串的长度，搜索全部字符串

当lastIndexOf是被带参数searchString和position调用时，执行下列步骤：
1. 让O是?RequrieObjectCoercible(this值）
2. 让S是?ToString(O)
3. 让searchStr是?ToString(searchString)
4. 让numPos是?ToNumber(position)
5. Assert：如果position是undefined，那么pos是NaN
6. 如果numPos是NaN，让pos是+∞，否则让pos是!ToIntegerOrInfinity(numPos)
7. 让len是S的长度
8. 让start是将pos局限在0和len间的结果
9. 让searchLen是searchStr的长度
10. 让k是不大于start的最大的非负整数，满足：k+searchLen <= len，且属于[0, searchLen)的每个整数有S上k+j的编码单元
    与searchStr的j处编码单元相同；如果不存在，让k是-1。
11. 返回F(k)
***** 注意2 lastIndexOf函数试图支持泛型，不要求this值是String对象。 因此他可以被传递给任意对象作为方法。
**** String.prototype.localeCompare( that [, reserved1 [, reserved2 ]] )
包含ECMA-402国际API的ECMAScript实现必须按照ECMA-402规范的规定来实现
localeCompare方法。如果没有包含ECMA-402的API，按照随后的规范
实现localeCompare方法。

当localeCompare方法被带that参数调用时返回不是NaN的Number，表示this值（转换为String）与that（转换为String）的
本地敏感的字符串比较。两个字符串S和That。按照实现定义的方式比较。结果被试图用于排序字符串值，按照主机默认本地的规定
进行排序，可能是负数、0或者正数，依赖于按照排序规则，依次是S在That前，相等或者S在That后。

在执行比较之前，下发步骤先被执行来准备字符串：
1. 让O是?RequireObjectCoercilbe(this值)
2. 让S是?ToString(O)
3. 让That是?ToString(that)

这意味着本方法的可选参数定义在ECMA-402规范；不支持ECMA-402的实现不能将参数用做他途。

localeCompare方法，如果被看作是有两个参数this和that的函数的话，在所有的String上是一致的
比较函数（23.1.3.27）
**** String.prototype.match( regexp )
当match方法被带参数regexp调用时，执行下列步骤：
1. 让O是?RequireObjectCoercible(this值)
2. 如果regexp不是undefined或者null，那么
    a. 让matcher是?GetMethod(regexp, @@match)
    b. 如果matcher不是undefined，那么
        i. 返回?Call(matcher, regexp, << O >>)
3. 让S是?ToString(O)
4. 让rx是?RegExpCreate(regexp, undefined)
5. 返回?Invoke(rx, @@match, << S >>)
***** 注意 match函数试图支持泛型，不要求this值是String对象。
                        因此可以被传递给其他对象作为方法。
**** String.prototype.matchAll( regexp )
以正则表达式regexp去匹配this值表示的字符串。如果能匹配到，返回一个迭代器，
每次迭代结果的值是一个数组，含有匹配的结果。如果匹配不到，则返回null。

当matchAll被调用时，执行下列步骤：
1. 让O是?RequireObjectCoercible(this值)
2. 如果regexp不是undefined或者null，那么
    a. 让isRegExp是?IsRegExp(regexp)
    b. 如果isRegExp是true，那么
        i. 让flags是?Get(regExp, "flags")
       ii. 执行?RequireObjectCoercible(flags)
      iii. 如果?ToString(flags)没有"g"，投掷TypeError异常
    c. 让matcher是?GetMethod(regexp, @@matchAll)
    d. 如果matcher不是undefined，那么
        i. 返回?Call(matcher, regexp, << O >>)
3. 让S是?ToString(O)
4. 让rx是?RegExpCreate(regexp, "g")
5. 返回?Invoke(rx, @@matchAll, << S >>)
***** 注意1 matchAll函数试图支持泛型，不要求this值是String对象。
                        因此可以被传递给其他对象作为方法。
***** 注意2 类似String.prototype.split，String.prototype.matchAll被设计为
                         不修改传入的参数。
**** String.prototype.normalize( [ form ] )
当normalize方法被带可选参数form调用，执行下列步骤：
1. 让O是?RequireObjectCoercible(this值)
2. 让S是?ToString(O)
3. 如果form是undefined，让f是"NFC"
4. 否则，让f是?ToString(form)
5. 如果f不是"NFC"、"NFD"、"NFKC"或"NFKD"，投掷RangeError异常
6. 让ns是S按照f规范化的结果，遵循https://unicode.org/reports/tr15/ 规定
7. 返回ns
***** 注意1 normalize函数试图支持泛型，不要求this值是String对象。
                        因此可以被传递给其他对象作为方法。
**** String.prototype.padEnd( maxLength [, fillString ] )
当padEnd方法被调用时，执行下列步骤：
1. 让O是?RequireObjectCoercible(this值）
2. 返回?StringPad(O, maxLength, fillString, end)
**** String.prototype.padStart( maxLength [, fillString ] )
当padStart方法被调用时，执行下列步骤：
1. 让O是?RequireObjectCoercible(this值）
2. 返回?StringPad(O, maxLength, fillString, start)
***** StringPad(O, maxLength, fillString, placement)
抽象操作StringPad接受参数O、maxLength、fillString和placement。被调用时执行下列
步骤：
1. Assert：placement是start或者end
2. 让S是?ToString(O)
3. 让intMaxLength是R(?ToLength(maxLength))
4. 让stringLength是S的长度
5. 如果intMaxLength <= stringLength，返回S
6. 如果fillString是undefined，让filler是只一个有0x0020（SPACE）的字符串
7. 否则，让filler是?ToString(fillString)
8. 如果filler是空字符串，返回S。
9. 让fillLen是intMaxLength - stringLength
10. 让truncateStringFill是重复filler的字符串拼接按照fillLen节取的子字符串。
11. 如果placement是start，返回truncateStringFill和S的字符串拼接
12. 返回S和truncateStringFill的字符串拼接。
****** 注意1 参数maxLength被处理为不小于S的长度
****** 注意2 参数fillString默认是" "（只含有一个编码单元0x0020 SPACE
                         的字符串）
**** String.prototype.repeat( count )
被带调用时执行下列步骤：
1. 让O是?RequrieObjectCoercible(this值）
2. 让S是?ToString(O)
3. 让n是?ToIntegerOrInfinity(count)
4. 如果n < 0 或者 n是+∞，投掷RangeError异常
5. 如果n是0，返回空字符串
6. 返回n个S拼接在一起的字符串
***** 注意2 本方法创建的String值含有count个this值转换出的String值
***** 注意1 repeat函数试图支持泛型，不要求this值是String对象。
                        因此可以被传递给其他对象作为方法。
**** String.prototype.replace( searchValue, replaceValue )
当replace方法被带参数searchValue和replaceValue调用时，执行下列步骤：
1. 让O是?RequireObjectCoercible(this值)
2. 如果searchValue不是undefined或者null，那么
    a. 让replacer是?GetMethod(searchValue, @@replace)
    b. 如果replacer不是undefined，那么
        i. 返回?Call(replacer, searchValue, << O, replaceValue >>)
3. 让string是?ToString(O)
4. 让searchString是?ToString(searchValue)
5. 让functionalReplce是IsCallable(repalceValue)
6. 如果functionalReplace是false，那么
    a. 置replaceValue是?ToString(replaceValue)
7. 让searchLength是searchString的长度
8. 让position是!StringIndexOf(string, searchString, 0)
9. 如果position是-1，返回string
10. 让preserved是string从0到position的子字符串
11. 如果functionalReplace是true，那么
    a. 让replacement是?ToString(?Call(replaceValue, undefined, << searchString,
       F(psoition), string >>))
12. 否则
    a. Assert：Type(replaceValue)是String
    b. 让capture是新的空列表
    c. 让replacement是!GetSubstitution(searchString, string, position, capture,
       undefined, replaceValue)
13. 返回preserved、replacement、string在psotion+searchLength及之后的子字符串的
    字符串拼接
***** 注意 replace函数试图支持泛型，不要求this值是String对象。因此可以被
            传递给其他对象作为方法。
***** GetSubstitution(matched, str, position, captures, namedCaptures, replacement)
抽象操作GetSubstitution接受参数matched、str、position(非负整数）、captrues、
namedCaptrues和replacement。被调用时执行下列步骤：
1. Assert：Type(matched)是String
2. 让matchLength是matched的编码单元数量
3. Assert：Type(str)是String
4. 让stringLength是str的编码单元数量
5. Assert：position <= stringLength
6. Assert：captures是可能空的String列表
7. Assert：Type(replacement)是String
8. 让tailPos是position + matchLength
9. 让m是captures的元素数量
10. 让result是通过从replacement的编码单元根据表54替换后的结果派生处的字符串。
    从左到右替换$，一旦替换了，新生成的替换文本不再参与替换。
11. 返回result

表54
| 编码单元                         | Unicode字符                                   | 替换文本                                                                                                                                     |
| 0x0024,0x0024                    | $$                                            | $                                                                                                                                            |
| 0x0024,0x0026                    | $&                                            | matched                                                                                                                                      |
| 0x0024,0x0060                    | $`                                            | str从0到position的子字符串                                                                                                                   |
| 0x0024,0x0027                    | $'                                            | 如果tailPos >= stringLength，空字符串。否则是str从tailPos及之后的子字符串                                                                    |
| 0x0024,N 其中0x0031<=N<=0x0039   | $n,其中n是1 2 3 4 5 6 7 8 9，而且$n后不是数字 | captures的第n个元素，n是1到9的数字。如果n<=m，而且captures第n个元素是undefined，使用空字符串。如果n>m，不替换。                              |
| 0x0024,N,N 其中0x0030<=N<=0x0039 | $nn,其中n是0 1 2 3 4 5 6 7 8 9                | captures的第nn个元素，nn是两位十进制数字，从01到99。如果nn<=m，而且captures第nn个元素是undefined，使用空字符串。如果nn是00或者nn>m，不替换。 |
| 0x0024,0x003C                    | $<                                            | 1. 如果namedCaptures是undefined，替换文本是"$<"                                                                                              |
|                                  |                                               | 2.否则                                                                                                                                       |
|                                  |                                               | a. Assert：Type(namedCaptrues)是Object                                                                                                       |
|                                  |                                               | b. 扫描到下一个> U+003E（GREATER-THAN SIGN）                                                                                                 |
|                                  |                                               | c. 如果没有找到，使用"$<"                                                                                                                    |
|                                  |                                               | d. 否则：                                                                                                                                    |
|                                  |                                               | i. 让groupName是$<和>包含的子字符串                                                                                                          |
|                                  |                                               | ii. 让capture是?Get(nameCaptures, groupName)                                                                                                 |
|                                  |                                               | iii. 如果capture是undefined，用空字符串替换直到>处的文本                                                                                     |
|                                  |                                               | iv. 否则用?ToString(capture)替换直到>处的文本，                                                                                              |
| 0x0024                           | 不是上述内容背景下的$                         | $                                                                                                                                            |
**** String.prototype.replaceAll( searchValue, replaceValue )
当replaceAll方法被带参数searchValue和replaceValue调用是，执行下列步骤：
1. 让O是?RequireObjectCoercible(this值)
2. 如果searchValue不是undefined和null，那么
    a. 让isRegExp是?IsRegExp(searchValue)
    b. 如果isRegExp是true，那么
        i. 让flags是?Get(regExp, "flags")
       ii. 执行?RequireObjectCoercible(flags)
      iii. 如果?ToString(flags)没有"g"，投掷TypeError异常
    c. 让replacer是?GetMethod(regexp, @@replace)
    d. 如果replacer不是undefined，那么
        i. 返回?Call(replacer, searchValue, << O, replaceValue >>)
3. 让string是?ToString(O)
4. 让searchString是?ToString(searchValue)
5. 让functionalReplace是IsCallable(replaceValue)
6. 如果functionalReplace是false，那么
    a. 置replaceValue是?ToString(replaceValue)
7. 让searchLength是searchString的长度
8. 让advanceBy是max(1, searchLength)
9. 让matchPositions是新的空列表
10. 让position是!StringIndexOf(string, searchString, 0)
11. 当position不是-1时，重复
    a. 追加position到matchPositions的末端
    b. 置position是!StringIndexOf(string, searchString, position + advanceBy)
12. 让endOfLastMatch是0
13. 让result是空字符串
14. 遍历matchedPositions的元素，记作p，做
    a. 让preserved是string上从endOfLastMatch到p的子字符串
    b. 如果functionalReplace是true，那么
        i. 让replacement是?ToString(?Call(replaceValue, undefined, << searchString,
           F(p), string >> ))
    c. 否则
        i. Assert：Type(replaceValue)是String
       ii. 让captures是空的新列表
      iii. 让repalcement是!GetSubstitution(searchString, string, p, captures,
           undefined, repalceValue)
    d. 置result是result preserved和replacement的字符串拼接
    e. 置endOfLastMatch是p + searchLength
15. 如果endOfLastMatch < string的长度，那么
    a. 置result是，result、string上从endOfLastMatch的子字符串，的字符串拼接
16. 返回result
**** String.prototype.search( regexp )
当search被带regexp参数调用时，执行下列步骤：
1. 让O是?RequireObjectCoercible(this值）
2. 如果regexp不是undefined和null，那么
    a. 让searcher是?GetMethod(regexp, @@search)
    b. 如果searcher不是undefined，那么
        i. 返回?Call(searcher, regexp, << O >>)
3. 让string是?ToString(O)
4. 让rx是?RegExpCreate(regexp, undefined)
5. 返回?Invoke(rx, @@search, << string >>)
***** 注意 search函数试图支持泛型，不要求this值是String对象。因此可以被
            传递给其他对象作为方法。
**** String.prototype.slice( start, end )
slice方法接受参数start和end，返回this值转换成String值上[start,end)内的子字符
串（如果end是undefined，则到String的末端）。设sourceLength是this值转换成String
时的长度。如果start是负数，被当作sourceLength + start。如果end是负数，被当
作sourceLength + end。结果是String值，不是String对象。被调用时执行下列步骤：
1. 让O是?RequireObjectCoercible(this值)
2. 让S是?ToString(O)
3. 让len是S的长度
4. 让intStart是?ToIntegerOrInfinity(start)
5. 如果intStart是-∞，让from是0
6. 否则如果intStart < 0，让from是max(len + intStart, 0)
7. 否则，让from是min(intStart, len)
8. 如果end是undefined，让intEnd是len；否则让intEnd是?ToIntegerOrInfinity(end)
9. 如果intEnd是-∞，让to是0
10. 否则如果intEnd < 0，让to是max(len + intEnd, 0)
11. 否则，让to是min(intEnd, len)
12. 如果from >= to，返回空字符串
13. 返回S上[from, to)的子字符串
***** 注意 slice函数试图支持泛型，不要求this值是String对象。因此可以被
            传递给其他对象作为方法。
**** String.prototype.split( seperator, limit )
返回Array对象，里面是从this值转换为String值的子字符串。子字符串是从左到
右寻找separator，匹配到的部分不返回，而是用于拆分String值。seperator可以是
任意长度的字符串，或者其他有@@split方法的对象。

当split方法被调用时，执行下列步骤：
1. 让O是?RequireObjectCoercible(this值)
2. 如果seperator不是undefined和null，那么
    a. 让splitter是?GetMethod(seperator, @@split)
    b. 如果splitter不是undefined，那么
        i. 返回?Call(splitter, seperator, << O, limit >>)
3. 让S是?ToString(O)
4. 让A是!ArrayCreate(0)
5. 让lengthA是0
6. 如果limit是undefined，让lim是2^32 -1，否则让lim是R(?ToUint32(limit))
7. 让R是?ToString(seperator)
8. 如果lim == 0，返回A
9. 如果sperator是undefined，那么
    a. 执行!CreateDataPropertyOrThrow(A, "0", S)
    b. 返回A
10. 让s是S的长度
11. 如果s==0，那么
    a. 如果R不是空字符串，那么
        i. 执行!CreateDataPropertyOrThrow(A, "0", S)
    b. 返回A
12. 让p是0
13. 让q是p
14. 重复，当q != s时
    a. 让e时SplitMatch(S, q, R)
    b. 如果e时not-matched，置q是q+1
    c. 否则
        i. Assert：e是非负整数，且e <= s
       ii. 如果e == p，置q是q+1
      iii. 否则
            1. 让T是S上[p,q)的子字符串
            2. 执行!CreateDataPropertyOrThrow(A, !ToString(F(lengthA)), T)
            3. 置length是lengthA+1
            4. 如果lengthA == lim, 返回A
            5. 置p是e
            6. 置q是p
15. 让T是S上[p,s)的子字符串
16. 执行!CreateDataPropertyOrThrow(A, !ToString(F(lengthA)), T)
17. 返回A
***** 注意1 seperator的值可能是空字符串。seperator不会去匹配在开始或者末尾
             处的空字符串，也不会去匹配上次匹配末尾的空字符串。如果
             seperator是空字符串，String会被按照编码单元拆分成数组；数组的
             长度等于String的长度，每个子字符串含有一个编码单元。

             如果this值是（或者转换为）空字符串，结果依赖于seperator能否
             匹配空字符串。如果能，结果是空数组，否则结果是含有一个空
             字符串的数组。

             如果seperator是undefined，那么结果是含有this值转换为String的数组。
             如果limit不是undefined，输出数组元素数量不会超过limit。
***** 注意2 split函数试图支持泛型，不要求this值是String对象。因此可以被
            传递给其他对象作为方法。
***** SplitMatch(S, q, R)
抽象操作SplitMatch接受参数S（String）、q（非负整数）和R（String）。返回
not-matched或者匹配的末端索引。被调用时执行下列步骤：
1. 让r是R的编码单元数量
2. 让s是S的编码单元数量
3. 如果q + r > s，返回not-matched
4. 如果有整数i在[0,r)之间，在S上q+i位置的编码单元与R上i位置的编码单元
   不同，返回not-matched
5. 返回q + r
**** String.prototype.startsWith( searchString [, position ] )
被调用时执行下列步骤：
1. 让O是?RequrieObjectCoercible(this值）
2. 让S是?ToString(O)
3. 让isRegExp是?isRegExp(searchString)
4. 如果isRegExp是true，投掷TypeError异常
5. 让searchStr是?ToString(searchString)
6. 让len是S的长度
7. 如果position是undefined，让pos是0，否则让pos是?ToIntegerOrInfinity(position)
8. 让start是将pos局限在0与len间的结果。
9. 让searcLength是searchStr的长度
10. 如果searchLength==0，返会true
11. 让end是start + searchLength
12. 如果end > len，返回false
13. 让substring是S上[start,end)的子字符串
14. 返回!SameValueNonNumeric(substring, searchStr)
***** 注意1 当searchString转换出的String与this对象转换为String后从position
                      开始每个编码单元都依次相同，返回true。其他返回false。
***** 注意2 如果第一个参数是正则表达式，投掷异常，以便将来的版本允许定义相应参数的扩展。
***** 注意3 startsWith函数试图是泛型的；不需要this值是String对象，因此他可以被传递给其他兑现作为方法。
**** String.prototype.substring( start, end )
substring接受参数start和end，返回this值转换为String后上[start,end)的子字符串。
结果是String值，不是String对象。

如果某个参数是NaN或者负数，替换为0；如果参数大于String的长度，替换为String的
长度。

如果start比end大，则互换。

被调用时执行下列步骤:
1. 让O是?RequrieObjectCoercible(this值）
2. 让S是?ToString(O)
3. 让len是S的长度
4. 让intStart是?ToIntegerOrInfinity(start)
5. 如果end是undefined，让intEnd是len；否则让intEnd是?ToIntegerOrInfinity(end)
6. 让finalStart是将intStart局限在0与len间的结果。
7. 让finalEnd是将intEnd局限在0与len间的结果。
8. 让from是min(finalStart, finalEnd)
9. 让to是max(finalStart, finalEnd)
10. 让end是start + searchLength
11. 返回S上[from,to)的子字符串
***** 注意 substring函数试图是泛型的；不需要this值是String对象，因此他可以被传递给其他兑现作为方法。
**** String.prototype.toLocaleLowerCase( [ reserved1 [, reserved2 ]] )
包含ECMA-402国际API的ECMAScript实现必须按照ECMA-402规范的规定来实现
toLocaleLowerCase方法。如果没有包含ECMA-402的API，按照随后的规范
实现toLocaleLowerCase方法。

本函数按照6.1.4里的描述将String翻译成UTF-16编码点再处理。

本函数除了结果试图按照主机环境所在地修正，而不是与所在地无关，之外，其他
环节与toLowerCase严格一致。也就是在小写的时候，根据语言不同（比如土耳其
语），使用不同的Unicode映射。

这意味着本方法的可选参数定义在ECMA-402规范；不支持ECMA-402的实现不能将参数用
做他途。
***** 注意 toLocaleLowerCase函数试图是泛型的；不需要this值是String对象，因此他可以被传递给其他兑现作为方法。
**** String.prototype.toLocaleUpperCase( [ reserved1 [, reserved2 ]] )
包含ECMA-402国际API的ECMAScript实现必须按照ECMA-402规范的规定来实现
toLocaseUppserCase方法。如果没有包含ECMA-402的API，按照随后的规范
实现toLocaleUpperCase方法。

本函数按照6.1.4里的描述将String翻译成UTF-16编码点再处理。

本函数除了结果试图按照主机环境所在地修正，而不是与所在地无关，之外，其他
环节与toUpperCase严格一致。也就是在大写的时候，根据语言不同（比如土耳其
语），使用不同的Unicode映射。

这意味着本方法的可选参数定义在ECMA-402规范；不支持ECMA-402的实现不能将参数用
做他途。
***** 注意 toLocaleUpperCase函数试图是泛型的；不需要this值是String对象，因此他可以被传递给其他兑现作为方法。
**** String.prototype.toLowerCase( )
本函数按照6.1.4里的描述将String翻译成UTF-16编码点再处理。被调用时执行下列
步骤：
1. 让O是?RequireObjectCoercible(this值)
2. 让S是?ToString(O)
3. 让sText是!StringToCodePoints(S)
4. 让lowerText是toLowercase(sText)，依据Unicode默认的大小写转换算法。
5. 让L是!CodePointsToString(lowerText)
6. 返回L

结果必须是根据Unicode字符库（Unicode字符库不仅明确包含UnicodeData.txt文件，
还包括全部本地敏感的映射文件SpecialCasings.txt）里本地无关的字符映射派生的。
***** 注意1 有些字符的映射会产生多个编码点。在这里结果String跟源String的长度
             不必相同。因为toUpperCase和toLowerCase都是背景敏感的行为，函数不
             是对陈的。换句话说s.toUpperCase().toLowerCase()不必与s.toLowerCase()
             相等。
***** 注意2 toLowerCase函数试图支持泛型，不要求this值是String对象。因此可以被传递给
             其他对象作为方法。
**** String.prototype.toString( )
当toString方法被调用时，执行下列步骤：
1. 返回?thisStringValue(this值)
***** 注意 String对象的toString方法与valueOf方法的结果相同。
**** String.prototype.toUpperCase( )
本函数按照6.1.4里的描述将String翻译成UTF-16编码点再处理。被调用时执行下列
步骤：

本函数除了映射使用Unicode默认大小写转换的toUpperCase算法外，其他环节行为与
String.prototype.toLowerCase严格相同。
***** 注意 toUpperCase函数试图支持泛型，不要求this值是String对象。因此可以被传递给
             其他对象作为方法。
**** String.prototype.trim( )
本函数按照6.1.4里的描述将String翻译成UTF-16编码点再处理。

被调用时执行下列步骤：
1. 让S是this值
2. 返回?TrimString(S, start+end)
***** 注意 trim函数试图支持泛型，不要求this值是String对象。因此可以被传递给
             其他对象作为方法。
***** TrimString(string, where)
抽象操作TrimString接受参数string和where。按照6.1.4里的描述将String翻译成
UTF-16编码点再处理。被调用时执行下列步骤：
1. 让str是?RequireObjectCoercible(string)
2. 让S是?ToString(str)
3. 如果where是start，让T是S去掉头部空白的字符串值副本
4. 否则如果where是end，让T是S去掉尾部空白的字符串值副本
5. 否则
    a. Assert：where是start+end
    b 让T是S去掉头尾空白的字符串值副本
6. 返回T

本定义里空白是WhiteSpace和LineTerminal的合集。在检测编码点是不是Unicode分类
"Space_Separator"（"Zs"）是，编码单元被按照6.1.4里的描述翻译成UTF-16编码点。
**** String.prototype.trimEnd( )
本函数按照6.1.4里的描述将String翻译成UTF-16编码点再处理。

被调用时执行下列步骤：
1. 让S是this值
2. 返回?TrimString(S, end)
***** 注意 trimEnd函数试图支持泛型，不要求this值是String对象。因此可以被传递给
             其他对象作为方法。
**** String.prototype.trimStart( )
本函数按照6.1.4里的描述将String翻译成UTF-16编码点再处理。

被调用时执行下列步骤：
1. 让S是this值
2. 返回?TrimString(S, start)
***** 注意 trimStart函数试图支持泛型，不要求this值是String对象。因此可以被传递给
             其他对象作为方法。
**** String.prototype.valueOf( )
当valueOf方法被调用时，执行下列步骤：
1. 返回?thisStringValue(this值)
**** String.prototype[@@iterator]( )
当@@iterator方法被调用时返回一个Iterator对象（27.1.1.2），它能遍历String值的
编码点，以String值形式返回每个编码点。被调用时执行下列步骤：
1. 让O是?RequireObjectCoercible(this值)
2. 让s是?ToString(O)
3. 让closure是新的捕获了s的无参数AbstractClosure。被调用时，执行下列步骤
    a. 让position是0
    b. 让len是s的长度
    c. 重复，当position < len
        i. 让cp是!CodePointAt(s, position)
       ii. 让nextIndex是position + cp.\[\[CodeUnitCount]]
      iii. 让resultString是s上[position, nextIndex)的子字符串
       iv. 置position是nextIndex
        v. 执行?Yield(resultString)
    d. 返回undefined
4. 返回!CreateIteratorFromClosure(closure, "%StringIteratorPrototype%",
   %StringIteratorPrototype%)

本方法的"name"性质值是"[Symbol.iterator]"
*** Properties of String Instances
String实例都是奇异对象，有特定的内部方法。String实例继承String原型对象的
性质。String实例有\[\[StringData]]内部占位。

String实例有"length"性质，和一套可枚举的整数索引性质。
**** length
这个String对象表示的String值的元素数量。

一旦String对象被初始化了，这个性质就不变了。属性是{ \[\[Writable]]:false,
\[\[Enumerable]]:false, \[\[Configurable]]:false }
*** String Iterator Objects
StringIterator是对象，表述特定String实例对象的特定遍历器。StringIterator对象
没有命名的构造范。StringIterator通过调用String实例对象的某些方法来创建。
**** The %StringIteratorPrototype% Object
%StringIteratorPrototype%对象：
. 性质被所有StringIterator对象继承
. 是基本对象
. 有\[\[Prototype]]内部占位，值是%IteratorPrototype%
. 有如下性质：
***** %StringIteratorPrototype%.next()
1. 返回?GeneratorResume(this值, empty, "%StringIteratorPrototype%")
***** %StringIteratorPrototype%[@@toStringTag]
@@toStringTag性质的初始值是"StringIterator"

本性质的属性是{ \[\[Writable]]:false, \[\[Enumerable]]:false,
\[\[Configurable]]:true }
** RegExp (Regular Expression) Objects
RegExp对象含有一个正则表达式和联结的标记。
*** 注意 正则表达式的形式和功能都是仿照Perl5编程语言的正则表达式的。
*** Patterns
RegExp构造范将随后的语法应用到输入的模式String。如果语法不能将这个String翻译
成Pattern的展开式，那就有错误。
**** Syntax
Pattern_[U, N] ::
    Disjunction_[?U, ?N]
Disjunction_[U, N] ::
    Alernative_[?U, ?N]
    Alernative_[?U, ?N] | Disjunction_[?U, ?N]
Alernative_[U, N] ::
    [empty]
    Alernative_[?U, ?N] Term_[?U, ?N]
Term_[U, N] ::
    Assertion_[?U, ?N]
    Atom_[?U, ?N]
    Attom_[?U, ?N] Quantifier
Assertion_[U, N] ::
    ^
    $
    \ b
    \ B
    ( ? = Disjunction_[?U, ?N] )
    ( ? ! Disjunction_[?U, ?N] )
    ( ? <= Disjunction_[?U, ?N] )
    ( ? <! Disjunction_[?U, ?N] )
Quantifier ::
    QuantifierPrefix
    QuantifierPrefix ?
QuantifierPrefix ::
    *
    \+
    ?
    { DecimalDigits_[~Sep] }
    { DecimalDigits_[~Sep] , }
    { DecimalDigits_[~Sep] , DecimalDigits_[~Sep] }
Atom_[U, N] ::
    PatternCharacter
    .
    \ AtomEscape_[?U, ?N]
    CharacterClass_[?U]
    ( GroupSpecifier_[?U, ?N] Disjunction_[?U, ?N] )
    ( ? : Disjunction_[?U, ?N] )
SyntaxCharacter :: one of
    ^ $ \ . * + ? ( ) [ ] { } |
PatternCharacter ::
    SourceCharacter不是SyntaxCharacter
AtomEscape_[U, N] ::
    DecimalEscape
    CharacterClassEscape_[?U]
    CharacterEscape_[?U]
    [+N] k GroupName_[?U]
CharacterEscape_[U] ::
    [empty]
    ControlEscape
    c ControlLetter
    0 [lookahead ∉ DecimalDigit]
    HexEscapedSequence
    RegExpUnicodeEscapeSequence_[?U]
    IdentityEscape_[?U]
ControlEscape :: one of
    f n r t v
ConrolLetter :: one of
    a b c d e f g h i j k l m n o p q r s t u v w x y z A B C D E F G H I J K L M N
    O P Q R S T U V W X Y Z
GroupSpecifier_[U] ::
    [empty]
    ? GroupName_[?U]
RegExpIdentifierName_[U] ::
    RegExpIdentifierStart_[?U]
    RegExpIdentifierName_[?U] RegExpIdentifierPart_[?U]
RegExpIdentifierStart_[U] ::
    UnicodeIDStart
    $
    \-
    \ RegExpUnicodeEscapeSequence_[+U]
    [~U] UnicodeLeadSurrogate UnicodeTailSurrogate
RegExpIdentifierPart_[U] ::
    UnicodeIDContinue
    $
    \ RegExpUnicodeEscapeSequence_[+U]
    [~U] UnicodeLeadSurrogate UnicodeTailSurrogate
    <ZWNJ>
    <ZWJ>
RegExpUnicodeEscapeSequence_[U] ::
    [empty]
    [~U] u HexLeadSurrogate \u HexTrailSurrogate
    [~U] u HexLeadSurrogate
    [~U] u HexTrailSurrogate
    [~U] u HexNonSurrogate
    [~U] u Hex4Digits
    [~U] u{ CodePoint }
UnicodeLeadSurrogate ::
    在0xD800到0xDBFF之间的任意Unicode编码点
UnicodeTailSurrogate ::
    在0xDC00到0xDFFF之间的任意Unicode编码点

每个\u HexTrailSurrogate，如果联结的u HexLeadSurrogate不明确，那么就联结到
最近的u HexLeadSurrogate，否则此u HexLeadSurrogate不会有\u HexTrailSurrogate

HexLeadSurrogate ::
    Hex4Digits 但须此Hex4Digits的MV在[0xD800, 0xDBFF]内
HexTrailSurrogate ::
    Hex4Digits 但须此Hex4Digits的MV在[0xDC00, 0xDFFF]内
HexNonSurrogate ::
    Hex4Digits 但须此Hex4Digits的MV不在[0xD800, 0xDFFF]内
IdentifyEscape_[U] ::
    [+U]SyntaxCharacter
    [+U]/
    [~U]SourceCharacter 但不是UnicodeIDContinue
DecimalEscape ::
    NonZeroDigit DecimalDigits_[~Sep]_opt [lookahead ∉ DecimalDigit]
CharacterClassEscape_[U] ::
    d
    D
    s
    S
    w
    W
    [+U]p{ UnicodePropertyValueExpression }
    [+U]P{ UnicodePropertyValueExpression }
UnicodePropertyValueExpression ::
    UnicodePropertyName = UnicodePropertyValue
    LoneUnicodePropertyNameOrValue
UnicodePropertyName ::
    UnicodePropertyNameCharacters
UnicodePropertyNameCharacters ::
    UnicodePropertyNameCharacter UnicodePropertyNameCharacters_opt
UnicodePropertyValue ::
    UnicodePropertyValueCharacters
LoneUnicodePropertyNameOrValue ::
    UnicodePropertyValueCharacters
UnicodePropertyValueCharacters ::
    UnicodePropertyValueCharacter UnicodePropertyValueCharacters_opt
UnicodePropertyValueCharacter::
    UnicodePropertyNameCharacter
    DecimalDigit
UnicodePropertyNameCharacter ::
    ControlLetter
    \-
CharacterClass_[U] ::
    [ [lookahead ≠ ^] ClassRanges_[?U] ]
    [ ^ ClassRanges_[?U] ]
ClassRanges_[U] ::
    [empty]
    NonemptyClassRanges_[?U]
NonemptyClassRanges_[U] ::
    ClassAtom_[?U]
    ClassAtom_[?U] NonemptyClassRangesNoDash_[?U]
    ClassAtom_[?U] \- CalssAtom_[?U] ClassRanges_[?U]
NonemptyClassRangesNoDash_[U] ::
    ClassAtom_[?U]
    ClassAtomNoDash_[?U] NonemptyClassRangesNoDash_[?U]
    ClassAtomNoDash_[?U] \- CalssAtom_[?U] ClassRanges_[?U]
ClassAtom_[U] ::
    \-
    ClassAtomNoDash_[?U]
ClassAtomNoDash_[U] ::
    SourceCharacter 但须不是 \ ] -
    \ ClassEscape_[?U]
ClassEscape_[U] ::
    b
    [+U]-
    CharacterClassEscape_[?U]
    CharacterEscape_[?U]
***** 注意 本节的一些码型在B.1.4提供了备选定义。    
**** Static Semantics: Early Errors
***** 注意 本节在B.1.4.1中有修复
Pattern :: Disjunction
. 如果NcapturingParens >= 2^32 -1，那么有SyntaxError
. 如果Pattern含有多个GroupSpecifier其包含RegExpIdentifierName有相同的
  CapturingGroupName，那么有SyntaxError

QuantifierPrefix :: { DecimalDigits , DecimalDigits }
. 如果第一个DecimalDigits的MV大于第二个DecimalDigits的MV，那么有SyntaxError

AtomEscape :: k GroupName
. 如果所在Pattern找不到GroupSpecifier，其包含的RegExpIdentifierName的
  CapturingGroupName与本码型GroupName的RegExpIdentifierName的CapturingGroupName相等，
  那么有SyntaxError
AtomEscape :: DecimalEscape
. 如果DecimalEscape的CapturingGroupNumber比NcapturingParens（22.2.2.1）大，那么有
  SyntaxError

NonemptyClassRanges :: ClassAtom - ClassAtom ClassRanges
. 如果第一个ClassAtom的IsCharacterClass是true，或者第二个ClassAtom的
  IsCharacterClass是true，那么是SyntaxError
. 如果第一个ClassAtom的IsCharacterClass是false，而且第二个ClassAtom的
  IsCharacterClass是false，但是第一个ClassAtom的CharacterValue大于第二个ClassAtom
  的CharacterValue，那么是SyntaxError

NonemptyClassRangesNoDash :: ClassAtomNoDash - ClassAtom ClassRanges
. 如果ClassAtomNoDash的IsCharacterClass是true，或者ClassAtom的IsCharacterClass
  是true，那么是SyntaxError
. 如果ClassAtomNoDash的IsCharacterClass是false，而且ClassAtom的IsCharacterClass
  是false，但是ClassAtomNoDash的CharacterValue大于ClassAtom的CharacterValue，那么
  是SyntaxError

RegExpIdentifierStart_[U] :: \ RegExpUnicodeEscapeSequence_[+U]
. 如果RegExpUnicodeEscapeSequence的CharacterValue不是"S" "_"或者不符合UnicodeIDStart
  文法码型，那么是SyntaxError

RegExpIdentifierStart_[U] :: UnicodeLeadSurrogate UnicodeTrailSurrogate
. 如果在UnicodeLeadSurrogate和UnicodeTrailSurrogate匹配的编码点上执行
  UTF16SurrogatePairToCodePoint的结果匹配不到UnicodeIDStart文法码型，那么是
  SyntaxError

RegExpIdentifierPart_[U] :: \ RegExpUnicodeEscapeSequence_[+U]
. 如果RegExpUnicodeEscapeSequence的CharacterValue不是"S"、"_"、<ZWNJ>、<ZWJ>或者不符
  合UnicodeIDContinue文法码型，那么是SyntaxError

RegExpIdentifierPart_[U] :: UnicodeLeadSurrogate UnicodeTrailSurrogate
. 如果在UnicodeLeadSurrogate和UnicodeTrailSurrogate匹配的编码点上执行
  UTF16SurrogatePairToCodePoint的结果匹配不到UnicodeIDContinue文法码型，那么是
  SyntaxError

UnicodePropertyValueExpression :: UnicodePropertyName = UnicodePropertyValue
. 如果UnicodePropertyName的源文本的Unicode编码点列表对应不到按照表56的
  "性质名称和别名"所列内容的编码点列表，那么是SyntaxError。
. 如果UnicodePropertyValue的源文本的Unicode编码点列表对应不到按照表58或表59根据
  UnicodePropertyName的源文本的Unicode性质或者性质别名对应在"性质值和别名"所列
  内容的编码点列表，那么是SyntaxError。

UnicodePropertyValueExpression :: LoneUnicodePropertyNameOrValue
. 如果LoneUnicodePropertyNameOrValue的源文本的Unicode编码点列表对应不到按照表58
  的"性质值和别名"所列内容的编码点列表，或者对应不到按照表57的"性质值和
  别名"所列内容的编码点列表，那么是SyntaxError。
**** Static Semantics: CapturingGroupNumber
***** 注意 本节在B.1.4.1进行了修正。
DecimalEscape :: NonZeroDigit
1. 返回NonZeroDigit的MV

DecimalEscape :: NonZeroDigit DecimalDigits
1. 让n是DecimalDigits的编码点数量
2. 返回((NonZeroDigit的MV)* 10^2 加上DecimalDigits的MV)

NonZeroDigit的MV、DecimalDigits的MV在12.8.3中进行了定义。   
**** Static Semantics: IsCharacterClass
***** 注意 本节在B.1.4.2进行了修正。
ClassAtom :: -
ClassAtomNoDash :: SourceCharacter 不是 \ ] -
ClassEscape :: b
ClassEscape :: -
ClassEscape :: CharacterEscape
1. 返回false

ClassEscape :: CharacterClassEscape
1. 返回true
**** Static Semantics: CharacterValue
***** 注意1 本节在B.1.4.3进行了修正。
ClassAtom :: -
1. 返回U+002D（HYPHEN-MINUS）编码点值

ClassAtomNoDash :: SourceCharacter 不是 \ ] -
1. 让ch是SourceCharacter匹配的编码点
2. 返回ch的编码点值
   
ClassEscape :: b
1. 返回U+0008（BACKSPACE）的编码点值

ClassEscape :: -
1. 返回U+002D（HYPHEN-MINUS）编码点值

ClassEscape :: ControlEscape
1. 根据表55返回对应的编码点值

表55
| ControlEscape | 编码点值 | 编码点 | Unicode名称           | 符号 |
| t             |        9 | U+0009 | CHARACTER TABULATION  | <HT> |
| n             |       10 | U+000A | LINE FEED（LF）       | <LF> |
| v             |       11 | U+000B | LINE TABULATION       | <VT> |
| f             |       12 | U+000C | FORM FEED（FF）       | <FF> |
| r             |       13 | U+000D | CARRIAGE RETURN（CR） | <CR> |

CharacterEscape :: c ControlLetter
1. 让ch是ControlLetter匹配的编码点
2. 让i是ch的编码点值
3. 返回i除以32的余数

CharacterEscape :: 0 [lookahead ∉ DecimalDigit]
1. 返回U+0000（NULL）的编码点值
***** 注意2 \0表示<NUL>字符，因此后面不能跟随数字。

CharacterEscape :: HexEscapeSequence
1. 返回HexEscapeSequence的MV

RegExpUnicodeEscapeSequence :: u HexLeadSurrogate \u HexTrailSurrogate
1. 让lead是HexLeadSurrogate的CharacterValue
2. 让trail是HexTrailSurrogate的CharaterValue
3. 让cp是UTF16SurrogatePairToCodePoint(lead, trail)
4. 返回cp的编码点值

RegExpUnicodeEscapeSequence :: u Hex4Digits
1. 返回Hex4Digits的MV

RegExpUnicodeEscapeSequence :: u{ CodePoint }
1. 返回CodePoint的MV

HexLeadSurrogate :: Hex4Digits
HexTrailSurrogate :: Hex4Digits
HexNonSurrogate :: Hex4Digits
1. 返回Hex4Digits的MV

CharacterEscape :: IdentityEscape
1. 让ch是IdentityEscape匹配的编码点
2. 返回ch的编码点值
**** Static Semantics: SourceText
UnicodePropertyNameCharacters ::
    UnicodePropertyNameCharacter UnicodePropertyNameCharacters_opt
UnicodePropertyValueCharacters ::
    UnicodePropertyValueCharacter UnicodePropertyValueCharacters_opt
1. 返回码型对应的源文本依次对应的Unicode编码点组成的列表。
**** Static Semantics: CapturingGroupName
RegExpIdentifieryName_[U] ::
    RegExpIdentifierStart_[?U]
    RegExpIdentifierName_[?U] RegExpIdentifieryPart_[?U]
1. 让idText是RegExpIdentifierName匹配的源文本。
2. 让idTextUnescaped是将idText中\RegExpUnicodeEscapeSequence替换为
   RegExpUnicodeEscapeSequence表述的编码点
3. 返回!CodePointsToString(idTextUnescaped)
*** Pattern Semantics
**** 注意1 本节在B.1.4.4进行了修正。
正则表达式范式按照下述过程准换为AbstractClosure。鼓励实现使用更有效的算法，
但要结果相同。AbstractClosure作为RegExp对象的\[\[RegExpMatched]]内部占位的值。

要么是BMP范式，要么是Unicode范式，依据是否有u标记。BMP范式是匹配码型的字符
串翻译成的Unicode的16位二进制数的编码点值都在Basic Multilingual Plane。
Unicode范式匹配码型的字符串翻译成UTF-16编码点。在BMP范式行为的背景里，
"字符"意味着16位二进制数的Unicode BMP编码点。而在Unicode范式行为的背景里，
"字符"意味着UTF-16编码的编码点（6.1.4）。两种背景里，"字符值"意味对应编码点
的数字值。

Pattern的句法与语义按照Pattern的源码是其SourceCharacter列表的方式定义的，其中
每个SourceCharacter对应一个Unicode编码点。如果BMP返回含有了non-BMP
SourceCharacter，整个范式用UTF-16编码，然后用编码单元作为列表的元素。
**** 注意2 例如，源文本的某个范式是单个non-BMP字符U+1D11E（MUSICAL SYMBOL G
            CLEF）。翻译为Unicode范式，它是只有一个元素（字符）的列表，元素
            是编码点0x1D11E。然而如果翻译成BMP范式，它先按照UTF-16编码，产生
            的列表有两个元素，分别是编码单元0xD834和0xDD1E。

            范式以ECMAScript String值形式传递给RegExp构造范，non-BMP字符会以
            UTF-16进行编码。例如，单个字符MUSICAL SYMBOL G CLEF范式，被翻译成
            String值，含有两个元素，长度是2，依次是0xD834和0xDD1E。因此BMP
            范式含有两个范式字符，不需要在这个字符串上进一步翻译。然而，
            如果是Unicode范式，因为是含有一个编码点U+1D11E的列表，需要使用
            UTF16SurrogatePairToCodePoint处理列表。

            实现可能不会实际进行UTF-16转换，但是本规范的语义要求范式匹配的
            结果是按照翻译后匹配的。
**** Notation
下方给出别名的描述：
. Input是被正则表达式范式匹配的String值的字符构成的列表。每个字符要么是
  编码单元，要么是编码点，依赖于范式调用方式。
. InputLength是Input里字符的数量
. 记法Input[n]意味着Input的第n个字符，n在[0, InputLength)范围上。
. NcapturingParens 是范式里左捕括号的数量（诡异的描述）（就是 Atom :: (
  GroupSpecifier Disjunction ) ParseNode的数量）。左捕括号是被Atom :: (
  GroupSpecifier Disjunction )码型的(终止符匹配到的(范式字符。
. DotAll是true，如果RegExp对象的\[\[OriginalFlags]]内部占位含有"s"，否则是false。
. IgnoreCase是true，如果RegExp对象的\[\[OriginalFlags]]内部占位含有"i"，
  否则是false。
. Multiline是true，如果RegExp对象的\[\[OriginalFlags]]内部占位含有"m"，
  否则是false。
. Unicode是true，如果RegExp对象的\[\[OriginalFlags]]内部占位含有"u"，
  否则是false。
. WordCharacters是63个"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_"
  字符的集合B（在Unicode Basic Latin块里的字母、数字和U+005F（LOW LINE））和其他
  能够Canonicalize到B的字符的集合C的并集。除非Unicode和IgnoreCase都是true，不然
  WordCharacters的就是B的63个字符。

此外，下方描述使用了下方的内部数据结构：
. CharSet是字符集合。如果Unicode标记是true，"全部字符"意味着CharSet包含所有
  编码点，否则"全部字符"意味着CharSet包含全部编码单元。
. State是有序对(endIndex, captures)，其中endIndex是整数，captures是NcapturingParens
  值的列表。State用于描述正则表达式匹配算法的部门匹配的状态。endIndex是范式
  在input上最大匹配的最后一个字符的索引加1，而captures持有捕获括号的结果。
  captures的第n个元素要么是第n个捕获括号含有的值的字符列表，要么是undefined，
  此是第n个捕获括号还没有到达。因为会向后寻找，很多State会在匹配过程的任
  何时刻可用。
. MatchResult是State或者是表明匹配失败的特殊信号failure。
. Continuation是AbstarctClosure，接受一个State参数，返回一个MatchResult。
  Continuation试图匹配模式在input上剩余的部分（由闭包捕获的值来明确），即从
  参数State的中间状态开始。如果匹配成功，Continuation返回抵达的最终状态；如果
  匹配失败了，返回failure。
. Matcher是AbstractClosure，接受两个参数State和Continuation，返回MatchResult。
  Matcher试图使用在Input上用范式的中间范式（由闭包捕获的值来明确）去匹配，
  即从参数State的中间状态开始。参数Continuation应该是匹配范式剩余部分的闭包。
  在匹配范式的子范式以得到新的State后，Matcher随后在此新的State上调用
  Continuation，来检测剩余的范式能否匹配。如果可以，Matcher返回被Continuation
  返回的State；如果不行，Matcher试图在其选择点上尝试不同的选择，不断调用
  Continuation，直到成功或者全部可能被耗尽。
**** Pattern
码型 Patter :: Disjunction 按照如下评估：
1. 带1作为direction参数评估Disjunction获得Matcher m。
2. 返回新的AbstractClosure，带有参数(str, index)，捕获了m，并在调用是执行以下步骤：
    a. Assert：Type(str)是String
    b. Assert：index是非负整数，且小于等于str的长度。
    c. 如果Unicode是true，让Input是!StringToCdoePoint(str)。否则让Input是str编码单元
       组成的列表。Input会被22.2.2的算法全程用到。Input的每个元素被认为是一个字符。
    d. 让InputLength是Input含有字符的数量。也被被22.2.2的算法全程用到。
    e. 让listIndex是str上index处元素在Input里字符的索引。
    f. 让c是新的Continuation带参数(y)，没有任何捕获，并执行下列步骤
        i. Assert：y是State
       ii. 返回y。
    g. 让cap是NcapturingParens个undefined值的列表，从1索引到NcapturingParens
    h. 让x是State(listInex, cap)
    i. 返回m(x, c)
***** 注意 Patter评估（编译）成一个AbstractClosure值。RegExpBuiltiinExec在String
          以及之上的偏移进行此过程，确定范式能否匹配String从偏移处开始的子字符串，而且
          如果匹配，就是捕获的括号的值。22.2.2的算法被设计成在编译范式的时候投掷SyntaxError；
          因此，一旦范式成功编译，并将结果AbstractClosure应用到String上时，不会投掷
          异常（除了实现定义的会在任意地方发生的异常，比如内存溢出）。
**** Disjunction
带参数direction

码型 Disjunction :: Alternative 如下评估：
1. 带参数direction评估Alternative得到Matcher m 。
2. 返回 m 。

码型 Disjunction :: Alternative | Disjunction 如下评估：
1. 带参数direction评估Alternative得到Matcher m1 。
2. 带参数direction评估Disjunction得到Matcher m2 。
3. 返回新的带参数(x, c)的Matcher，捕获了m1和m2，在被调用时执行下列步骤：
    a. Assert：x是State
    b. Assert：c是Continuation
    c. 让r是m1(x, c)
    d. 如果r不是failure，返回r
    e. 返回m2(x, c)
***** 注意 "|"作为正则表达式操作符时分隔两个备选。范式先尝试匹配左侧的Alternative（被后续
           正则表达式跟随）；如果它失败了，会尝试右侧Disjunction（被后续正则表达式跟随）。
           如果左侧Alternative、右侧Disjunction和后续表达式都有选择点，后续表达式的选择
           点在左侧Alternative移动到下一个选择点之前进行验证。如果左侧Alternative的选择点
           被耗尽了，尝试用右侧的Disjunction代替左侧的Alternative。范式上任何部分里被｜
           忽略的捕获括号产生undefined值，而不是String。因此，例如：
           /a|ab/.exec("abc")
           返回结果”a“，而不是”ab“，更多的，
           /((a)|(ab))((c)|(bc))/.exec("abc")
           返回数组
           ["abc", "a", "a", undefined, "bc", undefined, "bc"]
           而不是
           ["abc", "ab", undefined, "ab", "c", "c", undefined]
           在两个备选里的尝试顺序与direction值无关。
**** Alternative
带参数direction

码型 Alternative :: [empty] 如下评估：
1. 返回新的带参数(x,c)的Matcher，没有捕获变量，被调用时执行下列步骤：
    a. Assert：x是State
    b. Assert：c是Continuation
    c. 返回c(x)

码型 Alternative :: alternative Term 如下评估：
1. 带参数direction评估Alternative得到Matcher m1 。
2. 带参数direction评估Term得到Matcher m2 。
3. 如果direction == 1，那么
    a. 返回新的带参数(x, c)的Matcher，捕获了m1和m2，在被调用时执行下列步骤：
        i. Assert：x是State
       ii. Assert：c是Continuation
      iii. 让d是新的带参数(y)的Continuation，捕获了c和m2，被调用时执行下列步骤：
            1. Assert：y是State
            2. 返回m2(y,c)
       iv. 返回m1(x, d)
4. 否则
    a. Assert：direction是-1
    b. 返回新的带参数(x, c)的Matcher，捕获了m1和m2，在被调用时执行下列步骤：
        i. Assert：x是State
       ii. Assert：c是Continuation
      iii. 让d是新的带参数(y)的Continuation，捕获了c和m1，被调用时执行下列步骤：
            1. Assert：y是State
            2. 返回m1(y,c)
       iv. 返回m2(x, d)
***** 注意 连续的Term试图同事匹配input上连续的部分。当direction==1时，如果左侧Alternative、
          右侧Term和后续正则表达式都有选择点，在后续表达式的选择点在右侧Term移动到下一个选择
          点之前进行验证，右侧Term的选择点在左侧Alternative移动到下一个选择点之前进行验证。
          当direction == -1时，评估Alternative和Term的顺序相反。

**** Term
带参数direction

码型 Term :: Assertion 如下评估：
1. 返回评估Assertion的结果Matcher
***** 这里的结果Matcher与direction无关
码型 Term :: Atom 如下评估：
1. 返回带参数direction评估Atom的结果Matcher

码型 Term :: Atom Quantifier 如下评估：
1. 带参数direction评估Atom得到Matcher m
2. 评估Quantifier得到三个结果：非负整数min，非负整数（或者+∞）max和Boolean greedy
3. Assert：min <= max
4. 让parenIndex是在整个正则表达式里出现在本Term左侧的左捕获括号数量。这就是先于或者包含
   本Term的 Atom :: ( GroupSpecifier Disjunction ) 解析节点的数量
5. 让parenCount是在Atom中左捕获括号的苏亮。这就是Atom圈闭的
   Atom :: ( GroupSpecifier Disjunction ) 解析节点的数量
6. 返回带参数(x, c)的Matcher，捕获了m、min、max、greedy、parenIndex、parenCount，被
   调用时执行下列步骤：
    a. Assert：x是State
    b. Assert：c是Continuation
    c. 返回!RepeatMatcher(m, min, max, greedy, x, c, parenIndex, parenCount)
***** RepeatMatcher(m, min, max, greedy, x, c, parenIndex, parenCount)
抽象操作RepeatMatcher接受参数m（Matcher）、min（非负整数）、max（非负整数，或者+∞）、
greedy（Boolean）、x（State）、c（Continuation）、parenIndex（非负整数）和parenCount（
非负整数）。被调用时执行下列步骤：
1. 如果max == 0，返回c(x)
2. 让d带参数(y)的Continuation，捕获了m、min、max、greedy、x、c、parenIndex和parenCount。
   被调用时执行下列步骤：
    a. Assert：y是State
    b. 如果min==0而且y的endIndex == x的endIndex，返回failure
    c. 如果min==0，让min2是0，否则让min2是min-1
    d. 如果max是+∞，让max2是+∞，否则让max2是max-1
    e. 返回!RepeatMatcher(m, min2, max2, greedy, y, c, parenIndex, parencount)
3. 让cap是x的captures列表的副本。
4. 遍历(parenIndex, parenIndex + parenCount]内的整数，记作k，置cap[k]是undefined
5. 让e是x的endIndex
6. 让xr是State(e, cap)
7. 如果min != 0，返回 m(xr, d)
8. 如果greedy是false，那么
    a. 让z是c(x)
    b. 如果z不是failure，返回z
    c. 返回 m(xr, d)
9. 让z是m(xr, d)
10. 如果z不是failure，返回z
11. 返回c(x)
****** 注意1 注意跟随Quantifier的Atom按照Quantifier规定的次数进行重复。Quantifier可能是
            不贪婪的，此时Atom范式以尽可能少的重复进行匹配，尽管能匹配后续；也可能是贪婪的，
            此时如果能匹配后续，Atom范式尽可能多的重复进行匹配。使用Atom范式重复，而不是输
            入字符序列来匹配，这样重复不同的Atom可以匹配不同的输入子字符串。
****** 注意2 如果Atom和后续正则表达式都有选择点，Atom先匹配尽可能多（或少，如果是非贪婪的）的
            重复。在后续表达式的选择点在Atom最后一个重复里准备移动到下一个选择点之前进行验证。
            而在Atom第n次（最后的）重复的选择点是在第n-1次重复里准备移动到下一个选择点之前
            进行验证；可能有的点会多重复或者少重复Atom；他们都在Atom第n-1次重复里移动到下一
            个选择点之前被消耗完（重申：无论是尽可能多还是尽可能少）。以此类推。

            比较
            /a[a-z]{2,4}/.exec("abcdefghi")
            会返回"abcde"，而
            /a[a-z]{2,4}?/.exec("abcdefghi")
            返回"abc"

            在比如
            /(aa|aabaac|ba|b|c)*/.exec("aabaac")
            按照上述选择点顺序，会返回数组
            ["aaba", "ba"]
            而不是下方的
            ["aabaac", "aabaac"]
            ["aabaac", "c"]

            上述的选择顺序允许正则表达式计算两个数字的最大公约数（一元记法表述）。比如计算
            10和15的最大公约数：
            "aaaaaaaaaa,aaaaaaaaaaaaaaa".replace(/^(a+)\1*,\1+$/, "$1")
            返回一元记法的最大公约数"aaaaa"
****** 注意3 RepeatMatcher的步骤4，在每次Atom重复的时候，清除了Atom捕获的内容。可以下述
            正则表示里看到此行为
            /(z)((a+)?(b+)?(c))*/.exec("zaacbbbcac")
            会返回
            ["zaacbbbcac","z","ac","a",undefined,"c"]
            而不是
            ["zaacbbbcac","z","ac","a","bbb","c"]
            因为在外层*的遍历清除了计次Atom内捕获的String，这里包括2、3、4和5的捕获String。
            （它们都是最后一次匹配捕获的内容）。
****** 注意4 RepeatMatcher步骤2.b里，一旦满足了最小重复次数，匹配空字符串的Atom扩展式都不
            在参与重复。以阻止正则表达式在如下范式中陷入无限循环：
            /(a*)*/.exec("b")
            或者复杂一些的
            /(a*)b\1+/.exec("baaaaac")
            这回返回
            ["b", ""]
**** Assertion
码型 Assertion :: ^ 如下评估
1. 返回带参数(x,c)的新Matcher，没有捕获，被调用时执行下列步骤：
    a. Assert：x是State
    b. Assert：c是Continuation
    c. 让e是x的endIndex
    d. 如果e是0，或者如果Multiline是true且Input[e-1]是LineTerminator，那么
        i. 返回c(x)
    e. 返回failure
***** 注意 即使范式使用了y标记，^仍然只匹配Input的开始，或者（如果Multiline是true）匹配
          行的开始。

码型 Assertion :: $ 如下评估
1. 返回带参数(x,c)的新Matcher，没有捕获，被调用时执行下列步骤：
    a. Assert：x是State
    b. Assert：c是Continuation
    c. 让e是x的endIndex
    d. 如果e是InputLength，或者如果Multiline是true且Input[e1]是LineTerminator，那么
        i. 返回c(x)
    e. 返回failure

码型 Assertion :: \ b 如下评估
1. 返回带参数(x,c)的新Matcher，没有捕获，被调用时执行下列步骤：
    a. Assert：x是State
    b. Assert：c是Continuation
    c. 让e是x的endIndex
    d. 让a是!IsWordChar(e-1)
    e. 让b是!IsWordChar(e)
    f. 如果a是true而b是false，或者a是false而b是true，返回c(x)
    g. 返回failure

码型 Assertion :: \ B 如下评估
1. 返回带参数(x,c)的新Matcher，没有捕获，被调用时执行下列步骤：
    a. Assert：x是State
    b. Assert：c是Continuation
    c. 让e是x的endIndex
    d. 让a是!IsWordChar(e-1)
    e. 让b是!IsWordChar(e)
    f. 如果a是true且b是true，或者a是false且b是false，返回c(x)
    g. 返回failure

码型 Assertion :: ( ? = Disjunction) 如下评估
1. 以1为参数direction评估Disjunction得到Matcher m。
2. 返回带参数(x,c)的新Matcher，捕获m，被调用时执行下列步骤：
    a. Assert：x是State
    b. Assert：c是Continuation
    c. 让d是带参数(y)的新Continuation，没有捕获，被调用时执行下列步骤：
        i. Assert：y是State
       ii. 返回y
    d. 让r是m(x,d)
    e. 如果r是failure，返回failure
    f. 让y是r的State
    g. 让cap是y的captures列表
    h. 让xe是x的endIndex
    i. 让z是State(xe, cap)
    j. 返回c(z)

码型 Assertion :: ( ? ! Disjunction) 如下评估
1. 以1为参数direction评估Disjunction得到Matcher m。
2. 返回带参数(x,c)的新Matcher，捕获m，被调用时执行下列步骤：
    a. Assert：x是State
    b. Assert：c是Continuation
    c. 让d是带参数(y)的新Continuation，没有捕获，被调用时执行下列步骤：
        i. Assert：y是State
       ii. 返回y
    d. 让r是m(x,d)
    e. 如果r不是failure，返回failure
    f. 返回c(x)

码型 Assertion :: ( ? <= Disjunction) 如下评估
1. 以-1为参数direction评估Disjunction得到Matcher m。
2. 返回带参数(x,c)的新Matcher，捕获m，被调用时执行下列步骤：
    a. Assert：x是State
    b. Assert：c是Continuation
    c. 让d是带参数(y)的新Continuation，没有捕获，被调用时执行下列步骤：
        i. Assert：y是State
       ii. 返回y
    d. 让r是m(x,d)
    e. 如果r是failure，返回failure
    f. 让y是r的State
    g. 让cap是y的captures列表
    h. 让xe是x的endIndex
    i. 让z是State(xe, cap)
    j. 返回c(z)

码型 Assertion :: ( ? <! Disjunction) 如下评估
1. 以-1为参数direction评估Disjunction得到Matcher m。
2. 返回带参数(x,c)的新Matcher，捕获m，被调用时执行下列步骤：
    a. Assert：x是State
    b. Assert：c是Continuation
    c. 让d是带参数(y)的新Continuation，没有捕获，被调用时执行下列步骤：
        i. Assert：y是State
       ii. 返回y
    d. 让r是m(x,d)
    e. 如果r不是failure，返回failure
    f. 返回c(x)
***** IsWordChar( e )
抽象操作IsWorkChar接受参数e（整数）。被调用时执行下列步骤：
1. 如果e== -1，或者e是InputLength，返回false
2. 让c是Input[e]的字符
3. 如果c在WordCharacters里，返回true
4. 返回false
**** Quantifier
码型 Quantifier :: QuntifierPrefix 如下评估
1. 评估QuantifierPrefix或者两个结果：整数min和整数（或者+∞)max
2. 返回结果:min max 和 true

码型 Quantifier :: QuntifierPrefix? 如下评估
1. 评估QuantifierPrefix或者两个结果：整数min和整数（或者+∞)max
2. 返回结果:min max 和 false

码型 QuantifierPrefix :: * 如下评估
1. 返回结果：0 和 +∞

码型 QuantifierPrefix :: + 如下评估
1. 返回结果：1 和 +∞

码型 QuantifierPrefix :: ? 如下评估
1. 返回结果：0 和 1

码型 QuantifierPrefix :: { DecimalDigits } 如下评估
1. 让i是DecimalDigits的MV（12.8.3）
2. 返回结果：i 和 i

码型 QuantifierPrefix :: { DecimalDigits , } 如下评估
1. 让i是DecimalDigits的MV（12.8.3）
2. 返回结果：i 和 +∞

码型 QuantifierPrefix :: { DecimalDigits , DecimalDigits } 如下评估
1. 让i是第一个DecimalDigits的MV（12.8.3）
1. 让j是第二个DecimalDigits的MV（12.8.3）
2. 返回结果：i 和 j
**** Atom
带参数direction。
***** CharacterSetMatcher( A, invert, direction )
***** Canonicalize( ch )
***** UnicodeMatchProperty( p )
***** UnicodeMatchPropertyValue( p, v )
**** AtomEscape
***** BackreferenceMatcher( n, direction )
**** CharacterEscape
**** DecimalEscape
**** CharacterClassEscape
**** CharacterClass
**** ClassRanges
**** NonemptyClassRanges
***** CharacterRange( A, B )
**** NonemptyClassRangesNoDash
**** ClassAtom
**** ClassAtomNoDash
**** ClassEscape
*** The RegExp Constructor
**** RegExp( pattern, flags )
**** Abstract Operations for the RegExp Cosntructor
***** RegExpAlloc( newTarget )
***** RegExpInitialize( obj, patter, flags )
***** Static Semantics: ParsePattern( patternText, u )
***** RegExpCreate( P, F )
***** EscapeRegExpPattern( P, F )
*** Properties of the RegExp Constructor
**** RegExp.prototype
**** get RegExp[@@species]
*** Properties of the RegExp Prototype Object
**** RegExp.prototype.constructor
**** RegExp.prototype.exec( string )
***** RegExpExec( R, S )
***** RegExpBuiltinExec( R, S )
***** AdvanceStringIndex( S, index, unicode )
**** RegExp.prototype.dotAll
**** RegExp.prototype.flags
**** RegExp.prototype.global
**** RegExp.prototype.ignoreCase
**** RegExp.prototype[@@match]( string )
**** RegExp.prototype[@@matchAll]( string )
**** RegExp.prototype.multiple
**** RegExp.prototype[@@replace]( string. replaceValue )
**** RegExp.prototype[@@search]( string )
**** RegExp.prototype.source
**** RegExp.prototype[@@split]( string, limit )
**** RegExp.prototype.sticky
**** RegExp.prototype.test( S )
**** RegExp.prototype.toString( )
**** RegExp.prototype.unicode
*** Properties of RegExp Instances
**** lastIndex
*** RegExp String Iterator Objects
**** CreateRegExpStringIterator( R, S, global, fullUnicode )
**** The %RegExpStringIteratorPrototype% Object
***** %RegExpStringIteratorPrototype%.next()
***** %RegExpStringIteratorPrototype%[@@toStringTag]
* Indexed Collections
* Keyed Collections
* Structured Data
**
* Managing Memory
* Control Abstraction Objects
* Reflection
* Memory Model
* A Grammer Summary
* B Additional ECMAScript Features for Web Browsers
* C The Strict Mode of ECMAScript
* D Host Layering Points
* E Corrections and Clarifications in ECMAScript 2015 with Possible Compatibility Impact
* F Additions and Changes That Introduce Incompatibility with Prior Editions
* G Colophon
* H Bibliography
* I CopyRight & Software License
